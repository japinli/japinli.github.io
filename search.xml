<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 函数</title>
    <url>/2019/11/C-functions/</url>
    <content><![CDATA[<p>C 语言提供了子程序，它可以将我们的程序分割成不同的部分。为了编写函数，我们至少给出函数的定义。通常，我们还需要给出函数的声明；但是，函数的声明不是必须的，如果不给出函数声明，那么编译器将给出一个匹配该函数的隐式声明，而且我们将得到编译时警告。</p>
<p>每个程序都至少需要一个名为 <code>main</code> 的函数，这是程序执行的入口函数。本文主要分为以下几部分：</p>
<ul>
<li>函数声明</li>
<li>函数定义</li>
<li>函数调用</li>
<li>函数参数</li>
<li>变长参数列表</li>
<li>函数指针调用</li>
<li><code>main</code> 函数</li>
<li>递归函数</li>
<li>静态函数</li>
<li>嵌套函数</li>
</ul>
<span id="more"></span>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>我们编写函数声明时需要指定函数名称、参数列表以及函数返回类型。函数声明以分号结尾，其形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return-type function-name(parameter-list);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>return-type</code> 表明了函数返回值的数据类型。通过给定 <code>void</code> 的返回类型，我们可以声明函数不返回任何值。</li>
<li><code>function-name</code> 可以是任何有效的标识符（见<a href="/2019/06/C-lexical-elements/" title="标示符">标示符</a>）。</li>
<li><code>parameter-list</code> 由零个或多个参数组成，通过逗号隔开。参数由数据类型和可选的参数名组成。我们可以声明变长的参数，或者无参数（<code>void</code>）。如果不给定参数列表，那么就意味着该函数没有参数，但是最好显示的使用 <code>void</code> 给出。</li>
</ul>
<p>例如，下面是一个包含两个参数的函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果我们需要包含参数名称，我们可以在参数类型后给出，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数名同样可以为任何标识符，如果我们包含多个参数，那么在同一个声明中参数名不能重复。函数声明中的参数名称可以不必与函数定义时的参数名称一致。</p>
<p>我们应当在第一次使用函数之前声明该函数。我们可以将其放在头文件中，随后我们便可以在任何 C 源文件中通过 <code>#include</code> 指令来包含函数声明，从而使用该函数。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义给出了函数实际执行的操作。函数定义包含函数名称、返回类型、参数列表（数据类型和参数名）以及函数主体。函数主体由一系列包含在大括号内的语句组成；实际上它就是一个块语句（见 <a href="/2019/10/C-statements/" title="块语句">块语句</a>）。下面是函数定义的通用形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return-type</span><br><span class="line">function-name(parameter-list)</span><br><span class="line">&#123;</span><br><span class="line">    function-body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>return-type</code> 和 <code>function-name</code> 与函数声明中的相同（见函数声明）。</p>
</li>
<li><p><code>parameter-list</code> 与函数声明中的参数列表相同（见函数声明），但是，在函数定义时我们必须显示的给出参数名。</p>
</li>
</ul>
<p>例如，下面的函数定义包含两个整型参数并且返回它们的和作为返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">add_values</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了兼容最初的 C 语言设计，我们还可以在参数列表的右括号后指定函数参数的类型，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">add_values</span><span class="params">(x, y)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> x, <span class="keyword">int</span> y</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们强烈建议不要采用这种编码格式；它可能导致类型转换的细微问题，以及其他问题。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>我们可以通过函数名称以及提供该函数必要的参数来调用函数，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function-name(parameters)</span><br></pre></td></tr></table></figure>

<p>函数调用可以是独立的语句，也可被用作子表达式。例如，下面是一个独立的函数调用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>在上述的示例中，函数 <code>foo</code> 的参数为 <code>5</code>。</p>
<p>下面是用作子表达式的函数调用的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = square(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设函数 <code>square</code> 将其参数平方，则上面的示例将值 <code>25</code> 赋值给 <code>a</code>。</p>
<p>如果一个函数接受多个参数，我们需要使用逗号将其分隔开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = quux(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数可以是任何表达式 – 字面值、变量存储的值、内存地址或者通过组合这些值而构建的更复杂的表达式。</p>
<p>在函数体内，参数是传递给函数的值的本地副本；您不能通过更改本地副本来更改传入的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">23</span>;</span><br><span class="line">foo(x);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 定义函数 foo */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2</span> * a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例总，即使传递给函数 <code>foo</code> 得到参数被修改了，传递给函数的变量 <code>x</code> 也不会发生改变。如果希望使用该函数来更改 <code>x</code> 的原始值，则必须将函数调用合并到赋值语句中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = foo(x);</span><br></pre></td></tr></table></figure>

<p>如果传递给函数的值是内存地址（即指针），则可以访问（并更改）存储在该内存地址的数据。这样可以达到与其他语言中的按引用传递相似的效果，但是效果不一样：内存地址只是一个值，就像其他任何值一样，并且本身不能更改。传递指针和传递整数之间的区别在于您可以使用函数中的值进行何种操作。</p>
<p>下面是使用指针参数的函数调用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *x = *x + <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line">foo(&amp;a);</span><br></pre></td></tr></table></figure>

<p>该函数的形式参数是 <code>int</code> 类型的指针，我们通过向其传递 <code>int</code> 类型变量的地址来调用该函数。通过在函数体内对指针进行解引用操作，我们可以获取内存地址中的值并对其进行修改。上述示例将修改变量 <code>a</code> 的值为 <code>57</code>。</p>
<p>即使您不想改变存储在地址中的值，如果变量类型很大并且您需要节省内存空间或限制参数复制对性能的影响，则传递变量的地址而不是变量本身可能会很有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">const</span> struct foo *a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，除非您在内存地址非常大的计算机上工作，否则传递结构体的指针要比传递结构实例花费更少的内存。</p>
<p>任何类型的数组总是以指针的形式进行传递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>];</span><br><span class="line">foo(x);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用参数 <code>a</code> 调用函数 <code>foo</code> 不会将整个数组复制到 <code>foo</code> 函数的新局部参数中；而是将 <code>x</code> 作为指针传递给 <code>foo</code> 函数的第一个参数。但是要小心：在函数内，您不能使用 <code>sizeof</code> 来确定数组 <code>x</code> 的大小，而 <code>sizeof</code> 却告诉您指针 <code>x</code> 的大小。实际上，以上代码等效于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>];</span><br><span class="line">foo(x);</span><br></pre></td></tr></table></figure>

<p>在参数声明中明确指定数组的长度无济于事。如果您确实需要按值传递数组，则可以将其包装在结构中，尽管这样做几乎没有用（传递 <code>const</code> 限定的指针通常足以表明调用者不应该修改数组）。</p>
<h2 id="变长参数列表"><a href="#变长参数列表" class="headerlink" title="变长参数列表"></a>变长参数列表</h2><p>我们可以编写一个带有可变数量参数的函数。这些称为可变函数（_variadic functions_）。为此，该函数至少需要具有一个已知数据类型的参数，但是其余参数是可选的，并且在数量和数据类型上都可以不同。</p>
<p>您可以像平常一样列出初始参数，但之后再使用省略号：<code>...</code>。下面是一个示例函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_multiple_values</span><span class="params">(<span class="keyword">int</span> number, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要使用函数定义中的可变参数，我们需要使用库头文件 <code>&lt;stdarg.h&gt;</code> 中定义的宏，因此必须使用 <code>#include</code> 包含该文件。有关这些宏的详细说明，请参见 GNU C 库手册中有关可变参数功能的部分。</p>
<p>下面是一个可变参数函数的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">add_multiple_values</span> <span class="params">(<span class="keyword">int</span> number, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter, total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 声明 &#x27;va_list&#x27; 类型变量 */</span></span><br><span class="line">    va_list parameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 &#x27;va_start&#x27; 函数 */</span></span><br><span class="line">    va_start(parameters, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; number; counter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 获取可选参数的值 */</span></span><br><span class="line">        total += va_arg(parameters, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结束 &#x27;parameters&#x27; 变量的使用，释放资源 */</span></span><br><span class="line">    va_end(parameters);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用可选参数，您需要一种方法来知道有多少个参数。这可能会有所不同，因此无法进行硬编码，但是如果您不知道有多少个可选参数，则可能很难知道何时停止使用 <code>va_arg</code> 函数。在上面的示例中，函数 <code>add_multiple_values</code> 的第一个参数 <code>number</code> 是实际传递的可选参数的数量。因此，我们可以这样调用函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sum = add_multiple_values(<span class="number">3</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">190</span>);</span><br></pre></td></tr></table></figure>

<p>第一个参数指示跟随多少个可选参数。另外，请注意，您实际上并不需要使用 <code>va_end</code> 功能。实际上，对于GCC 而言，它什么也没做。但是，您可能要包括它以最大程度地与其他编译器兼容。</p>
<h2 id="函数指针调用"><a href="#函数指针调用" class="headerlink" title="函数指针调用"></a>函数指针调用</h2><p>我们也可以调用由指针标识的函数。间接操作符 <code>*</code> 在执行此操作时是可选的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo %d!\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d bar!\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">int</span>), <span class="keyword">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; times; ++j)</span><br><span class="line">        func(j);  <span class="comment">/* 与 (*func) (j); 作用相同 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span> want_foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*pf)(<span class="keyword">int</span>) = &amp;bar; <span class="comment">/* 运算符 &amp; 是可选的 */</span></span><br><span class="line">    <span class="keyword">if</span> (want_foo)</span><br><span class="line">        pf = foo;</span><br><span class="line">    message (pf, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a><code>main</code> 函数</h2><p>每个程序都至少需要一个名为 <code>main</code> 的函数。这是程序开始执行的地方。我们不需要为 <code>main</code> 函数提供声明或原型，我们只需要定义它即可。</p>
<p><code>main</code> 函数的返回值总是 <code>int</code> 类型。我们不必为 <code>main</code> 函数指定返回类型，但是我们可以这样做。需要注意的是，我们不能指定它的返回类型不是 <code>int</code>。</p>
<p>通常，<code>main</code> 函数的返回值表明了程序退出状态。返回 <code>0</code> 或者 <code>EXIT_SUCCESS</code> 表明成功，<code>EXIT_FAILURE</code> 则表示错误。否则，返回的值由实现定义。</p>
<p>在 <code>main</code> 函数的末尾到达 <code>&#125;</code> 而没有返回值，或者执行没有值的 <code>return</code> 语句（即 <code>return;</code>）都是等效的。在 C89 标准中，这是未定义的，然而在 C99 中明确定义这种情况返回 <code>0</code>。</p>
<p>我们可以编写没有任何参数的 <code>main</code> 函数（也就是 <code>int main(void)</code>），或者从命令行接受参数。这是一个非常简单的没有参数的主函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了接受来自命令行的参数，我们需要 <code>main</code> 函数提供两个参数，<code>argc</code> 和 <code>*argv[]</code>。我们可以改变参数的名称，但是它们数据类型不能改变 – <code>int</code> 类型和 <code>char</code> 类型的数组指针。<code>argc</code> 是命令行参数的数量，包括程序本身的名称。<code>argv</code> 是参数的数组，以字符串的形式给出。<code>argv[0]</code> 数组的第一个元素是在命令行中键入的程序名称；之后任何数组元素都是程序名称的参数。</p>
<p>下面的示例定义了 <code>main</code> 函数接受命名行参数，并且将其打印出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; argc; counter++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%s\n&quot;</span>, argv[counter]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>我们可以编写一个递归函数 – 调用自身的函数。如一个计算整数的阶乘的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (x * factorial(x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意不要编写无限递归的函数。在上面的示例中，一旦 <code>x</code> 为 <code>1</code>，则递归停止。但是，在以下示例中，递归不会停止，直到程序被中断或内存不足为止：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">watermelon</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (watermelon(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，函数也可以是间接递归的。</p>
<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>如果希望仅可在定义该函数的源文件中调用该函数，则可以将其定义为静态函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您正在构建可重用的函数库，并且需要包含一些最终用户不应该调用的子函数，则这很有用。</p>
<p>以这种方式定义的函数被称为具有静态链接；不幸的是 <code>static</code> 关键字具有多重含义，见 <a href="/2019/06/C-type-and-storage-class-specifiers/" title="存储类型说明符">存储类型说明符</a>。</p>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>作为 GNU C 扩展，我们可以在其他函数中定义函数，这种技术称为嵌套函数。</p>
<p>下面是使用嵌套函数定义的尾递归阶乘函数的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="title">factorial_helper</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> factorial_helper((a - <span class="number">1</span>), (a * b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial_helper(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，必须在函数的开头定义嵌套函数以及变量声明，然后再声明所有其他语句。</p>
<p>实际上，我在 <code>gcc -std=c99</code> 的时候也能通过编译，我使用的是 <code>GCC 7.4</code>，而使用 <code>clang -std=gnu99</code> 不能通过编译（<code>clang-1001.0.46.4</code>），具体的可能是编译器实现的问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Functions">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Functions</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言词法元素</title>
    <url>/2019/06/C-lexical-elements/</url>
    <content><![CDATA[<p>本文主要介绍 C 语言的词法元素，包括标识符、关键字、常量、操作符以及分隔符。其中关于操作符的一些更为详细的信息将在后续进行介绍。</p>
<img src="/2019/06/C-lexical-elements/C_lexical_elements.png" class="">

<span id="more"></span>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符在 C 语言中由于命令变量、函数、新的数据类型以及预处理的字符序列（例如，宏定义）。它可以包含字符、数字以及下划线（<code>_</code>)，标识符是区分大小写的，并且不能以数字开始。需要注意的是，GNU 扩展可以在标识符中使用美元符号（<code>$</code>）。</p>
<p>例如，下面的标识符是正确的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ok;</span><br><span class="line">int my_id;</span><br><span class="line">char *_name;</span><br></pre></td></tr></table></figure>

<p>而下面的标识符则错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int 2id;</span><br><span class="line">char *#a;</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是 C 语言保留的特殊标识符，这些标识符有特定的用处，因此不能用于其它用途。不同的标准下，C 语言支持的关键字有所不同。下表给出了不同标准下的关键字。</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>ANSI C89</td>
<td>auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while</td>
</tr>
<tr>
<td>ISO C99</td>
<td>inline, _Bool, _Complex, _Imaginary, restrict</td>
</tr>
<tr>
<td>GUN 扩展</td>
<td>__FUNCTION__, __PRETTY_FUNCTION__, __alignof, __alignof__, __asm, __asm__, __attribute, __attribute__, __builtin_offsetof, __builtin_va_arg, __complex, __complex__, __const, __extension__, __func__, __imag, __imag__, __inline, __inline__, __label__, __null, __real, __real__, __restrict, __restrict__, __signed, __signed__, __thread, __typeof, __volatile, __volatile__, restrict</td>
</tr>
</tbody></table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是一个数值或者字符值，例如，<code>5</code> 或者 <code>&#39;m&#39;</code>。所有的常量都有一个特定的数据类型，你可以显示地将其强制转换为某个特定类型或者你也可以让编译器选择默认的数据类型。C 语言包含四类常量：a. 整型常量；b. 字符常量；c. 浮点数常量；d. 字符串常量。</p>
<h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>整型常量是一个数字组成的序列，它可以伴随一个前缀用于表示常量的基数，同时也可以带有一个后缀用以表示数据类型。C 语言提供了三种基数的表示方式：</p>
<table>
<thead>
<tr>
<th>基数</th>
<th>前缀</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十六进制</td>
<td><code>0x</code> 或 <code>0X</code></td>
<td><code>0x2f</code>, <code>0x88</code>, <code>0XAB43</code></td>
</tr>
<tr>
<td>十进制</td>
<td>无</td>
<td><code>459</code>, <code>12</code>, <code>1293</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0</code></td>
<td><code>057</code>, <code>03</code>, <code>012</code></td>
</tr>
</tbody></table>
<p>数据类型则可以通过字符 <code>u</code> 和 <code>l</code> 来表示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>后缀</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>无符号整型 （<code>unsigned</code>）</td>
<td><code>u</code> 或 <code>U</code></td>
<td><code>45U</code></td>
</tr>
<tr>
<td>长整型（<code>long int</code>）</td>
<td><code>l</code> 或 <code>L</code></td>
<td><code>45L</code></td>
</tr>
<tr>
<td>长长整型 （<code>long long int</code>）</td>
<td><code>ll</code> 或 <code>LL</code></td>
<td><code>45LL</code></td>
</tr>
</tbody></table>
<p>长长整型（<code>long long int</code>）是在 ISO 99 和 GNU C 扩展中新加的数据类型。此外，我们可以通过将 <code>u</code> 和 <code>l</code> 组合起来形成无符号长整型数据类型。例如 <code>45ULL</code>。</p>
<p><strong>备注：</strong> <code>u</code> 和 <code>l</code> 的顺序没有多大关系。</p>
<h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><p>字符常量通常是有单引号包含起来的单个字符，例如，<code>A</code>。字符常量的默认数据类型为整型（<code>int</code> 类型）。一些字符无法用单个字符表示，因此需要进行转义。常见的转义字符如下所示：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\\</code></td>
<td>反斜杆字符</td>
</tr>
<tr>
<td><code>\?</code></td>
<td>问号字符</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>警报</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>退格字符</td>
</tr>
<tr>
<td><code>\e</code></td>
<td><ESC> 字符（GNU 扩展）</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>表格填充</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车符</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符号</td>
</tr>
<tr>
<td><code>\o</code>,<code>\oo</code>,<code>\ooo</code></td>
<td>八进制数</td>
</tr>
<tr>
<td><code>xh</code>,<code>\xhh</code>,<code>\xhhh</code>, <code>...</code></td>
<td>十六进制数</td>
</tr>
</tbody></table>
<p>虽然十六进制的表示方式后面可以跟任意多个数字，但是给定的字符集的字符数量是有限的。例如，常用扩展的 ASCII 字符集只有 256 个字符。如果你尝试给出一个超出字符集范围的十六进制字符表示，那么编译时将出错。（我测试过后发现其实有一个警告。）</p>
<h3 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h3><p>浮点数常量（实数常量）由整数部分，小数点和小数部分组成，同样它可以有一个可选的数据类型后缀。在表示浮点数常量时，我们可以省略整数部分或小数部分，但不能同时省略。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a, b, c, d, e, f;</span><br><span class="line"></span><br><span class="line">a = <span class="number">4.7</span>;</span><br><span class="line">b = <span class="number">4.</span>;</span><br><span class="line">c = <span class="number">4</span>;</span><br><span class="line">d = <span class="number">.7</span>;</span><br><span class="line">e = <span class="number">0.7</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是在 <code>c = 4;</code> 的赋值语句中，整型常量 <code>4</code> 将自动的由整型转换为浮点型（<code>double</code> 类型）。此外，我们还可以用科学计数的方式来表示浮点数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="number">5e2</span>;    <span class="comment">/* x 为 5 * 100，即 500.0 */</span></span><br><span class="line">y = <span class="number">5e-2</span>;   <span class="comment">/* y 为 5 * (1/100), 即 0.05 */</span></span><br></pre></td></tr></table></figure>

<p>你可以在浮点数后面添加 <code>F</code> 或 <code>f</code> 来表示单精度浮点数（<code>float</code> 类型），如果在浮点数后面添加 <code>L</code> 或 <code>l</code> 则表示该常量的数据类型为 <code>long double</code>。默认情况下，浮点数的类型为 <code>double</code>。</p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>字符串常量是由双引号包裹的零个或多个字符、数字以及转义字符序列。字符串常量的数据类型为字符数组。所有的字符串都包含一个空字符（<code>\0</code>）用来表示字符串结尾。字符串以字符数组的方式存储，它没有字符串长度的属性。字符串以末尾的空字符作为结束标志。两个相邻的字符串常量将会被连接为一个字符串常量，并且只保留最后一个字符串的空字符。</p>
<p>由于字符串由双引号作为标示，因此我们在字符串中使用双引号时需要对其进行转义。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;\&quot;Hello, world!\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果一个字符串太长以致于不能放在一行中，我们可以使用反斜杠 <code>\</code> 来将其拆分为单独的行。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;This is a long long long long long long long long long \</span><br><span class="line">long long long string.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在反斜杠后面不能有任何字符，尤其要注意空白字符，如空格、制表符等。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符（运算符）是一个特殊标记，它对一个，两个或三个操作数执行操作，例如加法或减法。后续将给出更为详细的介绍。</p>
<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>分隔符用于分割标记（<code>tokens</code>）。分隔符本身也是一种标记。它们由单个字符组成并代表其自身，C 语言中的分隔符标记包括 <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>&#123;</code>, <code>&#125;</code>, <code>;</code>, <code>,</code>, <code>.</code>, <code>:</code>。空白也是一种分隔符，但它不属于标记。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Lexical-Elements">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Lexical-Elements</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 程序结构和范围</title>
    <url>/2020/01/C-program-structure-and-scope/</url>
    <content><![CDATA[<p>在之前的几篇关于 C 语言的文章中，我们以及掌握了 C 语言的基本要素，本文主要介绍 C 语言的程序结构和范围。</p>
<span id="more"></span>

<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>我们可以将 C 程序写在一个源文件中，然而，更为常见的是将其按照功能模块将其划分到不同的源文件中。</p>
<p>通常，头文件（即以 <code>.h</code> 结尾的文件）包含函数和变量的声明；源文件（即以 <code>.c</code> 结尾的文件）包含相应的定义。如果我们不想某些声明被外部文件访问，那么也可以将声明放在源文件中。</p>
<p>例如，如果我们编写一个求平方根的函数，我们希望可以在定义该函数以外的文件访问，那么我们需要将函数的声明放在头文件中（即以 <code>.h</code> 结尾的文件）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sqrt.h */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span></span></span><br><span class="line"><span class="function"><span class="title">computeSqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该头文件可能包含其它我们需要使用的函数但其定义在不同的源文件中，我们可能不需要知道这些函数的实现。</p>
<p>This header file could be included by other source files which need to use your function, but do not need to know how it was implemented.</p>
<p>上述函数的定义应该在相应的源文件中出现（即以 <code>.c</code> 结尾的文件）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sqrt.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sqrt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span></span></span><br><span class="line"><span class="function"><span class="title">computeSqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>范围是指程序的哪些部分可以“看到”声明的对象。声明的对象可以只在特定的函数中可见、或者是特定的文件、亦或者是包含这个声明的头文件的一系列源文件中（需要使用 <code>extern</code> 声明）。</p>
<p>除非特定说明，在文件的顶层（即不在函数内）进行的声明对整个文件都是可见的，包括从函数内部，但在文件外部不可见；在函数内进行的声明仅在这些函数内可见；此外，声明对之前的声明不可见，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = x + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这样是可以的，但是如下方式则是不行的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = y + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Program-Structure-and-Scope">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Program-Structure-and-Scope</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言类型及存储类限定符</title>
    <url>/2019/06/C-type-and-storage-class-specifiers/</url>
    <content><![CDATA[<p>本文主要介绍 C 语言中的类型及存储类限定符，C 语言中提高了两个类型限定符：<code>const</code> 和 <code>volatile</code>；类型限定符指明了变量的访问方式。存储类限定符则指定了变量在内存中的存储方式，C 语言提供了四种存储类限定符：<code>auto</code>，<code>register</code>，<code>extern</code> 和 <code>static</code>。</p>
<span id="more"></span>

<h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符允许您指定变量的访问方式，C 语言提供了两个类型限定符：(a) <code>const</code> 指明变量是只读的，一旦初始化，它的值将不能被改变；(b) <code>volatile</code> 表明变量是显式可变的，并且看似无用的变量访问（例如，通过指针）不应该被优化掉。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14159f</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">float</span> currentTemperature = <span class="number">40.0</span>;</span><br></pre></td></tr></table></figure>

<p><code>const</code> 限定符除了能防止变量被意外改变之外，它还能辅助编译器进行优化。针对有回调函数或者信号处理函数更新的变量，我们可以将其定义为 <code>volatile</code> 从而避免编译器过度优化导致数据不一致。</p>
<h2 id="存储类限定符"><a href="#存储类限定符" class="headerlink" title="存储类限定符"></a>存储类限定符</h2><p>存储类限定允许您定义变量在内存中的存储方式。<code>auto</code> 关键字用于定义函数内部的局部变量，当函数返回时，这是局部变量（自动变量）将自动被清理掉，这是函数内部的变量默认行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> x = value;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>register</code> 关键字定义的变量被称为寄存器变量，它的行为与 <code>auto</code> 定义的变量几乎类似，稍有不同的是，该关键字表明该变量的使用频率极高，如果可能尽量将其放在寄存器中。如果变量被声明为 <code>register</code> 类型，__那么将不能对其进行取地址运算 (<code>&amp;</code>)__。这意味着您不能引用使用存储类寄存器声明的数组的元素。GCC 编译器在优化时可以很好的选择哪些变量使用被保存在寄存器中，因此寄存器变量很少使用。</p>
<p><code>static</code> 限定符与 <code>auto</code> 的作用正好相反：当将 <code>static</code> 应用于函数内部或块内的变量时，即使函数完成或块结束之后，这些变量都将保存其值。这就是所谓的__静态存储持续期 (Static Storage Duration)__。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sumSoFar = <span class="number">0</span>;</span><br><span class="line">    sumSoFar = sumSoFar + x;</span><br><span class="line">    <span class="keyword">return</span> sumSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，您还可以在顶层（即不在函数内）将变量（或函数）声明为 <code>static</code>。这些变量（全局变量）仅在当前源文件可见，其它源文件则不可见。这就给 <code>static</code> 带来了双重含义；第二种意义则是__静态链接 (Static Linkage)__。在单独的文件中具有静态链接的两个函数或变量是完全独立的；在声明它的文件之外都不可见。</p>
<p>声明为 <code>extern</code> 的未初始化变量的默认值为 <code>0</code>，<code>0.0</code> 或 <code>NULL</code>，具体值则取决于其类型。声明为 <code>auto</code> 和 <code>register</code> 的未初始化变量保留为初始化状态，因此不应假设这些变量保存特定的值。</p>
<p><code>extern</code> 对于声明要链接到项目的所有源文件可见的变量很有用。变量声明时并不会为其分配存储空间，所以你无法在 <code>extern</code> 声明语句中进行初始化操作。您必须同时进行 <code>extern</code> 声明和非 <code>extern</code> 声明，实际上后者是变量的定义，它将为期分配存储空间。<code>extern</code> 声明语句可以重复多次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> numberOfClients;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> numberOfClients = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Type-Qualifiers">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Type-Qualifiers</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS Mojave 上 GDB 调试配置</title>
    <url>/2019/06/GDB-on-MacOS-Mojave/</url>
    <content><![CDATA[<p>最近在 MacOS 上写代码，需要使用 gdb 进行调试，踩了一些坑，因此在这里做一个简要记录。稍微搜索一下我们就可以知道要在 MacOS 上使用 gdb 需要先创建一个自签名证书（<a href="https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d">看这里</a>)。</p>
<p>但是我们在 Mojave 上按照文章给出的方式进行，还是出现下面的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find Mach task port for process-id 432: (os/kern) failure (0x5).</span><br><span class="line"> (please check gdb is codesigned - see taskgated(8))</span><br></pre></td></tr></table></figure>

<p>在这个过程中，我还遇到了不能创建系统证书的问题。</p>
<span id="more"></span>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先，系统证书的问题可以通过先创建一个登陆证书，然后将其拖拽到系统条目下即可。那么证书的问题就可以解决了，原以为就可以高高兴兴的调试代码了，可是发现还是出现 <code>Unable to find Mach task ...</code> 错误。</p>
<blockquote>
<ol>
<li>Open Keychain Access</li>
<li>In menu, open Keychain Access &gt; Certificate Assistant &gt; Create a certificate</li>
<li>Give it a name (e.g. gdbc)<ul>
<li>Identity type: Self Signed Root</li>
<li>Certificate type: Code Signing</li>
<li>Check: let me override defaults</li>
</ul>
</li>
<li>Continue until “specify a location for…”</li>
<li>Set Keychain location to System</li>
<li>Create certificate and close Certificate Assistant.</li>
<li>Find certificate in System keychain.</li>
<li>Double click certificate</li>
<li>Expand Trust, set Code signing to always trust</li>
<li>Restart taskgated in terminal: <code>killall taskgated</code></li>
</ol>
</blockquote>
<p>实际上我们在上面的步骤 7 是选择的 <code>Login</code> 而非 <code>System</code>，在证书创建成功之后在将其拖拽到 <code>System</code> 类别下的。我只执行到了步骤 10，之后的步骤便没有继续执行。而是使用下面的方式，</p>
<p>原来是代码签署权利的问题。原文如下：</p>
<blockquote>
<p>This is related to codesign entitlements. you must add “com.apple.security.cs.debugger” key in signing process.</p>
<p>for example you must change <code>codesign -fs gdbcert /usr/local/bin/gdb</code> to <code>codesign --entitlements gdb.xml -fs gdbcert /usr/local/bin/gdb</code>.</p>
<p><code>gdb.xml</code> content must something like following code.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">   &lt;key&gt;com.apple.security.cs.debugger&lt;/key&gt;</span><br><span class="line">   &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，我们在使用 <code>codesign</code> 时采用了如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat gdb.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;com.apple.security.cs.debugger&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line">$ codesign --entitlements gdb.xml -fs gdbcert /usr/local/bin/gdb</span><br></pre></td></tr></table></figure>

<p>按照上面命令执行之后，果然能愉快的使用 gdb 了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d">https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d</a><br>[2] <a href="https://stackoverflow.com/questions/52699661/macos-mojave-how-to-achieve-codesign-to-enable-debugging-gdb">https://stackoverflow.com/questions/52699661/macos-mojave-how-to-achieve-codesign-to-enable-debugging-gdb</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 数据库分片集群入门</title>
    <url>/2021/05/MongoDB-sharding/</url>
    <content><![CDATA[<p>本文结合官方文档整理记录了一下关于 MongoDB 中分片的概念以及如何搭建一个分片集群。</p>
<span id="more"></span>

<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片（Sharding）是一种用于在多台计算机之间分配数据的方法。MongoDB 使用分片来支持具有非常大的数据集和高吞吐量操作的部署。</p>
<p>大数据集的数据库系统或高吞吐量应用程序对单个服务器的容量来说是一种挑战。例如，高查询率可能会耗尽服务器的 CPU 容量。大于系统 RAM 的工作集会增加磁盘驱动器的 I/O 压力。</p>
<p>垂直扩展（Vertical Scaling）可以增加单个服务器的处理能力，例如使用更快的 CPU，增加 RAM，或者增加存储空间。可用技术的局限性可能会限制一台计算机对于给定的工作负载没有足够的功能。此外，基于云的提供程序具有基于可用硬件配置的严格上限。因此，垂直扩展有一个实际的最大值。</p>
<p>水平扩展（Horizontal Scaling）涉及数据集的划分并在多台服务器上加载，同时添加其他服务器已根据需要增加容量。虽然单台计算机的整体速度或容量可能不高，但是每台计算机只能处理全部工作量的一部分，因此与单台高速大容量服务器相比，可能会提供更高的效率。扩展部署的容量仅需要根据需要添加其他服务器，这可以比单台机器的高端硬件降低总体成本。折衷方案是增加基础结构和部署维护的复杂性。</p>
<p>MongoDB 通过分片的方式支持水平扩展。</p>
<h3 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h3><p>MongoDB 分片集群（sharded cluster）包含以下组件：</p>
<ul>
<li><strong>shard</strong>: 每个分片都包含分片数据的子集。每个分片都可以部署为副本集。</li>
<li><strong>mongos</strong>: mongos 充当查询路由器，在客户端应用程序和分片群集之间提供接口。</li>
<li><strong>config servers</strong>: 配置服务器（config servers）存储群集的元数据和配置设置。</li>
</ul>
<p>下图描述了分片群集中组件的交互：</p>
<img src="/2021/05/MongoDB-sharding/sharded-cluster-production-architecture.bakedsvg.svg" class="">

<p>MongoDB 在 collection 级别对数据进行分片，从而将 collection 数据分布在集群中的各个分片上。</p>
<h3 id="分片键"><a href="#分片键" class="headerlink" title="分片键"></a>分片键</h3><p>MongoDB 使用分片键（shard keys）在各个分片之间分发 collection 的文档。分片键由文档中的一个或多个字段组成。</p>
<ul>
<li>从版本 4.4 开始，分片集合中的文档的分片键不再是必须的。缺少分片键在跨分片分发文档时被视为空值，但是在路由查询时则不会将其视为空值。</li>
<li>在 4.2 及更早版本中，分片集合中的每个文档中都必须存在分片键字段。</li>
</ul>
<p>文档的分片键值决定了其在各个分片中的分布。</p>
<ul>
<li>从 4.2 版本开始，如果您的文档分片键不包括不可变的 <code>_id</code> 域，那么您是可以更新文档分片键的。</li>
<li>在 4.0 及更早版本中，文档的分片键是不可变的。</li>
</ul>
<h3 id="分片键索引"><a href="#分片键索引" class="headerlink" title="分片键索引"></a>分片键索引</h3><p>要对已填充的集合进行分片，该集合必须具有以分片键开头的索引。在对一个空集合进行分片时，如果该集合还没有针对指定分片键的适当索引，则 MongoDB 会创建支持索引。</p>
<h3 id="分片键策略"><a href="#分片键策略" class="headerlink" title="分片键策略"></a>分片键策略</h3><p>分片键的选择会影响分片群集的性能，效率和可伸缩性。在拥有最佳硬件和基础结构的集群中，分片键可能会成为性能的瓶颈。</p>
<h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>MongoDB 分区将分片数据划分为块（chunks）。每个块都有一个基于分片键的范围，其包含下边界，而不包含上边界。</p>
<h3 id="均衡器和均匀分配"><a href="#均衡器和均匀分配" class="headerlink" title="均衡器和均匀分配"></a>均衡器和均匀分配</h3><p>为了在整个集群中的所有分片上实现块的均匀分布，均衡器在后台运行，以在各分片上迁移块。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>我们将在一台机器上部署 3 个配置服务器，3 个分片服务器（每个分片服务器包含 3 个副本集）以及 3 个 mongos 服务器，如下表所示。</p>
<table>
<thead>
<tr>
<th>name</th>
<th>IP</th>
<th>port</th>
</tr>
</thead>
<tbody><tr>
<td>config server1</td>
<td>127.0.0.1</td>
<td>27011</td>
</tr>
<tr>
<td>config server2</td>
<td>127.0.0.1</td>
<td>27012</td>
</tr>
<tr>
<td>config server3</td>
<td>127.0.0.1</td>
<td>27013</td>
</tr>
<tr>
<td>shard01 repl01</td>
<td>127.0.0.1</td>
<td>28011</td>
</tr>
<tr>
<td>shard01 repl02</td>
<td>127.0.0.1</td>
<td>28012</td>
</tr>
<tr>
<td>shard01 repl03</td>
<td>127.0.0.1</td>
<td>28013</td>
</tr>
<tr>
<td>shard02 repl01</td>
<td>127.0.0.1</td>
<td>28021</td>
</tr>
<tr>
<td>shard02 repl02</td>
<td>127.0.0.1</td>
<td>28022</td>
</tr>
<tr>
<td>shard02 repl03</td>
<td>127.0.0.1</td>
<td>28023</td>
</tr>
<tr>
<td>shard03 repl03</td>
<td>127.0.0.1</td>
<td>28031</td>
</tr>
<tr>
<td>shard03 repl03</td>
<td>127.0.0.1</td>
<td>28032</td>
</tr>
<tr>
<td>shard03 repl03</td>
<td>127.0.0.1</td>
<td>28033</td>
</tr>
<tr>
<td>mongos01</td>
<td>127.0.0.1</td>
<td>27017</td>
</tr>
<tr>
<td>mongos01</td>
<td>127.0.0.1</td>
<td>27018</td>
</tr>
<tr>
<td>mongos01</td>
<td>127.0.0.1</td>
<td>27019</td>
</tr>
</tbody></table>
<h3 id="创建配置服务器"><a href="#创建配置服务器" class="headerlink" title="创建配置服务器"></a>创建配置服务器</h3><p>对于生产环境来说，需要至少部署配置服务器三个副本集。配置服务器 01 配置文件 <code>config-server01.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">clusterRole:</span> <span class="string">configsvr</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">configServerRepl</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27011</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/home/japin/MongoDB/shardData/config-server-data01</span></span><br></pre></td></tr></table></figure>

<p>配置服务器 02 配置文件 <code>config-server02.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">clusterRole:</span> <span class="string">configsvr</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">configServerRepl</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27012</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/home/japin/MongoDB/shardData/config-server-data02</span></span><br></pre></td></tr></table></figure>

<p>配置服务器 03 配置文件 <code>config-server03.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">clusterRole:</span> <span class="string">configsvr</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">configServerRepl</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27013</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/home/japin/MongoDB/shardData/config-server-data03</span></span><br></pre></td></tr></table></figure>

<p>创建配置服务器数据目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /home/japin/MongoDB/shardData/config-server-data0&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<p>启动配置服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 3); <span class="keyword">do</span> mongod --fork --config config-server0<span class="variable">$i</span>.yml; <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<p>初始化配置服务器副本集。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ mongo --host <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">27011</span></span><br><span class="line">rs.initiate(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">&quot;configServerRepl&quot;</span>,</span><br><span class="line">    <span class="attr">configsvr</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">members</span>: [</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">&quot;127.0.0.1:27011&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">&quot;127.0.0.1:27012&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">_id</span>: <span class="number">3</span>, <span class="attr">host</span>: <span class="string">&quot;127.0.0.1:27013&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="创建分片服务器"><a href="#创建分片服务器" class="headerlink" title="创建分片服务器"></a>创建分片服务器</h3><p>分片节点 <code>01</code> 的配置文件，包含三个副本集合。分片节点 <code>01</code> 副本集 <code>01</code> 的配置 <code>shard01-01.yml</code> 如下所示。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/home/japin/MongoDB/log/shard01-01.log&#x27;</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">clusterRole:</span> <span class="string">shardsvr</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">shardServer01Repl</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28011</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/home/japin/MongoDB/shardData/shard01-data01</span></span><br></pre></td></tr></table></figure>

<p>分片节点 <code>01</code> 副本集 <code>02</code> 的配置 <code>shard01-02.yml</code> 如下所示。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/home/japin/MongoDB/log/shard01-02.log&#x27;</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">clusterRole:</span> <span class="string">shardsvr</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">shardServer01Repl</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28012</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/home/japin/MongoDB/shardData/shard01-data02</span></span><br></pre></td></tr></table></figure>

<p>分片节点 <code>01</code> 副本集 <code>03</code> 的配置 <code>shard01-03.yml</code> 如下所示。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/home/japin/MongoDB/log/shard01-03.log&#x27;</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">clusterRole:</span> <span class="string">shardsvr</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">shardServer01Repl</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">28013</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/home/japin/MongoDB/shardData/shard01-data03</span></span><br></pre></td></tr></table></figure>

<p>其他两个分片服务器机器副本集与上面类似，这里就不赘述了。接下来我们创建目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /home/japin/MongoDB/shardData/shard0&#123;1,2,3&#125;-data0&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<p>启动所有分片副本集节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 3); <span class="keyword">do</span> <span class="keyword">for</span> j <span class="keyword">in</span> $(seq 1 3); <span class="keyword">do</span> mongod --fork --config shard0<span class="variable">$i</span>-0<span class="variable">$j</span>.yml; <span class="keyword">done</span> <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<p>初始化 <code>shard01</code> 分片副本集。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mongo --host 127.0.0.1 --port 28011</span></span><br><span class="line">rs.initiate(</span><br><span class="line">  &#123;</span><br><span class="line">    _id: &quot;shardServer01Repl&quot;,</span><br><span class="line">    members: [</span><br><span class="line">      &#123; _id: 1, host: &quot;127.0.0.1:28011&quot; &#125;,</span><br><span class="line">      &#123; _id: 2, host: &quot;127.0.0.1:28012&quot; &#125;,</span><br><span class="line">      &#123; _id: 3, host: &quot;127.0.0.1:28013&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>初始化 <code>shard02</code> 分片副本集。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mongo --host 127.0.0.1 --port 28021</span></span><br><span class="line">rs.initiate(</span><br><span class="line">  &#123;</span><br><span class="line">    _id: &quot;shardServer02Repl&quot;,</span><br><span class="line">    members: [</span><br><span class="line">      &#123; _id: 1, host: &quot;127.0.0.1:28021&quot; &#125;,</span><br><span class="line">      &#123; _id: 2, host: &quot;127.0.0.1:28022&quot; &#125;,</span><br><span class="line">      &#123; _id: 3, host: &quot;127.0.0.1:28023&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>初始化 <code>shard03</code> 分片副本集l。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mongo --host 127.0.0.1 --port 28031</span></span><br><span class="line">rs.initiate(</span><br><span class="line">  &#123;</span><br><span class="line">    _id: &quot;shardServer03Repl&quot;,</span><br><span class="line">    members: [</span><br><span class="line">      &#123; _id: 1, host: &quot;127.0.0.1:28031&quot; &#125;,</span><br><span class="line">      &#123; _id: 2, host: &quot;127.0.0.1:28032&quot; &#125;,</span><br><span class="line">      &#123; _id: 3, host: &quot;127.0.0.1:28033&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="创建-mongos-服务器"><a href="#创建-mongos-服务器" class="headerlink" title="创建 mongos 服务器"></a>创建 mongos 服务器</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/home/japin/MongoDB/log/mongos01.log&#x27;</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">configDB:</span> <span class="string">configServerRepl/127.0.0.1:27011,127.0.0.1:27012,127.0.0.1:27013</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/home/japin/MongoDB/log/mongos02.log&#x27;</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">configDB:</span> <span class="string">configServerRepl/127.0.0.1:27011,127.0.0.1:27012,127.0.0.1:27013</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27018</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;/home/japin/MongoDB/log/mongos03.log&#x27;</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">  <span class="attr">configDB:</span> <span class="string">configServerRepl/127.0.0.1:27011,127.0.0.1:27012,127.0.0.1:27013</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 3); <span class="keyword">do</span> mongos --fork --config mongos0<span class="variable">$i</span>.yml; <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<h3 id="添加分片服务器到集群"><a href="#添加分片服务器到集群" class="headerlink" title="添加分片服务器到集群"></a>添加分片服务器到集群</h3><p>以下操作将单个分片副本集添加到集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mongo --host 127.0.0.1 --port 27017</span></span><br><span class="line">sh.addShard(&quot;shardServer01Repl/127.0.0.1:28011,127.0.0.1:28012,127.0.0.1:28013&quot;)</span><br><span class="line">sh.addShard(&quot;shardServer02Repl/127.0.0.1:28021,127.0.0.1:28022,127.0.0.1:28023&quot;)</span><br><span class="line">sh.addShard(&quot;shardServer03Repl/127.0.0.1:28031,127.0.0.1:28032,127.0.0.1:28033&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="为数据库开启分片"><a href="#为数据库开启分片" class="headerlink" title="为数据库开启分片"></a>为数据库开启分片</h3><p>首先使用 <code>use mydb</code> 创建一个数据库，随后通过 <code>sh.enableSharding(&quot;mydb&quot;)</code> 为其开启分片功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mongos&gt;</span><span class="bash"> sh.enableSharding(<span class="string">&quot;mydb&quot;</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1621422117, 7),</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1621422117, 8),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的命令查看服务器分片信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mongos&gt;</span><span class="bash"> db.serverStatus().sharding</span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;configsvrConnectionString&quot; : &quot;configServerRepl/127.0.0.1:27011,127.0.0.1:27012,127.0.0.1:27013&quot;,</span><br><span class="line">	&quot;lastSeenConfigServerOpTime&quot; : &#123;</span><br><span class="line">		&quot;ts&quot; : Timestamp(1621422635, 17),</span><br><span class="line">		&quot;t&quot; : NumberLong(1)</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;maxChunkSizeInBytes&quot; : NumberLong(67108864)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">mongos&gt;</span><span class="bash"> db.serverStatus().shardingStatistics</span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;numHostsTargeted&quot; : &#123;</span><br><span class="line">		&quot;find&quot; : &#123;</span><br><span class="line">			&quot;allShards&quot; : 0,</span><br><span class="line">			&quot;manyShards&quot; : 0,</span><br><span class="line">			&quot;oneShard&quot; : 0,</span><br><span class="line">			&quot;unsharded&quot; : 0</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;insert&quot; : &#123;</span><br><span class="line">			&quot;allShards&quot; : 0,</span><br><span class="line">			&quot;manyShards&quot; : 0,</span><br><span class="line">			&quot;oneShard&quot; : 0,</span><br><span class="line">			&quot;unsharded&quot; : 0</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;update&quot; : &#123;</span><br><span class="line">			&quot;allShards&quot; : 0,</span><br><span class="line">			&quot;manyShards&quot; : 0,</span><br><span class="line">			&quot;oneShard&quot; : 0,</span><br><span class="line">			&quot;unsharded&quot; : 0</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;delete&quot; : &#123;</span><br><span class="line">			&quot;allShards&quot; : 0,</span><br><span class="line">			&quot;manyShards&quot; : 0,</span><br><span class="line">			&quot;oneShard&quot; : 0,</span><br><span class="line">			&quot;unsharded&quot; : 0</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;aggregate&quot; : &#123;</span><br><span class="line">			&quot;allShards&quot; : 0,</span><br><span class="line">			&quot;manyShards&quot; : 0,</span><br><span class="line">			&quot;oneShard&quot; : 0,</span><br><span class="line">			&quot;unsharded&quot; : 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;catalogCache&quot; : &#123;</span><br><span class="line">		&quot;numDatabaseEntries&quot; : NumberLong(1),</span><br><span class="line">		&quot;numCollectionEntries&quot; : NumberLong(1),</span><br><span class="line">		&quot;countStaleConfigErrors&quot; : NumberLong(0),</span><br><span class="line">		&quot;totalRefreshWaitTimeMicros&quot; : NumberLong(3385241),</span><br><span class="line">		&quot;numActiveIncrementalRefreshes&quot; : NumberLong(0),</span><br><span class="line">		&quot;countIncrementalRefreshesStarted&quot; : NumberLong(2),</span><br><span class="line">		&quot;numActiveFullRefreshes&quot; : NumberLong(0),</span><br><span class="line">		&quot;countFullRefreshesStarted&quot; : NumberLong(2),</span><br><span class="line">		&quot;countFailedRefreshes&quot; : NumberLong(0),</span><br><span class="line">		&quot;operationsBlockedByRefresh&quot; : &#123;</span><br><span class="line">			&quot;countAllOperations&quot; : NumberLong(0),</span><br><span class="line">			&quot;countInserts&quot; : NumberLong(0),</span><br><span class="line">			&quot;countQueries&quot; : NumberLong(0),</span><br><span class="line">			&quot;countUpdates&quot; : NumberLong(0),</span><br><span class="line">			&quot;countDeletes&quot; : NumberLong(0),</span><br><span class="line">			&quot;countCommands&quot; : NumberLong(0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">mongos&gt;</span><span class="bash"> db.printShardingStatus()</span></span><br><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">  	&quot;_id&quot; : 1,</span><br><span class="line">  	&quot;minCompatibleVersion&quot; : 5,</span><br><span class="line">  	&quot;currentVersion&quot; : 6,</span><br><span class="line">  	&quot;clusterId&quot; : ObjectId(&quot;60a4e790c9fbede2e257b1f8&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shardServer01Repl&quot;,  &quot;host&quot; : &quot;shardServer01Repl/127.0.0.1:28011,127.0.0.1:28012,127.0.0.1:28013&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shardServer02Repl&quot;,  &quot;host&quot; : &quot;shardServer02Repl/127.0.0.1:28021,127.0.0.1:28022,127.0.0.1:28023&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shardServer03Repl&quot;,  &quot;host&quot; : &quot;shardServer03Repl/127.0.0.1:28031,127.0.0.1:28032,127.0.0.1:28033&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">        &quot;4.4.4&quot; : 3</span><br><span class="line">  autosplit:</span><br><span class="line">        Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">        Currently enabled:  yes</span><br><span class="line">        Currently running:  yes</span><br><span class="line">        Collections with active migrations:</span><br><span class="line">                config.system.sessions started at Wed May 19 2021 19:16:45 GMT+0800 (CST)</span><br><span class="line">        Failed balancer rounds in last 5 attempts:  0</span><br><span class="line">        Migration Results for the last 24 hours:</span><br><span class="line">                248 : Success</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;config&quot;,  &quot;primary&quot; : &quot;config&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                config.system.sessions</span><br><span class="line">                        shard key: &#123; &quot;_id&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shardServer01Repl	776</span><br><span class="line">                                shardServer02Repl	124</span><br><span class="line">                                shardServer03Repl	124</span><br><span class="line">                        too many chunks to print, use verbose if you want to force print</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;mydb&quot;,  &quot;primary&quot; : &quot;shardServer02Repl&quot;,  &quot;partitioned&quot; : true,  &quot;version&quot; : &#123;  &quot;uuid&quot; : UUID(&quot;5d958304-ff6a-4568-88d4-20f3dcc568c5&quot;),  &quot;lastMod&quot; : 1 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.mongodb.com/manual/sharding/">https://docs.mongodb.com/manual/sharding/</a><br>[2] <a href="https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/">https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/</a></p>
<div class="just-for-fun">
笑林广记 - 偶遇知音

<p>某生素善琴，尝谓世无知音，抑抑不乐。<br>一日无事，抚琴消遣，忽闻隔邻，有叹息声，大喜，以为知音在是，款扉叩之，<br>邻媪曰：“无他，亡儿存日，以弹絮为业，今客鼓此，酷类其音，闻之，不觉悲从中耳。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle sys_connect_by_path 函数迁移到 PostgreSQL 数据库</title>
    <url>/2021/05/Oracle-sys-connect-by-path-to-PostgreSQL/</url>
    <content><![CDATA[<p>本文简要记录一下如何将 Oracle 数据库中的 <code>sys_connect_by_path()</code> 函数迁移到 PostgreSQL 数据库中。</p>
<p>函数 <code>sys_connect_by_path()</code> 通常是与 Oracle 中的 <code>connect by</code> 子句一起使用的，而 <code>connect by</code> 子句转换到 PostgreSQL 中时通常是使用 <code>WITH RECUSIVE</code> 来实现。</p>
<span id="more"></span>

<h2 id="最小示例"><a href="#最小示例" class="headerlink" title="最小示例"></a>最小示例</h2><p>为了演示，本文提供了一个最小可执行示例。Oracle 中的示例表如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl(id <span class="type">int</span>, pid <span class="type">int</span>, path <span class="type">varchar</span>(<span class="number">100</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;home&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;ubuntu&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;codes&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;centos&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">4</span>, <span class="string">&#x27;videos&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于 PostgreSQL 与 Oracle 数据类型有所不同，这里需要对表结构进行简单的修改，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl(id <span class="type">int</span>, pid <span class="type">int</span>, path text);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;home&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;ubuntu&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;codes&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;centos&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">4</span>, <span class="string">&#x27;videos&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Oracle-sys-connect-by-path-示例"><a href="#Oracle-sys-connect-by-path-示例" class="headerlink" title="Oracle sys_connect_by_path 示例"></a>Oracle sys_connect_by_path 示例</h2><p>函数 <code>sys_connect_by_path</code> 仅在分层查询中有效。它返回从根到节点的列值的路径，对于 <code>CONNECT BY</code> 条件返回的每一行，列值用指定分隔符进行分隔。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  id,</span><br><span class="line">  pid,</span><br><span class="line">  path,</span><br><span class="line">  sys_connect_by_path(path, <span class="string">&#x27;/&#x27;</span>) <span class="keyword">AS</span> full_path</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  tbl t</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span></span><br><span class="line">  t.pid <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span></span><br><span class="line">  PRIOR t.id <span class="operator">=</span> t.pid;</span><br><span class="line"> ID <span class="operator">|</span> PID <span class="operator">|</span>  PATH  <span class="operator">|</span>     FULL_PATH</span><br><span class="line"><span class="comment">----+-----+--------+---------------------</span></span><br><span class="line"> <span class="number">1</span>  <span class="operator">|</span>  <span class="number">0</span>  <span class="operator">|</span> home   <span class="operator">|</span> <span class="operator">/</span>home</span><br><span class="line"> <span class="number">2</span>  <span class="operator">|</span>  <span class="number">1</span>  <span class="operator">|</span> ubuntu <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>ubuntu</span><br><span class="line"> <span class="number">3</span>  <span class="operator">|</span>  <span class="number">2</span>  <span class="operator">|</span> codes  <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>ubuntu<span class="operator">/</span>codes</span><br><span class="line"> <span class="number">4</span>  <span class="operator">|</span>  <span class="number">1</span>  <span class="operator">|</span> centos <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>centos</span><br><span class="line"> <span class="number">5</span>  <span class="operator">|</span>  <span class="number">4</span>  <span class="operator">|</span> videos <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>centos<span class="operator">/</span>videos</span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL-迁移-sys-connect-by-path"><a href="#PostgreSQL-迁移-sys-connect-by-path" class="headerlink" title="PostgreSQL 迁移 sys_connect_by_path"></a>PostgreSQL 迁移 sys_connect_by_path</h2><p>下面我们使用递归 CTE 来实现 Oracle 中的 <code>sys_connect_by_path</code> 函数的功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    id,</span><br><span class="line">    pid,</span><br><span class="line">    path,</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span> <span class="operator">||</span> path <span class="keyword">AS</span> full_path</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    tbl</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    pid <span class="operator">=</span> <span class="number">0</span>   <span class="comment">-- START WITH</span></span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    t.id,</span><br><span class="line">    t.pid,</span><br><span class="line">    t.path,</span><br><span class="line">    cte.full_path <span class="operator">||</span> <span class="string">&#x27;/&#x27;</span> <span class="operator">||</span> t.path <span class="keyword">AS</span> full_path</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    tbl t <span class="keyword">JOIN</span> cte</span><br><span class="line">      <span class="keyword">ON</span> cte.id <span class="operator">=</span> t.pid <span class="comment">-- CONNECT BY</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte;</span><br><span class="line"> id <span class="operator">|</span> pid <span class="operator">|</span>  path  <span class="operator">|</span>      full_path</span><br><span class="line"><span class="comment">----+-----+--------+---------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> home   <span class="operator">|</span> <span class="operator">/</span>home</span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> ubuntu <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>ubuntu</span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> centos <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>centos</span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span> codes  <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>ubuntu<span class="operator">/</span>codes</span><br><span class="line">  <span class="number">5</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> videos <span class="operator">|</span> <span class="operator">/</span>home<span class="operator">/</span>centos<span class="operator">/</span>videos</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>这里需要注意，我们需要在开始的时候在需要连接的字段前加上分隔符，这样才能与 Oracle 保持一致。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions164.htm">https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions164.htm</a></p>
<div class="just-for-fun">
笑林广记 - 应先备酒

<p>妻好吃酒，屡索夫不与，叱之曰：“开门七件事：柴、米、油、盐、酱、醋、茶，何曾见个酒字？”<br>妻曰：“酒是不曾开门就要用的，须是隔夜先买，如何放得在开门里面？”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>非超级用户下运行 Solaris SMF 服务</title>
    <url>/2019/10/SMF-on-Solaris-under-non-superuser/</url>
    <content><![CDATA[<p>今天在 Solaris 上遇到一个问题，我需要在非超级用户下运行某个服务。默认情况下，通过 SMF 管理的都是在 root 用户下运行的，但是我们可以通过修改配置文件来使其运行到特定用户下。</p>
<span id="more"></span>

<p>例如，我们有如下一个配置文件（部分）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exec_method</span> <span class="attr">type</span>=<span class="string">&quot;method&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;/path/to/exec_binary <span class="symbol">&amp;amp;</span>&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method_context</span> <span class="attr">working_directory</span>=<span class="string">&quot;/path/to/work&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method_environment</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">envar</span> <span class="attr">name</span>=<span class="string">&quot;HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/home/path&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">method_environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method_context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exec_method</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们想要 <code>exec_binary</code> 在 <code>tom</code> 用户下运行，那么我们需要加入 <code>method_credential</code> 元素，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exec_method</span> <span class="attr">type</span>=<span class="string">&quot;method&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span> <span class="attr">exec</span>=<span class="string">&quot;/path/to/exec_binary <span class="symbol">&amp;amp;</span>&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method_context</span> <span class="attr">working_directory</span>=<span class="string">&quot;/path/to/work&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method_credential</span> <span class="attr">user</span>=<span class="string">&quot;tom&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method_environment</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">envar</span> <span class="attr">name</span>=<span class="string">&quot;HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/home/path&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">method_environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method_context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exec_method</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们便可以在 <code>tom</code> 用户下运行 <code>exec_binary</code> 的服务了，这里需要注意 <code>method_credential</code> 的位置，它需要位于 <code>method_environment</code> 之前，否则将出现如下问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element method_context: validity error : Element method_context content does not follow the DTD, expecting ((method_profile | method_credential)? , method_environment?), got (method_environment method_credential )</span><br><span class="line">svccfg: Document is not valid.</span><br></pre></td></tr></table></figure>

<p>我们可通过查看 <code>/usr/share/lib/xml/dtd/service_bundle.dtd.1</code> 文件来了解更多的 SMF 配置信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.linuxquestions.org/questions/solaris-opensolaris-20/problem-by-validate-a-manefest-file-4175468958/">https://www.linuxquestions.org/questions/solaris-opensolaris-20/problem-by-validate-a-manefest-file-4175468958/</a><br>[2] <a href="https://www.master-tutorial.design/2010/06/credentials-and-projects-for-solaris-10.html">https://www.master-tutorial.design/2010/06/credentials-and-projects-for-solaris-10.html</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Solaris</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾 ARP 协议</title>
    <url>/2019/09/arp-protocol/</url>
    <content><![CDATA[<p>ARP (Address Resolution Protoco)，中文地址解析协议，用来将网络层的 IP 地址转换为数据链路层的物理地址，该协议属于 TCP/IP 协议簇。当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据 48 bit 的以太网地址来确定目的接口的。设备驱动程序从不检查 IP 数据报中的目的 IP 地址。而地址解析为这两种不同的地址形式提供映射: 32 bit 的 IP 地址和数据链路层使用的任何类型的地址。<a href="https://tools.ietf.org/rfc/rfc826.txt">RFC 826</a> 给出了 ARP 协议的规范。ARP 协议为 IP 地址到对应的硬件物理地址提供了动态映射，通常情况下用户或系统管理员不用担心。</p>
<span id="more"></span>

<h2 id="ARP-原理"><a href="#ARP-原理" class="headerlink" title="ARP 原理"></a>ARP 原理</h2><p>我们知道主机之间是通过 IP 地址来进行通信的，而 IP 地址属于网络层，而实际上网络通信需要知道通信设备的硬件地址（即 MAC 地址）。ARP 协议便是做这项工作的。假设我们在局域网中有两台主机 <code>A</code> 和 <code>B</code>，<code>A</code> 想要与 <code>B</code> 进行通信，但是 <code>A</code> 只知道 <code>B</code> 的 IP 地址，其通信的硬件地址查询过程如下：</p>
<ol>
<li>主机 <code>A</code> 首先检测自己的 ARP 缓存中是否包含主机 <code>B</code> 的 IP 与 MAC 地址之间的映射关系。如果存在则可以直接通信；反之，则需要先获取主机 <code>B</code> 的 IP 与 MAC 地址之间的映射关系。</li>
<li>主机 <code>A</code> 的 ARP 缓存中不存在该 IP 地址的映射记录，因此主机 <code>A</code> 需要想局域网广播请求该 IP 对应的 MAC 地址。</li>
<li>局域网内的其它机器在收到该 ARP 请求之后，会获取主机 <code>A</code> 的 IP 地址和 MAC 地址并添加到自己的 ARP 缓存中，若该主机的 IP 地址为 ARP 所请求的 IP 地址，那么它需要发送 ARP 响应包，反之，则忽略该 ARP 请求。</li>
<li>主机 <code>B</code> 在接收到该 ARP 请求之后会将自己的 IP 地址和 MAC 地址填入数据包中并__定向__ 发送给主机 <code>A</code>。</li>
<li>主机 <code>A</code> 在接收到主机  <code>B</code> 的 ARP 响应之后使用该包的 IP 和 MAC 地址更新 ARP 缓存。此时，主机 <code>A</code> 和 <code>B</code> 便可以正常通信了。</li>
</ol>
<p>我们可以通过 <code>arp -a</code> 查看当前的 ARP 缓存。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">xiaoqiang (192.168.31.1) at 50:64:2b:18:b8:e3 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.31.29) at e0:6:e6:ca:25:26 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.31.126) at 40:83:1d:b9:f4:71 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.31.255) at ff:ff:ff:ff:ff:ff on en0 ifscope [ethernet]</span><br><span class="line">? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]</span><br><span class="line">? (239.255.255.250) at 1:0:5e:7f:ff:fa on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure>

<h2 id="ARP-报文格式"><a href="#ARP-报文格式" class="headerlink" title="ARP 报文格式"></a>ARP 报文格式</h2><p>在以太网上解析 IP 地址时，ARP 请求和应答的格式如下图所示。</p>
<img src="/2019/09/arp-protocol/arp.png" class="" title="ARP 报文结构">

<ul>
<li>以太网报头中的前两个字段是以太网的目的地址和源地址（即物理地址、MAC 地址）。若目的地址全为 <code>1</code>，这表明其为广播地址。局域网中的所有以太网接口都要接收广播的数据帧。</li>
<li>帧类型则表明后续的数据类型，对于 ARP 请求和应答来说，它为 <code>0x0806</code>。</li>
<li>硬件类型和协议类型用来描述 ARP 分组中的各个字段。 例如，一个 ARP 请求分组询问协议地址（这里是 IP 地址）对应的硬件地址（这里是以太网地址)。硬件类型字段表示硬件地址的类型。它的值为 <code>1</code> 即表示以太网地址。协议类型字段表示要映射的协议地址类型。它的值为 <code>0x0800</code> 即表示 IP 地址。</li>
<li>硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上 IP 地址的 ARP 请求或应答来说，它们的值分别为 <code>6</code> 和 <code>4</code>。</li>
<li>操作字段 <code>op</code> 给出了操作类型，它包含 ARP 请求 （<code>1</code>）、ARP 应答（<code>2</code>）、RARP 请求（<code>3</code>）和 RARP 应答（<code>4</code>）四种操作。</li>
<li>最后四个字段分别是发送端的以太网地址和协议地址以及目的端的以太网地址和协议地址。</li>
</ul>
<h2 id="ARP-请求与响应"><a href="#ARP-请求与响应" class="headerlink" title="ARP 请求与响应"></a>ARP 请求与响应</h2><p>现在我们对 ARP 的工作原理以及报文格式有所了解，接下来就是如何去填充 ARP 报文？当我们请求一个 IP 地址的 MAC 地址时，我们是不知道其 MAC 地址的，即__以太网目的地址__和__目的端以太网地址__，而__以太网源地址__、<strong>发送端以太网地址__、__发送端 IP 地址__以及__目的端 IP 地址__我们是知道的。__op</strong> 字段则是根据 ARP 操作类型进行填充，这里为 ARP 请求，故值为 <code>1</code>。其它五个字段则是固定的，__帧类型__为 <code>0x0806</code>；__硬件类型__为 <code>0x01</code>；__协议类型__为 <code>0x0800</code>；__硬件地址长度__为 <code>6</code>；__协议地址长度__为 <code>4</code>。那么我们该如何填充__以太网目的地址__和__目的端以太网地址__呢？其实它们是相同的。我们需要将其设置为广播地址（<code>0xFF,0xFF, 0xFF,0xFF,0xFF, 0xFF</code>），这样局域网中的每个网络接口都会接收这个数据包并进行处理。</p>
<p>如下图所示，我在主机 <code>lenovo</code> 上通过 <code>arping -I interface 192.168.31.138</code> 向局域网查询 IP 地址为 <code>192.168.31.138</code> 的 MAC 地址，同时在该主机上通过 <code>tcpdum</code> 捕获 ARP 数据包。</p>
<img src="/2019/09/arp-protocol/tcpdump_arp.png" class="" title="ARP 请求响应">

<p>ARP 响应报文则是将 ARP 请求包中的__以太网源地址__设置为响应主机的以太网地址，同时将 ARP 请求报文中的__以太网源地址__设置为响应报文中的__以太网目的地址__，同时需要将 ARP 请求报文中的 __发送端以太网地址__和__发送端 IP 地址__分别设置为 ARP 响应报文中的 __目的端以太网地址__和__目的端 IP 地址__，ARP 请求报文中的 __目的端 IP 地址__设置为 ARP 响应报文的__发送端 IP 地址__，并将该 IP 地址所在网卡的 MAC 地址设置为 ARP 响应报文中的 __发送端以太网地址__，最后更新 <strong>op</strong> 为 <code>2</code>，即 ARP 响应。</p>
<h2 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h2><p>如果在 ARP 请求报文中的__目的端 IP 地址__和__发送端 IP 地址__相同时会出现什么情况呢？这种情况属于 ARP 的一种特性，即免费 ARP （Gratuitous ARP）。</p>
<p>免费ARP可以有两个方面的作用：</p>
<ol>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。</li>
<li>通过发送免费 ARP 来更新局域网中该 IP 地址对应的 MAC 地址，即刷新局域网主机的 ARP 缓存。</li>
</ol>
<p>我们可以通过 <code>arping -I interface -U ipaddress</code> 来发送免费 ARP。</p>
<h2 id="关于-ARP-的编程"><a href="#关于-ARP-的编程" class="headerlink" title="关于 ARP 的编程"></a>关于 ARP 的编程</h2><p>在 Linux 平台上，<code>&lt;netinet/if_ether.h&gt;</code> 头文件中定义了 ARP 地址解析协议的数据结构，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ethernet Address Resolution Protocol.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See RFC 826 for protocol description.  Structure below is adapted</span></span><br><span class="line"><span class="comment"> * to resolving internet addresses.  Field names used correspond to</span></span><br><span class="line"><span class="comment"> * RFC 826.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">ether_arp</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">arphdr</span> <span class="title">ea_hdr</span>;</span>          <span class="comment">/* fixed-size header */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_sha[ETH_ALEN];      <span class="comment">/* sender hardware address */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_spa[<span class="number">4</span>];             <span class="comment">/* sender protocol address */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_tha[ETH_ALEN];      <span class="comment">/* target hardware address */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> arp_tpa[<span class="number">4</span>];             <span class="comment">/* target protocol address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_hrd ea_hdr.ar_hrd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_pro ea_hdr.ar_pro</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_hln ea_hdr.ar_hln</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_pln ea_hdr.ar_pln</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arp_op  ea_hdr.ar_op</span></span><br></pre></td></tr></table></figure>

<p><code>struct arphdr</code> 则定义在 <code>&lt;net/if_arp.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ARP protocol opcodes. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_REQUEST   1               <span class="comment">/* ARP request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_REPLY     2               <span class="comment">/* ARP reply.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_RREQUEST  3               <span class="comment">/* RARP request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_RREPLY    4               <span class="comment">/* RARP reply.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_InREQUEST 8               <span class="comment">/* InARP request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_InREPLY   9               <span class="comment">/* InARP reply.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARPOP_NAK       10              <span class="comment">/* (ATM)ARP NAK.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* See RFC 826 for protocol description.  ARP packets are variable</span></span><br><span class="line"><span class="comment">   in size; the arphdr structure defines the fixed-length portion.</span></span><br><span class="line"><span class="comment">   Protocol type values are the same as those for 10 Mb/s Ethernet.</span></span><br><span class="line"><span class="comment">   It is followed by the variable-sized fields ar_sha, arp_spa,</span></span><br><span class="line"><span class="comment">   arp_tha and arp_tpa in that order, according to the lengths</span></span><br><span class="line"><span class="comment">   specified.  Field names used correspond to RFC 826.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ar_hrd;          <span class="comment">/* Format of hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ar_pro;          <span class="comment">/* Format of protocol address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ar_hln;               <span class="comment">/* Length of hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ar_pln;               <span class="comment">/* Length of protocol address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ar_op;           <span class="comment">/* ARP opcode (command).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">/* Ethernet looks like this : This bit is variable sized</span></span><br><span class="line"><span class="comment">       however...  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_sha[ETH_ALEN];   <span class="comment">/* Sender hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_sip[<span class="number">4</span>];          <span class="comment">/* Sender IP address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_tha[ETH_ALEN];   <span class="comment">/* Target hardware address.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __ar_tip[<span class="number">4</span>];          <span class="comment">/* Target IP address.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>而以太网首都则定义在 <code>&lt;net/ethernet.h&gt;</code> 头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a name for the 48 bit ethernet address available on many</span></span><br><span class="line"><span class="comment">   systems.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ether_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> ether_addr_octet[ETH_ALEN];</span><br><span class="line">&#125; __attribute__ ((__packed__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 10Mb/s ethernet header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ether_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  ether_dhost[ETH_ALEN];       <span class="comment">/* destination eth addr */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  ether_shost[ETH_ALEN];       <span class="comment">/* source ether addr    */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> ether_type;                  <span class="comment">/* packet type ID field */</span></span><br><span class="line">&#125; __attribute__ ((__packed__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ethernet protocol ID&#x27;s */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_PUP           0x0200          <span class="comment">/* Xerox PUP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_SPRITE        0x0500          <span class="comment">/* Sprite */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_IP            0x0800          <span class="comment">/* IP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_ARP           0x0806          <span class="comment">/* Address resolution */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_REVARP        0x8035          <span class="comment">/* Reverse ARP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_AT            0x809B          <span class="comment">/* AppleTalk protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_AARP          0x80F3          <span class="comment">/* AppleTalk ARP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_VLAN          0x8100          <span class="comment">/* IEEE 802.1Q VLAN tagging */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_IPX           0x8137          <span class="comment">/* IPX */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_IPV6          0x86dd          <span class="comment">/* IP protocol version 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHERTYPE_LOOPBACK      0x9000          <span class="comment">/* used to test interfaces */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_ADDR_LEN  ETH_ALEN                 <span class="comment">/* size of ethernet addr */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_TYPE_LEN  2                        <span class="comment">/* bytes in type field */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_CRC_LEN   4                        <span class="comment">/* bytes in CRC field */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_HDR_LEN   ETH_HLEN                 <span class="comment">/* total octets in header */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_MIN_LEN   (ETH_ZLEN + ETHER_CRC_LEN) <span class="comment">/* min packet length */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_MAX_LEN   (ETH_FRAME_LEN + ETHER_CRC_LEN) <span class="comment">/* max packet length */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://tools.ietf.org/rfc/rfc826.txt">https://tools.ietf.org/rfc/rfc826.txt</a><br>[2] <a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/4/">TCP/IP 详解，卷 1： 协议 - 第 4 章 ARP 地址解析协议</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Boyer-Moore 多数派投票算法</title>
    <url>/2021/08/boyer-moore-majority-voting-algorithm/</url>
    <content><![CDATA[<img src="/2021/08/boyer-moore-majority-voting-algorithm/boyer-moore.gif" class="">

<p>Boyer-Moore 投票算法是流行的最优算法之一，它用于在给定元素中找出出现次数超过 <code>N/2</code> 的元素。它需要对给定元素进行 2 次遍历，其时间复杂度为 <code>O(N)</code>，空间复杂度为 <code>O(1)</code>。</p>
<span id="more"></span>

<p>让我们通过一个例子来看看其算法背后的原理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,1,1,1,2,3,5&#125;</span><br><span class="line">输出：1</span><br><span class="line">解释：1 出现超过 3 次。</span><br><span class="line">输入：&#123;1,2,3&#125;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p>该算法的工作原理是，如果一个元素出现超过 <code>N/2</code> 次，则意味着除此之外的其余元素肯定会小于 <code>N/2</code>。那么，让我们检查一下算法的过程。</p>
<ul>
<li>首先，从给定的元素集中选择一个候选元素，如果它与候选元素相同，则增加投票数。否则，减少票数如果票数变为 <code>0</code>，则选择另一个新元素作为新候选元素。</li>
</ul>
<h2 id="背后的原理"><a href="#背后的原理" class="headerlink" title="背后的原理"></a>背后的原理</h2><p>当元素与候选元素相同时，我们增加投票数；当元素与候选元素不相同时，我们减少投票数。我们减少投票实际上意味着我们正在降低所选候选元素获胜机会，因为我们知道如果获选元素是多数，那么它出现的次数必然超过 <code>N/2</code> 次，而其余的元素则少于 <code>N/2</code> 次。当我们发现与候选元素不同的元素时，我们会持续的减少投票数。当投票数变为 <code>0</code> 时，这就意味着有相同数量的不同元素，这不应该成为多数元素的情况。因此，候选元素不能成为多数元素，所以我们选择当前的元素作为新的候选元素，并继续上述过程，直到所有元素都完成。最后的候选元素将是我们的多数元素。我们用第 2 次遍历来检查候选元素的数量是否大于 <code>N/2</code>，如果是的话，我们就认为它是多数元素。</p>
<h2 id="实现算法的步骤"><a href="#实现算法的步骤" class="headerlink" title="实现算法的步骤"></a>实现算法的步骤</h2><ol>
<li>找到多数的候选元素<ul>
<li>初始化变量 <code>i, votes = 0, candidate = -1</code></li>
<li>使用 <code>for</code> 循环遍历数组</li>
<li>如果 <code>votes = 0</code>，则选择 <code>candidate = arr[i]</code>，并且增加投票数 <code>votes = 1</code></li>
<li>如果当前的元素与候选元素相同，则 <code>votes++</code></li>
<li>否则 <code>votes--</code></li>
</ul>
</li>
<li>检查候选元素是否有超过 <code>N/2</code> 投票数<ul>
<li>初始化变量 <code>count = 0</code>，如果元素与候选者相同则加 <code>1</code></li>
<li>检查 <code>count &gt; N/2</code>，如果是返回候选元素</li>
<li>否则返回 <code>-1</code></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们模拟上面的例子：</span><br><span class="line">给定元素：</span><br><span class="line">  arr[] =       1    1    1    1    2    3    5</span><br><span class="line"> votes = 0      1    2    3    4    3    2    1</span><br><span class="line"> candidate = -1 1    1    1    1    1    1    1</span><br><span class="line"> candidate = 1  第一次遍历后</span><br><span class="line">                1    1    1    1    2    3    5</span><br><span class="line"> count = 0      1    2    3    4    4    4    4</span><br><span class="line"> candidate = 1</span><br><span class="line"> Hence count &gt; 7/2 =3</span><br><span class="line"> 因此，1 是多数元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ implementation for the above approach</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Function to find majority element</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMajority</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, candidate = <span class="number">-1</span>, votes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Finding majority candidate</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = arr[i];</span><br><span class="line">            votes = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == candidate)</span><br><span class="line">                votes++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                votes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Checking if majority candidate occurs more than n/2</span></span><br><span class="line">    <span class="comment">// times</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == candidate) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; n / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="built_in">findMajority</span>(arr, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; The majority element is : &quot;</span> &lt;&lt; majority;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> <code>O(n)</code>（对于数组的两次遍历）<br><strong>空间复杂度：</strong> <code>O(1)</code></p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>[1] <a href="https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm/">https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm/</a></p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><p>该算法来自于 <a href="https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf">MJRTY - A Fast Majority Vote Algorithm</a> 论文。您可以在<a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html">这里</a>看到算法的演示。</p>
<div class="just-for-fun">
笑林广记 - 不明

<p>一官断事不明，惟好酒怠政，贪财酷民。<br>百姓怨恨，乃作诗以诮之云：“黑漆皮灯笼，半天萤火虫，粉墙画白虎，黄纸写乌龙，茄子敲泥磬，冬瓜撞木钟，唯知钱与酒，不管正和公。”</p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 系统 DNS 服务器配置</title>
    <url>/2018/09/configure-dns-on-ubuntu/</url>
    <content><![CDATA[<p>域名系统 (Domain Name System, DNS) 是为连接到互联网或专用网络的计算机、服务或其他资源提供的一个分散且分级的命名系统。他可以理解为域名和 IP 地址相互映射的一个分布式数据库，通过域名系统，用户可以使用相对容易记忆的域名来访问互联网，而不用去记忆难以理解的 IP 字符串，由域名到 IP 地址转换的过程则被叫做域名解析。下图给出了一个典型的域名分级系统 (图片来源于维基百科)。</p>
<img src="/2018/09/configure-dns-on-ubuntu/Domain_name_space.png" class="" title="Domain name space">

<span id="more"></span>

<p>在 Ubuntu 平台，我目前所了解到的 DNS 的配置主要有两种方式 (配置文件修改)：网络配置文件 interfaces 和域名解析配置文件 resolvconf。</p>
<h3 id="网络配置文件"><a href="#网络配置文件" class="headerlink" title="网络配置文件"></a>网络配置文件</h3><p>若是通过网络配置文件修改 DNS，那么我们只需要在 /etc/network/interfaces 文件中加入 nameserver 即可，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dns-nameserver 114.114.114.114</span><br><span class="line">dns-nameservers 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure>

<p>dns-nameserver: 用于添加一个域名服务器，如果需要指定多个域名服务器则需要使用添加多行。<br>dns-nameservers: 用于同时指定多个域名服务器地址，用空格隔开。</p>
<p>通过这种方式修改 DNS 后需要重启电脑方可生效。</p>
<h3 id="域名解析配置文件"><a href="#域名解析配置文件" class="headerlink" title="域名解析配置文件"></a>域名解析配置文件</h3><p>Ubuntu 系统提供了 resolvconf 工具来管理其域名信息，其配置文件为在 /etc/resolvconf/resolv.conf.d/ 目录下，通过修改该目录下的 head 文件，我们可以添加特定的域名服务器。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure>

<p>在该文件中，每个域名服务器的地址单独一行，不能同时在一行上指定多个域名服务器。修改成功后，我们只需要运行 <code>sudo resolvconf -u</code> 更新 /etc/resolv.conf 文件即可。这种方式不需要重启电脑。此外，我们也可以直接在 /etc/resolv.conf 文件中添加域名服务器，但是这种方式添加的域名服务器在系统重启之后将失效，这是因为 /etc/resolv.conf 文件是由 resolvconf 命令生成的，重启后该文件将被重写。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH 私钥转 RSA 私钥</title>
    <url>/2022/01/convert-openssh-private-key-to-rsa-private-key/</url>
    <content><![CDATA[<p>今天遇到关于私钥格式的问题，需要通过远程连接访问远端的服务器，该服务器是客户给的，然后通过 ssh 的方式访问，然而客户给的私钥是如下形式的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAA...</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<p>通过 ssh 连接时报无效的格式，<code>Load key &quot;~/.ssh/openssh_id_rsa&quot;: invalid format</code>。本文简要记录一下解决方法。</p>
<span id="more"></span>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我们可以通过工具将其转换为 <code>RSA</code> 格式的私钥，需要使用到 putty 工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install putty</span></span><br></pre></td></tr></table></figure>

<p>首先，我们通过 puttygen 将 OpenSSH 的私钥转换为 SSHv2 的中间格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> puttygen ~/.ssh/openssh_id_rsa -O private-sshcom -o ~/.ssh/sshv2_id_rsa</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>~/.ssh/openssh_id_rsa</code> 是原始的 OpenSSH 私钥文件，<code>~/.ssh/sshv2_id_rsa</code> 是生成的中间文件（SSHv2 格式），其格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----</span><br><span class="line">P2/56wAABa4AAAA3aWYtbW9kbntzaWdue3JzYS1wa2NzMS1za...</span><br><span class="line">---- END SSH2 ENCRYPTED PRIVATE KEY ----</span><br></pre></td></tr></table></figure>

<p>接着，我们使用 ssh-keygen 将 SSHv2 格式的文件转换为 RSA 格式的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -i -f ~/.ssh/sshv2_id_rsa &gt; ~/.ssh/converted_id_rsa</span></span><br></pre></td></tr></table></figure>

<p>最后，转换后的 RSA 私钥格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIG5AIBAAKCAYEArwZXd5mI3XeOynhMIFWbRX1HoDWvXXO0C...</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://federicofr.wordpress.com/2019/01/02/how-to-convert-openssh-private-keys-to-rsa-pem/">https://federicofr.wordpress.com/2019/01/02/how-to-convert-openssh-private-keys-to-rsa-pem/</a></p>
<div class="just-for-fun">
笑林广记 - 坐监

<p>一监生妻屡劝其夫读书，因假寓于寺中，素无书箱，乃唤脚夫以罗担挑书先往。<br>脚夫中途疲甚，身坐担上，适生至，闻傍人语所坐《通鉴》，因怒责脚夫，夫谢罪曰：“小人因为不识字，一时坐了鉴（监），弗怪弗怪。”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>OpenSSH</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 视图替换时更新输出列的 collation 问题</title>
    <url>/2022/02/create-or-replace-view-output-column-collation/</url>
    <content><![CDATA[<p>最近在邮件列表中发现 <a href="https://www.postgresql.org/message-id/17404-8a4a270ef30a6709@postgresql.org"><code>CREATE OR REPLACE VIEW</code> 存在一个 bug，无法更新输出列的 collation</a>。如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (info text);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> my_tbl_view <span class="keyword">AS</span> <span class="keyword">SELECT</span> info <span class="keyword">FROM</span> tbl;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span></span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># \d<span class="operator">+</span> my_tbl_view</span><br><span class="line">                        <span class="keyword">View</span> &quot;public.my_tbl_view&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Description</span><br><span class="line"><span class="comment">--------+------+-----------+----------+---------+----------+-------------</span></span><br><span class="line"> info   <span class="operator">|</span> text <span class="operator">|</span>           <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span></span><br><span class="line"><span class="keyword">View</span> definition:</span><br><span class="line"> <span class="keyword">SELECT</span> tbl.info</span><br><span class="line">   <span class="keyword">FROM</span> tbl;</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> my_tbl_view <span class="keyword">AS</span> <span class="keyword">SELECT</span> info <span class="keyword">COLLATE</span> &quot;en_US.utf8&quot; <span class="keyword">FROM</span> tbl;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span></span><br><span class="line">postgres<span class="operator">=</span># \d<span class="operator">+</span> my_tbl_view</span><br><span class="line">                        <span class="keyword">View</span> &quot;public.my_tbl_view&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Description</span><br><span class="line"><span class="comment">--------+------+-----------+----------+---------+----------+-------------</span></span><br><span class="line"> info   <span class="operator">|</span> text <span class="operator">|</span>           <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span></span><br><span class="line"><span class="keyword">View</span> definition:</span><br><span class="line"> <span class="keyword">SELECT</span> tbl.info <span class="keyword">COLLATE</span> &quot;en_US.utf8&quot; <span class="keyword">AS</span> info</span><br><span class="line">   <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>Collation</code> 列中没有发生改变，而且也没任何提示，只是默默的丢弃了 <code>COLLATE &quot;en_US.utf8&quot;</code>，但是在视图的定义中又更新了 <code>Collation</code>，这多少让人有点疑惑。</p>
<span id="more"></span>

<p>接着尝试在新建视图的时候指定 <code>Collation</code> 发现它是可以被记录的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> my_tbl_view1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> info <span class="keyword">COLLATE</span> &quot;en_US.utf8&quot; <span class="keyword">FROM</span> tbl;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span></span><br><span class="line">postgres<span class="operator">=</span># \d<span class="operator">+</span> my_tbl_view1</span><br><span class="line">                        <span class="keyword">View</span> &quot;public.my_tbl_view1&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Collation</span>  <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Description</span><br><span class="line"><span class="comment">--------+------+------------+----------+---------+----------+-------------</span></span><br><span class="line"> info   <span class="operator">|</span> text <span class="operator">|</span> en_US.utf8 <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span></span><br><span class="line"><span class="keyword">View</span> definition:</span><br><span class="line"> <span class="keyword">SELECT</span> tbl.info <span class="keyword">COLLATE</span> &quot;en_US.utf8&quot; <span class="keyword">AS</span> info</span><br><span class="line">   <span class="keyword">FROM</span> tbl;</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> my_tbl_view1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> info <span class="keyword">COLLATE</span> &quot;C&quot; <span class="keyword">FROM</span> tbl;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span></span><br><span class="line">postgres<span class="operator">=</span># \d<span class="operator">+</span> my_tbl_view1</span><br><span class="line">                        <span class="keyword">View</span> &quot;public.my_tbl_view1&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Collation</span>  <span class="operator">|</span> Nullable <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Storage  <span class="operator">|</span> Description</span><br><span class="line"><span class="comment">--------+------+------------+----------+---------+----------+-------------</span></span><br><span class="line"> info   <span class="operator">|</span> text <span class="operator">|</span> en_US.utf8 <span class="operator">|</span>          <span class="operator">|</span>         <span class="operator">|</span> extended <span class="operator">|</span></span><br><span class="line"><span class="keyword">View</span> definition:</span><br><span class="line"> <span class="keyword">SELECT</span> tbl.info <span class="keyword">COLLATE</span> &quot;C&quot; <span class="keyword">AS</span> info</span><br><span class="line">   <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>CREATE OR REPLACE VIEW</code> 属于 DDL 语句，因此在 PostgreSQL 内部是通过 <code>ProcessUtility()</code> 函数来处理的，其处理流程如下图所示。</p>
<img src="/2022/02/create-or-replace-view-output-column-collation/flow-for-create-view.png" class="" title="Flow of CREATE VIEW in PostgreSQL">

<p>其中关于视图信息的内容主要集中在 <code>DefineVirtualRelation()</code> 函数中，其流程如下所示。</p>
<img src="/2022/02/create-or-replace-view-output-column-collation/flow-of-DefineVirtualRelation.png" class="" title="Flow of DefineVirtualRelation">

<p>当我们执行的是 <code>CREATE OR REPLACE VIEW</code> 命令并且视图存在时将执行上图中左边部分流程：</p>
<ol>
<li>检测当前视图是否正在被使用；</li>
<li>构建视图的属性列；</li>
<li>检测视图新的属性列与旧属性列，违反相应的规则将拒绝更改视图；</li>
<li>处理新增的属性列，如果有新增的属性列；</li>
<li>以规则的形式存储视图查询语句。</li>
</ol>
<p>通过查看 <code>checkViewTupleDesc()</code> 函数，我们发现它在比较新旧属性时忽略了 <code>collation</code> 相关的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Verify that tupledesc associated with proposed new view definition</span></span><br><span class="line"><span class="comment"> * matches tupledesc of old view.  This is basically a cut-down version</span></span><br><span class="line"><span class="comment"> * of equalTupleDescs(), with code added to generate specific complaints.</span></span><br><span class="line"><span class="comment"> * Also, we allow the new tupledesc to have more columns than the old.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">checkViewTupleDesc</span><span class="params">(TupleDesc newdesc, TupleDesc olddesc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>         i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newdesc-&gt;natts &lt; olddesc-&gt;natts)</span><br><span class="line">        ereport(ERROR,</span><br><span class="line">                (errcode(ERRCODE_INVALID_TABLE_DEFINITION),</span><br><span class="line">                 errmsg(<span class="string">&quot;cannot drop columns from view&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; olddesc-&gt;natts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Form_pg_attribute newattr = TupleDescAttr(newdesc, i);</span><br><span class="line">        Form_pg_attribute oldattr = TupleDescAttr(olddesc, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX msg not right, but we don&#x27;t support DROP COL on view anyway */</span></span><br><span class="line">        <span class="keyword">if</span> (newattr-&gt;attisdropped != oldattr-&gt;attisdropped)</span><br><span class="line">            ereport(ERROR,</span><br><span class="line">                    (errcode(ERRCODE_INVALID_TABLE_DEFINITION),</span><br><span class="line">                     errmsg(<span class="string">&quot;cannot drop columns from view&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(NameStr(newattr-&gt;attname), NameStr(oldattr-&gt;attname)) != <span class="number">0</span>)</span><br><span class="line">            ereport(ERROR,</span><br><span class="line">                    (errcode(ERRCODE_INVALID_TABLE_DEFINITION),</span><br><span class="line">                     errmsg(<span class="string">&quot;cannot change name of view column \&quot;%s\&quot; to \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                            NameStr(oldattr-&gt;attname),</span><br><span class="line">                            NameStr(newattr-&gt;attname)),</span><br><span class="line">                     errhint(<span class="string">&quot;Use ALTER VIEW ... RENAME COLUMN ... to change name of view column instead.&quot;</span>)));</span><br><span class="line">        <span class="comment">/* XXX would it be safe to allow atttypmod to change?  Not sure */</span></span><br><span class="line">        <span class="keyword">if</span> (newattr-&gt;atttypid != oldattr-&gt;atttypid ||</span><br><span class="line">            newattr-&gt;atttypmod != oldattr-&gt;atttypmod)</span><br><span class="line">            ereport(ERROR,</span><br><span class="line">                    (errcode(ERRCODE_INVALID_TABLE_DEFINITION),</span><br><span class="line">                     errmsg(<span class="string">&quot;cannot change data type of view column \&quot;%s\&quot; from %s to %s&quot;</span>,</span><br><span class="line">                            NameStr(oldattr-&gt;attname),</span><br><span class="line">                            format_type_with_typemod(oldattr-&gt;atttypid,</span><br><span class="line">                                                     oldattr-&gt;atttypmod),</span><br><span class="line">                            format_type_with_typemod(newattr-&gt;atttypid,</span><br><span class="line">                                                     newattr-&gt;atttypmod))));</span><br><span class="line">        <span class="comment">/* We can ignore the remaining attributes of an attribute... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We ignore the constraint fields.  The new view desc can&#x27;t have any</span></span><br><span class="line"><span class="comment">     * constraints, and the only ones that could be on the old view are</span></span><br><span class="line"><span class="comment">     * defaults, which we are happy to leave in place.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在随后的属性列处理中，将跳过已有的属性列，只针对新增的属性列进行处理，从而导致 <code>collation</code> 信息没有机会更新，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If new attributes have been added, we must add pg_attribute entries</span></span><br><span class="line"><span class="comment"> * for them.  It is convenient (although overkill) to use the ALTER</span></span><br><span class="line"><span class="comment"> * TABLE ADD COLUMN infrastructure for this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we must do this before updating the query for the view,</span></span><br><span class="line"><span class="comment"> * since the rules system requires that the correct view columns be in</span></span><br><span class="line"><span class="comment"> * place when defining the new rules.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also note that ALTER TABLE doesn&#x27;t run parse transformation on</span></span><br><span class="line"><span class="comment"> * AT_AddColumnToView commands.  The ColumnDef we supply must be ready</span></span><br><span class="line"><span class="comment"> * to execute as-is.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (list_length(attrList) &gt; rel-&gt;rd_att-&gt;natts)</span><br><span class="line">&#123;</span><br><span class="line">    ListCell   *c;</span><br><span class="line">    <span class="keyword">int</span>         skip = rel-&gt;rd_att-&gt;natts;</span><br><span class="line"></span><br><span class="line">    foreach(c, attrList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (skip &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            skip--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        atcmd = makeNode(AlterTableCmd);</span><br><span class="line">        atcmd-&gt;subtype = AT_AddColumnToView;</span><br><span class="line">        atcmd-&gt;def = (Node *) lfirst(c);</span><br><span class="line">        atcmds = lappend(atcmds, atcmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EventTriggerAlterTableStart called by ProcessUtilitySlow */</span></span><br><span class="line">    AlterTableInternal(viewOid, atcmds, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the new view columns visible */</span></span><br><span class="line">    CommandCounterIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Tom Lane 认为这是一个 bug，当在修改视图属性列的 <code>collation</code> 时应该报错，这和修改属性的数据类型一样不确定是否安全，Tom Lane 的解决方案是在判断新旧属性的 <code>collation</code> 不一致时报错并终止，如下所示。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">index e183ab097c44cda951696e1b2f2250118344c72c..459e9821d08142fb66f901e554c6a894b528d3bf 100644 (file)</span></span><br><span class="line"><span class="comment">--- a/src/backend/commands/view.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/commands/view.c</span></span><br><span class="line"><span class="meta">@@ -282,7 +282,12 @@</span> checkViewTupleDesc(TupleDesc newdesc, TupleDesc olddesc)</span><br><span class="line">                            NameStr(oldattr-&gt;attname),</span><br><span class="line">                            NameStr(newattr-&gt;attname)),</span><br><span class="line">                     errhint(&quot;Use ALTER VIEW ... RENAME COLUMN ... to change name of view column instead.&quot;)));</span><br><span class="line"><span class="deletion">-       /* XXX would it be safe to allow atttypmod to change?  Not sure */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       /*</span></span><br><span class="line"><span class="addition">+        * We cannot allow type, typmod, or collation to change, since these</span></span><br><span class="line"><span class="addition">+        * properties may be embedded in Vars of other views/rules referencing</span></span><br><span class="line"><span class="addition">+        * this one.  Other column attributes can be ignored.</span></span><br><span class="line"><span class="addition">+        */</span></span><br><span class="line">        if (newattr-&gt;atttypid != oldattr-&gt;atttypid ||</span><br><span class="line">            newattr-&gt;atttypmod != oldattr-&gt;atttypmod)</span><br><span class="line">            ereport(ERROR,</span><br><span class="line"><span class="meta">@@ -293,7 +298,18 @@</span> checkViewTupleDesc(TupleDesc newdesc, TupleDesc olddesc)</span><br><span class="line">                                                     oldattr-&gt;atttypmod),</span><br><span class="line">                            format_type_with_typemod(newattr-&gt;atttypid,</span><br><span class="line">                                                     newattr-&gt;atttypmod))));</span><br><span class="line"><span class="deletion">-       /* We can ignore the remaining attributes of an attribute... */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       /*</span></span><br><span class="line"><span class="addition">+        * At this point, attcollations should be both valid or both invalid,</span></span><br><span class="line"><span class="addition">+        * so applying get_collation_name unconditionally should be fine.</span></span><br><span class="line"><span class="addition">+        */</span></span><br><span class="line"><span class="addition">+       if (newattr-&gt;attcollation != oldattr-&gt;attcollation)</span></span><br><span class="line"><span class="addition">+           ereport(ERROR,</span></span><br><span class="line"><span class="addition">+                   (errcode(ERRCODE_INVALID_TABLE_DEFINITION),</span></span><br><span class="line"><span class="addition">+                    errmsg(&quot;cannot change collation of view column \&quot;%s\&quot; from \&quot;%s\&quot; to \&quot;%s\&quot;&quot;,</span></span><br><span class="line"><span class="addition">+                           NameStr(oldattr-&gt;attname),</span></span><br><span class="line"><span class="addition">+                           get_collation_name(oldattr-&gt;attcollation),</span></span><br><span class="line"><span class="addition">+                           get_collation_name(newattr-&gt;attcollation))));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/17404-8a4a270ef30a6709@postgresql.org">https://www.postgresql.org/message-id/17404-8a4a270ef30a6709@postgresql.org</a></p>
<div class="just-for-fun">
笑林广记 - 咬飞边

<p>贫子途遇监生，忽然抱住咬耳一口，生惊问其故，答曰：“我穷苦极矣。见了大锭银子，如何不咬些飞边用用。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 上创建 U 盘启动器</title>
    <url>/2020/07/create-u-bootloader-on-macos/</url>
    <content><![CDATA[<p>本文记载了如何在 MacOS 平台制作 U 盘安装镜像，这里主要使用到了 hdiutil，diskutil 和 dd 三个命令。</p>
<span id="more"></span>

<p>我们在官网现在的镜像大都是以 iso 结尾的文件，例如，本文中使用的 ubuntu-16.04-server-amd64.iso 镜像，在 Linux 平台，我们可以直接使用 dd 将这个镜像写到 U 盘上即可作为启动盘，但是在 MacOS 平台上，则需要将 iso 文件转换为 dmg 格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hdiutil convert -format UDRW ubuntu-16.04-server-amd64.iso -o ubuntu-16.04-server-amd64.img</span></span><br><span class="line">Reading Master Boot Record (MBR : 0)…</span><br><span class="line">Reading Ubuntu-Server 18.04.4 LTS arm64  (Apple_ISO : 1)…</span><br><span class="line">Reading  (Type CD : 2)…</span><br><span class="line">....................................................................................................</span><br><span class="line">Reading  (Type EF : 3)…</span><br><span class="line">....................................................................................................</span><br><span class="line">Elapsed Time:  2.094s</span><br><span class="line">Speed: 454.9Mbytes/sec</span><br><span class="line">Savings: 0.0%</span><br><span class="line">created: /Users/japin/Downloads/ubuntu-18.04.4-server-arm64.img.dmg</span><br></pre></td></tr></table></figure>

<p>从上面的命令我们可以看到，文件将自动加上 dmg 后缀。上面的命令将 ubuntu-16.04-server-amd64.iso 镜像转换为 UDRW 格式并存储到 ubuntu-16.04-server-amd64.img.dmg 文件中。</p>
<p>接下来我们通过 diskutil 命令查看当前 U 盘的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diskutil list</span></span><br><span class="line">/dev/disk0 (internal, physical):</span><br><span class="line"><span class="meta">   #</span><span class="bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      GUID_partition_scheme                        *251.0 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS Container disk1         250.7 GB   disk0s2</span><br><span class="line"></span><br><span class="line">/dev/disk1 (synthesized):</span><br><span class="line"><span class="meta">   #</span><span class="bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      APFS Container Scheme -                      +250.7 GB   disk1</span><br><span class="line">                                 Physical Store disk0s2</span><br><span class="line">   1:                APFS Volume Macintosh HD            11.1 GB    disk1s1</span><br><span class="line">   2:                APFS Volume Macintosh HD - Data     76.8 GB    disk1s2</span><br><span class="line">   3:                APFS Volume Preboot                 81.3 MB    disk1s3</span><br><span class="line">   4:                APFS Volume Recovery                528.1 MB   disk1s4</span><br><span class="line">   5:                APFS Volume VM                      3.2 GB     disk1s5</span><br><span class="line"></span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line"><span class="meta">   #</span><span class="bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:     Apple_partition_scheme                        *8.1 GB     disk2</span><br><span class="line">   1:        Apple_partition_map                         4.1 KB     disk2s1</span><br><span class="line">   2:                  Apple_HFS                         2.5 MB     disk2s2</span><br></pre></td></tr></table></figure>

<p>可以看到，我们的 U 盘对应的是 <code>/dev/disk2</code>，使用下面的命令卸载 U 盘。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diskutil unmountDisk /dev/disk2</span></span><br><span class="line">Unmount of all volumes on disk2 was successful</span><br></pre></td></tr></table></figure>

<p>最后，使用 dd 命令将其写入到 U 盘中，这里需要注意我们的 U 盘设备名应使用 <code>/dev/rdisk2</code>，即在 <code>/dev/disk2</code> 的磁盘名前面加上 <code>r</code> 字母。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dd <span class="keyword">if</span>=ubuntu-18.04.4-server-arm64.img.dmg of=/dev/rdisk2 bs=1m</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 数据库跨库查询</title>
    <url>/2019/05/cross-database-querying-in-postgresql/</url>
    <content><![CDATA[<p>PostgreSQL 数据库默认情况下是不支持跨数据库访问的。如果我们想要执行跨数据库的查询，我们需要借助 dblink 来实现，dblink 是 PostgreSQL 的一个模块，支持从数据库会话中连接到其他数据库。</p>
<span id="more"></span>

<h2 id="安装-dblink"><a href="#安装-dblink" class="headerlink" title="安装 dblink"></a>安装 dblink</h2><p>通过 <code>CREATE EXTENSION dblink;</code> 即可安装 dblink。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE EXTENSION dblink;</span><br><span class="line">CREATE EXTENSION</span><br></pre></td></tr></table></figure>
<p>dblink 提供了一系列函数用于访问远端数据库，具体的可以参看 <a href="https://www.postgresql.org/docs/10/dblink.html">PostgreSQL dblink</a> 文档。</p>
<h2 id="本地跨库访问"><a href="#本地跨库访问" class="headerlink" title="本地跨库访问"></a>本地跨库访问</h2><p>为了演示本地跨库访问，我们首先在 <code>postgres</code> 中建立 <code>userinfo</code> 表，随后在本地新建一个 <code>localdb</code> 数据库，并在其中建立一个 <code>local_test</code> 数据表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE TABLE userinfo (id int primary key, name text);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres=# INSERT INTO userinfo VALUES (1, &#x27;Eric&#x27;), (2, &#x27;Tom&#x27;);</span><br><span class="line">INSERT 0 2</span><br><span class="line">postgres=# SELECT * FROM userinfo;</span><br><span class="line"> id | name</span><br><span class="line">----+------</span><br><span class="line">  1 | Eric</span><br><span class="line">  2 | Tom</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres=# CREATE DATABASE localdb;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres=# \c localdb</span><br><span class="line">You are now connected to database &quot;localdb&quot; as user &quot;japin&quot;.</span><br><span class="line">localdb=# CREATE TABLE local_test (id serial primary key, ival int default 0, create_time timestamptz not null default now());</span><br><span class="line">CREATE TABLE</span><br><span class="line">localdb=# INSERT INTO local_test(ival) VALUES (1), (2), (3), (4);</span><br><span class="line">INSERT 0 4</span><br><span class="line">localdb=# SELECT * FROM local_test;</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时，如果我想在 <code>postgres</code> 数据库中查询 <code>local_test</code> 表，就需要使用到 dblink 来访问了。首先，我们通过 <code>dblink_connect</code> 创建一个连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT dblink_connect(&#x27;local_dblink_test&#x27;, &#x27;dbname=localdb&#x27;);</span><br><span class="line"> dblink_connect</span><br><span class="line">----------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随后，我们就可以通过 dblink 执行查询了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT * FROM dblink(&#x27;local_dblink_test&#x27;, &#x27;SELECT * FROM local_test;&#x27;) AS lt(id int, ival int, create_time timestamptz);</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，我们也可以将返回结果与本库中的表进行联合查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT u.id, name, create_time FROM userinfo u JOIN dblink(&#x27;local_dblink_test&#x27;, &#x27;SELECT * FROM local_test;&#x27;) AS lt(id int, ival int, create_time timestamptz) on u.id = lt.id;</span><br><span class="line"> id | name |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 | Eric | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 | Tom  | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便，我们可以为 <code>dblink</code> 的执行创建一个视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE VIEW v_localdb_test AS SELECT * FROM dblink(&#x27;local_dblink_test&#x27;, &#x27;SELECT * FROM local_test;&#x27;) AS lt(id int, ival int, create_time timestamptz);</span><br><span class="line">CREATE VIEW</span><br><span class="line">postgres=# SELECT * FROM v_localdb_test ;</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line">postgres=# SELECT u.id, name, create_time FROM userinfo u JOIN v_localdb_test v ON u.id = v.id;</span><br><span class="line"> id | name |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 | Eric | 2019-05-09 15:03:44.701121+08</span><br><span class="line">  2 | Tom  | 2019-05-09 15:03:44.701121+08</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 在 <code>local_test</code> 表中 <code>id</code> 字段类型为 <code>serial</code>，但是在通过 <code>dblink</code> 查询时返回的结果类型不能使用 <code>serial</code> 类型。</p>
<h2 id="远端跨库访问"><a href="#远端跨库访问" class="headerlink" title="远端跨库访问"></a>远端跨库访问</h2><p>上面我们介绍了 PostgreSQL 如何在本地进行跨库访问，其实远端跨库访问本质也是类似的，只不过在配置 <code>dblink_connect</code> 连接参数时需要指明远端数据库的地址、端口、用户名和密码等信息。</p>
<p>我们在远端创建一个 <code>remotedb</code> 数据库，并在该数据库中创建一个 <code>remote_test</code> 表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# create database remotedb;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres=# \c remotedb</span><br><span class="line">remotedb=# CREATE TABLE remote_test (id serial primary key, ival int not null default 0, create_time timestamptz default now());</span><br><span class="line">CREATE TABLE</span><br><span class="line">remotedb=# INSERT INTO remote_test(ival) values (1),(2),(3),(4),(5);</span><br><span class="line">INSERT 0 5</span><br><span class="line">remotedb=# SELECT * FROM remote_test;</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  2 |    2 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  3 |    3 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  4 |    4 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">  5 |    5 | 2019-05-09 07:34:42.599409+00</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，我们在本地通过 dblink 进行连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT dblink_connect(&#x27;remote_dblink_test&#x27;, &#x27;dbname=remotedb hostaddr=10.9.10.24 port=5432 user=postgres password=postgres&#x27;);</span><br><span class="line"> dblink_connect</span><br><span class="line">----------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# SELECT * FROM dblink(&#x27;remote_dblink_test&#x27;, &#x27;SELECT * FROM remote_test;&#x27;) AS t(id int, ival int, create_time timestamptz);</span><br><span class="line"> id | ival |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 |    1 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  2 |    2 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  3 |    3 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  4 |    4 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  5 |    5 | 2019-05-09 15:34:42.599409+08</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">postgres=# SELECT u.id, name, create_time FROM userinfo u JOIN dblink(&#x27;remote_dblink_test&#x27;, &#x27;SELECT * FROM remote_test;&#x27;) AS t(id int, ival int, create_time timestamptz) ON u.id = t.id;</span><br><span class="line"> id | name |          create_time</span><br><span class="line">----+------+-------------------------------</span><br><span class="line">  1 | Eric | 2019-05-09 15:34:42.599409+08</span><br><span class="line">  2 | Tom  | 2019-05-09 15:34:42.599409+08</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关闭-dblink"><a href="#关闭-dblink" class="headerlink" title="关闭 dblink"></a>关闭 dblink</h2><p>最后，当不需要在使用 dblink 访问外部数据库时，我们需要使用 <code>dblink_disconnect</code> 来关闭连接。首先，我们通过 <code>dblink_get_connections</code> 来查看现有的 dblink 连接，随后将其关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT dblink_get_connections();</span><br><span class="line">         dblink_get_connections</span><br><span class="line">----------------------------------------</span><br><span class="line"> &#123;local_dblink_test,remote_dblink_test&#125;</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# SELECT dblink_disconnect(&#x27;remote_dblink_test&#x27;);</span><br><span class="line"> dblink_disconnect</span><br><span class="line">-------------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# SELECT dblink_disconnect(&#x27;local_dblink_test&#x27;);</span><br><span class="line"> dblink_disconnect</span><br><span class="line">-------------------</span><br><span class="line"> OK</span><br><span class="line">(1 row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/11/dblink.html">https://www.postgresql.org/docs/11/dblink.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>dblink</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 自定义封面</title>
    <url>/2019/04/customize-latex-title-page/</url>
    <content><![CDATA[<p>本文主要记录在使用 LaTeX 进行封面自定义的相关实现，如下图 1 所示。</p>
<img src="/2019/04/customize-latex-title-page/customize-title-page.png" class="" title="LaTeX Title Page">
<p style="text-align:center">图 1 LaTeX 自定义封面</p>

<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>图 1 的封面通过 LaTeX 实现起来非常简单，我们只需要会使用几个基本的命令就足够了。从图中我们可以将封面分为六个部分，它们分别是最上面的横线、居中的标题、标题下的横线、作者信息、日期以及封面底部的横线。如下所示：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;book&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">\begin</span>&#123;titlepage&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Top rules</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">\rule</span>&#123;<span class="keyword">\textwidth</span>&#125;&#123;1pt&#125;   <span class="comment">% The top horizontal rule</span></span><br><span class="line">    <span class="keyword">\vspace</span>&#123;0.2<span class="keyword">\textheight</span>&#125;  <span class="comment">% Whitespace between top horizontal rule and title</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Title</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="keyword">\Huge</span> Customize <span class="keyword">\LaTeX</span>&#123;&#125; Title Page&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\vspace</span>&#123;0.025<span class="keyword">\textheight</span>&#125;   <span class="comment">% Whitespace between the title and short horizontal rule</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">\rule</span>&#123;0.83<span class="keyword">\textwidth</span>&#125;&#123;0.4pt&#125;  <span class="comment">% The short horizontal rule under title</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">\vspace</span>&#123;0.1<span class="keyword">\textheight</span>&#125;  <span class="comment">% Whitespace between the short horizontal rule and author</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Author</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="keyword">\Large</span> Author: <span class="keyword">\textsc</span>&#123;Japin Li&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\vfill</span>  <span class="comment">% Whitespace between author and date</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="keyword">\large</span> <span class="keyword">\today</span>&#125;</span><br><span class="line">    <span class="keyword">\vspace</span>&#123;0.1<span class="keyword">\textheight</span>&#125;  <span class="comment">% Whitespace between date and bottom horizontal rule</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%    Bottom rules</span></span><br><span class="line">    <span class="comment">%------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">\rule</span>&#123;<span class="keyword">\textwidth</span>&#125;&#123;1pt&#125;  <span class="comment">% The bottom horizontal rule</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">\end</span>&#123;titlepage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中我只是将 <code>titlepage</code> 直接在文档中给出，其实我们还可以通过重定义 <code>\maketitle</code> 命令来实现自定义封面，这时我们还需要传入一些特定的参数，详细实现可以参考我实现的 <a href="https://github.com/japinli/ferret">ferret</a>。您也可以在封面中使用 <code>\includegraphics</code> 命令来导入图片。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://en.wikibooks.org/wiki/LaTeX/Title_Creation">https://en.wikibooks.org/wiki/LaTeX/Title_Creation</a></p>
]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>列存数据库 cstore_fdw 的实现</title>
    <url>/2018/10/cstore-fdw-implementation/</url>
    <content><![CDATA[<p>在<a href="/2018/09/introduction-cstore-fdw-columnar-store/" title="上一篇">上一篇</a>中我介绍了如何安装和使用列存数据库 cstore_fdw。接着，我将在本篇中介绍 cstore_fdw 是如何实现的。</p>
<p>Cstore_fdw 是基于 PostgreSQL 开发的一款列存数据库，它采用 ORC 作为低层的物理存储格式 (有部分改动)，使用 protobuf 进行序列化并采用 PostgreSQL 外部插件的形式集成到数据库中。Cstore_fdw 包含 3 个头文件以及 5 个源文件：</p>
<ul>
<li><strong>cstore_compression.c</strong> - 该文件包含 cstore_fdw 使用的压缩和解压缩的算法实现。</li>
<li><strong>cstore_fdw.c</strong> - 该文件包含列存扫描、分析以及复制数据到 cstore_fdw 外部表的函数的定义。它使用了 cstore_reader 和 cstore_writer 提供的 API 接口来读写 cstore 文件。</li>
<li><strong>cstore_fdw.h</strong> - 该文件包含 cstore_fdw 使用的类型及函数声明。</li>
<li><strong>cstore_metadata_serialization.c</strong> - 该文件包含 cstore_fdw 序列化和反序列化元数据的函数的实现。</li>
<li><strong>cstore_metadata_serialization.h</strong> - 该文件包含 cstore_fdw 序列化和反序列化元数据的函数的声明。</li>
<li><strong>cstore_reader.c</strong> - 该文件包含读取 cstore 文件的函数定义。它包括读取文件元数据，row stripes 以及跳跃不相关的数据块或列数据。</li>
<li><strong>cstore_version_compat.h</strong> - 该文件包含用于编写与 PostgreSQL 版本无关的代码宏。</li>
<li><strong>cstore_writer.c</strong> - 该文件包含写入 cstore 文件的函数定义。它包括写入文件元数据，row stripes 以及计算跳跃块节点信息。</li>
</ul>
<span id="more"></span>

<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>Cstore_fdw 使用表数据文件 (Table Data File) 和表页脚文件 (Table Footer File) 来管理列存数据。</p>
<ul>
<li><strong>表数据文件</strong> - 该文件包含表数据以及用于执行 WHERE 查询时所用到的跳跃块信息。如果为外部表指定了 <code>filename</code> 参数，那么数据文件则存储在该参数指定的位置。否则，他将采用 <code>$PGDATA/$dboid/$relfilenode</code> 的路径进行存储。</li>
<li><strong>表页脚文件</strong> - 该文件包含每个 stripe 在表数据文件中的偏移位置及其长度。它的存储路径则是在表数据文件后添加 <code>.footer</code> 后缀。</li>
</ul>
<h3 id="表页脚文件"><a href="#表页脚文件" class="headerlink" title="表页脚文件"></a>表页脚文件</h3><p>表页脚文件同样由三个部分组成，它们是 Table Footer，Postscript 和 Postscript Size。</p>
<ul>
<li><strong>Table Footer</strong> - 该部分包含每个 stripe 的文件偏移位置以及不同部分的长度。我们可以使用这些信息来读取 stripe 结构。</li>
<li><strong>Postscript</strong> - 该部分包含 table footer 的长度以及签名和版本信息。</li>
<li><strong>Postscript Size</strong> - 表页脚文件的最后一个字节用于读取 postscript 结构。</li>
</ul>
<p>我们可以在 <a href="https://github.com/citusdata/cstore_fdw/blob/master/cstore_fdw.h">cstore_fdw.h</a> 文件和 <a href="https://github.com/citusdata/cstore_fdw/blob/master/cstore.proto">cstore.proto</a> 文件中查看该文件的物理布局。图 1 展示了包含四个 stripe 结构的表页脚的物理布局结构。</p>
<img src="/2018/10/cstore-fdw-implementation/Physical-of-Table-Footer.svg" class="" title="The Physical Layout of Table Footer">
<p style="text-align:center">图 1 表页脚的物理布局</p>

<h3 id="表数据文件"><a href="#表数据文件" class="headerlink" title="表数据文件"></a>表数据文件</h3><p>Cstore_fdw 中数据被划分为单个的 row stripe 结构并存储在表数据文件中，每个 row stripe 中包含的行数可以通过 <code>stripe_row_count</code> 参数进行修改，每个 stripe 包含下面三个部分：</p>
<ul>
<li><strong>Stripe Skip List</strong> - 该部分包含 stripe 中每个列数据块的统计信息 (最大值、最小值以及位置信息，参考 <a href="https://github.com/citusdata/cstore_fdw/blob/master/cstore_fdw.h">cstore_fdw.h</a> 中的定义)。我们可以通过这是信息来执行 WHERE 条件的过滤从而避免读取不必要的数据块。</li>
<li><strong>Stripe Data</strong> - 在列数据块中我们存储两个内容： “exists” 和 “value”。其中 “exists” 是一个布尔数组，它表明哪些值不为 NULL，而 “value” 数组则包含不为 NULL 的数据。如果使用了压缩，那么 “value” 的内容将会被压缩后在存储。我们可以使用 <code>compression=pglz</code> 来启用压缩。Cstore_fdw 使用 PostgreSQL 中的 Datum 结构来表示磁盘上的数据值。</li>
<li><strong>Stripe Footer</strong> - 该部分包含 stripe skip list 和 stripe data 的数据长度。</li>
</ul>
<p>图 2 给出了 cstore_fdw 中表数据文件的物理布局。</p>
<img src="/2018/10/cstore-fdw-implementation/Physical-of-Table-Data.svg" class="" title="The Physical Layout of Table Data">
<p style="text-align:center">图 2 表数据的物理布局</p>

<p>正如上文所述，表数据文件被划分为 stripe 结构，而 strip 内部又由 skip list，stripe data 和 stripe footer 组成。然而在 skip list 和 stripe data 内部则是由每个属性列组成，并且每个属性列又被划分为 block 结构。Skip list 中包含 block skip node 用于执行过滤，从而跳过不相关的数据块。Stripe data 则将数据进一步划分为 exists block 和 values block，它们分别存储属性值存储标志和属性值。</p>
<h2 id="列存读写实现"><a href="#列存读写实现" class="headerlink" title="列存读写实现"></a>列存读写实现</h2><p>Cstore_fdw 在读写数据文件分为两个步骤：(a) 读写表页脚文件；(b) 读写表数据文件。本节主要介绍 cstore_fdw 的读写实现。</p>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>Cstore_fdw 在写入数据时通过 TableStateWrite 结构维护数据写入状态，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TableWriteState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        FILE *tableFile;                     <span class="comment">/* 数据文件描述符 */</span></span><br><span class="line">        TableFooter *tableFooter;            <span class="comment">/* 表页脚文件结构 */</span></span><br><span class="line">        StringInfo tableFooterFilename;      <span class="comment">/* 表页脚文件名称 */</span></span><br><span class="line">        CompressionType compressionType;     <span class="comment">/* 压缩类型，用于压缩数据值 */</span></span><br><span class="line">        TupleDesc tupleDescriptor;           <span class="comment">/* 元组描述符 */</span></span><br><span class="line">        FmgrInfo **comparisonFunctionArray;  <span class="comment">/* 压缩函数数组 */</span></span><br><span class="line">        uint64 currentFileOffset;            <span class="comment">/* 当前文件写入的偏移位置 */</span></span><br><span class="line">        Relation relation;                   <span class="comment">/* 当前关系表结构 */</span></span><br><span class="line"></span><br><span class="line">        MemoryContext stripeWriteContext;    <span class="comment">/* Stripe 内存管理句柄 */</span></span><br><span class="line">        StripeBuffers *stripeBuffers;        <span class="comment">/* 用于存储 stripe data 数据 */</span></span><br><span class="line">        StripeSkipList *stripeSkipList;      <span class="comment">/* 跳跃表信息 */</span></span><br><span class="line">        uint32 stripeMaxRowCount;            <span class="comment">/* Stripe 最大的行记录数 */</span></span><br><span class="line">        ColumnBlockData **blockDataArray;    <span class="comment">/* 当前 stripe 每个列的 block 信息 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compressionBuffer 用于进行压缩时的临时存储，将它放至在这里主要是为了</span></span><br><span class="line"><span class="comment">         * 减小内存的分配，它位于 stripeWriteContext 内存上下文并且在该内存上下</span></span><br><span class="line"><span class="comment">         * 文重置时被删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        StringInfo compressionBuffer;</span><br><span class="line">&#125; TableWriteState;</span><br></pre></td></tr></table></figure>

<p>假设我们有一个名为 test 的数据表，其中包含两个属性，cstore_fdw 在执行 COPY 命令导入数据时会先执行 <code>CStoreBeginWrite()</code> 函数来初始化 TableWriteState 结构。图 3 给出了 TableWriteState 的逻辑结构。</p>
<img src="/2018/10/cstore-fdw-implementation/Logical-of-TableWriteState.svg" class="" title="The Logical Layout of TableWriteState">
<p style="text-align:center">图 3 TableWriteState 的逻辑结构</p>

<p><code>CStoreBeginWrite()</code> 函数的执行主要分为以下四个步骤：</p>
<ol>
<li>检测表页脚文件是否存在。如果存在，则将其内容读取出来并反序列化到 TableFooter 对象中；反之，若是不存在该文件，说明是第一次向表中插入数据，cstore_fdw 则在内存中创建一个新的 TableFooter 对象。其实在构造 TableFooter 之前，cstore_fdw 会根据表页脚文件的存在与否来决定表数据文件的打开方式。</li>
<li>从 tableFooter-&gt;stripMetadataList 中读取当前表数据文件的写入位置，并将表数据文件的文件写入指针移动到该位置，即读取最后一个 StripeMetadata 并将四个成员相加从而计算下个 stripe 应该写入的位置。</li>
<li>遍历所有的列并获取该列的压缩算法。</li>
<li>创建 stripe 内存上下文，在此之后，所有的列存相关的内存分配都在该内存上下文上进行分配，以便进行内存管理。同时我们需要为每个列新建 ColumnBlockData 对象用于存储插入的值，详细见 <code>CreateEmptyBlockDataArray()</code> 函数。</li>
</ol>
<p>在初始化 TableWriteState 完成之后，我们就需要向列存写入数据了，cstore_fdw 通过 <code>CStoreWriteRow()</code> 函数来实现该功能，其执行过程如下：</p>
<ol>
<li>检测 TableWriteState-&gt;stripeBuffers 是否为空。若为空，则调用 <code>CreateEmptyStripeBuffers()</code> 函数和 <code>CreateEmptyStripeSkipList()</code> 函数为每个列创建 ColumnBuffers 对象和 ColumnBlockSkipNode 对象。</li>
<li>遍历所有属性列并如果该属性列为空则设置 existsArray 中对应的值为 false；反之则调用 <code>SerializeSingleDatum()</code> 函数将值序列化到 valueBuffer 中，同时它将调用 <code>UpdateBlockSkipNodeMinMax()</code> 函数更新当前数据块中的最大值、最小值的统计信息。</li>
<li>判断当前数据块是否已满。若当前数据块已满，则调用 <code>SerializeBlockData()</code> 函数对当前数据块进行序列化。该函数内部首先将所有列的 exists 信息分别序列化到对应的 ColumnBlockBuffers 中的 existsBuffer 中，随后将所有列的 values 信息分别序列化到对应的 ColumnBlockBuffers 中的 valueBuffer 中。需要注意的是，在序列化属性值的时候，将根据属性列是否可以压缩来对其进行数据压缩。</li>
<li>最后，检查当前 stripe 的行记录数是否已经达到 stripe 可容纳的最大行记录数。若是则调用 <code>FlushStrip()</code> 函数将当前 stripe 刷到磁盘，并在 TableFooter 中新增一条 stripeMetadata 元数据；反之则进行下一条记录的写入操作。</li>
</ol>
<p>当所有记录通过 <code>CStoreWriteRow()</code> 函数写入到列存数据库中后，cstore_fdw 将通过 <code>CStoreEndWrite()</code> 函数来执行最后的清理动作。该函数主要进行以下工作：</p>
<ol>
<li>如果 stripe 不为空，则将 stripe 信息刷写到磁盘。</li>
<li>将数据文件内容同步到磁盘（stripe 信息的刷写可能只是到达了磁盘驱动的缓存中，而并没有实际落盘）。</li>
<li>创建临时文件刷写 TableFooter 信息，当 TableFooter 落盘成功后重名该文件为标准的表页脚文件名。</li>
</ol>
<p>至此，整个 cstore_fdw 的数据写入过程就介绍完毕了，接下来我们将介绍其数据读取部分的实现。</p>
<h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>同样，cstore_fdw 在读取数据时也通过一个名为 TableReadState 的结构来维护数据读取的相关信息，其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct TableReadState</span><br><span class="line">&#123;</span><br><span class="line">    FILE *tableFile;</span><br><span class="line">    TableFooter *tableFooter;</span><br><span class="line">    TupleDesc tupleDescriptor;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 指向查询中的列的 Var 指针，使用它来获取投影的列</span><br><span class="line">     */</span><br><span class="line">    List *projectedColumnList;</span><br><span class="line"></span><br><span class="line">    List *whereClauseList;                 /* 过滤条件 */</span><br><span class="line">    MemoryContext stripeReadContext;</span><br><span class="line">    StripeBuffers *stripeBuffers;          /* Stripe 对象 */</span><br><span class="line">    uint32 readStripeCount;</span><br><span class="line">    uint64 stripeReadRowCount;             /* 已经读取的行记录数（当前 stripe 中）*/</span><br><span class="line">    ColumnBlockData **blockDataArray;</span><br><span class="line">    int32 deserializedBlockIndex;          /* 当前反序列化的数据块编号 */</span><br><span class="line">&#125; TableReadState;</span><br></pre></td></tr></table></figure>

<p>当我们从 cstore_fdw 中读取数据时，首先需要通过 <code>CStoreBeginRead()</code> 函数来初始化 TableReadState 结构，随后调用 <code>CStoreReadNextRow()</code> 函数读取行记录，最后通过 <code>CStoreEndRead()</code> 函数进行清理工作。上述函数均依赖 TableReadState 结构来维护当前读取的信息。图 4 给出了 TableReadState 的逻辑结构。</p>
<img src="/2018/10/cstore-fdw-implementation/Logical-of-TableReadState.svg" class="" title="The Logical Layout of TableReadState">
<p style="text-align:center">图 4 TableReadState 的逻辑结构</p>

<p><code>CStoreBeginRead()</code> 函数主要负责初始化工作，它返回的 TableReadState 结构将用于整个读取过程。该函数的执行步骤如下：</p>
<ol>
<li>尝试从表页脚文件中读取 TableFooter 信息。函数 <code>CStoreReadFooter()</code> 用于读取表页脚文件，该函数首先读取文件的最后一个字节作为 postcript 的长度；随后对去 postscript 信息并通过 <code>DeserializePostScript()</code> 函数进行反序列化并校验其是否被修改，然后返回 TableFooter 信息的长度；最后将文件中的 TableFooter 信息通过 <code>DescrializeTableFooter()</code> 函数反序列化到 TableReadState-&gt;tableFooter 结构中。</li>
<li>打开表数据文件并创建 stripeReadContext 内存上下文。</li>
<li>由 <code>ProjectedColumnMask()</code> 函数根据 projectedColumnList 参数获取投影列信息，并使用 <code>CreateEmptyBlockDataArray()</code> 函数为所有投影的列新建 ColumnBlockData 对象。</li>
<li>最后，初始化反序列的数据块索引、当前 stripe 已读的行数、已读取的 stripe 数量等信息并返回 TableReadState 结构。</li>
</ol>
<p>接着，cstore_fdw 将通过 <code>CStoreReadNextRow()</code> 函数读取行记录。函数在成功读取到行数据时会将返回 true 并将数据通过参数的形式返回；若没有更多的记录可读，函数将返回 false。该函数的执行过程如下：</p>
<ol>
<li>首先判断 TableReadState-&gt;stripeBuffers 是否为空。若为空，则说明没有载入 stripe 信息，因此需要载入一个非空的 stripe 以便读取数据。如果当前读取的 stripe 编号与 TableFooter 中记录的 stripeMetadata 的数量相等，则说明没有可读的 stripe 信息，这标志了数据已经读取完，返回 false；反之则通过 <code>LoadFilteredStripeBuffers()</code> 函数载入 stripe 信息并将 TableReadState-&gt;readStripeCount 加 1。如果读取的 stripe 中行记录数为 0 则说明该 stripe 中不包含记录，因此我们需要继续读取下一个 stripe；反之则重置 TableReadState-&gt;stripeReadRowCount、TableReadState-&gt;deserializeBlockIndex 等与 stripe 相关的信息。</li>
<li>判断当前所读取的行是否在已经反序列化的数据块中。若是则转至 3，反之则需要通过函数 <code>DeserializeBlockData()</code> 来反序列化一个新的数据块用于读取数据。</li>
<li>调用函数 <code>ReadStripeNextRow()</code> 读取一条行记录。如果当前读取的 TableReadState-&gt;stripeReadRowCount 与 TableReadState-&gt;stripeBuffers-&gt;rowCount 相等则说明当前 stripe 中的行记录以及读取完，将 TableReadState-&gt;stripeBuffers 置为 NULL 为下次读取作准备。</li>
</ol>
<p>当表中所有的数据都已读出，cstore_fdw 将通过 <code>CStoreEndRead()</code> 函数来进行后续的善后工作。其中主要包括内存上下文的释放，文件的关闭等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文结合 cstore_fdw 的源码分析了其物理的存储格式，梳理了其数据读写的流程。从源码角度我们可以看到 cstore_fdw 在每次插入都会新建 stripe 来处理插入的数据，若是大量的小数据插入势必会导致元数据信息的迅速膨胀，从而影响性能，因此 cstore_fdw 不支持 INSERT 语句。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>cstore_fdw</tag>
        <tag>列存</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言软件包下载</title>
    <url>/2020/05/download-go-package/</url>
    <content><![CDATA[<p>作为一个刚入门的 Go 小白来说，下载第三方包就成为了第一道坎 :( 。本文简要介绍一下如何下载 Go 软件包，尤其是 Google 系列的包。</p>
<span id="more"></span>

<p>本文基于 Go 1.13.4 版本，例如，我们要下载 <code>golang.org/x/tools</code> 包，由于某些不可抗力的原因，我们会遇到下面的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get golang.org/x/tools</span></span><br><span class="line">package golang.org/x/tools: unrecognized import path &quot;golang.org/x/tools&quot; (https fetch: Get https://golang.org/x/tools?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)</span><br></pre></td></tr></table></figure>

<p>出现了问题，自然就有解决办法，毕竟国内也还是要进行 Go 语言开发的，因此，关于 Go 语言包的代理就应运而生，<a href="https://goproxy.io/">goproxy</a> 就是其中之一。</p>
<p>根据介绍，我们可以设置 Go 的环境变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GO111MODULE=on</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPROXY=<span class="string">&quot;https://goproxy.io,direct&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>随后，我们便可以正常下载 Go 语言包了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get golang.org/x/tools</span></span><br><span class="line">go: finding golang.org/x/tools latest</span><br><span class="line">go: downloading golang.org/x/tools v0.0.0-20200515220128-d3bf790afa53</span><br><span class="line">go: extracting golang.org/x/tools v0.0.0-20200515220128-d3bf790afa53</span><br></pre></td></tr></table></figure>

<p>这是在 Go 1.13 及其之后的版本有效，对于之前的版本，我们可以采用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable the go modules feature</span><br><span class="line">export GO111MODULE=&quot;on&quot;</span><br><span class="line"># Set the GOPROXY environment variable</span><br><span class="line">export GOPROXY=&quot;https://goproxy.io&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs 编辑二进制文件</title>
    <url>/2018/10/editing-binary-files-in-emacs/</url>
    <content><![CDATA[<p>二进制文件是以二进制格式存储的文件，它是计算机可读的，人类不直接阅读二进制文件。所有的可执行程序都以二进制文件存储。那我们该如何编辑二进制文件呢？在我使用的 Emacs 编辑器中提供了一个 hexl-mode 的主模式来编辑二进制文件。本文记录了 Emacs 中编辑二进制文件的基本操作。</p>
<img src="/2018/10/editing-binary-files-in-emacs/Editing_Binary_File.png" class="" title="Editing Binary File">

<span id="more"></span>

<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>我们可以使用 <code>M-x hexl-find-file</code> 取代 <code>C-x C-f</code> 命令来编辑二进制文件，该命令将文件内容转换为十六进制，并允许用户进行编辑。当用户保存文件时，它将会自动转换为二进制格式。</p>
<p>当然，我们也可以使用 `M-x hexl-mode** 来将现有的缓冲区转换为十六进制，这在以普通方式打开二进制文件时非常有用。</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>普通文本字符在 hexl-mode 下被覆盖。这是为了降低意外破坏文件中数据对齐的风险。针对二进制文件，hexl-mode 有特殊的插入命令。以下是 hexl-mode 的命令列表：</p>
<ul>
<li><strong>C-M-d</strong> 插入一个包含十进制代码的字节。</li>
<li><strong>C-M-o</strong> 插入一个包含八进制代码的字节。</li>
<li><strong>C-M-x</strong> 插入一个包含十六进制代码的字节。</li>
<li><strong>C-M-[</strong> 移动到 1k 字节页面的开头。</li>
<li><strong>C-M-]</strong> 移动到 1k 字节页面的结尾。</li>
<li><strong>M-g</strong> 移至以十六进制指定的地址。</li>
<li><strong>M-j</strong> 移至以十进制指定的地址。</li>
<li><strong>C-c C-c</strong> 退出 hexl-mode，返回调用 hexl-mode 之前返回此缓冲区的主模式。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.webopedia.com/TERM/B/binary_file.html">https://www.webopedia.com/TERM/B/binary_file.html</a><br>[2] <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Editing-Binary-Files.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Editing-Binary-Files.html</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs ERC SASL 配置</title>
    <url>/2022/09/emcas-erc-sasl/</url>
    <content><![CDATA[<p>最近在使用 IRC 的时候发现 Emacs 的 ERC 不能登录 IRC 了，提示如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Opening connection..                                                    [13:47]</span><br><span class="line">-zinc.libera.chat- *** Checking Ident</span><br><span class="line">-zinc.libera.chat- *** Looking up your hostname...</span><br><span class="line">-zinc.libera.chat- *** No Ident response</span><br><span class="line">-zinc.libera.chat- *** Couldn&#x27;t look up your hostname</span><br><span class="line">-zinc.libera.chat- *** Notice -- SASL authentication to a NickServ account</span><br><span class="line">                 with a verified email address is required to connect from</span><br><span class="line">                 your current network. Please see</span><br><span class="line">                 https://libera.chat/guides/sasl for configuration assistance.</span><br><span class="line">==&gt; ERROR from irc.libera.chat: Closing Link: 117.139.163.129 (SASL</span><br><span class="line">    authentication to a NickServ account with a verified email address is</span><br><span class="line">    required to connect from your current network. Please see</span><br><span class="line">    https://libera.chat/guides/sasl for configuration assistance.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connection failed!  Not re-establishing connection.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** ERC terminated: connection broken by remote peer</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这是由于 <a href="https://libera.chat/">Libera.Chat</a> 要求对某些 IP 范围使用 SASL。在采用了官网给出的<a href="https://libera.chat/guides/emacs-erc">解决方案</a>之后，发现还是不行，启动 Emacs 的时候将遇到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning (initialization): An error occurred while loading ‘/Users/japin/.emacs.d/init.el’:</span><br><span class="line"></span><br><span class="line">Symbol&#x27;s function definition is void: define-erc-response-handler</span><br><span class="line"></span><br><span class="line">To ensure normal operation, you should investigate and remove the</span><br><span class="line">cause of the error in your initialization file.  Start Emacs with</span><br><span class="line">the ‘--debug-init’ option to view a complete error backtrace. Disable showing Disable logging</span><br></pre></td></tr></table></figure>

<p>我尝试在 <a href="https://github.com/search?q=erc-sasl&ref=opensearch">Github 上搜索 <code>erc-sasl</code></a>，找到两个与之相关的项目，我选择了 <a href="https://github.com/kimjetwav/erc-sasl">kimjetwav</a> 的实现（仅仅是因为它在最近更新过），经过测试发现可以正常使用。</p>
<p>通过查看其源码，我发现 kimjetwav 的实现中导入了 <code>erc</code>，搜索一番之后，<a href="https://doc.endlessparentheses.com/Fun/define-erc-response-handler.html">才知道 <code>define-erc-response-handler</code> 是在 <code>erc-backend.el</code> 中定义的</a>。而官网给的 <code>erc-sasl</code> 中并没有导入，于是我们尝试在官网的 <code>erc-sasl</code> 中加入 <code>erc</code>，其也可以正常工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://libera.chat/guides/emacs-erc">https://libera.chat/guides/emacs-erc</a><br>[2] <a href="https://libera.chat/guides/sasl">https://libera.chat/guides/sasl</a><br>[3] <a href="https://github.com/kimjetwav/erc-sasl/blob/master/erc-sasl.el">https://github.com/kimjetwav/erc-sasl/blob/master/erc-sasl.el</a><br>[4] <a href="https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bchat/erc/local/erc-sasl/erc-sasl.el">https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bchat/erc/local/erc-sasl/erc-sasl.el</a><br>[5] <a href="https://doc.endlessparentheses.com/Fun/define-erc-response-handler.html">https://doc.endlessparentheses.com/Fun/define-erc-response-handler.html</a></p>
<div class="just-for-fun">
笑林广记 - 医银入肚

<p>一富翁含银于口，误吞入，肚甚痛，延医治之。<br>医曰：“不难，先买纸牌一副，烧灰咽之，再用艾丸炙脐，其银自出。”<br>翁询其故，医曰：“外面用火烧，里面有强盗打劫，哪怕你的银子不出来。”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 命令</title>
    <url>/2020/04/gdb-commands/</url>
    <content><![CDATA[<p>在<a href="/2020/01/getting-in-and-out-of-gdb/" title="上一篇">上一篇</a>文章中，我们介绍了如何进入和退出 GDB，以及一些基本的配置，本文主要介绍 GDB 的命令语法、与命令相关的配置，如何对命令进行补全、有关命令的选项以及如何获取命令的帮助信息。</p>
<span id="more"></span>

<h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><p>GDB 命令是一个单行的输入，这一行是没有限制的。GDB 命令的语法是命令名后跟参数。例如，命令 <code>step</code> 可以跟一个参数代表步进的次数，如 <code>step 5</code>。我们也可以使用不带参数的 <code>step</code> 命令，某些命令不允许带参数。</p>
<p>如果 GDB 命令的名称缩写没有歧义的话，我们可以简写命令名称。在某些情况下，我们甚至可以不明确的缩写。例如，即使有其他命令以 <code>s</code> 开头，GDB 也将 <code>s</code> 定义为 <code>step</code>。我们可以通过将缩写用作 <code>help</code> 命令的参数来测试缩写。</p>
<p>如果输入空行（即输入 <code>RET</code> 回车键）的话则表示重复之前的命令。某些命令（例如，<code>run</code> 命令）不会以这种方式重复，这些命令通常我们也不需要它重复执行。用户定义的命令可以禁用这个功能。</p>
<p>当我们使用 <code>RET</code> 来重复 <code>list</code> 和 <code>x</code> 命令时，它们会构造新的参数而不是使用之前输入的参数。这样可以很容易的查看源码和内存。</p>
<p>GDB 还可以通过另一种方式使用 <code>RET</code>：以类似于通用实用程序的方式对冗长的输出进行分区。</p>
<p>任何位于 <code>#</code> 字符之后的文本都是注释的内容，这通常在命令文件中非常有用。</p>
<h2 id="命令配置"><a href="#命令配置" class="headerlink" title="命令配置"></a>命令配置</h2><p>许多命令都可以由命令特定的变量或者配置来更改其行为。我们可以使用 <code>set</code> 子命令来修改配置。例如，<code>print</code> 命令（查看数据）打印数组的内容取决于 <code>set print elements NUMBER-OF-ELEMENTS</code> 和 <code>set print array-indexes</code> 以及其他配置。</p>
<p>我们可以在 GDB 启动时加载的 gdbinit 文件中更改这些设置。这些配置也可以在 gdb 回话中临时修改。例如，要更改要打印的数组元素的限制，可以执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(GDB) set print elements 10</span><br><span class="line">(GDB) print some_array</span><br><span class="line">$1 = &#123;0, 10, 20, 30, 40, 50, 60, 70, 80, 90...&#125;</span><br></pre></td></tr></table></figure>

<p>上面的命令 <code>set print elements 10</code> 将默认打印的数组大小由 200 修改为 10。如果仅打算将此限制 10 用于打印 some_array，则我们需要将其设置回默认值 200 。</p>
<p>某些命令允许使用命令选项来覆盖设置。例如，<code>print</code> 命令支持一系列选项来覆盖相关的全局设置。上面的命令我们可以使用下面的命令来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(GDB) print -elements 10 -- some_array</span><br><span class="line">$1 = &#123;0, 10, 20, 30, 40, 50, 60, 70, 80, 90...&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们可以在命令调用期间使用 <code>with</code> 命令来临时更改设置，即 <code>with setting [value] [-- command]</code> 或者 <code>w setting [value] [-- command]</code>，在命令执行期间临时将 <code>setting</code> 设置为 <code>value</code>。其中 <code>setting</code> 是任何可以使用 <code>set</code> 命令修改的配置。如果没有提供 <code>command</code>，那么将会重复执行上一条命令。如果指定了 <code>command</code>，那么必须使用 <code>--</code> 来分割设置和命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(GDB) with print array on -- print some_array</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(GDB) set print array on</span><br><span class="line">(GDB) print some_array</span><br><span class="line">(GDB) set print array off</span><br></pre></td></tr></table></figure>
<p>当我们覆盖自定义命令或者使用 Python 和 Guile 时非常有用。<br>如果我们需要为一个命令临时修改多个设置，我们可以使用嵌套的 <code>with</code> 命令，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with language ada -- with print elements 10</span><br></pre></td></tr></table></figure>

<p>上面的命令临时地将语言设置为 <code>ada</code> 并且设置数组和字符串的输出限制为 10。</p>
<h2 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h2><p>当只有一个候选的命令时，GDB 可以补全用户输入的命令，任何时候，GDB 都可以查看用户可能输入的命令。这对于 GDB 的命令、子命令、命令选项以及程序的符号名都是有效的。</p>
<p>当我们需要补全命令时，我们可以直接输入 <code>TAB</code>。如果只有一种可能性，则 GDB 会填入单词，并等待我们完成命令（或按 <code>RET</code> 键输入）。例如，如果我们输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info bre TAB</span><br></pre></td></tr></table></figure>

<p>GDB 将会补全 <code>bre</code> 为 <code>breakpoints</code>，因为对于 <code>info</code> 的子命令并且以 <code>bre</code> 开头的只有 <code>breakpoints</code> 一个候选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure>

<p>此时，我们可以输入 <code>RET</code> 来执行 <code>info breakpoints</code> 命令，或者如果 <code>breakpoints</code> 不是我们期望的命令，我们可以使用退格键删除补全的内容，并输入我们想要的命令。（如果我们确定想要执行的命令就是 <code>info breakpoints</code>，我们可以在输入 <code>info bre</code> 之后立即输入 <code>RET</code> 来执行这条命令，这就是利用了 GDB 命令缩写的功能。）</p>
<p>如果我们在输入 <code>TAB</code> 进行补全时，候选项不止一个，那么 GDB 会发出铃声，我们可以尝试输入更多的字符来补全信息，或者再次输入 <code>TAB</code> 来查看可能的候选项。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b make_ TAB</span><br><span class="line"></span><br><span class="line">GDB sounds bell; press TAB again, to see:</span><br><span class="line"></span><br><span class="line">make_a_section_from_file     make_environ</span><br><span class="line">make_abs_section             make_function_type</span><br><span class="line">make_blockvector             make_pointer_type</span><br><span class="line">make_cleanup                 make_reference_type</span><br><span class="line">make_command                 make_symbol_completion_list</span><br><span class="line">(gdb) b make_</span><br></pre></td></tr></table></figure>

<p>当我么输入 <code>make_</code> 并按 <code>TAB</code> 键时，由于存在多个候选项，因此 GDB 将会发出铃声，当我么再次输入 <code>TAB</code> 时，GDB 会显示可能的候选项。随后，GDB 会赋值用户的输入并继续等待用户输入。</p>
<p>如果我们只是想要第一时间看到可能的候选项，我们可以直接输入 <code>M-?</code> 而不是连续输入两次 <code>TAB</code>。<code>M-?</code> 是 <code>META ?</code> 的简写。我们可以通过按 <code>ESC+?</code> 来达到相同的目的。</p>
<p>如果候选项非常大，GDB 将尽可能多的输出候选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b mTABTAB</span><br><span class="line">main</span><br><span class="line">&lt;... the rest of the possible completions ...&gt;</span><br><span class="line">*** List may be truncated, max-completions reached. ***</span><br><span class="line">(gdb) b m</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的命令来控制候选项的数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set max-completions limit</span><br><span class="line">set max-completions unlimited</span><br></pre></td></tr></table></figure>

<p>上面的命令用于设置显示的最大的候选项数量。当达到最大的限制时，GDB 将不会在显示其他可能的候选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show max-completions</span><br></pre></td></tr></table></figure>

<p>显示候选项限制。</p>
<p>有时我们输入的内容逻辑上属于一个完整的内容，但是它包含了特殊字符，例如括号等。为了让补全在这种情况下也可以正常工作，我们需要使用单引号将其包裹起来。例如在补全 C++ 中模版名时经常会遇到这种情况，在正常情况下，GDB 会将 <code>&lt;</code> 视为一个分隔符，并假定它是小于符号。</p>
<p>如下所示，当我们需要使用 <code>print</code> 或者 <code>call</code> 命令调用 C++ 模版函数时，我们需要区分使用那个版本，如 <code>name&lt;int&gt;()</code> 或 <code>name&lt;float&gt;()</code>。为了在这种情况下使用补全共鞥，我们需要在函数名称之前键入 <code>&#39;</code> ，随后在使用补全的快捷键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p &#x27;func&lt; M-?</span><br><span class="line">func&lt;int&gt;()    func&lt;float&gt;()</span><br><span class="line">(gdb) p &#x27;func&lt;</span><br></pre></td></tr></table></figure>

<p>但是在设置断点时，我们并不需要这样做，这是因为 GDB 知道我们需要在函数上设置断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b func&lt; M-?</span><br><span class="line">func&lt;int&gt;()    func&lt;float&gt;()</span><br><span class="line">(gdb) b func&lt;</span><br></pre></td></tr></table></figure>

<p>这对于 C++ 中的重载函数也是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b bubble( M-?</span><br><span class="line">bubble(int)    bubble(double)</span><br><span class="line">(gdb) b bubble(dou M-?</span><br><span class="line">bubble(double)</span><br></pre></td></tr></table></figure>

<p>GDB 提供了 <code>set overload-resolution off</code> 来禁止重载函数的解析。</p>
<p>当 GDB 在补全结构体的成员时，他将尝试补全除了左侧之外可用的字段名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p gdb_stdout.M-?</span><br><span class="line">magic                to_fputs             to_rewind</span><br><span class="line">to_data              to_isatty            to_write</span><br><span class="line">to_delete            to_put               to_write_async_safe</span><br><span class="line">to_flush             to_read</span><br></pre></td></tr></table></figure>

<p>上面的 <code>gdb_stdout</code> 变量在 GDB 源码中的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ui_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> *magic;</span><br><span class="line">   ui_file_flush_ftype *to_flush;</span><br><span class="line">   ui_file_write_ftype *to_write;</span><br><span class="line">   ui_file_write_async_safe_ftype *to_write_async_safe;</span><br><span class="line">   ui_file_fputs_ftype *to_fputs;</span><br><span class="line">   ui_file_read_ftype *to_read;</span><br><span class="line">   ui_file_delete_ftype *to_delete;</span><br><span class="line">   ui_file_isatty_ftype *to_isatty;</span><br><span class="line">   ui_file_rewind_ftype *to_rewind;</span><br><span class="line">   ui_file_put_ftype *to_put;</span><br><span class="line">   <span class="keyword">void</span> *to_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>GDB 的某些命令支持一个 <code>-</code> 给出命令选项，例如，<code>print -pretty</code>。与命令名称一样，命令选项也可以采用缩写的形式，前提是这个缩写不会导致歧义，同时，我梦也可以用 <code>TAB</code> 来补全命令选项（或者是查看可能的命令选项）。</p>
<p>GDB 某些命令将原始输入作为参数。例如，<code>print</code> 命令可以处理 GDB 支持的任何语言的表达式。在这些命令中，原始输入可能以 <code>-</code> 开始，因此这可能会与命令选项产生混淆，例如， <code>print -p</code> （它可以是 <code>print -pretty</code> 的缩写或者取变量 <code>p</code> 的相反数），因此如果我们的命令中包含选项，我们需要使用 <code>--</code> 来分割命令选项和参数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print -object on -pretty off -element unlimited -- *myptr</span><br><span class="line">(gdb) p -o -p 0 -e u -- *myptr</span><br></pre></td></tr></table></figure>

<p>上面两条命令是等价的。</p>
<p>我们可以使用补全功能来查看命令可用的选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print -TABTAB</span><br><span class="line">-address         -max-depth       -raw-values      -union</span><br><span class="line">-array           -null-stop       -repeats         -vtbl</span><br><span class="line">-array-indexes   -object          -static-members</span><br><span class="line">-elements        -pretty          -symbol</span><br></pre></td></tr></table></figure>

<p>补全功能同样也能给出命令选项的参数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print -elements TABTAB</span><br><span class="line">NUMBER     unlimited</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，选项期望输入一个整数（如，100），而不是文本 <code>NUMBER</code>。</p>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>在 GDB 中，我们可以使用 <code>help</code> 命令来获取帮助信息。我们可以使用不带参数的 <code>help</code>（缩写为 <code>h</code>）来显示命令分类类的简短列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without</span><br><span class="line">               stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of</span><br><span class="line">commands in that class.</span><br><span class="line">Type &quot;help&quot; followed by command name for full</span><br><span class="line">documentation.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>help class</code> 可以获取命令分类下的命令信息。例如，我们可以查看 <code>status</code> 分类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) help status</span><br><span class="line">Status inquiries.</span><br><span class="line"></span><br><span class="line">List of commands:</span><br><span class="line"></span><br><span class="line">info -- Generic command for showing things</span><br><span class="line">        about the program being debugged</span><br><span class="line">show -- Generic command for showing things</span><br><span class="line">        about the debugger</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by command name for full</span><br><span class="line">documentation.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p><code>help command</code> 则可以查看具体命令的使用。</p>
<p><code>apropos [-v] regexp</code> 命令可以在所有 GDB 命令中搜索与正则表达式匹配的命令。<code>-v</code> 是详细的意思。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apropos alias</span><br><span class="line">alias -- Define a new command that is an alias of an existing command</span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">d -- Delete some breakpoints or auto-display expressions</span><br><span class="line">del -- Delete some breakpoints or auto-display expressions</span><br><span class="line">delete -- Delete some breakpoints or auto-display expressions</span><br></pre></td></tr></table></figure>

<p><code>complete args</code> 命令用于获取所有以 <code>args</code> 开始的命令。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) complete i</span><br><span class="line">if</span><br><span class="line">ignore</span><br><span class="line">inferior</span><br><span class="line">info</span><br><span class="line">init-if-undefined</span><br><span class="line">interpreter-exec</span><br><span class="line">interrupt</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>除了 <code>help</code> 命令之外，我们还可以使用 <code>info</code> 和 <code>show</code> 命令来获取程序或 GDB 的状态。</p>
<ul>
<li><code>info</code> - 该命令可以缩写为 <code>i</code>，它用于获取当前程序的状态。例如，我们可以使用它来函数的参数 <code>info args</code>，查看当前使用的寄存器 <code>info registers</code>，或者是查看当前设置的断点信息 <code>info breakpoints</code>。我们可以使用 <code>help info</code> 来查看所有 <code>info</code> 的子命令。</li>
<li><code>set</code> - 我们可以使用 <code>set</code> 命令给环境变量赋值。例如，我们可以使用 <code>set prompt $</code> 将 GDB 命令提示符号修改为 <code>$</code> 符。</li>
<li><code>show</code> - 与 <code>info</code> 命令不通，<code>show</code> 用来查看 GDB 自身的状态。我们可以改变大多数我们可以使用 <code>show</code> 命令查看的内容。例如，我们可以使用 <code>set radix</code> 命令设置系统编号，并使用 <code>show radix</code> 来查询当前值。</li>
</ul>
<p>为了获取所有可以设置的参数，我们可以使用没有参数的 <code>show</code> 命令，或者 <code>info set</code> 命令，它们是等效的。</p>
<p>有几个 <code>show</code> 的子命令是无法使用 <code>set</code> 命令进行修改的。</p>
<ul>
<li><code>show version</code> - 查看当前 GDB 的版本信息。</li>
<li><code>show copying</code> &amp; <code>info copying</code> - 显示有关复制 GDB 的权限的信息。</li>
<li><code>show warranty</code> &amp; <code>info warranty</code> - 显示 GNU “NO WARRANTY” 声明。</li>
<li><code>show configuration</code> - 显示编译 GDB 时的详细配置信息。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Commands.html#Commands">https://sourceware.org/gdb/current/onlinedocs/gdb/Commands.html#Commands</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 崩溃问题</title>
    <url>/2022/09/gdb-crash/</url>
    <content><![CDATA[<center><font size=1>本图片来自于 The Art of Debugging with GDB, DDD, and Eclipse 1st Edition, Kindle Edition 的封面</font size></center>
<img src="/2022/09/gdb-crash/gdb.png" class="">

<p>今天在调试程序的时候遇到了 GDB 导致的 segfault，感觉还挺有意思的，因此在这里做一个简要记录。</p>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsb_release -a</span></span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.04.6 LTS</span><br><span class="line">Release:        18.04</span><br><span class="line">Codename:       bionic</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb --version</span></span><br><span class="line">GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br></pre></td></tr></table></figure>

<h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><p>场景是这样的，我在一个终端中进入了一个临时的工作目录；随后，我在另一个终端中将这个临时目录删除了；之后，我再回到第一个终端，并启动 GDB 进行调试，结果就遇到了 crash。为了方便演示，我们这里使用如下的测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GDB segfault\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -g -O0 -o segfault segfault.c</span></span><br></pre></td></tr></table></figure>

<p>为了后续方便测试，我们将 <code>segfault</code> 这个二进制文件所在路径加入到环境变量中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PWD</span>:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure>

<p>随后，我们在新建一个目录 <code>t</code>，并进入该目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir t &amp;&amp; <span class="built_in">cd</span> t</span></span><br></pre></td></tr></table></figure>

<p>然后，在另一个终端中删除目录 <code>t</code>。最后我们在第一个终端中执行下面的调试命令即可触发。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb segfault</span></span><br><span class="line">gdb: warning: error finding working directory: No such file or directory</span><br><span class="line">GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过生成 coredump 文件，我们可以看到如下的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gdb gdb /tmp/core.0.10585.1653385146</span><br><span class="line">GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from gdb...Reading symbols from /usr/lib/debug/.build-id/aa/405dd866e17b9353dd22ef4350c9f765bed9aa.debug...done.</span><br><span class="line"><span class="keyword">done</span>.</span><br><span class="line">[New LWP 10585]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">Core was generated by `gdb -p 28121<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:65</span></span><br><span class="line"><span class="string">65      ../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.</span></span><br><span class="line"><span class="string">(gdb) bt</span></span><br><span class="line"><span class="string">#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:65</span></span><br><span class="line"><span class="string">#1  0x0000560b9bc52469 in gdb_abspath (path=path@entry=0x560b9dd723c0 &quot;system-supplied DSO at 0x7ffc9cd80000&quot;) at ./gdb/common/pathstuff.c:143</span></span><br><span class="line"><span class="string">#2  0x0000560b9bd97d03 in objfile::objfile (this=0x560b9d077640, abfd=0x560b9ddc52b0, name=0x560b9dd723c0 &quot;system-supplied DSO at 0x7ffc9cd80000&quot;, flags_=...)</span></span><br><span class="line"><span class="string">    at ./gdb/objfiles.c:400</span></span><br><span class="line"><span class="string">#3  0x0000560b9bdff2f9 in symbol_file_add_with_addrs (abfd=abfd@entry=0x560b9ddc52b0, name=0x560b9dd723c0 &quot;system-supplied DSO at 0x7ffc9cd80000&quot;, add_flags=...,</span></span><br><span class="line"><span class="string">    addrs=addrs@entry=0x560b9cdee4d0, flags=..., parent=parent@entry=0x0) at ./gdb/symfile.c:1153</span></span><br><span class="line"><span class="string">#4  0x0000560b9bdff9e5 in symbol_file_add_from_bfd (abfd=abfd@entry=0x560b9ddc52b0, name=&lt;optimized out&gt;, add_flags=..., addrs=addrs@entry=0x560b9cdee4d0, flags=...,</span></span><br><span class="line"><span class="string">    flags@entry=..., parent=parent@entry=0x0) at ./gdb/symfile.c:1263</span></span><br><span class="line"><span class="string">#5  0x0000560b9bbb08f2 in symbol_file_add_from_memory (templ=templ@entry=0x560b9cebeb50, addr=&lt;optimized out&gt;, size=&lt;optimized out&gt;,</span></span><br><span class="line"><span class="string">    name=name@entry=0x560b9dd723c0 &quot;system-supplied DSO at 0x7ffc9cd80000&quot;, from_tty=from_tty@entry=0) at ./gdb/symfile-mem.c:133</span></span><br><span class="line"><span class="string">#6  0x0000560b9bbb0a3f in add_vsyscall_page (target=&lt;optimized out&gt;, from_tty=&lt;optimized out&gt;) at ./gdb/symfile-mem.c:205</span></span><br><span class="line"><span class="string">#7  0x0000560b9bd9a41d in generic_observer_notify (args=0x7ffd04f1f450, subject=&lt;optimized out&gt;) at ./gdb/observer.c:167</span></span><br><span class="line"><span class="string">#8  observer_notify_inferior_created (objfile=&lt;optimized out&gt;, from_tty=from_tty@entry=1) at ./observer.inc:426</span></span><br><span class="line"><span class="string">#9  0x0000560b9bd58861 in post_create_inferior (target=&lt;optimized out&gt;, from_tty=from_tty@entry=1) at ./gdb/infcmd.c:501</span></span><br><span class="line"><span class="string">#10 0x0000560b9bd5ac3c in setup_inferior (from_tty=from_tty@entry=1) at ./gdb/infcmd.c:2660</span></span><br><span class="line"><span class="string">#11 0x0000560b9bd5ad3c in attach_post_wait (from_tty=1, mode=ATTACH_POST_WAIT_STOP, args=&lt;optimized out&gt;) at ./gdb/infcmd.c:2689</span></span><br><span class="line"><span class="string">#12 0x0000560b9bcbe00d in do_my_continuations_1 (err=0, pmy_chain=&lt;synthetic pointer&gt;) at ./gdb/continuations.c:59</span></span><br><span class="line"><span class="string">#13 do_my_continuations (err=0, list=&lt;optimized out&gt;) at ./gdb/continuations.c:83</span></span><br><span class="line"><span class="string">#14 do_all_inferior_continuations (err=err@entry=0) at ./gdb/continuations.c:125</span></span><br><span class="line"><span class="string">#15 0x0000560b9bd54c97 in inferior_event_handler (event_type=&lt;optimized out&gt;, client_data=&lt;optimized out&gt;) at ./gdb/inf-loop.c:59</span></span><br><span class="line"><span class="string">#16 0x0000560b9bd6bd5c in fetch_inferior_event (client_data=&lt;optimized out&gt;) at ./gdb/infrun.c:3973</span></span><br><span class="line"><span class="string">#17 0x0000560b9bd274fd in gdb_wait_for_event (block=block@entry=0) at ./gdb/event-loop.c:859</span></span><br><span class="line"><span class="string">#18 0x0000560b9bd276ef in gdb_do_one_event () at ./gdb/event-loop.c:322</span></span><br><span class="line"><span class="string">#19 0x0000560b9bd277a6 in gdb_do_one_event () at ./gdb/event-loop.c:353</span></span><br><span class="line"><span class="string">#20 0x0000560b9be34d3c in wait_sync_command_done () at ./gdb/top.c:503</span></span><br><span class="line"><span class="string">#21 0x0000560b9be34d7a in maybe_wait_sync_command_done (was_sync=&lt;optimized out&gt;, was_sync@entry=0) at ./gdb/top.c:520</span></span><br><span class="line"><span class="string">#22 0x0000560b9bd8290f in catch_command_errors (command=0x560b9bd5ae80 &lt;attach_command(char const*, int)&gt;, arg=arg@entry=0x7ffd04f2089f &quot;28121&quot;, from_tty=1) at ./gdb/main.c:381</span></span><br><span class="line"><span class="string">#23 0x0000560b9bd83cbc in captured_main_1 (context=&lt;optimized out&gt;) at ./gdb/main.c:1061</span></span><br><span class="line"><span class="string">#24 captured_main (data=&lt;optimized out&gt;) at ./gdb/main.c:1147</span></span><br><span class="line"><span class="string">#25 gdb_main (args=&lt;optimized out&gt;) at ./gdb/main.c:1173</span></span><br><span class="line"><span class="string">#26 0x0000560b9bb8decb in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at ./gdb/gdb.c:32</span></span><br></pre></td></tr></table></figure>

<p>可以看到是在 <code>gdb_abspath()</code> 函数中调用 <code>strlen()</code> 触发的，大概率这里的值是空值。<code>gdb_abspath()</code> 函数的源码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">gdb::unique_xmalloc_ptr&lt;<span class="keyword">char</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">gdb_abspath</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">gdb_assert</span> (path != <span class="literal">NULL</span> &amp;&amp; path[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gdb_tilde_expand_up</span> (path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IS_ABSOLUTE_PATH</span> (path))</span><br><span class="line">    <span class="keyword">return</span> gdb::unique_xmalloc_ptr&lt;<span class="keyword">char</span>&gt; (<span class="built_in">xstrdup</span> (path));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Beware the // my son, the Emacs barfs, the botch that catch...  */</span></span><br><span class="line">  <span class="keyword">return</span> gdb::unique_xmalloc_ptr&lt;<span class="keyword">char</span>&gt;</span><br><span class="line">    (<span class="built_in">concat</span> (current_directory,</span><br><span class="line">             <span class="built_in">IS_DIR_SEPARATOR</span> (current_directory[<span class="built_in">strlen</span> (current_directory) - <span class="number">1</span>])</span><br><span class="line">             ? <span class="string">&quot;&quot;</span> : SLASH_STRING,</span><br><span class="line">             path, (<span class="keyword">char</span> *) <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>current_directory</code> 是一个全局变量，由于它为空导致了崩溃。我在代码中查找了关于该变量的所有引用，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep <span class="string">&#x27;current_directory&#x27;</span> -rn . --include <span class="string">&quot;*.c&quot;</span></span><br><span class="line">./gdb/cli/cli-cmds.c:364:  <span class="keyword">if</span> (strcmp (cwd.get (), current_directory) != 0)</span><br><span class="line">./gdb/cli/cli-cmds.c:366:                      current_directory, cwd.get ());</span><br><span class="line">./gdb/cli/cli-cmds.c:368:    printf_unfiltered (_(<span class="string">&quot;Working directory %s.\n&quot;</span>), current_directory);</span><br><span class="line">./gdb/cli/cli-cmds.c:414:      xfree (current_directory);</span><br><span class="line">./gdb/cli/cli-cmds.c:415:      current_directory = dir_holder.release ();</span><br><span class="line">./gdb/cli/cli-cmds.c:419:      <span class="keyword">if</span> (IS_DIR_SEPARATOR (current_directory[strlen (current_directory) - 1]))</span><br><span class="line">./gdb/cli/cli-cmds.c:420:       current_directory = concat (current_directory, dir_holder.get (),</span><br><span class="line">./gdb/cli/cli-cmds.c:423:       current_directory = concat (current_directory, SLASH_STRING,</span><br><span class="line">./gdb/cli/cli-cmds.c:430:  <span class="keyword">for</span> (p = current_directory; *p;)</span><br><span class="line">./gdb/cli/cli-cmds.c:444:             <span class="keyword">while</span> (q != current_directory &amp;&amp; !IS_DIR_SEPARATOR (q[-1]))</span><br><span class="line">./gdb/cli/cli-cmds.c:447:             <span class="keyword">if</span> (q == current_directory)</span><br><span class="line">./gdb/cli/cli-cmds.c:448:               /* current_directory is</span><br><span class="line">./gdb/cli/cli-cmds.c:722:  <span class="built_in">chdir</span> (current_directory);</span><br><span class="line">./gdb/source.c:510:           name = current_directory;</span><br><span class="line">./gdb/source.c:540:     name = concat (current_directory, SLASH_STRING, name, (char *)NULL);</span><br><span class="line">./gdb/source.c:799:       len = strlen (current_directory);</span><br><span class="line">./gdb/source.c:806:       strcpy (filename, current_directory);</span><br><span class="line">./gdb/tracefile-tfile.c:441:    filename.reset (concat (current_directory, <span class="string">&quot;/&quot;</span>, filename.get (),</span><br><span class="line">./gdb/top.c:133:char *current_directory;</span><br><span class="line">./gdb/top.c:1875:      history_filename = concat (current_directory, <span class="string">&quot;/_gdb_history&quot;</span>,</span><br><span class="line">./gdb/top.c:1878:      history_filename = concat (current_directory, <span class="string">&quot;/.gdb_history&quot;</span>,</span><br><span class="line">./gdb/top.c:1958:    history_filename = reconcat (history_filename, current_directory, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">./gdb/top.c:2123:  make_final_cleanup (do_chdir_cleanup, xstrdup (current_directory));</span><br><span class="line">./gdb/bsd-kvm.c:84:       temp = concat (current_directory, <span class="string">&quot;/&quot;</span>, filename, (char *)NULL);</span><br><span class="line">./gdb/go32-nat.c:464:  <span class="built_in">chdir</span> (current_directory);</span><br><span class="line">./gdb/common/pathstuff.c:142:    (concat (current_directory,</span><br><span class="line">./gdb/common/pathstuff.c:143:        IS_DIR_SEPARATOR (current_directory[strlen (current_directory) - 1])</span><br><span class="line">./gdb/corelow.c:290:    filename.reset (concat (current_directory, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">./gdb/gdbserver/server.c:63:char *current_directory;</span><br><span class="line">./gdb/gdbserver/server.c:3598:  current_directory = getcwd (NULL, 0);</span><br><span class="line">./gdb/gdbserver/server.c:3599:  <span class="keyword">if</span> (current_directory == NULL)</span><br><span class="line">./gdb/main.c:538:  current_directory = getcwd (NULL, 0);</span><br><span class="line">./gdb/main.c:539:  <span class="keyword">if</span> (current_directory == NULL)</span><br></pre></td></tr></table></figure>

<p>通过上面的查找可以看到仅在 <code>server.c</code> 和 <code>main.c</code> 中对其进行了初始化（调用 <code>getcwd()</code> 函数），事实上，在上述的测试情况下 <code>getcwd()</code> 函数将返回 <code>NULL</code>，然而其只是给出一个警告便继续执行了，因此在后续使用 <code>current_directory</code> 时是对空指针进行操作，从而导致崩溃。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">current_directory = getcwd (<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (current_directory == <span class="literal">NULL</span>)</span><br><span class="line">  perror_warning_with_name (_(<span class="string">&quot;error finding working directory&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这个问题在之后的版本被修复了<sup>[1]</sup>。但不幸的是在 GDB 8.1.1 版本没有机会没有合并（与 GDB 的版本维护策略相关），因此建议升级一下 GDB，目前的 GDB 12 版本是已经确定修复了。感兴趣如何修复的朋友可以在<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=patch;h=ff8577f64987a898e1dc5eb6afb66a404fb7bb16">这里</a>看到 patch 的完整内容。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=23613">https://sourceware.org/bugzilla/show_bug.cgi?id=23613</a></p>
<div class="just-for-fun">
笑林广记 - 讲解

<p>有姓李者暴富而骄，或嘲之云：“一童读百家姓首句，求师解释，<br>师曰：‘赵是精赵的赵字（吴俗谓人呆为赵），钱是有铜钱的钱字，孙是小猢狲的孙字，李是姓张姓李的李字。’<br>童又问：‘倒转亦可讲得否？’<br>师曰：‘也讲得。’<br>童曰：‘如何讲？’<br>师曰：‘不过姓李的小猢狲，有了几个臭铜钱，一时就精赵起来。’”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 基本使用</title>
    <url>/2020/01/getting-in-and-out-of-gdb/</url>
    <content><![CDATA[<p>在工作中经常使用 GDB 来调试程序，但是一直都没有系统的进行学习过，为此，我打算对其进行一个系统的学习，学习的主要材料来自 GNU GDB 文档 <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">Debugging with GDB</a>。</p>
<p>本文主要包括如何运行以及退出 GDB，通常，我们使用 <code>gdb</code> 即可进入 GDB，而 <code>quit</code> 命令或者 <code>Ctrl-d</code> 快捷键便可以退出 GDB。</p>
<span id="more"></span>

<h2 id="运行-GDB"><a href="#运行-GDB" class="headerlink" title="运行 GDB"></a>运行 GDB</h2><p>通过在命令行中输入 <code>gdb</code> 就可以进入到 GDB，此时，GDB 将读取用户输入的命令并执行，这其实就是一个交互式的界面，读取用户命令，执行用户命令，再读取用户命令，直到用户输入退出指令执行退出操作。</p>
<p>我们还可以在 <code>gdb</code> 运行时指定一系列参数和选项，从而指定更多关于我们调试环境的一些设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb program</span></span><br></pre></td></tr></table></figure>

<p>上面是最常用的 GDB 使用方式，它指定我们将要调试的可执行程序。此外，我们还可以指定调试的程序以及一个 core 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb program core</span></span><br></pre></td></tr></table></figure>

<p>如果我们要调试正在运行的程序，我们还可以使用进程 ID 或者 <code>-p</code> 选项作为第二个参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb program 1234</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb -p 1234</span></span><br></pre></td></tr></table></figure>

<p>上面的命令将使用 GDB 附加到进程 ID 为 <code>1234</code> 的进程上，如果使用 <code>-p</code> 选项，我们可以省略 <code>program</code> 程序名。</p>
<p>我们可以选择使用 <code>--args</code> 来向调试的程序传递参数，该选项将终止可选参数的处理。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb --args gcc -O2 -c foo.c</span></span><br></pre></td></tr></table></figure>

<p>上面的命令将使用 GDB 调试 gcc 程序，并将 <code>-O2 -c foo.c</code> 作为 <code>gcc</code> 的命令行参数。</p>
<p>GDB 运行时会输出类似下面的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">GNU gdb (GDB) 8.3</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-apple-darwin18.5.0&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>--slient</code> 或者 <code>-q/--quite</code> 选项来抑制这些信息的输出。还有很多关于 GDB 的命令行选项，我们可以通过 <code>gdb -help</code> 来获取其使用方法。</p>
<h3 id="文件选择"><a href="#文件选择" class="headerlink" title="文件选择"></a>文件选择</h3><p>当 GDB 运行时，它将读取选项以外的所有参数以指定可执行文件和 core 文件（或者进程 ID）中读取其它参数。这与分别由 <code>-se</code> 和 <code>-c</code> （或者 <code>-p</code>）指定参数相同。（GDB 将第一个没有选项关联的参数视为与 <code>-se</code> 后跟参数等效；将第二个没有选项关联的参数视为与 <code>-c</code> 或者 <code>-p</code> 后跟参数等效。）如果第二个参数以数字开始，GDB 首先尝试将其附加为一个进程，如果失败了，GDB 则试图将其作为一个 core 文件来打开。如果我们有一个以数字开始的 core 文件，那么我们可以为期添加前缀（如 <code>./</code>）来避免 GDB 将其视为一个进程 ID。</p>
<p>如果 GDB 不支持配置 core 文件，例如对于大多是嵌入式目标，那么 GDB 将输出日志并忽略第二个参数。</p>
<p>大多数 GDB 选项都有长，短选项两种形式；如果我们截断了长格式，只要足够 GDB 区分歧义，那么它也是能识别的。</p>
<style>
table th:nth-of-type(1) {
    width: 35%;
}
table th:nth-of-type(2) {
    width: 65%;
}
</style>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-symbols file</code>, <br/><code>-s file</code></td>
<td>从文件 <code>file</code> 中读取符号表</td>
</tr>
<tr>
<td><code>-exec file</code>, <br/><code>-e file</code></td>
<td>使用文件 <code>file</code> 作为可执行文件在适当时执行，并与核心转储一起检查纯数据</td>
</tr>
<tr>
<td><code>-se file</code></td>
<td>从文件 <code>file</code> 中读取符号表，并将其用作可执行文件</td>
</tr>
<tr>
<td><code>-core file</code>, <br/><code>-c file</code></td>
<td>使用文件 <code>file</code> 作为 coredump 文件进行检查</td>
</tr>
<tr>
<td><code>-pid number</code>, <br/><code>-p number</code></td>
<td>与 <code>attach</code> 命令一样，附加到进程 ID 为 <code>number</code> 的进程</td>
</tr>
<tr>
<td><code>-command file</code>, <br/><code>-x file</code></td>
<td>执行 <code>file</code> 文件中的命令，该文件的内容与 <code>source</code> 命令的内容相同</td>
</tr>
<tr>
<td><code>-eval-command command</code>, <br/><code>-ex command</code></td>
<td>执行单个的 GDB 命令，可多次使用，也可以与 <code>-x</code> 交叉使用</td>
</tr>
<tr>
<td><code>-init-command file</code>, <br/><code>-ix file</code></td>
<td>在加载 <code>inferior</code> 之前（在加载 <code>gdbinit</code> 文件之后）执行 <code>file</code> 文件内的 GDB 命令</td>
</tr>
<tr>
<td><code>-init-eval-command command</code>,<br/> <code>-iex command</code></td>
<td>在加载 <code>inferior</code> 之前（在加载 <code>gdbinit</code> 文件之后）执行单个 GDB 命令</td>
</tr>
<tr>
<td><code>-directory directory</code>, <br/><code>-d directory</code></td>
<td>将目录 <code>directory</code> 作为源码或脚本的搜索路径</td>
</tr>
<tr>
<td><code>-r</code>, <br/><code>-readnow</code></td>
<td>立即读取每个符号文件的整个符号表，而不是默认值，默认值是根据需要逐步读取它。这会使启动速度变慢，但会使以后的操作变快</td>
</tr>
<tr>
<td><code>--readnever</code></td>
<td>不要读取每个符号文件的符号调试信息。这使启动速度更快，但以无法执行符号调试为代价。DWARF展开信息也不会被读取，这意味着 backtrace 可能变得不完整或不准确。这种用法通常是用户只关心程序的执行顺序。</td>
</tr>
</tbody></table>
<h3 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h3><p>我们可以在不同模式下运行 GBD，例如，批处理模式或者静默模式。</p>
<ul>
<li><p><code>-nx, -n</code> 不要执行初始化文件中的命令。GDB 包含三个初始化文件，它们按照如下的顺序加载：</p>
<ul>
<li><code>system.gdbinit</code> - 系统级别的初始化文件，它由编译时选项 <code>--with-system-gdbinit</code> 指定的位置。GDB 会在命令行选项处理之前加载此文件。</li>
<li><code>system.gdbinit.d</code> - 这是系统级别的初始化目录。它由编译时选项 <code>--with-system-gdbinit-dir</code> 指定。此处的文件将在 <code>system.gdbinit</code> 文件之后、命令行选项之前进行加载，该目录下可能存在多个文件，它们按字母顺序进行加载。文件需要具有公认的脚本语言扩展名（<code>.py/.scm</code>）或以 <code>.gdb</code> 扩展名（将其视为普通的 GDB 命令）命名。GDB 不会递归的加载该目录下的子目录。</li>
<li><code>~/.gdbinit</code> - 用户家目录初始化文件，它在 <code>system.gdbinit</code> 之后，命令行选项处理之前加载。</li>
<li><code>./.gdbinit</code> - 当前目录的初始化文件。它最后被加载，除了 <code>-x</code> 和 <code>-nx</code> 命令行选项之外。<code>-x</code> 和 <code>-ex</code> 是最后被处理的，在 <code>./.gdbinit</code> 之后加载。</li>
</ul>
</li>
<li><p><code>-nh</code> 不要执行来自用户家目录下的初始化文件（即 <code>~/.gdbinit</code>）中的命令。</p>
</li>
<li><p><code>-quite, -silent, -q</code> 静默模式，不输出介绍信息和版权信息。在批处理模式下也不会输出这些信息。</p>
</li>
<li><p><code>-batch</code> 批处理模式。在处理完由 <code>-x</code> 指定的所有命令文件（如果没有使用 <code>-n</code> 选项，也将处理初始化文件中的命令）并退出，正常返回 0，非 0 表示出现错误。批处理模式将会禁止分页功能，即终端的宽度和高度没有限制，类似于 <code>set confirm off</code>。</p>
</li>
<li><p><code>-cd directory</code> 使用 <code>directory</code> 作为工作目录，而不是当前目录作为工作目录。</p>
</li>
<li><p><code>-data-directory directory, -D directory</code> 使用 <code>directory</code> 作为 GDB 运行时的数据目录，这个目录包含了 GDB 的辅助文件。</p>
</li>
</ul>
<p>此处只列出了部分选项，更多选项<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Mode-Options.html#Mode-Options">请看这里</a>。</p>
<h3 id="GDB-在启动时都做了什么"><a href="#GDB-在启动时都做了什么" class="headerlink" title="GDB 在启动时都做了什么"></a>GDB 在启动时都做了什么</h3><p>下面是有关 GDB 在会话启动过程中执行的操作的说明：</p>
<ol>
<li><p>设置命令行指定的命令解释器。</p>
</li>
<li><p>读取系统级别的初始化文件以及系统级别的初始化目录，并执行这些文件中的命令。这些文件以 <code>.gdb</code> 结尾（包含 GDB 命令）或者 GDB 支持的脚本语言的后缀结尾。</p>
</li>
<li><p>读取用户级别的初始化文件并执行其中的命令。</p>
</li>
<li><p>执行由 <code>-iex</code> 或 <code>-ix</code> 选项指定的命令文件或命令，按照指定的顺序执行。</p>
</li>
<li><p>处理命令行选项和操作数。</p>
</li>
<li><p>读取并执行来自当前工作目录下的初始化文件（需要 <code>set auto-load local-gdbinit</code> 设置为 <code>on</code>）。仅在当前目录不是用户家目录时才会执行。因此，我们可以在调用 GDB 的目录中拥有多个初始化文件，一个初始化文件位于用户家目录中，而另一个文件特定于要调试的程序目录。</p>
</li>
<li><p>如果命令行选项指定了待调试的程序，或者需要附加的进程，或者 core 文件，GDB 会加载为程序或其加载的共享库提供的有自动加载的脚本。<br>如果我们想要禁用启动时自动加载脚本，可以按如下方式使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb -iex &quot;set auto-load python-scripts off&quot; myprogname</span><br></pre></td></tr></table></figure>

<p>选项 <code>-ex</code> 不会有效，这是因为它加载的时间太晚了，以致于来不及关闭自动加载功能。</p>
</li>
<li><p>按顺序执行来自 <code>-ex</code> 和 <code>-x</code> 选项指定的命令。</p>
</li>
<li><p>读取历史文件中的历史文件。</p>
</li>
</ol>
<p>初始化文件使用的语法与命令文件相同，并且 GDB 处理的方式也一样。用户家目录的初始化文件设置选项可以影响后续选项的处理。如果使用了 <code>-nx</code> 选项，那么将不会执行初始化文件中的命令。</p>
<p>通过 <code>gdb --help</code> 可以看到 GDB 启动时加载的初始化文件列表。</p>
<h2 id="退出-GDB"><a href="#退出-GDB" class="headerlink" title="退出 GDB"></a>退出 GDB</h2><p>我们可以使用 <code>quit [expression]</code> 或者 <code>q [expression]</code> 退出 GDB。如果没有指定 <code>expression</code> 表达式，GDB 将正常终止；否则他将使用表达式 <code>experssion</code> 的结果作为错误码。</p>
<p>中断（通常是 <code>Ctrl-c</code>）不会退出 GDB，而是终止正在运行的 GDB 命令，并返回到 GDB 的命令行。如果您一直在使用 GDB 来控制连接的进程或设备，则可以使用 <code>detach</code> 命令释放它。</p>
<h2 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="Shell 命令"></a>Shell 命令</h2><p>如果我们想要在调试期间执行 shell 命令，我们没有必要离开或者挂起 GDB；我们可以直接使用 SHELL 命令。</p>
<p>我们可以使用 <code>shell command-string</code> 或者 <code>!command-string</code> 来执行标准的 shell 命令。需要注意的是在 <code>!</code> 和 <code>command-string</code> 之间没有空格。如果存在空格，那么将使用环境变量 <code>SHELL</code> 来运行 shell 命令。否则，GDB 将使用默认的 shell（Unix 系统为 /bin/sh，Windows 平台为 COMMAND.COM 等）。</p>
<p>编译工具 <code>make</code> 总是在开发环境中，因此，在 GDB 中我们不必为 <code>make</code> 使用 <code>shell</code> 命令。</p>
<ul>
<li><p><code>make make-args</code> -  将以给定的参数执行 <code>make</code> 命令，这等同于 <code>shell make make-args</code>。</p>
</li>
<li><p><code>pipe [command] | shell_command</code> 和 <code>| [command] | shell_command</code> - 命令执行 <code>command</code> 命令并将结果重定向到 <code>shell_command</code> 中。</p>
</li>
<li><p><code>pipe -d delim command delim shell_command</code> 和<code>| -d delim command delim shell_command</code> - 与上面的命令相似，不同的是我们可以指定分割符 <code>delim</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p var</span><br><span class="line">$1 = &#123;</span><br><span class="line">  black = 144,</span><br><span class="line">  red = 233,</span><br><span class="line">  green = 377,</span><br><span class="line">  blue = 610,</span><br><span class="line">  white = 987</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(gdb) pipe p var | wc</span><br><span class="line">      7      19      80</span><br><span class="line">(gdb) | p var | wc -l</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">(gdb) p /x var</span><br><span class="line">$4 = &#123;</span><br><span class="line">  black = 0x90,</span><br><span class="line">  red = 0xe9,</span><br><span class="line">  green = 0x179,</span><br><span class="line">  blue = 0x262,</span><br><span class="line">  white = 0x3db</span><br><span class="line">&#125;</span><br><span class="line">(gdb) || grep red</span><br><span class="line">  red =&gt; 0xe9,</span><br><span class="line"></span><br><span class="line">(gdb) | -d ! echo this contains a | char\n ! sed -e &#x27;s/|/PIPE/&#x27;</span><br><span class="line">this contains a PIPE char</span><br><span class="line">(gdb) | -d xxx echo this contains a | char!\n xxx sed -e &#x27;s/|/PIPE/&#x27;</span><br><span class="line">this contains a PIPE char!</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>变量 <code>$_shell_exitcode</code> 和 <code>$_shell_exitsignal</code> 可以方便的检查 <code>shell</code>, <code>make</code>, <code>pipe</code> 和 <code>|</code> 最后一个 shell 命令的退出状态。</p>
<h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><p>我们可能想要将 GDB 的输出保存在文件中，GDB 提供多个命令来控制日志的输出。</p>
<ul>
<li><code>set logging on</code> - 启用日志。</li>
<li><code>set logging off</code> - 禁用日志。</li>
<li><code>set logging file filename</code> - 改变当前日志文件名。默认为 gdb.txt。</li>
<li><code>set logging overwrite [on|off]</code> - 默认情况下，GDB 将采用追加的方法写日志文件。我们可以通过设置该参数来改变其行为。</li>
<li><code>set logging redirect [on|off]</code> - 默认情况下，GDB 会同时输出到终端和日志文件中，如果设置 <code>redirect</code>，那么只会输出到日志文件。如果是使用多个 TUI 模式，在 GDB 的命令窗口没有输出，也就无法输出到日志文件中。</li>
<li><code>set logging debugredirect [on|off]</code> - 默认情况下，GDB 的调试输出同时输出到终端和日志文件中，如果设置了 <code>debugredirect</code>，那么就只会输出到日志文件中。GDB 8.1 没有这个命令。</li>
<li><code>show logging</code> - 显示当前日志配置。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://sourceware.org/gdb/current/onlinedocs/gdb">https://sourceware.org/gdb/current/onlinedocs/gdb</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Git bisect 二分查找实践</title>
    <url>/2022/02/git-bisect-in-practice/</url>
    <content><![CDATA[<p>最近在分析 bug 的时候接触到了 <code>git bisect</code> 这个命令，虽然之前也知道这个命令，但是由于平时用的不多所以没有深入的研究，对它的使用方法也不是很熟悉。其实这个命令使用起来还是非常简单的，本文结合实际情况简要介绍一下 <code>git bisect</code> 的使用方法。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>git bisect</code> 是一个使用二分查找来定位引入 bug 提交记录的命令。<a href="https://git-scm.com/docs/git-bisect">官方文档</a>详细的说明了其使用方法，这里有一篇通俗易懂的 <a href="https://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination"><code>git bisect</code> 使用介绍</a>（您可能需要梯子才能打开）。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我在分析 PostgreSQL <a href="https://www.postgresql.org/message-id/17409-52871dda8b5741cb%40postgresql.org">BUG #17409</a> 的问题时，尝试用 <code>git bisect</code> 来定位问题，发现它真的是太香了。Bug 的提交者明确指出在之前的版本中是执行执行相应的操作的，但是在之后的版本中就报错了，那么可以肯定是在其中某个提交中引入了 bug，这种情况非常适合 <code>git bisect</code> 来快速定位到 bug 引入的提交。</p>
<p>由于 PotgreSQL 的版本历史记录非常清晰，我根据用户提供的版本信息找到 7966b79801 这个提交，并验证其可以正常工作，那么我们就可以以此作为起点，从这个点到目前 master 分支上最新的提交，少说也有 3k 个提交记录了，如果我们一个一个提交的验证，肯定不切实际，通过二分的方式，我们可以快速的完成这个过程。</p>
<p>首先我们执行 <code>git bisect start</code> 开始二分查找。接着我们标记 7966b79801 这个提交为正常的，标记 19252e8ec9 为异常的（不能正常工作），这两个点就是二分查找的起点和终点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git bisect good 7966b79801</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad 19252e8ec9</span></span><br><span class="line">Bisecting: 1902 revisions left to test after this (roughly 11 steps)</span><br><span class="line">[c30f54ad732ca5c8762bb68bbe0f51de9137dd72] Detect POLLHUP/POLLRDHUP while running queries.</span><br></pre></td></tr></table></figure>

<p>在标记异常的提交之后，它将给出一个新的提交，并且估算出整个查找过程的步数，从上面看到在 3k 多个提交中定位引入问题的提交大概只需要 11 步即可完成，是不是效率贼高啊！！！</p>
<p>现在我们来测试 c30f54ad73 这个提交，如果正常就用 good 标记，异常则用 bad 标记，重复这个过程，最后就可以找到引入 bug 的提交记录，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad</span></span><br><span class="line">Bisecting: 950 revisions left to test after this (roughly 10 steps)</span><br><span class="line">[24b83a5082541bdb1b333b7fcbe92f194128595c] Doc: clarify data type behavior of COALESCE and NULLIF.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 475 revisions left to test after this (roughly 9 steps)</span><br><span class="line">[65330622441d7ee08f768c4326825ae903f2595a] doc: Clarify status of SELECT INTO on reference page</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad</span></span><br><span class="line">Bisecting: 237 revisions left to test after this (roughly 8 steps)</span><br><span class="line">[f234899353f8998bdbd265125ce4a505a312d910] remove missing reference to crypto test from patch 978f869b99</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad</span></span><br><span class="line">Bisecting: 118 revisions left to test after this (roughly 7 steps)</span><br><span class="line">[9c83b54a9ccdb111ce693ada2309475197c19d70] Fix a recently-introduced race condition in LISTEN/NOTIFY handling.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 59 revisions left to test after this (roughly 6 steps)</span><br><span class="line">[c7aba7c14efdbd9fc1bb44b4cb83bedee0c6a6fc] Support subscripting of arbitrary types, not only arrays.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad</span></span><br><span class="line">Bisecting: 29 revisions left to test after this (roughly 5 steps)</span><br><span class="line">[6114040711affa2b0bcf47fa2791187daf8455fb] Small code simplifications</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 14 revisions left to test after this (roughly 4 steps)</span><br><span class="line">[947789f1f5fb61daf663f26325cbe7cad8197d58] Avoid using tuple from syscache for update of pg_database.datfrozenxid</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 7 revisions left to test after this (roughly 3 steps)</span><br><span class="line">[f2a69b352de1dffc534c4835010e736018aa94de] Doc: clarify that CREATE TABLE discards redundant unique constraints.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 3 revisions left to test after this (roughly 2 steps)</span><br><span class="line">[62ee70331336161cb44733b6c3e0811696d962aa] Teach contain_leaked_vars that assignment SubscriptingRefs are leaky.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 1 revision left to test after this (roughly 1 step)</span><br><span class="line">[16c302f51235eaec05a1f85a11c1df04ef3a6785] Simplify code for getting a unicode codepoint&#x27;s canonical class.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">Bisecting: 0 revisions left to test after this (roughly 0 steps)</span><br><span class="line">[8b069ef5dca97cd737a5fd64c420df3cd61ec1c9] Change get_constraint_index() to use pg_constraint.conindid</span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad</span></span><br><span class="line">8b069ef5dca97cd737a5fd64c420df3cd61ec1c9 is the first bad commit</span><br><span class="line">commit 8b069ef5dca97cd737a5fd64c420df3cd61ec1c9</span><br><span class="line">Author: Peter Eisentraut &lt;peter@eisentraut.org&gt;</span><br><span class="line">Date:   Wed Dec 9 15:12:05 2020 +0100</span><br><span class="line"></span><br><span class="line">    Change get_constraint_index() to use pg_constraint.conindid</span><br><span class="line"></span><br><span class="line">    It was still using a scan of pg_depend instead of using the conindid</span><br><span class="line">    column that has been added since.</span><br><span class="line"></span><br><span class="line">    Since it is now just a catalog lookup wrapper and not related to</span><br><span class="line">    pg_depend, move from pg_depend.c to lsyscache.c.</span><br><span class="line"></span><br><span class="line">    Reviewed-by: Matthias van de Meent &lt;boekewurm+postgres@gmail.com&gt;</span><br><span class="line">    Reviewed-by: Tom Lane &lt;tgl@sss.pgh.pa.us&gt;</span><br><span class="line">    Reviewed-by: Michael Paquier &lt;michael@paquier.xyz&gt;</span><br><span class="line">    Discussion: https://www.postgresql.org/message-id/flat/4688d55c-9a2e-9a5a-d166-5f24fe0bf8db%40enterprisedb.com</span><br><span class="line"></span><br><span class="line"> src/backend/catalog/pg_depend.c      | 69 ------------------------------------</span><br><span class="line"> src/backend/commands/tablecmds.c     |  1 -</span><br><span class="line"> src/backend/optimizer/util/plancat.c |  1 -</span><br><span class="line"> src/backend/utils/adt/ruleutils.c    |  3 +-</span><br><span class="line"> src/backend/utils/cache/lsyscache.c  | 27 ++++++++++++++</span><br><span class="line"> src/include/catalog/dependency.h     |  2 --</span><br><span class="line"> src/include/utils/lsyscache.h        |  1 +</span><br><span class="line"> 7 files changed, 29 insertions(+), 75 deletions(-)</span><br></pre></td></tr></table></figure>

<p>如上所示，经过 11 次操作我们就定位了引入 bug 的提交，并且使用起来也没有想象中那么复杂。如果您对 <code>git bisect</code> 不是很熟悉，想要找示例练手，本文的示例是一个不错的选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://git-scm.com/docs/git-bisect">https://git-scm.com/docs/git-bisect</a><br>[2] <a href="https://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination">https://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination</a></p>
<div class="just-for-fun">
笑林广记 - 入场

<p>监生应试入场方出，一故人相遇揖之，并揖路旁猪屎。<br>生问：“此臭物，揖之何为？”<br>答曰：“他臭便臭，也从大肠（场）里出来的。”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 git blame</title>
    <url>/2019/12/git-blame/</url>
    <content><![CDATA[<p>最近在向 PostgreSQL 社区提交 patch 时，发现其维护者很快就定位到了代码何时由谁更改了，作为一个萌新，我也不好意思问:(，只能自己下来查找资料，经过一番搜索，发现了 <code>git blame</code> 这个命令。</p>
<span id="more"></span>

<h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><p>Git 的 blame 子命令可以显示一个文件每一行最后的修改作者及信息。由此，我们便可以快速定位代码的修改。</p>
<p>例如，我们可以通过如下命令来查看文件的更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    1) /*-------------------------------------------------------------------------</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    2)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    3)  * timestamp.c</span><br><span class="line">cc26ea9fe2e (Peter Eisentraut   2013-04-20 11:04:41 -0400    4)  *        Functions for the built-in SQL types &quot;timestamp&quot; and &quot;interval&quot;.</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    5)  *</span><br><span class="line">97c39498e5c (Bruce Momjian      2019-01-02 12:44:25 -0500    6)  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    7)  * Portions Copyright (c) 1994, Regents of the University of California</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    8)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000    9)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   10)  * IDENTIFICATION</span><br><span class="line">9f2e2113869 (Magnus Hagander    2010-09-20 22:08:53 +0200   11)  *        src/backend/utils/adt/timestamp.c</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   12)  *</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   13)  *-------------------------------------------------------------------------</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   14)  */</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000   15)</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000   16) #include &quot;postgres.h&quot;</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000   17)</span><br><span class="line">4bc578eb838 (Marc G. Fournier   1997-04-03 19:58:11 +0000   18) #include &lt;ctype.h&gt;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   19) #include &lt;math.h&gt;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000   20) #include &lt;limits.h&gt;</span><br><span class="line">dd4eea257b7 (Neil Conway        2005-06-30 03:48:58 +0000   21) #include &lt;sys/time.h&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是不是觉得太长了不方便查看，没关系，<code>git blame</code> 还提供了参数可以控制文件中查看的内容。例如查看文件第 20 行到 40 行之间的改动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 20,40 ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 20) #include &lt;limits.h&gt;</span><br><span class="line">dd4eea257b7 (Neil Conway        2005-06-30 03:48:58 +0000 21) #include &lt;sys/time.h&gt;</span><br><span class="line">cb292206c5c (Peter Eisentraut   2000-07-12 22:59:15 +0000 22)</span><br><span class="line">18952f67446 (Tom Lane           2000-05-29 01:59:17 +0000 23) #include &quot;access/xact.h&quot;</span><br><span class="line">5cabcfccce4 (Tom Lane           2002-08-26 17:54:02 +0000 24) #include &quot;catalog/pg_type.h&quot;</span><br><span class="line">df1a699e5ba (Tom Lane           2017-04-05 23:51:27 -0400 25) #include &quot;common/int128.h&quot;</span><br><span class="line">b6d15590f72 (Tom Lane           2008-05-04 23:19:24 +0000 26) #include &quot;funcapi.h&quot;</span><br><span class="line">30f609484d0 (Tom Lane           2003-05-12 23:08:52 +0000 27) #include &quot;libpq/pqformat.h&quot;</span><br><span class="line">8507ddb9c63 (Thomas G. Lockhart 1997-07-01 00:22:46 +0000 28) #include &quot;miscadmin.h&quot;</span><br><span class="line">b8a18ad4850 (Noah Misch         2015-03-01 13:22:34 -0500 29) #include &quot;nodes/makefuncs.h&quot;</span><br><span class="line">c13897983a0 (Robert Haas        2012-02-08 09:33:02 -0500 30) #include &quot;nodes/nodeFuncs.h&quot;</span><br><span class="line">1fb57af9206 (Tom Lane           2019-02-09 18:08:48 -0500 31) #include &quot;nodes/supportnodes.h&quot;</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 32) #include &quot;parser/scansup.h&quot;</span><br><span class="line">bec98a31c55 (Tom Lane           2000-07-17 03:05:41 +0000 33) #include &quot;utils/array.h&quot;</span><br><span class="line">94094c05697 (Marc G. Fournier   1997-03-14 05:58:13 +0000 34) #include &quot;utils/builtins.h&quot;</span><br><span class="line">b5f7cff84f5 (Tom Lane           2005-06-29 22:51:57 +0000 35) #include &quot;utils/datetime.h&quot;</span><br><span class="line">6bf0bc842bd (Tomas Vondra       2018-07-29 03:30:48 +0200 36) #include &quot;utils/float.h&quot;</span><br><span class="line">b5f7cff84f5 (Tom Lane           2005-06-29 22:51:57 +0000 37)</span><br><span class="line">e303a2dbe8c (Tom Lane           2002-09-21 19:52:41 +0000 38) /*</span><br><span class="line">e303a2dbe8c (Tom Lane           2002-09-21 19:52:41 +0000 39)  * gcc&#x27;s -ffast-math switch breaks routines that expect exact results from</span><br><span class="line">a536b2dd80f (Bruce Momjian      2005-07-21 03:56:25 +0000 40)  * expressions like timeval / SECS_PER_HOUR, where timeval is double.</span><br></pre></td></tr></table></figure>

<p>我们还可以通过指定偏移的方式来显示。例如，下面的命令可以到达和上面的命令相同的效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 20,+21 ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 40,-21 ./src/backend/utils/adt/timestamp.c</span></span><br></pre></td></tr></table></figure>

<p>如果我们向查看一个函数的变更呢？是否需要先在源文件中查看函数的起止行，然后在指定行号呢？答案当然是 NO。我们可以通过指定函数名来完成这一需求。例如，我想要查看 <code>timestamp_part</code> 函数的更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L :timestamp_part ./src/backend/utils/adt/timestamp.c</span></span><br><span class="line">ae526b40703 (Tom Lane           2000-06-09 01:11:16 +0000 4522) timestamp_part(PG_FUNCTION_ARGS)</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4523) &#123;</span><br><span class="line">220db7ccd8c (Tom Lane           2008-03-25 22:42:46 +0000 4524)         text       *units = PG_GETARG_TEXT_PP(0);</span><br><span class="line">1dc34982511 (Bruce Momjian      2005-10-15 02:49:52 +0000 4525)         Timestamp       timestamp = PG_GETARG_TIMESTAMP(1);</span><br><span class="line">ae526b40703 (Tom Lane           2000-06-09 01:11:16 +0000 4526)         float8          result;</span><br><span class="line">a70e13a39ec (Tom Lane           2016-03-16 19:09:04 -0400 4527)         Timestamp       epoch;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4528)         int                     type,</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4529)                                 val;</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4530)         char       *lowunits;</span><br><span class="line">547df0cc853 (Thomas G. Lockhart 2002-04-21 19:52:18 +0000 4531)         fsec_t          fsec;</span><br><span class="line">b6b71b85bc4 (Bruce Momjian      2004-08-29 05:07:03 +0000 4532)         struct pg_tm tt,</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4533)                            *tm = &amp;tt;</span><br><span class="line">41f1f5b76ad (Thomas G. Lockhart 2000-02-16 17:26:26 +0000 4534)</span><br><span class="line">220db7ccd8c (Tom Lane           2008-03-25 22:42:46 +0000 4535)         lowunits = downcase_truncate_identifier(VARDATA_ANY(units),</span><br><span class="line">220db7ccd8c (Tom Lane           2008-03-25 22:42:46 +0000 4536)                                                                                         VARSIZE_ANY_EXHDR(units),</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4537)                                                                                         false);</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4538)</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4539)         type = DecodeUnits(0, lowunits, &amp;val);</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4540)         if (type == UNKNOWN_FIELD)</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4541)                 type = DecodeSpecial(0, lowunits, &amp;val);</span><br><span class="line">0bd61548ab8 (Tom Lane           2004-05-07 00:24:59 +0000 4542)</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4543)         if (TIMESTAMP_NOT_FINITE(timestamp))</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4544)         &#123;</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4545)                 result = NonFiniteTimestampTzPart(type, val, lowunits,</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4546)                                                                                   TIMESTAMP_IS_NOBEGIN(timestamp),</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4547)                                                                                   false);</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4548)                 if (result)</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4549)                         PG_RETURN_FLOAT8(result);</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4550)                 else</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4551)                         PG_RETURN_NULL();</span><br><span class="line">647d87c56ab (Tom Lane           2016-01-21 22:26:20 -0500 4552)         &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>您以为这就完了么？Too yong too simple. <code>git blame</code> 的 <code>-L</code> 参数还支持正则表达式。我们可以是下面的正则表达式方式实现上面的需求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L <span class="string">&#x27;/^timestamp_part(/,/^&#125;$/&#x27;</span> ./src/backend/utils/adt/timestamp.c</span></span><br></pre></td></tr></table></figure>

<p>暂时先整理到此处，更多的用法可以查看<a href="https://git-scm.com/docs/git-blame">文档</a>或帮助手册 (<code>man git-blame</code>)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://git-scm.com/docs/git-blame">https://git-scm.com/docs/git-blame</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 撤销已经修改的文件</title>
    <url>/2019/12/git-discard-changes/</url>
    <content><![CDATA[<p>Git 中可以通过 <code>git checkout -- &lt;file&gt;...</code> 来撤销当前工作空间的修改。例如，我们有以下文件已经做出了修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch hunghudb-11.3beta</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   src/backend/postmaster/pgstat.c</span><br><span class="line">        modified:   src/backend/replication/logical/reorderbuffer.c</span><br><span class="line">        modified:   src/backend/storage/file/buffile.c</span><br><span class="line">        modified:   src/include/pgstat.h</span><br><span class="line">        modified:   src/include/replication/reorderbuffer.h</span><br><span class="line">        modified:   src/include/storage/buffile.h</span><br></pre></td></tr></table></figure>

<p>如果此时我想要撤销这些修改，我们应该怎么做呢？</p>
<span id="more"></span>

<p>最简单的方法是针对每个文件，我们可以使用下面的命令进行撤销：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- src/backend/postmaster/pgstat.c</span><br></pre></td></tr></table></figure>


<p>下面的命令通过将 <code>git</code> 与 shell 结合使用，更为方便快捷。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- $(git status -s | grep &#x27;^ M&#x27; | cut -d&#x27; &#x27; -f 3)</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以使用 <code>git checkout .</code> 命令来撤销所有修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &#x27;*.c&#x27;</span><br></pre></td></tr></table></figure>

<p>上面的命令可以撤销所有对 C 源文件的修改。</p>
<p><a href="https://public-inbox.org/git/xmqqy2zszuz7.fsf@gitster-ct.c.googlers.com/">Git 2.23 版本中引入了 <code>git restore</code> 和 <code>git switch</code> 命令</a>，其中 <code>git restore</code> 可以用于撤销修改，其使用方式与 <code>git checkout</code> 类似。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>git restore --worktree README.md</code></td>
<td>表示撤销 README.md 文件工作区的的修改</td>
</tr>
<tr>
<td><code>git restore --staged README.md</code></td>
<td>表示撤销暂存区的修改，将文件状态恢复到未 add 之前</td>
</tr>
<tr>
<td><code>git restore -s HEAD~1 README.md</code></td>
<td>表示将当前工作区切换到上个 commit 版本</td>
</tr>
<tr>
<td><code>git restore -s &lt;commit&gt; README.md</code></td>
<td>表示将当前工作区切换到指定 commit 的版本</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://git-scm.com/docs/git-checkout">https://git-scm.com/docs/git-checkout</a><br>[2] <a href="https://public-inbox.org/git/xmqqy2zszuz7.fsf@gitster-ct.c.googlers.com/">https://public-inbox.org/git/xmqqy2zszuz7.fsf@gitster-ct.c.googlers.com/</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 跳过 SSL 验证</title>
    <url>/2019/08/git-skip-ssl-verify/</url>
    <content><![CDATA[<p>有时，我们在克隆代码或者拉取代码时想要跳过 SSL 验证（至于为什么有这么奇葩的需求就不多说了，自行体会），git 提供了多种方式可供用户选择。</p>
<p>首先，我们看来看看克隆代码时如何跳过 SSL 验证。如下，我们可以使用 <code>GIT_NO_SSL_VERIFY</code> 环境变量来设置是否采用 SSL 验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> GIT_SSL_NO_VERIFY=<span class="literal">true</span> git <span class="built_in">clone</span> https://github.com/xxx/xxx</span></span><br></pre></td></tr></table></figure>

<p>如果是仓库已经采用 SSL 验证克隆下来，但是在随后的拉取过程中想要取消 SSL 验证，我们可以通过修改配置来完成，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config http.sslVerify <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>

<p>如果您想后续的仓库都跳过 SSL 验证，可以设置全局的 <code>http.sslVerify</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global http.sslVerify <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 多仓库分支同步</title>
    <url>/2019/01/git-sync-branches-among-remote-repositories/</url>
    <content><![CDATA[<p>今天遇到一个 git 远程仓库分支同步的问题，主要的诉求是将两个远程仓库的分支同步到一致状态。起初，项目只是在 GitHub 上进行维护，后期又在 GitLab 上创建了该项目，并且两个仓库之间的分支情况有所不同。我们可以使用如下命令同步两个远程仓库之间的分支信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch --all -p</span><br><span class="line">$ git push github &quot;refs/remotes/gitlab/*:refs/heads/*&quot;</span><br><span class="line">$ git push gitlab &quot;refs/remotes/github/*:refs/heads/*&quot;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> <code>github</code> 指向远端的 GitHub 项目地址，同理，<code>gitlab</code> 指向远端的 GitLab 项目地址。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言 http 响应头设置</title>
    <url>/2020/09/go-http-response-writer/</url>
    <content><![CDATA[<p>Go 语言的 <code>net/http</code> 包为我们提供了一个 HTTP 客户端和服务器的实现，通过它我们可以快速的搭建一个 HTTP 服务器，本文记录一下在编写 HTTP 服务器时关于设置 HTTP 响应头遇到的一个小问题。</p>
<span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>问题的表象是通过 <code>w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)</code> （<code>w</code> 为 <code>http.ResponseWriter</code> 对象）无法设置响应头的 <code>Content-Type</code> 为 <code>application/json</code>。下面是是一个简单的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">        Code    <span class="keyword">int</span></span><br><span class="line">        Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        res := Status&#123;Code: <span class="number">200</span>, Message: <span class="string">&quot;hello world!&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">        w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">        json.NewEncoder(w).Encode(&amp;res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line"></span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行上面的程序，随后我们去访问可以看到如下所示的响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -i http://localhost:8080/hello</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 14 Sep 2020 09:40:11 GMT</span><br><span class="line">Content-Length: 38</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;Code&quot;:200,&quot;Message&quot;:&quot;hello world!&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>从响应的结果可以看到，<code>Content-Type</code> 并没有被设置为我想要的 <code>application/json</code>。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过测试我发现，经过如下修改，就可以正确的设置 HTTP 响应头。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/main.go b/main.go</span></span><br><span class="line"><span class="comment">index 8bec8e3..459fb77 100644</span></span><br><span class="line"><span class="comment">--- a/main.go</span></span><br><span class="line"><span class="comment">+++ b/main.go</span></span><br><span class="line"><span class="meta">@@ -13,8 +13,8 @@</span> type Status struct &#123;</span><br><span class="line"> func hello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        res := Status&#123;Code: 200, Message: &quot;hello world!&quot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-       w.WriteHeader(200)</span></span><br><span class="line">        w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)</span><br><span class="line"><span class="addition">+       w.WriteHeader(200)</span></span><br><span class="line"></span><br><span class="line">        json.NewEncoder(w).Encode(&amp;res)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以下是测试输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -i http://localhost:8080/hello</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Mon, 14 Sep 2020 09:48:52 GMT</span><br><span class="line">Content-Length: 38</span><br><span class="line"></span><br><span class="line">&#123;&quot;Code&quot;:200,&quot;Message&quot;:&quot;hello world!&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？通过查看 <a href="https://github.com/golang/go/blob/master/src/net/http/server.go#L100">Go 语言的源码</a>，发现了如下内容：</p>
<blockquote>
<p> type ResponseWriter interface {<br>     // Header returns the header map that will be sent by<br>     // WriteHeader. The Header map also is the mechanism with which<br>     // Handlers can set HTTP trailers.<br>     //<br>     // Changing the header map after a call to WriteHeader (or<br>     // Write) has no effect unless the modified headers are<br>     // trailers.<br>     //<br>     // There are two ways to set Trailers. The preferred way is to<br>     // predeclare in the headers which trailers you will later<br>     // send by setting the “Trailer” header to the names of the<br>     // trailer keys which will come later. In this case, those<br>     // keys of the Header map are treated as if they were<br>     // trailers. See the example. The second way, for trailer<br>     // keys not known to the Handler until after the first Write,<br>     // is to prefix the Header map keys with the TrailerPrefix<br>     // constant value. See TrailerPrefix.<br>     //<br>     // To suppress automatic response headers (such as “Date”), set<br>     // their value to nil.<br>     Header() Header<br> …<br>}</p>
</blockquote>
<p>从注释我们可以看到，在调用了 <code>WriteHeader()</code> 或者是 <code>Write()</code> 函数之后去改变响应头（trailers 响应头除外）是没有效果的。<br>其实，在 Go 的文档里面也出现了上述注释，只是在读文档的时候不够仔细，导致忽略了这一点。</p>
<p>关于 HTTP Trailers 的相关说明可以参考<a href="https://www.geeksforgeeks.org/http-headers-trailer/">这里</a>。</p>
<p>我们从源码角度来做简要分析。首先，我们看看 <code>ResponseWriter</code> 是如何获取 <code>Header</code> 结构的，如下所示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span> <span class="title">Header</span><span class="params">()</span> <span class="title">Header</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> w.cw.header == <span class="literal">nil</span> &amp;&amp; w.wroteHeader &amp;&amp; !w.cw.wroteHeader &#123;</span><br><span class="line">                <span class="comment">// Accessing the header between logically writing it</span></span><br><span class="line">                <span class="comment">// and physically writing it means we need to allocate</span></span><br><span class="line">                <span class="comment">// a clone to snapshot the logically written state.</span></span><br><span class="line">                w.cw.header = w.handlerHeader.Clone()</span><br><span class="line">        &#125;</span><br><span class="line">        w.calledHeader = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> w.handlerHeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，我们在调用 <code>w.Header()</code> 函数获取的其实是 <code>w.handlerHeader</code>，因此，我们添加的 HTTP 响应头也是存放在该结构中的。接着我们在来看看 <code>w.WriteHeader()</code> 函数是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (w *response) WriteHeader(code int) &#123;</span><br><span class="line">        if w.conn.hijacked() &#123;</span><br><span class="line">                caller := relevantCaller()</span><br><span class="line">                w.conn.server.logf(&quot;http: response.WriteHeader on hijacked connection from %s (%s:%d)&quot;, caller.Function, path.Base(caller.File), caller.Line)</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        if w.wroteHeader &#123;</span><br><span class="line">                caller := relevantCaller()</span><br><span class="line">                w.conn.server.logf(&quot;http: superfluous response.WriteHeader call from %s (%s:%d)&quot;, caller.Function, path.Base(caller.File), caller.Line)</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        checkWriteHeaderCode(code)</span><br><span class="line">        w.wroteHeader = true</span><br><span class="line">        w.status = code</span><br><span class="line"></span><br><span class="line">        if w.calledHeader &amp;&amp; w.cw.header == nil &#123;</span><br><span class="line">                w.cw.header = w.handlerHeader.Clone()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if cl := w.handlerHeader.get(&quot;Content-Length&quot;); cl != &quot;&quot; &#123;</span><br><span class="line">                v, err := strconv.ParseInt(cl, 10, 64)</span><br><span class="line">                if err == nil &amp;&amp; v &gt;= 0 &#123;</span><br><span class="line">                        w.contentLength = v</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                        w.conn.server.logf(&quot;http: invalid Content-Length of %q&quot;, cl)</span><br><span class="line">                        w.handlerHeader.Del(&quot;Content-Length&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，<code>w.WriteHeader()</code> 将 <code>w.handlerHeader</code> 中的 HTTP 响应头克隆到了 <code>w.cw.header</code> 中（其中 <code>cw</code> 为 <code>*chunkWriter</code> 类型）。最终，<code>net/http</code> 是通过 <code>func (cw *chunkWriter) writeHeader(p []byte)</code>  函数来完成响应头的处理的，而这其中关于 HTTP 响应头，除了 Trailer 类型的响应头外，都是从 <code>cw.header</code>  中获取的，因此，在调用 <code>w.WriteHeader()</code> 之后，我们设置的非 Trailer 响应头是无效的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/golang/go/blob/master/src/net/http/server.go">https://github.com/golang/go/blob/master/src/net/http/server.go</a><br>[2] <a href="https://golang.org/pkg/net/http/">https://golang.org/pkg/net/http/</a><br>[3] <a href="https://www.geeksforgeeks.org/http-headers-trailer/">https://www.geeksforgeeks.org/http-headers-trailer/</a></p>
<div class="just-for-fun">
笑林广记 - 原不识字

<p>有延师教其子者，师至，主人曰：“家贫，多失礼于先生，奈何！”<br>师曰：“何言之谦，仆固无不可者。”<br>主人曰：“蔬食，可乎？”<br>曰：“可。”<br>主人曰：“家无藏获，凡洒扫庭除，启闭门户，劳先生为之，可乎？”<br>曰：“可。”<br>主人曰：“或家人妇子欲买零星杂物，屈先生一行，可乎？”<br>曰：“可。”<br>主人曰：“如此，幸甚！”<br>师曰：“仆亦有一言，愿主人勿讶焉。”<br>主人问何言？<br>师曰：“自愧幼时不学耳！”<br>主人曰：“何言之谦。”<br>师曰：“不敢欺，仆实不识一字。”</p>
</div>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言实战</title>
    <url>/2021/05/go-in-action/</url>
    <content><![CDATA[<p>最近由于需要从事 Go 语言相关的工作，为此花了约一个星期的时间将《Go 语言实战》这本书过了一遍，对 Go 语言有了一个基本的认识。这本书短小精悍，全书 200 多页，详细介绍了 Go 语言的数组、切片的底层原理，Go 语言的类型系统、并发、通道以及测试。当然部分内容也没有深入的讲解，如映射，其底层的实现介绍的不是很充分。《Go 语言实战》这本书适合有一定语言编程经验的读者。</p>
<span id="more"></span>

<ol>
<li><p>之前只是知道在 <code>import</code> 包的时候可以使用 <code>_</code> 来避免对于没有使用的包产生的编译时错误。但其实它还能做其他的处理，调用包提供的 <code>init()</code> 函数进行初始化动作。所有的 <code>init()</code> 函数都在 <code>main()</code> 函数之前执行。</p>
</li>
<li><p>深入理解了数组和切片之间的关系。切片的底层依然是数组，但是在 Go 语言中数组的大小是不变的，但切片就相对灵活多了，我们可以将切片看作是 <code>(pointer, length, capacity)</code> 的三元组，其中 <code>pointer</code> 指向了底层数组的位置（当前切片在数组中的位置），<code>length</code> 则是当前切片中元素的个数，<code>capacity</code> 是切片的容量。我们可以在同一个数组上创建多个切片，但是要注意多个切片之前的操作可能导致数据错乱。例如：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">arr1 := arr[:<span class="number">4</span>]</span><br><span class="line">arr2 := arr[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>

<p> 当我们修改 <code>arr2[0]</code> 的时候，<code>arr1[2]</code> 的值也会相应的改变，这是因为他们底层共享同一个数组。切片在传递参数的时候要比数组的效率高很多。</p>
</li>
<li><p>Go 语言通过接口来实现多态。</p>
</li>
<li><p>嵌入类型，这里涉及到嵌入类型方法的提升以及公开和未公开属性的相关内容。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entities</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">	Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user            <span class="comment">// 这是一个嵌入类型</span></span><br><span class="line">	Level <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;path/to/user/entities&quot;</span></span><br><span class="line">)</span><br><span class="line">a := entities.Admin&#123;</span><br><span class="line">    Level: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置未公开的内部类型的公开字段的值</span></span><br><span class="line">a.Name = <span class="string">&quot;Bill&quot;</span></span><br><span class="line">a.Email = <span class="string">&quot;bill@example.com&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试。测试部分包含单元测试、表组测试、模仿调用、测试服务端点。这些都给出来示例，指导我们如何编写可测试的代码。我们还可以通过 <code>godoc</code> 来为我们的包提供文档。后续还需要深入了解 <code>go test</code> 相关的功能。</p>
</li>
</ol>
<p>整本书的内容蛮多的，关于并发和并发模式，这部分只做了大概的了解，还没有深入的理解，尤其是第 7 章并发模式。</p>
<div class="just-for-fun">
笑林广记 - 先后

<p>有人剃头于铺，其人剃发极草率，既毕，特倍与之钱而行。<br>异日复往，其人竭力为主剃发，加倍工夫，事事周到，既已，乃少给其资。<br>其人不服曰：“前次剃头草率，尚蒙厚赐，此番格外用心，何可如此？”<br>此人谓曰：“今之资，前已给过。今日所给乃前次之资也。”</p>
</div>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 访问达梦数据库</title>
    <url>/2021/07/golang-access-dm-database/</url>
    <content><![CDATA[<p>本文简要记录一下如何使用 Go 语言来访问达梦数据库。达梦数据库随安装包提供了 Go 语言的 driver，目前该 driver 仅支持 Windows 和 Linux 操作系统，不支持 MacOS 系统。</p>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本次的测试环境如下所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu</td>
<td>18.04</td>
</tr>
<tr>
<td>Go</td>
<td>go1.14.3</td>
</tr>
<tr>
<td>达梦数据库</td>
<td>DM-V8</td>
</tr>
</tbody></table>
<h2 id="配置达梦数据库驱动"><a href="#配置达梦数据库驱动" class="headerlink" title="配置达梦数据库驱动"></a>配置达梦数据库驱动</h2><p>在安装完了达梦数据库之后，我们需要将安装目录下的 <code>drivers/go/dm-go-driver.zip</code> 文件解压到 <code>$GOROOT/src</code> 目录下。其官方文档说的是解压到 <code>$GOPATH/src</code> 路径下，经过测试不能正常工作，可能是由于 Go 语言版本导致的（包管理的方式发生了变化，本文采用 <code>GO111MODULE=on</code> 的方式进行包管理），官方采用的 <code>go1.13</code>，我在这里并没有进行详细的测试，毕竟我也仅仅是一名 Go 小白而已。</p>
<h2 id="访问达梦数据库"><a href="#访问达梦数据库" class="headerlink" title="访问达梦数据库"></a>访问达梦数据库</h2><p>首先，我们使用下面的命令初始化项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir dmtest &amp;&amp; <span class="built_in">cd</span> dmtest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go mod init dmtest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch main.go</span></span><br></pre></td></tr></table></figure>

<p>文件 <code>main.go</code> 的内容如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;dm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    db  *sql.DB</span><br><span class="line">    err error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    driverName := <span class="string">&quot;dm&quot;</span></span><br><span class="line">    dataSourceName := <span class="string">&quot;dm://SYSDBA:123456789@10.9.10.184:5236&quot;</span></span><br><span class="line">    <span class="keyword">if</span> db, err = connect(driverName, dataSourceName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = insertTable(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = selectTable(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(driverName <span class="keyword">string</span>, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*sql.DB, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> db *sql.DB</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> db, err = sql.Open(driverName, dataSourceName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;connect to \&quot;%s\&quot; succeed.\n&quot;</span>, dataSourceName)</span><br><span class="line">    <span class="keyword">return</span> db, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertTable</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    sql := <span class="string">&quot;INSERT INTO tbl VALUES (1, &#x27;world&#x27;);&quot;</span></span><br><span class="line"></span><br><span class="line">    data, err := db.Exec(sql)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Insert data succeed: %v\n&quot;</span>, data)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectTable</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    sql := <span class="string">&quot;SELECT * FROM tbl;&quot;</span></span><br><span class="line"></span><br><span class="line">    rows, err := db.Query(sql)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> err = rows.Scan(&amp;id, &amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\t%v\n&quot;</span>, id, name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建一个连接，并向表中插入一条记录，随后再读取该记录。在这之前，我们需要先在达梦数据库中创建一个名为 <code>tbl</code> 的表，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p>编译上面的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build</span></span><br><span class="line">go: finding module for package golang.org/x/text/encoding/ianaindex</span><br><span class="line">go: finding module for package golang.org/x/text/message</span><br><span class="line">go: finding module for package golang.org/x/text/encoding</span><br><span class="line">go: finding module for package golang.org/x/text/language</span><br><span class="line">go: finding module for package github.com/golang/snappy</span><br><span class="line">go: found github.com/golang/snappy in github.com/golang/snappy v0.0.4</span><br><span class="line">go: found golang.org/x/text/encoding in golang.org/x/text v0.3.6</span><br></pre></td></tr></table></figure>

<p>运行时报段错误，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./dmtest</span></span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x93e04e]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">dm.(*Properties).GetTrimString(0x0, 0xa490a3, 0xc, 0x0, 0x0, 0x0, 0x0)</span><br><span class="line">        /opt/go1.14.3/src/dm/zv.go:80 +0x3e</span><br><span class="line">dm.(*DmConnector).mergeConfigs(0xc000014600, 0xa56519, 0x26, 0x108a8b0, 0x0)</span><br><span class="line">        /opt/go1.14.3/src/dm/n.go:766 +0x855</span><br><span class="line">dm.(*DmDriver).openConnector(0xc00005ae80, 0xa56519, 0x26, 0xa08c60, 0xc000106101, 0x7fca885b6038)</span><br><span class="line">        /opt/go1.14.3/src/dm/p.go:78 +0xaf</span><br><span class="line">dm.(*DmDriver).OpenConnector(0xc00005ae80, 0xa56519, 0x26, 0x7fca885b6038, 0xc00005ae80, 0x1, 0xc000045e88)</span><br><span class="line">        /opt/go1.14.3/src/dm/p.go:62 +0x3f</span><br><span class="line">database/sql.Open(0xa43c5f, 0x2, 0xa56519, 0x26, 0xc000070150, 0xa43c5f, 0x2)</span><br><span class="line">        /opt/go1.14.3/src/database/sql/sql.go:754 +0x114</span><br><span class="line">main.connect(0xa43c5f, 0x2, 0xa56519, 0x26, 0xc000045f48, 0x5cb1ba, 0xfaf920)</span><br><span class="line">        /home/japin/Codes/gocode/src/dmtest/main.go:40 +0x56</span><br><span class="line">main.main()</span><br><span class="line">        /home/japin/Codes/gocode/src/dmtest/main.go:19 +0x5d</span><br></pre></td></tr></table></figure>

<h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>从上面的错误代码可以猜测多半是由于 <code>dm/zv.go</code> 中的空指针导致的段错误。我们通过 gdb 来进行分析，重新编译程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -gcflags=all=<span class="string">&quot;-N -l&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>接着使用 gdb 调试发现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb ./dmtest</span></span><br><span class="line">0x0000000000ace1ae in dm.(*Properties).GetTrimString (g=0x0, key=..., def=..., ~r2=...) at /opt/go1.14.3/src/dm/zv.go:80</span><br><span class="line">80              value, ok := g.innerProps[strings.ToLower(key)]</span><br><span class="line">(gdb) p g</span><br><span class="line"><span class="meta">$</span><span class="bash">2 = (dm.Properties *) 0x0</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x0000000000ace1ae <span class="keyword">in</span> dm.(*Properties).GetTrimString (g=0x0, key=..., def=..., ~r2=...) at /opt/go1.14.3/src/dm/zv.go:80</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x0000000000a4f76f <span class="keyword">in</span> dm.(*DmConnector).mergeConfigs (c=0xc00007a000, dsn=..., ~r1=...) at /opt/go1.14.3/src/dm/n.go:766</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x0000000000a54f00 <span class="keyword">in</span> dm.(*DmDriver).openConnector (d=0xc000110e80, dsn=..., ~r1=0x0, ~r2=...) at /opt/go1.14.3/src/dm/p.go:78</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x0000000000a54b8d <span class="keyword">in</span> dm.(*DmDriver).OpenConnector (d=0xc000110e80, dsn=..., ~r1=..., ~r2=...) at /opt/go1.14.3/src/dm/p.go:62</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x00000000006c4b8b <span class="keyword">in</span> database/sql.Open (driverName=..., dataSourceName=..., ~r2=0x0, ~r3=...) at /opt/go1.14.3/src/database/sql/sql.go:754</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x0000000000b03183 <span class="keyword">in</span> main.connect (driverName=..., dataSourceName=..., ~r2=0x0, ~r3=...) at /home/japin/Codes/gocode/src/dmtest/main.go:40</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x0000000000b02cde <span class="keyword">in</span> main.main () at /home/japin/Codes/gocode/src/dmtest/main.go:19</span></span><br></pre></td></tr></table></figure>

<p>可以看到这是由于 <code>GetTrimString()</code> 函数中调用 <code>g.innerProps[strings.ToLower(key)]</code> 导致的，因为变量 <code>g</code> 为空。那么 <code>g</code> 是什么呢？通过查看上层调用栈 <code>#1</code>，可以得到这里的 <code>g</code> 其实就是 <code>GlobalProperties</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) up</span><br><span class="line">#1  0x0000000000a4f76f in dm.(*DmConnector).mergeConfigs (c=0xc00007a000, dsn=..., ~r1=...) at /opt/go1.14.3/src/dm/n.go:766</span><br><span class="line">766                     addressRemapStr = GlobalProperties.GetTrimString(AddressRemapKey, &quot;&quot;)</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>通过查找 <code>GlobalProperties</code>，我们发现它是在 <code>zzm.go</code> 的 <code>load()</code> 函数中初始化的，代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filePath: dm_svc.conf 文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(filePath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> filePath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>:</span><br><span class="line">                        filePath = os.Getenv(<span class="string">&quot;SystemRoot&quot;</span>) + <span class="string">&quot;\\system32\\dm_svc.conf&quot;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">                        filePath = <span class="string">&quot;/etc/dm_svc.conf&quot;</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        file, err := os.Open(filePath)</span><br><span class="line">        <span class="keyword">defer</span> file.Close()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fileReader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">        GlobalProperties = NewProperties()</span><br><span class="line">        <span class="keyword">var</span> groupProps *Properties</span><br><span class="line">        <span class="keyword">var</span> line <span class="keyword">string</span> <span class="comment">//dm_svc.conf读取到的一行</span></span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看到达梦的 driver 程序会查找 <code>dm_svc.conf</code> 配置文件，仅当配置文件存在时才会初始化 <code>GlobalProperties</code> 变量。该文件在 Linux 配置默认在 <code>/etc/dm_svc.conf</code>，然而我并没有这个文件，所以导致 <code>GlobalProperties</code> 为空，从而出现段错误。</p>
<p>在安装完达梦数据库之后，它默认会在 <code>/etc</code> 目录下创建 <code>dm_svc.conf</code> 文件，由于数据库服务器和开发环境不是同一环境，因此开发环境默认没有 <code>/etc/dm_svc.conf</code> 文件，解决办法就是创建一个 <code>/etc/dm_svc.conf</code> 文件。重新运行程序，一切正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./dmtest</span><br><span class="line">connect to &quot;dm://SYSDBA:123456789@10.9.10.184:5236&quot; succeed.</span><br><span class="line">Insert data succeed: &#123;0xc000688080 0xc00009e000&#125;</span><br><span class="line">1       world</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在查看达梦数据库提供的 driver 时，我发现达梦一个很有意思的地方，看下图：</p>
<img src="/2021/07/golang-access-dm-database/dm_driver_directory.png" class="">

<p>你是想做混淆吗？但是代码又放在那儿的。如果不是做混淆，那么还是建议取个有意义的文件名，毕竟是要自己维护的。</p>
<p>上述问题可能并不是特别难定位，但是从中还是可以看出一些问题。</p>
<ol>
<li>国产软件在健壮性方面还是有待加强。</li>
<li>文档不够清晰。</li>
<li>代码规范有待提高（当然这可能就是人家的特色）。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://eco.dameng.com/docs/zh-cn/app-dev/go-go.html">https://eco.dameng.com/docs/zh-cn/app-dev/go-go.html</a><br>[2] <a href="https://golang.org/doc/gdb">https://golang.org/doc/gdb</a></p>
<div class="just-for-fun">
笑林广记 - 有理

<p>一官最贪，一日拘两造对鞫，原告馈以五十金，被告闻知，加倍贿托。<br>及审时，不问情由，抽签竟打原告。<br>原告将手作五数势曰：“小的是有理的。”<br>官亦以手覆曰：“奴才，你虽有理。”<br>又以一手仰曰：“他比你更有理哩！”</p>
</div>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>达梦</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang cron v3 定时任务</title>
    <url>/2021/08/golang-cron/</url>
    <content><![CDATA[<p>最近由于工作原因，需要在 Golang 中创建一个定时任务来执行一些工作。在 Linux 中，我们可以通过 crontab 来实现这个功能；在 Golang 中也有一个名为 <a href="https://github.com/robfig/cron">cron</a> 的包，通过它我们可以很方便地在 Golang 中实现定时任务，本文简要记录了 <a href="https://github.com/robfig/cron">cron</a> 的使用方法。</p>
<img src="/2021/08/golang-cron/crontab-guru.jpg" class="">

<span id="more"></span>

<h2 id="最小示例"><a href="#最小示例" class="headerlink" title="最小示例"></a>最小示例</h2><p>首先我们创建一个最小示例来看看 <code>cron</code> 是如何工作的，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir crontest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> crontest &amp;&amp; go mod init crontest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch main.go</span></span><br></pre></td></tr></table></figure>

<p>文件 <code>main.go</code> 中的内容如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/robfig/cron/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := cron.New()</span><br><span class="line"></span><br><span class="line">    c.AddFunc(<span class="string">&quot;*/1 * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Execute cron task at %s\n&quot;</span>, time.Now().String())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    c.Start()</span><br><span class="line">	<span class="keyword">defer</span> c.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们使用 <code>go build</code> 来编译，并运行该程序，可以得到如下输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./crontest</span></span><br><span class="line">Execute cron task at 2021-08-06 20:29:00.000304257 +0800 CST m=+12.310669667</span><br><span class="line">Execute cron task at 2021-08-06 20:30:00.00037062 +0800 CST m=+72.310736162</span><br><span class="line">Execute cron task at 2021-08-06 20:31:00.000493635 +0800 CST m=+132.310859212</span><br><span class="line">Execute cron task at 2021-08-06 20:32:00.000351753 +0800 CST m=+192.310717288</span><br><span class="line">Execute cron task at 2021-08-06 20:33:00.000309421 +0800 CST m=+252.310674994</span><br><span class="line">Execute cron task at 2021-08-06 20:34:00.000350467 +0800 CST m=+312.310716002</span><br><span class="line">Execute cron task at 2021-08-06 20:35:00.000311664 +0800 CST m=+372.310677063</span><br><span class="line">Execute cron task at 2021-08-06 20:36:00.000345813 +0800 CST m=+432.310711346</span><br><span class="line">Execute cron task at 2021-08-06 20:37:00.000545952 +0800 CST m=+492.310911501</span><br></pre></td></tr></table></figure>

<p>我们通过 <code>cron.New()</code> 来创建一个 cron 作业运行器，接着，通过 <code>c.AddFunc()</code> 函数向 cron 作业运行器中添加一个按指定时间运行的任务，该函数的第一个参数指定了定时表达式，第二个参数则是由匿名函数提供的具体需要完成的任务，在这里我们仅仅是输出一条日志。最后，调用 <code>c.Start()</code> 函数启动 cron 调度程序。</p>
<p>默认情况下，所有解释和调度都在机器的本地时区 (time.Local) 中完成。我们也可以在构建时指定不同的时区：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cron.New(cron.WithLocation(time.UTC))</span><br></pre></td></tr></table></figure>

<h3 id="定时表达式"><a href="#定时表达式" class="headerlink" title="定时表达式"></a>定时表达式</h3><p>定时表达式从左到由分别是 <code>Minutes</code>，<code>Hours</code>，<code>Day of month</code>，<code>Month</code> 和 <code>Day of week</code>。</p>
<table>
<thead>
<tr>
<th>域名</th>
<th>必须</th>
<th>允许的值</th>
<th>允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td>Minutes</td>
<td>Yes</td>
<td>0-59</td>
<td>* / , -</td>
</tr>
<tr>
<td>Hours</td>
<td>Yes</td>
<td>0-23</td>
<td>* / , -</td>
</tr>
<tr>
<td>Day of month</td>
<td>Yes</td>
<td>1-31</td>
<td>* / , - ?</td>
</tr>
<tr>
<td>Month</td>
<td>Yes</td>
<td>1-12 or JAN-DEC</td>
<td>* / , -</td>
</tr>
<tr>
<td>Day of week</td>
<td>Yes</td>
<td>0-6 or SUN-SAT</td>
<td>* / , - ?</td>
</tr>
</tbody></table>
<p><code>Month</code> 和 <code>Day of Week</code> 的值不区分大小写，例如 <code>SUN</code>，<code>Sun</code> 和 <code>sun</code> 是一样的。</p>
<ul>
<li><code>*</code> - 表示 cron 表达式将匹配字段的所有值；例如，在第 5 个字段（月）中使用星号表示每个月。</li>
<li><code>/</code> - 表示描述范围的增量。例如，第 1 个字段（分钟）中的 <code>3-59/15</code> 将表示一小时的第 3 分钟，此后每 15 分钟一次。</li>
<li><code>,</code> - 用于分隔列表中的项目。例如，在第 5 个字段（星期几）中使用 <code>MON</code>，<code>WED</code>，<code>FRI</code> 表示星期一、星期三和星期五。</li>
<li><code>-</code> - 用于定义范围。例如，<code>9-17</code> 表示上午 9 点到下午 5 点之间的每小时。</li>
<li><code>?</code> - 可以使用问号代替 <code>*</code> 以将月中的某天或一周中的某天留空。</li>
</ul>
<h3 id="预定义时间表"><a href="#预定义时间表" class="headerlink" title="预定义时间表"></a>预定义时间表</h3><p><a href="https://github.com/robfig/cron">cron</a> 提供了多个预定义计划之一来代替 cron 表达式。</p>
<table>
<thead>
<tr>
<th>预定义值</th>
<th>描述</th>
<th>等同于</th>
</tr>
</thead>
<tbody><tr>
<td>@yearly (or @annually)</td>
<td>每年的 1 月 1 日午夜运行一次</td>
<td>0 0 1 1 *</td>
</tr>
<tr>
<td>@monthly</td>
<td>每月的第一天午夜运行一次</td>
<td>0 0 1 * *</td>
</tr>
<tr>
<td>@weekly</td>
<td>每周周六/周日之间的午夜运行一次</td>
<td>0 0 * * 0</td>
</tr>
<tr>
<td>@daily (or @midnight)</td>
<td>每天午夜运行一次</td>
<td>0 0 * * *</td>
</tr>
<tr>
<td>@hourly</td>
<td>每小时开始时运行一次</td>
<td>0 * * * *</td>
</tr>
</tbody></table>
<p>由于添加 Seconds 是对标准 cron 规范最常见的修改，因此 cron 提供了一个内置函数来执行此操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cron.New(cron.WithSeconds())</span><br></pre></td></tr></table></figure>

<p>例如，我们将上述代码进行修改，使其支持秒级别的定时任务，代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := cron.New(cron.WithSeconds())</span><br><span class="line"></span><br><span class="line">    c.AddFunc(<span class="string">&quot;*/5 * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Execute cron task at %s\n&quot;</span>, time.Now().String())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    c.Start()</span><br><span class="line">	<span class="keyword">defer</span> c.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./crontest</span><br><span class="line">Execute cron task at 2021-08-06 21:29:10.000409533 +0800 CST m=+1.862999190</span><br><span class="line">Execute cron task at 2021-08-06 21:29:15.000346401 +0800 CST m=+6.862936200</span><br><span class="line">Execute cron task at 2021-08-06 21:29:20.000336872 +0800 CST m=+11.862926638</span><br><span class="line">Execute cron task at 2021-08-06 21:29:25.00041627 +0800 CST m=+16.863006019</span><br><span class="line">Execute cron task at 2021-08-06 21:29:30.000354942 +0800 CST m=+21.862944684</span><br><span class="line">Execute cron task at 2021-08-06 21:29:35.000375026 +0800 CST m=+26.862964792</span><br></pre></td></tr></table></figure>

<h2 id="使用-Job-来创建定时任务"><a href="#使用-Job-来创建定时任务" class="headerlink" title="使用 Job 来创建定时任务"></a>使用 Job 来创建定时任务</h2><p>上面我们通过 <code>AddFunc()</code> 函数来创建了一个定时任务，实际上通过查看 <a href="https://github.com/robfig/cron">cron</a> 的源码，我们可以发现其本质也是封装成一个 Job 来调用，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FuncJob is a wrapper that turns a func() into a cron.Job</span></span><br><span class="line"><span class="keyword">type</span> FuncJob <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncJob)</span> <span class="title">Run</span><span class="params">()</span></span> &#123; f() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddFunc adds a func to the Cron to be run on the given schedule.</span></span><br><span class="line"><span class="comment">// The spec is parsed using the time zone of this Cron instance as the default.</span></span><br><span class="line"><span class="comment">// An opaque ID is returned that can be used to later remove it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cron)</span> <span class="title">AddFunc</span><span class="params">(spec <span class="keyword">string</span>, cmd <span class="keyword">func</span>()</span>) <span class="params">(EntryID, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.AddJob(spec, FuncJob(cmd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们尝试通过 <code>AddJob()</code> 的方式来创建定时任务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/robfig/cron/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job1 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Job2 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Job1)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Run job1 at %s\n&quot;</span>, time.Now().String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this Job2)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Run job2 at %s\n&quot;</span>, time.Now().String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := cron.New(cron.WithSeconds())</span><br><span class="line"></span><br><span class="line">    c.AddFunc(<span class="string">&quot;*/5 * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Execute cron task at %s\n&quot;</span>, time.Now().String())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    c.AddJob(<span class="string">&quot;*/10 * * * * *&quot;</span>, Job1&#123;&#125;)</span><br><span class="line">    c.AddJob(<span class="string">&quot;*/30 * * * * *&quot;</span>, Job2&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    c.Start()</span><br><span class="line">    <span class="keyword">defer</span> c.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了两个结构体 <code>Job1</code> 和 <code>Job2</code>，为了满足 cron 的需要，它们必须实现 <code>Run()</code> 这个接口。在 <code>Run()</code> 接口中我们输出两个日志信息，这个就是我们定时任务所做的全部工作，然后通过 <code>c.AddJob()</code> 添加 Job 即可。程序执行过程如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./crontest</span></span><br><span class="line">Execute cron task at 2021-08-06 22:08:15.000392468 +0800 CST m=+2.864996300</span><br><span class="line">Run job1 at 2021-08-06 22:08:20.000339425 +0800 CST m=+7.864943177</span><br><span class="line">Execute cron task at 2021-08-06 22:08:20.000494832 +0800 CST m=+7.865098624</span><br><span class="line">Execute cron task at 2021-08-06 22:08:25.000372842 +0800 CST m=+12.864976583</span><br><span class="line">Execute cron task at 2021-08-06 22:08:30.000453832 +0800 CST m=+17.865057603</span><br><span class="line">Run job2 at 2021-08-06 22:08:30.000418619 +0800 CST m=+17.865022319</span><br><span class="line">Run job1 at 2021-08-06 22:08:30.000472417 +0800 CST m=+17.865076204</span><br><span class="line">Execute cron task at 2021-08-06 22:08:35.000387698 +0800 CST m=+22.864991512</span><br><span class="line">Run job1 at 2021-08-06 22:08:40.000350366 +0800 CST m=+27.864954043</span><br><span class="line">Execute cron task at 2021-08-06 22:08:40.000375622 +0800 CST m=+27.864979303</span><br><span class="line">Execute cron task at 2021-08-06 22:08:45.000366659 +0800 CST m=+32.864970478</span><br><span class="line">Run job1 at 2021-08-06 22:08:50.000284729 +0800 CST m=+37.864888549</span><br><span class="line">Execute cron task at 2021-08-06 22:08:50.000341062 +0800 CST m=+37.864944800</span><br></pre></td></tr></table></figure>

<p>最后，在推荐一个简单快捷的 crontab 编辑工具 [crontab guru][<a href="https://crontab.guru/]%E3%80%82">https://crontab.guru/]。</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://pkg.go.dev/github.com/robfig/cron/v3">https://pkg.go.dev/github.com/robfig/cron/v3</a></p>
<div class="just-for-fun">
笑林广记 - 取金

<p>一官出朱票，取赤金二锭，铺户送讫，当堂领价。<br>官问：“价值几何？”<br>铺家曰：“平价该若干，今系老爷取用，只领半价可也。”<br>官顾左右曰：“这等，发一锭还他。”<br>发金后，铺户仍候领价。<br>官曰：“价已发过了。”<br>铺家曰：“并未曾发。”<br>官怒曰：“刁奴才，你说只领半价，故发一锭还你，抵了一半价钱，本县不曾亏你，如何胡缠？快撵出去！”</p>
</div>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gtags 忽略不相关的目录</title>
    <url>/2021/06/gtags-exclude-some-directories/</url>
    <content><![CDATA[<p>我在 Emacs 中使用 gtags (GNU global source code tag system) 来作为代码导航的基本工具，它默认标记根目录及其子目录，但是有一些子目录其实我并不想要被标记。本文简要记录一下如何告知 gtags 忽略某些目录或文件。</p>
<span id="more"></span>

<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>gtags 默认提供了一个配置文件，我们可以通过这个配置文件来进行定制。为了不影响其他用户，建议拷贝到各自用户的家目录下进行设置，如下所示。</p>
<p>Linux 系统一般为 <code>/usr/local/share/gtags/gtags.conf</code>（MacOS 系统在 <code>/usr/local/etc/gtags.conf</code>），我们将其拷贝到用户家目录下，并命名为 <code>.globalrc</code>，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- Linux</span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /usr/<span class="built_in">local</span>/share/gtags/gtags.conf ~/.globalrc</span></span><br><span class="line">-- MacOS</span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /usr/<span class="built_in">local</span>/etc/gtags.conf ~/.globalrc</span></span><br></pre></td></tr></table></figure>

<p>接着，我们在该文件中搜索 <code>skip</code>，然后加上我们想要忽略的目录或文件即可，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">common:\</span><br><span class="line">    :skip=Debug/,HTML/,HTML.pub/,tags,TAGS,ID,y.tab.c,y.tab.h,gtags.files,cscope.files,cscope.out,cscope.po.out,cscope.in.out,SCCS/,RCS/,CVS/,CVSROOT/,&#123;arch&#125;/,autom4te.cache/,*.orig,*.rej,*.bak,*~,#*#,*.swp,*.tmp,*_flymake.*,*_flymake,*.o,*.a,*.so,*.lo,*.zip,*.gz,*.bz2,*.xz,*.lzh,*.Z,*.tgz,*.min.js,*min.css:</span><br></pre></td></tr></table></figure>

<p>该项使用逗号作为分隔符，支持正则表达式。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>上述方法稍微复杂，针对不同的项目，配置起来比较繁琐，最近在看到 <a href="http://peter.eisentraut.org/">Peter Eisentraut</a> 关于 <a href="http://peter.eisentraut.org/blog/2016/07/20/using-gnu-global-with-postgresql">PostgreSQL 中使用 GNU Global 的文章</a>之后，才发现原来还可以这样优雅的解决。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git ls-files &gt; gtags.files  <span class="comment"># Git 托管的源码目录</span></span><br><span class="line">$ gtags</span><br></pre></td></tr></table></figure>

<p>我们利用 git 的特性来获取到所有的文件，然后将其保存到 <code>gtags.files</code> 文件中，随后在执行 <code>gtags</code> 命令来生成符号信息。这种方式也存在一些缺点：</p>
<ol>
<li>它不能为自动生成的文件提供导航；</li>
<li>每次拉取新代码时，都需要重复执行 <code>git ls-files &gt; gtags.files &amp;&amp; gtags</code> 命令；</li>
<li>新增的文件（尚未纳入 git 托管）同样不能提供导航。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://stackoverflow.com/questions/42315741/how-gtags-exclude-some-specific-subdirectories">https://stackoverflow.com/questions/42315741/how-gtags-exclude-some-specific-subdirectories</a><br>[2] <a href="http://peter.eisentraut.org/blog/2016/07/20/using-gnu-global-with-postgresql">http://peter.eisentraut.org/blog/2016/07/20/using-gnu-global-with-postgresql</a></p>
<div class="just-for-fun">
笑林广记 - 帝怕妒妇

<p>房夫人性妒悍，玄龄惧之，不敢置一妾。<br>太宗命后召夫人，告以媵妾之流，今有定制，帝将有美女之赐。<br>夫人执意不回，帝遣斟以恐之，曰：“若然，是抗旨矣，当饮此鸠。”<br>夫人一举而尽，略无留难。曰：“我见尚怕，何况于玄龄？”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>gtags</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习 Emacs</title>
    <url>/2019/03/how-to-learn-emacs/</url>
    <content><![CDATA[<img src="/2019/03/how-to-learn-emacs/How-to-Learn-Emacs-v2-Large.png" class="" title="How to Learn Emacs">


<p><a href="http://sachachua.com/blog/2013/05/how-to-learn-emacs-a-hand-drawn-one-pager-for-beginners/">上图</a>来自于 <a href="http://sachachua.com/blog/">Sacha Chua</a> 的博客。她的博客记录许多关于学习 Emacs 的资源。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>列存数据库 cstore_fdw 入门</title>
    <url>/2018/09/introduction-cstore-fdw-columnar-store/</url>
    <content><![CDATA[<p>Cstore_fdw 是 Citus Data 开发的一款开放源码的 PostgreSQL 列存扩展插件。列存储在数据批量导入的分析场景能够提供更好的性能。Cstore_fdw 通过只读取磁盘上相关的列数据来提升性能，同时，由于每列的数据来自同一个域，因此更利于数据压缩，cstore_fdw 提供 6~10 倍的数据压缩能力，从而减小了对磁盘存储的需求。</p>
<p>Cstore_fdw 采用 Optimized Row Columnar (ORC) 格式作为其数据的物理存储格式。ORC 优化了 Facebook 的 RCFile 存储格式，并具有以下优点：</p>
<ul>
<li>压缩 (Compression) - 大约减少了 2~4 倍的内存和磁盘存储空间。易于扩展以支持不同的编码。</li>
<li>列投影 (Column Projections) - 仅仅读取与该查询有关的数据列，提高了 I/O 效率。</li>
<li>跳跃索引 (Skip Indexes) - 为每个行组 (Row Groups) 存储其最大值和最小值，并利用他们来跳过不相关的数据行。</li>
</ul>
<p>除此之外，cstore_fdw 使用了 PostgreSQL 的数据类型和 fdw API 编程接口，这样做的好处有以下几点：</p>
<ul>
<li>支持 40+ 的 PostgreSQL 数据类型，用户也可以创建并使用新的类型。</li>
<li>统计信息收集，PostgreSQL 使用这些统计信息来评估不同的查询计划并选择最优查询计划的来执行。</li>
<li>配置简单，用户只需要创建外部表并导入数据，之后就可以使用 SQL 进行查询。</li>
</ul>
<span id="more"></span>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Cstore_fdw 依赖 protobuf-c 来序列化和反序列化表的元数据信息，因此需要先安装 protobuf-c 套件 (Ubuntu 平台)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install protobuf-c-compiler libprotobuf-c-dev</span></span><br></pre></td></tr></table></figure>

<p>首先，编译安装 PostgreSQL 数据库，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://ftp.postgresql.org/pub/<span class="built_in">source</span>/v9.3.24/postgresql-9.3.24.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xf postgresql-9.3.24.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> postgresql-9.3.24</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/home/postgres/postgresql-9.3.24/Debug --enable-debug --enable-cassert CFLAGS=<span class="string">&#x27;-O0 -g&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Debug</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;<span class="string">END &gt;pg-9.3.24.env</span></span></span><br><span class="line">export PGHOME=$PWD</span><br><span class="line">export PGDATA=\$PGHOME/pgdata</span><br><span class="line">export PATH=\$PGHOME/bin:\$PATH</span><br><span class="line">export LD_LIBRARY_PATH=\$PGHOME/lib:\$LD_LIBRARY_PATH</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>为了使用方便，我将 PostgreSQL 的环境变量配置到了 pg-9.3.24.env 文件中，当需要使用是只需要 source 以下即可。<br>接着，编译安装 cstore_fdw 插件，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/citusdata/cstore_fdw</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> cstore_fdw</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> . /path/to/pg-9.3.24.env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> Cstore_fdw 支持 PostgreSQL 9.3, 9.4, 9.5, 9.6 和 10 的版本，更早的版本则不支持。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在使用 cstore_fdw 之前，我们需要将他添加到 postgresql.conf 文件的 shared_preload_libraries 中，并重启 PostgreSQL 数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared_preload_libraries = &#x27;cstore_fdw&#x27; # (change requires restart)</span><br></pre></td></tr></table></figure>

<p>以下四个选项可以在创建 cstore 外部表的时候指定：</p>
<ul>
<li>filename (可选) - 存放列存表数据的绝对路径，如果没有指定该选项，那么 cstore_fdw 则采用默认的 $PGHOME/cstore_fdw 来存储列存表数据。如果为该参数指定了值，则使用该值作为前缀来存储列存表数据信息。例如，当指定的 filename 值为 /cstore_fdw/my_table，那么 cstore_fdw 将使用 /cstore_fdw/my_table 来存储列存表用户数据，同时，使用 /cstore_fdw/my_table.footer 来存储列存表的元数据信息。</li>
<li>compression (可选) - 该参数用于指定用户数据的压缩算法，目前仅支持 none 和 pglz 两个值，即不压缩或者使用 pglz 压缩算法进行压缩，默认值为 none。</li>
<li>stripe_row_count (可选) - 该参数指定每个 stripe 中行记录数，默认值为 150000。该值越小，加载数据或者查询时使用的内存也就越小，相反，其性能也就越低。</li>
<li>block_row_count (可选) - 该参数指定每个列数据块 (column block) 中的行记录数，默认为 10000。Cstore_fdw 压缩数据、创建跳跃索引以及磁盘读取时都是以块 (block) 为最小单元。该值越大，则利用数据压缩，并可以减少磁盘读取的次数量，然而，这将影响到跳过不相关的数据块的概率。</li>
</ul>
<p>Cstore_fdw 提供了两种方式用于向其导入数据：</p>
<ul>
<li>使用 <code>COPY</code> 命令将文件、程序或者标准输入中导入数据；</li>
<li>使用 <code>INSERT INTO cstore_table SELECT ...</code> 语法从其他表导入数据。</li>
</ul>
<p>我们可以使用 <code>ANALYZE</code> 命令收集列存表的统计信息，从而帮助优化器选择最优的查询计划。</p>
<p><strong>注意：</strong> Cstore_fdw 目前并不支持使用 <code>UPDATE</code> 或 <code>DELETE</code> 命令来对表进行更新。同样，他也不支持单条记录的插入，这是由于每次导入数据都会形成至少一个数据块，若是支持单条记录插入，那么每个 <code>INSERT</code> 命令插入一条纪律，将导致数据块过多从而影响性能，为此，Cstore_fdw 不支持单条记录的插入。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>为了展示 cstore_fdw，我们可以使用官方给出的测试数据用以验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://examples.citusdata.com/customer_reviews_1998.csv.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget http://examples.citusdata.com/customer_reviews_1999.csv.gz</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gzip -d customer_reviews_1998.csv.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gzip -d customer_reviews_1999.csv.gz</span></span><br></pre></td></tr></table></figure>

<p>接着初始化数据库并修改 <code>shared_preload_libraries</code> 参数，然后启动并登陆到 postgres 数据库，然后执行下面的命令创建列存储外部表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在首次安装完成之后加载 cstore_fdw 插件</span><br><span class="line">CREATE EXTENSION cstore_fdw;</span><br><span class="line"></span><br><span class="line">-- 创建服务对象</span><br><span class="line">CREATE SERVER cstore_server FOREIGN DATA WRAPPER cstore_fdw;</span><br><span class="line"></span><br><span class="line">-- 创建外部表</span><br><span class="line">CREATE FOREIGN TABLE customer_reviews</span><br><span class="line">(</span><br><span class="line">    customer_id TEXT,</span><br><span class="line">    review_date DATE,</span><br><span class="line">    review_rating INTEGER,</span><br><span class="line">    review_votes INTEGER,</span><br><span class="line">    review_helpful_votes INTEGER,</span><br><span class="line">    product_id CHAR(10),</span><br><span class="line">    product_title TEXT,</span><br><span class="line">    product_sales_rank BIGINT,</span><br><span class="line">    product_group TEXT,</span><br><span class="line">    product_category TEXT,</span><br><span class="line">    product_subcategory TEXT,</span><br><span class="line">    similar_product_ids CHAR(10)[]</span><br><span class="line">)</span><br><span class="line">SERVER cstore_server</span><br><span class="line">OPTIONS(compression &#x27;pglz&#x27;);</span><br></pre></td></tr></table></figure>

<p>最后，我们使用 <code>COPY</code> 命令导入数据到列存储外部表中，并使用 <code>ANALYZE</code> 命令收集统计信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY customer_reviews FROM &#x27;/path/to/customer_reviews_1998.csv&#x27; WITH CSV;</span><br><span class="line">COPY customer_reviews FROM &#x27;/path/to/customer_reviews_1999.csv&#x27; WITH CSV;</span><br></pre></td></tr></table></figure>

<p>在执行完上述操作之后，我们就可以在列存表上执行查询操作了。例如，执行下面的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查找特定客户在 1998 年对 Dune 系列所做的所有评论</span><br><span class="line">SELECT</span><br><span class="line">    customer_id, review_date, review_rating, product_id, product_title</span><br><span class="line">FROM</span><br><span class="line">    customer_reviews</span><br><span class="line">WHERE</span><br><span class="line">    customer_id =&#x27;A27T7HVDXA3K2A&#x27; AND</span><br><span class="line">    product_title LIKE &#x27;%Dune%&#x27; AND</span><br><span class="line">    review_date &gt;= &#x27;1998-01-01&#x27; AND</span><br><span class="line">    review_date &lt;= &#x27;1998-12-31&#x27;;</span><br><span class="line"></span><br><span class="line">-- 我们是否有书的标题长度和评论评级之间的相关性？</span><br><span class="line">SELECT</span><br><span class="line">    width_bucket(length(product_title), 1, 50, 5) title_length_bucket,</span><br><span class="line">    round(avg(review_rating), 2) AS review_average,</span><br><span class="line">    count(*)</span><br><span class="line">FROM</span><br><span class="line">   customer_reviews</span><br><span class="line">WHERE</span><br><span class="line">    product_group = &#x27;Book&#x27;</span><br><span class="line">GROUP BY</span><br><span class="line">    title_length_bucket</span><br><span class="line">ORDER BY</span><br><span class="line">    title_length_bucket;</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>在卸载 cstore_fdw 之前，我们需要删除所有的 cstore 列存表、server 和扩展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP FOREIGN TABLE customer_reviews;</span><br><span class="line">DROP SERVER cstore_server;</span><br><span class="line">DROP EXTENSION cstore_fds;</span><br></pre></td></tr></table></figure>

<p>Cstore_fdw 会自动的创建目录来存储列存相关的数据，我们可以执行下面的命令来删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf <span class="variable">$PGDATA</span>/cstore_fdw</span></span><br></pre></td></tr></table></figure>

<p>注意，上面给出的是 cstore_fdw 的默认路径，若在建表的时候指定了 filename，其位置可能不同。</p>
<p>此外，别忘了将 postgresql.conf 文件中 <code>shared_preload_libraries</code> 中的 <code>cstore_fdw</code> 移除掉。最后，我们可以到 cstore_fdw 的源码目录执行 <code>make uninstall</code> 删除已安装的 cstore_fdw 相关的文件。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://github.com/citusdata/cstore_fdw">https://github.com/citusdata/cstore_fdw</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>cstore_fdw</tag>
        <tag>列存</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse 导入证书文件</title>
    <url>/2019/01/import-certificate-into-eclipse/</url>
    <content><![CDATA[<p>现在越来越多的网站采用 HTTPS 协议，今天就遇到一个关于 HTTPS 证书的问题，服务器端采用 HTTPS 加密传输，而证书是使用的自签名证书，因此客户端开发时需要将其导入到 Eclipse 中才能通过验证（客户端采用 Java 开发）。Eclipse 采用 keystore 来管理证书，可以利用工具 <code>keytool</code> 来管理证书文件，本文主要记录 Eclipse 证书管理的基本使用，以及使用自签名证书的格式问题。</p>
<span id="more"></span>

<h3 id="导入-SSL-证书"><a href="#导入-SSL-证书" class="headerlink" title="导入 SSL 证书"></a>导入 SSL 证书</h3><p>我登陆到服务器取下了服务端使用的 SSL 证书（一个名为 ssl.pem 的文件），随后通过 <code>keytool</code> 将其导入到 Eclipse 中，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ keytool -import -alias &lt;provide_an_alias&gt; -file &lt;certificate_file&gt; -keysotre &lt;your_path_to_jre&gt;/lib/security/cacerts</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> <code>&lt; &gt;</code> 中的内容需要根据实际情况填写。</p>
<p>然而我执行时出现了如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool error: java.lang.Exception: Input not an X.509 certificate</span><br><span class="line">java.lang.Exception: Input not an X.509 certificate</span><br><span class="line">        at sun.security.tools.KeyTool.addTrustedCert(KeyTool.java:1913)</span><br><span class="line">        at sun.security.tools.KeyTool.doCommands(KeyTool.java:818)</span><br><span class="line">        at sun.security.tools.KeyTool.run(KeyTool.java:172)</span><br><span class="line">        at sun.security.tools.KeyTool.main(KeyTool.java:166)</span><br></pre></td></tr></table></figure>

<h3 id="证书格式转换"><a href="#证书格式转换" class="headerlink" title="证书格式转换"></a>证书格式转换</h3><p>从上面的错误结果可以看到证书格式不是标准的 X.509 格式，于是我查看了一下 ssl.pem 文件的内容，其格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">BASE64 ENCODING INFORMATION</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">BASE64 ENCODING INFORMATION</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>这与 X.509 的证书格式不同，因此出现上述问题。X.509 证书的格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">BASE64 ENCODING CERTIFICATE INFORMATION</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>因此，我们需要将 ssl.pem 格式的证书转换为 X.509 格式，我们利用 openssl 来实现，其命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -in ssl.pem -text</span><br></pre></td></tr></table></figure>

<p>此外，我们可以直接将 ssl.pem 文件中的 <code>-----BEGIN CERTIFICATE-----</code> 到 <code>-----END CERTIFICATE-----</code> 之间的内容拷贝出来即可。</p>
<p>现在我们再次使用 <code>keytool -import</code> 命令导入证书即可。</p>
<p><strong>备注：</strong></p>
<ol>
<li>当 <code>keytool</code> 提示输入密码时，请输入：<code>changeit</code>。这应该是默认的。</li>
<li>当 <code>keytool</code> 询问是否信任该证书时，请输入：<code>yes</code>。默认为 <code>on</code>。</li>
</ol>
<h3 id="删除证书"><a href="#删除证书" class="headerlink" title="删除证书"></a>删除证书</h3><p>当我们不再需要这个自签名证书时，可以通过如下命令将其从 keystore 中删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ keytool -delete -alias &lt;cert_alias&gt; -keystore &lt;your_path_to_jre&gt;/lib/security/cacerts</span><br></pre></td></tr></table></figure>

<p>我们也可以使用下面的命令查看 keystore 中证书的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ keytool -list -v -keystore &lt;your_path_to_jre&gt;/lib/security/cacerts</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://stackoverflow.com/questions/684081/importing-ssl-certificate-into-eclipse">Importing SSL certificate into eclipse</a><br>[2] <a href="https://stackoverflow.com/questions/9889669/error-importing-ssl-certificate-not-an-x-509-certificate">Error importing SSL certificate not an X509 certificate</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 页码设置</title>
    <url>/2019/03/latex-page-numbering/</url>
    <content><![CDATA[<p>默认情况下，LaTeX 会在每个页面的底部生成一个页码编号，即使是标题页也是如此。通常情况下，我们不需要在标题页输出页码编号，而且目录页一般也会采用罗马数字的形式给出页码，而正文内容则以阿拉伯数字的形式给出页码编号。本文接下来介绍了 LaTeX 中基本的页码设置。</p>
<span id="more"></span>

<h2 id="页码设置相关的命令"><a href="#页码设置相关的命令" class="headerlink" title="页码设置相关的命令"></a>页码设置相关的命令</h2><p>在 LaTex 中，与页码和页面设置相关的命令有 <code>\pagestyle&#123;type&#125;</code>，<code>\thispagestyle&#123;type&#125;</code>，<code>setcounter&#123;page&#125;&#123;number&#125;</code> 和 <code>\pagenumbering&#123;style&#125;</code>。</p>
<p>其中 <code>\pagestyle&#123;type&#125;</code> 和 <code>\thispagestyle&#123;type&#125;</code> 命令用于设置页面样式 (页眉和页脚)。<code>\pagestyle&#123;type&#125;</code> 和 <code>\thispagestyle&#123;type&#125;</code> 的主要区别在于 <code>\pagestyle&#123;type&#125;</code> 对后续所有页面都有效，而 <code>\thispagestyle&#123;type&#125;</code> 仅仅对当前页面有效。在 LaTeX 中，默认提供了以下五种页面样式：</p>
<ul>
<li><strong>empty</strong> - 没有页眉和页脚</li>
<li><strong>plain</strong> - 没有页眉，页脚包含一个居中的页码</li>
<li><strong>headings</strong> - 没有页脚，页眉包含章/节或者字节的名字和页码</li>
<li><strong>myheadings</strong> - 没有页脚，页眉包含有页码</li>
</ul>
<p>默认情况下，页码从第一页开始 (通常是包含标题页的) 并且以阿拉伯数字形式显示 (例如：1，2，3, … )。页码的编号也可以通过 <code>\setcounter&#123;page&#125;&#123;number&#125;</code> 命令手动设置，需要注意的是，手动设置可能会导致重复的页码出现。</p>
<p><code>\pagenumbering&#123;style&#125;</code> 命令则用于改变页码的显示风格。LaTeX 中页码风格包含以下五类：</p>
<ul>
<li><strong>arabic</strong> - 阿拉伯数字</li>
<li><strong>roman</strong> - 小写的罗马数字</li>
<li><strong>Roman</strong> - 大写的罗马数字</li>
<li><strong>alph</strong> - 小写的字符形式</li>
<li><strong>Alph</strong> - 大写的字符形式</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;fontspec, xunicode, xlextra&#125;</span><br><span class="line">\usepackage&#123;xeCJK&#125;</span><br><span class="line"></span><br><span class="line">\title&#123;\LaTeX 页码设置&#125;</span><br><span class="line">\author&#123;Japinli&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">\thispagestyle&#123;empty&#125; % 当前页不显示页码</span><br><span class="line">\newpage</span><br><span class="line"></span><br><span class="line">\pagestyle&#123;headings&#125;</span><br><span class="line">\setcounter&#123;page&#125;&#123;1&#125;</span><br><span class="line">\pagenumbering&#123;Roman&#125;</span><br><span class="line"></span><br><span class="line">\section*&#123;前言&#125;</span><br><span class="line">学习如何在\LaTeX 中设置页码。</span><br><span class="line">\newpage</span><br><span class="line"></span><br><span class="line">\tableofcontents</span><br><span class="line">\newpage</span><br><span class="line"></span><br><span class="line">\setcounter&#123;page&#125;&#123;1&#125;</span><br><span class="line">\pagenumbering&#123;arabic&#125;</span><br><span class="line"></span><br><span class="line">\section&#123;页码风格&#125;</span><br><span class="line"></span><br><span class="line">\LaTeX 中包含五种页码风格，分别是\emph&#123;arabic&#125;，\emph&#123;roman&#125;，\emph&#123;Roman&#125;，</span><br><span class="line">\emph&#123;alph&#125;和\emph&#123;Alph&#125;。</span><br><span class="line"></span><br><span class="line">\section&#123;页码风格说明&#125;</span><br><span class="line"></span><br><span class="line">\emph&#123;arabic&#125;代表阿拉伯数字类型。</span><br><span class="line"></span><br><span class="line">\emph&#123;roman&#125;代表小写的罗马数字类型。</span><br><span class="line"></span><br><span class="line">\emph&#123;Roman&#125;代表大写的罗马数字类型。</span><br><span class="line"></span><br><span class="line">\emph&#123;alph&#125;代表小写的字符类型。</span><br><span class="line"></span><br><span class="line">\emph&#123;Alph&#125;代表大写的字符类型。</span><br><span class="line"></span><br><span class="line">\section&#123;页码风格设置&#125;</span><br><span class="line"></span><br><span class="line">为了改变页码的风格，可以使用\emph&#123;\textbackslash pagenumbering\&#123;sytle\&#125;&#125;</span><br><span class="line">命令设置。</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 中的 JOIN 策略及其性能</title>
    <url>/2021/07/join-stragegies-and-performance-in-postgresql/</url>
    <content><![CDATA[<img src="/2021/07/join-stragegies-and-performance-in-postgresql/hashjoint.png" class="">

<p>在 PostgreSQL 数据库中有三种 JOIN（连接）策略，它们的工作方式截然不同。如果 PostgreSQL 选择了错误的策略，查询性能会受到很大的影响。这篇文章解释了这些连接策略，如何通过索引来支持它们，它们存在什么问题，以及如何调整连接从而获得更好的性能。</p>
<span id="more"></span>

<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="Relation（关系表）"><a href="#Relation（关系表）" class="headerlink" title="Relation（关系表）"></a>Relation（关系表）</h3><p>一个连接将组合来自两个关系表的数据，这些关系表可以是一个基表，也可以是任何计划节点的结果。例如，类似下面的连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line">   <span class="keyword">JOIN</span> (b <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> c <span class="keyword">ON</span> ...)</span><br><span class="line">      <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>基表 <code>a</code> 将和 <code>b</code> 与 <code>c</code> 的连接结果进行连接。</p>
<h3 id="Inner-和-outer-关系表"><a href="#Inner-和-outer-关系表" class="headerlink" title="Inner 和 outer 关系表"></a>Inner 和 outer 关系表</h3><p>任何连接的执行计划都类似于下面的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN (COSTS OFF)</span><br><span class="line">SELECT * FROM a JOIN b USING (id);</span><br><span class="line"></span><br><span class="line">         QUERY PLAN</span><br><span class="line">----------------------------</span><br><span class="line"> Hash Join</span><br><span class="line">   Hash Cond: (a.id = b.id)</span><br><span class="line">   -&gt;  Seq Scan on a</span><br><span class="line">   -&gt;  Hash</span><br><span class="line">         -&gt;  Seq Scan on b</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>

<p>我们把连接关系的上层（在这种情况下是对 <code>a</code> 的顺序扫描）称为连接的外层关系，我们把下层关系（从 <code>b</code> 计算的散列）称为内层关系。</p>
<h3 id="连接条件以及连接键"><a href="#连接条件以及连接键" class="headerlink" title="连接条件以及连接键"></a>连接条件以及连接键</h3><p>两个关系的笛卡尔乘积或交叉连接是指把一个关系的每一条记录与另一个关系的每一条记录结合起来。连接条件是一个过滤器，它排除了这些组合中的一些。有几种写连接条件的方法，但都可以转化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &lt;join type&gt; JOIN b ON &lt;join condition&gt;</span><br></pre></td></tr></table></figure>

<p>如果连接条件的形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.col1 &lt;operator&gt; b.col2 [AND ...]</span><br></pre></td></tr></table></figure>

<p>那么 <code>a.clo1</code> 和 <code>b.col2</code> 被称为连接键。</p>
<p>请注意，对于内连接来说，连接条件和 <code>WHERE</code> 条件之间没有区别，但这对于外连接来说并不成立。</p>
<h2 id="嵌套循环连接策略"><a href="#嵌套循环连接策略" class="headerlink" title="嵌套循环连接策略"></a>嵌套循环连接策略</h2><p>这是最简单和最通用的连接策略。PostgreSQL 按顺序扫描外部关系，并为每个结果行扫描内部关系以查找匹配行。</p>
<h3 id="有助于嵌套循环连接的索引"><a href="#有助于嵌套循环连接的索引" class="headerlink" title="有助于嵌套循环连接的索引"></a>有助于嵌套循环连接的索引</h3><p>由于按顺序扫描外部关系，因此外部关系上的任何索引都无济于事。但是内部关系的连接键上的索引可以大大加快嵌套循环连接的速度。</p>
<h3 id="嵌套循环连接策略的用例"><a href="#嵌套循环连接策略的用例" class="headerlink" title="嵌套循环连接策略的用例"></a>嵌套循环连接策略的用例</h3><p>如果外部关系很小，嵌套循环连接就特别有效，因为这样内部循环就不会被频繁执行。这是在具有规范化数据模型的 OLTP 工作负载中使用的典型的连接策略，它的效率很高。如果外层关系很大，嵌套的循环连接通常是非常低效的，即使它们被内部关系的索引所支持。</p>
<p>除此之外，如果没有连接条件使用 <code>=</code> 操作符，它是唯一可以使用的连接策略。因此，在没有其他策略可以使用的情况下，它也可以作为一种后备策略。</p>
<h2 id="Hash-连接策略"><a href="#Hash-连接策略" class="headerlink" title="Hash 连接策略"></a>Hash 连接策略</h2><p>首先，PostgreSQL 按顺序扫描内部关系并建立一个哈希表，其中哈希键由所有使用 <code>=</code> 操作符的连接键组成。然后，它按顺序扫描外部关系，并为找到的每一条记录探测哈希，以找到匹配的连接键。</p>
<p>这有点类似于一个嵌套的循环连接。建立哈希表是一个额外的启动工作，但是探测哈希表要比扫描内部关系快得多。</p>
<h3 id="有助于-Hash-连接的索引"><a href="#有助于-Hash-连接的索引" class="headerlink" title="有助于 Hash 连接的索引"></a>有助于 Hash 连接的索引</h3><p>由于我们按顺序扫描两个关系，因此没有索引对哈希连接有帮助。</p>
<h3 id="Hash-连接策略的用例"><a href="#Hash-连接策略的用例" class="headerlink" title="Hash 连接策略的用例"></a>Hash 连接策略的用例</h3><p>如果涉及的关系都不小，但较小的表的哈希表适合在 <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-WORK-MEM"><code>work_mem</code></a> 中，那么哈希连接是最好的。这是因为，否则 PostgreSQL 会分批建立哈希表，并将其存储在临时磁盘文件中，这将损害性能。在这种情况下，优化器通常会选择一个不同的连接策略，比如合并(Merge)连接。</p>
<p>只有当连接条件中的运算符是 <code>=</code> 时，在哈希表中查找数值才会起作用，所以你至少需要一个带有该运算符的连接条件。</p>
<h2 id="合并连接策略"><a href="#合并连接策略" class="headerlink" title="合并连接策略"></a>合并连接策略</h2><p>在一个合并连接中，PostgreSQL 使用 <code>=</code> 运算符来选择所有的连接条件。然后它通过连接键对两个表进行排序（这意味着数据类型必须是可排序的）。然后在两个排序的列表中进行迭代，找到匹配的条目。</p>
<h3 id="有助于合并连接的索引"><a href="#有助于合并连接的索引" class="headerlink" title="有助于合并连接的索引"></a>有助于合并连接的索引</h3><p>在排序键上的索引可以加速排序，所以在两个关系的连接键上的索引可以加速合并连接的速度。然而，显式排序通常更便宜，除非可以使用仅索引扫描。</p>
<h3 id="合并连接策略的用例"><a href="#合并连接策略的用例" class="headerlink" title="合并连接策略的用例"></a>合并连接策略的用例</h3><p>如果涉及的关系对于适合 <code>work_mem</code> 的散列来说都太大了，优化器通常会选择合并连接。所以这是连接真正大表的最佳策略。</p>
<p>像散列连接一样，只有当至少有一个带有 <code>=</code> 操作符的连接条件时，合并连接才是可行的。</p>
<h2 id="PostgreSQL-连接策略汇总表"><a href="#PostgreSQL-连接策略汇总表" class="headerlink" title="PostgreSQL 连接策略汇总表"></a>PostgreSQL 连接策略汇总表</h2><table>
<thead>
<tr>
<th></th>
<th>嵌套循环连接</th>
<th>Hash 连接</th>
<th>合并连接</th>
</tr>
</thead>
<tbody><tr>
<td>算法</td>
<td>对于每个外部关系行，扫描内部关系</td>
<td>从内部关系构建哈希，扫描外部关系，探测哈希</td>
<td>对关系进行排序并合并行</td>
</tr>
<tr>
<td>有帮助的索引</td>
<td>内部关系的连接键上的索引</td>
<td>无</td>
<td>两个关系的连接键上的索引</td>
</tr>
<tr>
<td>适合的条件</td>
<td>外部关系很小</td>
<td>Hash 适合 work_mem</td>
<td>两个表都很大</td>
</tr>
</tbody></table>
<h2 id="对查询性能的影响"><a href="#对查询性能的影响" class="headerlink" title="对查询性能的影响"></a>对查询性能的影响</h2><p>选择错误的连接策略会导致性能不佳：</p>
<ul>
<li>如果优化器低估了行数，它可能会错误地选择嵌套循环连接。然后它会比预期的更频繁地扫描内部关系，从而导致性能不佳。</li>
<li>如果优化器高估了行数，它可能会错误地选择散列或合并连接。然后它必须完全扫描这两个关系，这可能比使用内部关系上的索引的嵌套循环连接更糟糕。</li>
</ul>
<p>在这两种情况下，错误的行计数估计都是问题的原因。因此，虽然连接可能是我们花费大部分执行时间的地方，但原因是之前发生的错误估计。</p>
<h2 id="如何让-PostgreSQL-选择正确的连接策略"><a href="#如何让-PostgreSQL-选择正确的连接策略" class="headerlink" title="如何让 PostgreSQL 选择正确的连接策略"></a>如何让 PostgreSQL 选择正确的连接策略</h2><p>找出最好的连接策略是什么（也许 PostgreSQL 无论如何都在做正确的事情）。您可以使用 <code>SET</code> 命令临时禁用不同的连接策略，该命令会更改当前数据库会话中的参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> enable_hashjoin <span class="operator">=</span> off;</span><br><span class="line"><span class="keyword">SET</span> enable_mergejoin <span class="operator">=</span> off;</span><br><span class="line"><span class="keyword">SET</span> enable_nestloop <span class="operator">=</span> off;</span><br></pre></td></tr></table></figure>

<p>请注意，您不能真正禁用嵌套循环连接，只能阻止 PostgreSQL 使用它们。如果没有带有 <code>=</code> 运算符的连接条件，则嵌套循环连接是唯一的方法。</p>
<p>调优查询通常不是一项简单直接的任务。但是，这里有一些指导方针和想法：</p>
<ul>
<li>如果坏的连接策略是由于错误的估计而选择的，那么试着改善这个估计。对表进行分析，也许增加 <code>default_statistics_target</code>，看看是否会有不同。试着用更简单的 <code>WHERE</code> 条件重写查询，使优化器的任务更容易。</li>
<li>尝试增加 <code>work_mem</code> 并查看是否可以获得更便宜的哈希连接。</li>
<li>配置告诉 PostgreSQL 你的硬件和资源的参数：<code>random_page_cost</code>、<code>effective_cache_size</code> 和 <code>effective_io_concurrency</code>。这将允许它正确定价索引扫描。</li>
<li>您可以使用仅索引扫描加速嵌套循环和合并连接。为此，您必须将所有必需的列添加到索引中（最好使用 <code>INCLUDE</code> 子句），并确保经常清理表。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解连接策略对于想要了解执行计划和调整查询的任何人来说都是至关重要的。查询调优的艺术无法在一篇文章中传达，但我希望我可以在这里收集一些相关信息。</p>
<p>如果您想阅读有关使用联接调整查询的更多信息，请阅读我们有关该主题的其他一些文章，例如<a href="https://www.cybertec-postgresql.com/en/next-stop-joining-1-million-tables/">连接 100 万个表</a>或<a href="https://www.cybertec-postgresql.com/en/postgresql-speeding-up-group-by-and-joins/">加速 GROUP BY 和连接</a>。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><ul>
<li>本文翻译自 Laurenz Albe 的 <a href="https://www.cybertec-postgresql.com/en/join-strategies-and-performance-in-postgresql/">JOIN STRATEGIES AND PERFORMANCE IN POSTGRESQL</a>。</li>
<li>Laurenz Albe 是 CYBERTEC 的高级顾问和支持工程师。自 2006 年以来，他一直在与 PostgreSQL 合作并为之做出贡献。</li>
</ul>
<div class="just-for-fun">
笑林广记 - 贪官

<p>有农夫种茄不活，求计于老圃。<br>圃曰：“此不难，每茄树下埋钱一文即活。”<br>问其何故，答曰：“有钱者生，无钱者死。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 发布者与订阅者不同的 datestyle 导致失败</title>
    <url>/2021/10/logical-replication-with-different-datestyle-between-publisher-and-subscriber/</url>
    <content><![CDATA[<p>最近在浏览 PostgreSQL 邮件列表时发现一个 bug：逻辑复制时，如果发布者和订阅者的 <code>datestyle</code> 不一致可能导致逻辑复制失败。本文简要记录这个问题的分析与修复方法。</p>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>逻辑复制的环境搭建就不赘述了。我们直接来看看如何重现这个问题。首先我们在发布者上执行下面的命令修改日期格式为 <code>SQL, MDY</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres[<span class="number">6789</span>]<span class="operator">=</span># <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> datestyle <span class="keyword">TO</span> <span class="string">&#x27;SQL, MDY&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接着在订阅者上使用相同的命令修改日志格式为 <code>SQL, DMY</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres[<span class="number">9876</span>]<span class="operator">=</span># <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> datestyle <span class="keyword">TO</span> <span class="string">&#x27;SQL, DMY&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行完上述命令之后，重启发布者和订阅者。接着使用下面的命令重现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- publisher</span><br><span class="line">postgres[6789]=# CREATE TABLE tbl (a date);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[6789]=# INSERT INTO tbl values (&#x27;10-17-2021&#x27;), (&#x27;10-18-2021&#x27;);</span><br><span class="line">INSERT 0 2</span><br><span class="line">postgres[6789]=# CREATE PUBLICATION pub FOR TABLE tbl ;</span><br><span class="line">CREATE PUBLICATION</span><br><span class="line">postgres[6789]=# table tbl;</span><br><span class="line">     a</span><br><span class="line">------------</span><br><span class="line"> 10/17/2021</span><br><span class="line"> 10/18/2021</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">-- subscriber</span><br><span class="line">postgres[9876]=# CREATE TABLE tbl (a date);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[9876]=# CREATE SUBSCRIPTION sub CONNECTION &#x27;dbname=postgres port=6789&#x27; PUBLICATION pub;</span><br><span class="line">NOTICE:  created replication slot &quot;sub&quot; on publisher</span><br><span class="line">CREATE SUBSCRIPTION</span><br><span class="line">postgres[9876]=# table tbl ;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，订阅者并没有获取到发布者的数据。查看订阅者的日志，可以发现如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-10-17 11:40:41.082 CST [1138050] LOG:  logical replication table synchronization worker for subscription &quot;sub&quot;, table &quot;tbl&quot; has started</span><br><span class="line">2021-10-17 11:40:41.106 CST [1138050] ERROR:  date/time field value out of range: &quot;10/17/2021&quot;</span><br><span class="line">2021-10-17 11:40:41.106 CST [1138050] HINT:  Perhaps you need a different &quot;datestyle&quot; setting.</span><br><span class="line">2021-10-17 11:40:41.106 CST [1138050] CONTEXT:  COPY tbl, line 1, column a: &quot;10/17/2021&quot;</span><br><span class="line">2021-10-17 11:40:41.109 CST [1135717] LOG:  background worker &quot;logical replication worker&quot; (PID 1138050) exited with exit code 1</span><br></pre></td></tr></table></figure>

<p>以上就是整个问题的复现过程。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个问题是由于 <a href="https://www.postgresql.org/docs/13/runtime-config-client.html#GUC-DATESTYLE"><code>datestyle</code></a> 这个参数导致的，那么我们先看看它有什么作用。</p>
<blockquote>
<p><strong>DateStyle (string)</strong><br>Sets the display format for date and time values, as well as the rules for interpreting ambiguous date input values. For historical reasons, this variable contains two independent components: the output format specification (ISO, Postgres, SQL, or German) and the input/output specification for year/month/day ordering (DMY, MDY, or YMD). These can be set separately or together. The keywords Euro and European are synonyms for DMY; the keywords US, NonEuro, and NonEuropean are synonyms for MDY. See <a href="https://www.postgresql.org/docs/13/datatype-datetime.html">Section 8.5</a> for more information. The built-in default is ISO, MDY, but initdb will initialize the configuration file with a setting that corresponds to the behavior of the chosen lc_time locale.</p>
</blockquote>
<p>从文档说明来看，它用于显示日期格式。该参数分为两个独立的部分：输出格式规范和年月日排序的输入输出规范。</p>
<p>输出格式规范包含 <code>ISO</code>，<code>Postgres</code>，<code>SQL</code> 和 <code>German</code>。年月日排序的输入输出规范包含 <code>DMY</code>，<code>MDY</code> 和 <code>YMD</code>。</p>
<p>结合日志我们可以发现，发布者的采用的是 <code>SQL, MDY</code>，而订阅者采用的是 <code>SQL, DMY</code>，因此，发布端的 <code>10/17/2021</code> 表示 2021 年 10 月 17 日，然而，在订阅端却被识别为 2021 年 17 月 10 日，从而导致日期越界。</p>
<p>了解了问题的原因，那么我们就可以对其进行修复了。当我们在连接到发布者的时候通过指定 <code>datestyle</code> 即可解决这个问题。</p>
<p>通过查看代码我们发现，逻辑复制是通过 <code>walrcv_connect()</code> 函数来建立连接的，它被定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> walrcv_connect(conninfo, logical, appname, err) \</span></span><br><span class="line"><span class="meta">    WalReceiverFunctions-&gt;walrcv_connect(conninfo, logical, appname, err)</span></span><br></pre></td></tr></table></figure>

<p>为此，我们需要知道 <code>WalReceiverFunctions-&gt;walrcv_connect()</code> 函数的实现。<code>WalReceiverFunctions</code> 则是在 <code>libpqwalreceiver.c</code> 文件中声明定义的一个静态变量，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> WalReceiverFunctionsType PQWalReceiverFunctions = &#123;</span><br><span class="line">    libpqrcv_connect,</span><br><span class="line">    libpqrcv_check_conninfo,</span><br><span class="line">    libpqrcv_get_conninfo,</span><br><span class="line">    libpqrcv_get_senderinfo,</span><br><span class="line">    libpqrcv_identify_system,</span><br><span class="line">    libpqrcv_server_version,</span><br><span class="line">    libpqrcv_readtimelinehistoryfile,</span><br><span class="line">    libpqrcv_startstreaming,</span><br><span class="line">    libpqrcv_endstreaming,</span><br><span class="line">    libpqrcv_receive,</span><br><span class="line">    libpqrcv_send,</span><br><span class="line">    libpqrcv_create_slot,</span><br><span class="line">    libpqrcv_get_backend_pid,</span><br><span class="line">    libpqrcv_exec,</span><br><span class="line">    libpqrcv_disconnect</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合 <code>WalReceiverFunctionsType</code> 类型的声明，我们可以得知流复制是通过 <code>libpqrcv_connect()</code> 函数来完成的。通过如下修改即可修复上述问题：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</span></span><br><span class="line"><span class="comment">index 5c6e56a5b2..81cf9e30d7 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</span></span><br><span class="line"><span class="meta">@@ -30,6 +30,7 @@</span></span><br><span class="line"> #include &quot;pqexpbuffer.h&quot;</span><br><span class="line"> #include &quot;replication/walreceiver.h&quot;</span><br><span class="line"> #include &quot;utils/builtins.h&quot;</span><br><span class="line"><span class="addition">+#include &quot;utils/guc.h&quot;</span></span><br><span class="line"> #include &quot;utils/memutils.h&quot;</span><br><span class="line"> #include &quot;utils/pg_lsn.h&quot;</span><br><span class="line"> #include &quot;utils/tuplestore.h&quot;</span><br><span class="line"><span class="meta">@@ -218,6 +219,7 @@</span> libpqrcv_connect(const char *conninfo, bool logical, const char *appname,</span><br><span class="line"> 	if (logical)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		PGresult   *res;</span><br><span class="line"><span class="addition">+		const char *datestyle;</span></span><br><span class="line"></span><br><span class="line"> 		res = libpqrcv_PQexec(conn-&gt;streamConn,</span><br><span class="line"> 							  ALWAYS_SECURE_SEARCH_PATH_SQL);</span><br><span class="line"><span class="meta">@@ -229,6 +231,23 @@</span> libpqrcv_connect(const char *conninfo, bool logical, const char *appname,</span><br><span class="line"> 							pchomp(PQerrorMessage(conn-&gt;streamConn)))));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		PQclear(res);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		datestyle = GetConfigOption(&quot;datestyle&quot;, true, true);</span></span><br><span class="line"><span class="addition">+		if (datestyle != NULL) &#123;</span></span><br><span class="line"><span class="addition">+			char *sql;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			sql = psprintf(&quot;SELECT pg_catalog.set_config(&#x27;datestyle&#x27;, &#x27;%s&#x27;, false);&quot;, datestyle);</span></span><br><span class="line"><span class="addition">+			res = libpqrcv_PQexec(conn-&gt;streamConn, sql);</span></span><br><span class="line"><span class="addition">+			if (PQresultStatus(res) != PGRES_TUPLES_OK)</span></span><br><span class="line"><span class="addition">+			&#123;</span></span><br><span class="line"><span class="addition">+				PQclear(res);</span></span><br><span class="line"><span class="addition">+				ereport(ERROR,</span></span><br><span class="line"><span class="addition">+						(errmsg(&quot;could not set datestyle: %s&quot;,</span></span><br><span class="line"><span class="addition">+								pchomp(PQerrorMessage(conn-&gt;streamConn)))));</span></span><br><span class="line"><span class="addition">+			&#125;</span></span><br><span class="line"><span class="addition">+			PQclear(res);</span></span><br><span class="line"><span class="addition">+			pfree(sql);</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	conn-&gt;logical = logical;</span><br></pre></td></tr></table></figure>

<p>需要注意的是物理复制也是通过 <code>libpqrcv_connect()</code> 函数来建立连接的。理论上 <code>datestyle</code> 仅会影响到逻辑复制，为此，我将设置 <code>datestyle</code> 的代码放到了逻辑复制部分中。</p>
<p>最后，附带上测试用例。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/test/subscription/t/100_bugs.pl b/src/test/subscription/t/100_bugs.pl</span></span><br><span class="line"><span class="comment">index baa4a90771..a88a61df41 100644</span></span><br><span class="line"><span class="comment">--- a/src/test/subscription/t/100_bugs.pl</span></span><br><span class="line"><span class="comment">+++ b/src/test/subscription/t/100_bugs.pl</span></span><br><span class="line"><span class="meta">@@ -6,7 +6,7 @@</span> use strict;</span><br><span class="line"> use warnings;</span><br><span class="line"> use PostgresNode;</span><br><span class="line"> use TestLib;</span><br><span class="line"><span class="deletion">-use Test::More tests =&gt; 5;</span></span><br><span class="line"><span class="addition">+use Test::More tests =&gt; 6;</span></span><br><span class="line"></span><br><span class="line"> # Bug #15114</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -224,3 +224,44 @@</span> $node_sub-&gt;safe_psql(&#x27;postgres&#x27;, &quot;DROP TABLE tab1&quot;);</span><br><span class="line"> $node_pub-&gt;stop(&#x27;fast&#x27;);</span><br><span class="line"> $node_pub_sub-&gt;stop(&#x27;fast&#x27;);</span><br><span class="line"> $node_sub-&gt;stop(&#x27;fast&#x27;);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+# Verify different datestyle between publisher and subscriber.</span></span><br><span class="line"><span class="addition">+$node_publisher = PostgresNode-&gt;new(&#x27;datestyle_publisher&#x27;);</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;init(allows_streaming =&gt; &#x27;logical&#x27;);</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;append_conf(&#x27;postgresql.conf&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;datestyle = &#x27;SQL, MDY&#x27;&quot;);</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;start;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+$node_subscriber = PostgresNode-&gt;new(&#x27;datestyle_subscriber&#x27;);</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;init(allows_streaming =&gt; &#x27;logical&#x27;);</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;append_conf(&#x27;postgresql.conf&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;datestyle = &#x27;SQL, DMY&#x27;&quot;);</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;start;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;safe_psql(&#x27;postgres&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;CREATE TABLE tab_rep(a date)&quot;);</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;safe_psql(&#x27;postgres&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;INSERT INTO tab_rep VALUES (&#x27;07-18-2021&#x27;), (&#x27;05-15-2018&#x27;)&quot;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;safe_psql(&#x27;postgres&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;CREATE TABLE tab_rep(a date)&quot;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+# Setup logical replication</span></span><br><span class="line"><span class="addition">+my $node_publisher_connstr = $node_publisher-&gt;connstr . &#x27; dbname=postgres&#x27;;</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;safe_psql(&#x27;postgres&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;CREATE PUBLICATION tab_pub FOR ALL TABLES&quot;);</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;safe_psql(&#x27;postgres&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;CREATE SUBSCRIPTION tab_sub CONNECTION &#x27;$node_publisher_connstr&#x27; PUBLICATION tab_pub&quot;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;wait_for_catchup(&#x27;tab_sub&#x27;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+my $result = $node_subscriber-&gt;safe_psql(&#x27;postgres&#x27;,</span></span><br><span class="line"><span class="addition">+	&quot;SELECT count(*) FROM tab_rep&quot;);</span></span><br><span class="line"><span class="addition">+is($result, qq(2), &#x27;failed to replication date from different datestyle&#x27;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+# Clean up the tables on both publisher and subscriber as we don&#x27;t need them</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;safe_psql(&#x27;postgres&#x27;, &#x27;DROP TABLE tab_rep&#x27;);</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;safe_psql(&#x27;postgres&#x27;, &#x27;DROP TABLE tab_rep&#x27;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+$node_publisher-&gt;stop(&#x27;fast&#x27;);</span></span><br><span class="line"><span class="addition">+$node_subscriber-&gt;stop(&#x27;fast&#x27;);</span></span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>在我最初的 patch 中是通过 <code>libpqrcv_PQexec()</code> 去修改参数，这实际上会导致网络的开销，为了避免这一点，有两种解决方案：</p>
<ol>
<li>在 walsender 端设置 <code>datestyle</code>，<code>intervalstyle</code> 和 <code>extra_float_digits</code>。</li>
<li>在 walreceiver 端设置 <code>datestyle</code>，<code>intervalstyle</code> 和 <code>extra_float_digits</code>。</li>
</ol>
<p>在 walsender 端设置可能导致现有的一些插件无法正常使用，经过讨论，大部分都接受在 walreceiver 端进行设置。该 patch 于 2021 年 11 月 2 日的时候合并到主分支，合并的 patch 如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</span></span><br><span class="line"><span class="comment">index 5c6e56a5b2..c08e599eef 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</span></span><br><span class="line"><span class="meta">@@ -128,8 +128,8 @@</span> libpqrcv_connect(const char *conninfo, bool logical, const char *appname,</span><br><span class="line"> &#123;</span><br><span class="line">        WalReceiverConn *conn;</span><br><span class="line">        PostgresPollingStatusType status;</span><br><span class="line"><span class="deletion">-       const char *keys[5];</span></span><br><span class="line"><span class="deletion">-       const char *vals[5];</span></span><br><span class="line"><span class="addition">+       const char *keys[6];</span></span><br><span class="line"><span class="addition">+       const char *vals[6];</span></span><br><span class="line">        int                     i = 0;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line"><span class="meta">@@ -153,8 +153,20 @@</span> libpqrcv_connect(const char *conninfo, bool logical, const char *appname,</span><br><span class="line">        vals[i] = appname;</span><br><span class="line">        if (logical)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="addition">+               /* Tell the publisher to translate to our encoding */</span></span><br><span class="line">                keys[++i] = &quot;client_encoding&quot;;</span><br><span class="line">                vals[i] = GetDatabaseEncodingName();</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+               /*</span></span><br><span class="line"><span class="addition">+                * Force assorted GUC parameters to settings that ensure that the</span></span><br><span class="line"><span class="addition">+                * publisher will output data values in a form that is unambiguous to</span></span><br><span class="line"><span class="addition">+                * the subscriber.  (We don&#x27;t want to modify the subscriber&#x27;s GUC</span></span><br><span class="line"><span class="addition">+                * settings, since that might surprise user-defined code running in</span></span><br><span class="line"><span class="addition">+                * the subscriber, such as triggers.)  This should match what pg_dump</span></span><br><span class="line"><span class="addition">+                * does.</span></span><br><span class="line"><span class="addition">+                */</span></span><br><span class="line"><span class="addition">+               keys[++i] = &quot;options&quot;;</span></span><br><span class="line"><span class="addition">+               vals[i] = &quot;-c datestyle=ISO -c intervalstyle=postgres -c extra_float_digits=3&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        keys[++i] = NULL;</span><br><span class="line">        vals[i] = NULL;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/CAFF0-CF=D7pc6st-3A9f1JnOt0qmc+BcBPVzD6fLYisKyAjkGA@mail.gmail.com">https://www.postgresql.org/message-id/CAFF0-CF=D7pc6st-3A9f1JnOt0qmc+BcBPVzD6fLYisKyAjkGA@mail.gmail.com</a><br>[2] <a href="https://www.postgresql.org/docs/13/runtime-config-client.html#GUC-DATESTYLE">https://www.postgresql.org/docs/13/runtime-config-client.html#GUC-DATESTYLE</a></p>
<div class="just-for-fun">
笑林广记 - 同僚

<p>有妻、妾各居者。<br>一日，妾欲谒妻，谋之于夫：“当如何写帖？”<br>夫曰：“该用‘寅弟’二字。”<br>妾问其义如何，夫曰：“同僚写帖，皆用此称呼，做官府之例耳。”<br>妾曰：“我辈并无官职，如何亦写此帖？”<br>夫曰：“官职虽无，同僚总是一样。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Psql 内存泄漏</title>
    <url>/2022/07/memory-leak-in-psql-describe/</url>
    <content><![CDATA[<img src="/2022/07/memory-leak-in-psql-describe/memory-leak.jpeg" class="">

<p>今天在邮件列表中发现一个关于 <a href="https://www.postgresql.org/message-id/OS0PR01MB61136CE4A6A21950B82202F8FB8F9%40OS0PR01MB6113.jpnprd01.prod.outlook.com">psql 内存泄露的问题</a>，经过测试，确实存在内存泄露。同时，我在查看周围的代码时，还发现其它地方也存在类似的内存泄漏。本文简要记录一下该问题。</p>
<span id="more"></span>

<p>内存泄露发生在 <code>validateSQLNamePattern()</code> 函数中，其函数定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">validateSQLNamePattern</span><span class="params">(PQExpBuffer buf, <span class="keyword">const</span> <span class="keyword">char</span> *pattern, <span class="keyword">bool</span> have_where,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">bool</span> force_escape, <span class="keyword">const</span> <span class="keyword">char</span> *schemavar,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">char</span> *namevar, <span class="keyword">const</span> <span class="keyword">char</span> *altnamevar,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">char</span> *visibilityrule, <span class="keyword">bool</span> *added_clause,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">int</span> maxparts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PQExpBufferData dbbuf;</span><br><span class="line">    <span class="keyword">int</span>         dotcnt;</span><br><span class="line">    <span class="keyword">bool</span>        added;</span><br><span class="line"></span><br><span class="line">    initPQExpBuffer(&amp;dbbuf);</span><br><span class="line">    added = processSQLNamePattern(pset.db, buf, pattern, have_where, force_escape,</span><br><span class="line">                                  schemavar, namevar, altnamevar,</span><br><span class="line">                                  visibilityrule, &amp;dbbuf, &amp;dotcnt);</span><br><span class="line">    <span class="keyword">if</span> (added_clause != <span class="literal">NULL</span>)</span><br><span class="line">        *added_clause = added;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dotcnt &gt;= maxparts)</span><br><span class="line">    &#123;</span><br><span class="line">        pg_log_error(<span class="string">&quot;improper qualified name (too many dotted names): %s&quot;</span>,</span><br><span class="line">                     pattern);</span><br><span class="line">        termPQExpBuffer(&amp;dbbuf);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxparts &gt; <span class="number">1</span> &amp;&amp; dotcnt == maxparts - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PQdb(pset.db) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pg_log_error(<span class="string">&quot;You are currently not connected to a database.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(PQdb(pset.db), dbbuf.data) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pg_log_error(<span class="string">&quot;cross-database references are not implemented: %s&quot;</span>,</span><br><span class="line">                         pattern);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信您一眼就能发现哪儿出现了内存泄露。</p>
<p><code>initPQExpBuffer()</code> 函数将调用 <code>malloc()</code> 函数分配 512 字节的内存。该函数仅在 <code>dotcnt &gt;= maxparts</code> 时释放了其分配的内存，后续忽略了该内存的释放，从而导致内存泄露。我们可以通过诸如 <code>\dRp</code> 命令来测试。</p>
<p>由于每次泄露的内存比较小，为了能明显的感知内存泄露，我们可以通过 vim 来创建一个包含 10000 条 <code>\dRp</code> 的 SQL 文件，随后使用 psql 连接数据库并执行该文件，同时，使用 <code>top</code> 命令和 <code>/proc/pid/status</code> 观察内存变化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ top -p <span class="variable">$pid</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> cat /proc/<span class="variable">$pid</span>/status | grep -i rss; sleep 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>$pid</code> 为 psql 进程的 ID。</p>
<p>通过上述操作可以看到内存会一直小幅度上涨，并且不会被释放。我们尝试应用下面的补丁，可以避免内存泄露。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bin/psql/describe.c b/src/bin/psql/describe.c</span></span><br><span class="line"><span class="comment">index 88d92a08ae..0ce38e4b4c 100644</span></span><br><span class="line"><span class="comment">--- a/src/bin/psql/describe.c</span></span><br><span class="line"><span class="comment">+++ b/src/bin/psql/describe.c</span></span><br><span class="line"><span class="meta">@@ -6023,15 +6023,18 @@</span> validateSQLNamePattern(PQExpBuffer buf, const char *pattern, bool have_where,</span><br><span class="line"> 		if (PQdb(pset.db) == NULL)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			pg_log_error(&quot;You are currently not connected to a database.&quot;);</span><br><span class="line"><span class="addition">+			termPQExpBuffer(&amp;dbbuf);</span></span><br><span class="line"> 			return false;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		if (strcmp(PQdb(pset.db), dbbuf.data) != 0)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			pg_log_error(&quot;cross-database references are not implemented: %s&quot;,</span><br><span class="line"> 						 pattern);</span><br><span class="line"><span class="addition">+			termPQExpBuffer(&amp;dbbuf);</span></span><br><span class="line"> 			return false;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"><span class="addition">+	termPQExpBuffer(&amp;dbbuf);</span></span><br><span class="line"> 	return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当我们在重复上面的测试步骤，可以发现内存基本上不会发生变化。随后我又查看了 <code>psql/describe.c</code> 文件中关于 <code>validateSQLNamePattern()</code> 调用的地方，发现其也存在大量的内存泄露。主要集中在 <code>initPQExpBuffer()</code> 函数调用后，在错误情况下，忽略了该内存的释放。我们可以使用诸如 <code>\dRp .*fdkf.*</code> 的命令来进行测试。由于补丁内容比较大，就不展示了，在下面的参考链接中包含了该 patch。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/OS0PR01MB61136CE4A6A21950B82202F8FB8F9%40OS0PR01MB6113.jpnprd01.prod.outlook.com">https://www.postgresql.org/message-id/OS0PR01MB61136CE4A6A21950B82202F8FB8F9%40OS0PR01MB6113.jpnprd01.prod.outlook.com</a></p>
<p><strong>备注：</strong>图片来源于 <a href="https://www.krwalters.com/2018/03/14/memory-leak-in-woodstock/%E3%80%82">https://www.krwalters.com/2018/03/14/memory-leak-in-woodstock/。</a></p>
<div class="just-for-fun">
笑林广记 - 春生帖

<p>一财主不通文墨，谓友曰：“某人甚是欠通，清早来拜我，就写晚生帖。”<br>傍一监生曰：“这倒还差不远，好像这两日秋天拜客，竟有写春生帖子的哩。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>psql</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 迁移 PostgreSQL - DUAL 表</title>
    <url>/2021/09/migrate-oracle-dual-to-postgresql/</url>
    <content><![CDATA[<p>Oracle 迁移到 PostgreSQL 中最常见的问题就是 <code>DUAL</code> 表的问题。在 Oracle 数据库中，每个查询都必须跟随一个 <code>FROM</code> 子句，这是强制性的。然而在 PostgreSQL 数据库中，<code>FROM</code> 子句是可选的。本文记录了如何将 Oracle 中的 <code>DUAL</code> 表迁移到 PostgreSQL 数据库中。</p>
<span id="more"></span>

<h2 id="Oracle-DUAL-表"><a href="#Oracle-DUAL-表" class="headerlink" title="Oracle DUAL 表"></a>Oracle <code>DUAL</code> 表</h2><p>Oracle 中的 <code>DUAL</code> 表包含一行一列数据，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line"><span class="operator">-</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<h2 id="迁移解决方案"><a href="#迁移解决方案" class="headerlink" title="迁移解决方案"></a>迁移解决方案</h2><p>针对 Oracle 中 <code>DUAL</code> 表的迁移，我们有两种解决方案。</p>
<ol>
<li>第一种是直接将 Oracle 中的 <code>FROM DUAL</code> 子句移除。这是最简单的迁移方式。</li>
<li>第二种是通过创建一个视图来模拟 <code>DUAL</code> 表。这种情况通常用于不能更改应用程序的情况。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> public.dual <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="string">&#x27;X&#x27;</span>::<span class="type">varchar</span> <span class="keyword">AS</span> D;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> public.dual <span class="keyword">FROM</span> PUBLIC;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">REFERENCES</span> <span class="keyword">ON</span> public.dual <span class="keyword">TO</span> PUBLIC;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion">https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion</a><br>[2] <a href="https://github.com/orafce/orafce">https://github.com/orafce/orafce</a></p>
<div class="just-for-fun">
笑林广记 - 避暑

<p>官值暑月，欲觅避凉之地。同僚纷议。<br>或曰：“某山幽雅。”<br>或曰：“某寺清闲。”<br>一老人进曰：“山寺虽好，总不如此座公厅，最是凉快。”<br>官曰：“何以见得？”<br>答曰：“别处多有日头，独此处有天无日。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 迁移 PostgreSQL - 空字符串</title>
    <url>/2021/09/migrate-oracle-empty-string-to-postgresql/</url>
    <content><![CDATA[<p>Oracle 数据库中空字符串和 <code>NULL</code> 在字符串的环境下是相同的，这就意味着我们可以直接将其与字符串进行操作从而得到我们想要的结果，然而在 PostgreSQL 数据库中，任何字符串与 <code>NULL</code> 进行操作结果均为 <code>NULL</code>。因此，在迁移 <code>NULL</code> 字符串操作时，我们需要特别注意。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了后面的演示说明，这里提供了一个简单的测试数据，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (id <span class="type">int</span>, data <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Good&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>接着，我们分别在 PostgreSQL 和 Oracle 数据库中执行下面的语句，可以发现它们的不同之处。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, data <span class="operator">||</span> <span class="string">&#x27;, ooooooh, my God!&#x27;</span> <span class="keyword">AS</span> data <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure>

<p>Oracle 中的执行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, data <span class="operator">||</span> <span class="string">&#x27;, ooooooh, my God!&#x27;</span> <span class="keyword">AS</span> data <span class="keyword">FROM</span> t1;</span><br><span class="line"></span><br><span class="line">        ID DATA</span><br><span class="line"><span class="comment">---------- ----------------------------</span></span><br><span class="line">         <span class="number">1</span> Good, ooooooh, my God<span class="operator">!</span></span><br><span class="line">         <span class="number">2</span> , ooooooh, my God<span class="operator">!</span></span><br></pre></td></tr></table></figure>

<p>PostgreSQL 中的执行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> id, data <span class="operator">||</span> <span class="string">&#x27;, ooooooh, my God!&#x27;</span> <span class="keyword">AS</span> data <span class="keyword">FROM</span> t1;</span><br><span class="line"> id <span class="operator">|</span>          data</span><br><span class="line"><span class="comment">----+------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> Good, ooooooh, my God<span class="operator">!</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>其结果与上文描述一致，因此我们在将字符串操作迁移到 PostgreSQL 的时候需要进行判空处理。</p>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>我们可以使用 <code>coalesce()</code> 来进行迁移处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> id, <span class="built_in">coalesce</span>(data, <span class="string">&#x27;&#x27;</span>) <span class="operator">||</span> <span class="string">&#x27;, ooooooh, my God!&#x27;</span> <span class="keyword">AS</span> data <span class="keyword">FROM</span> t1;</span><br><span class="line"> id <span class="operator">|</span>          data</span><br><span class="line"><span class="comment">----+------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> Good, ooooooh, my God<span class="operator">!</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> , ooooooh, my God<span class="operator">!</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>这种方式在 Oracle 中同样适用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, <span class="built_in">coalesce</span>(data, <span class="string">&#x27;&#x27;</span>) <span class="operator">||</span> <span class="string">&#x27;, ooooooh, my God!&#x27;</span> <span class="keyword">AS</span> data <span class="keyword">FROM</span> t1;</span><br><span class="line"></span><br><span class="line">        ID DATA</span><br><span class="line"><span class="comment">---------- ----------------------------</span></span><br><span class="line">         <span class="number">1</span> Good, ooooooh, my God<span class="operator">!</span></span><br><span class="line">         <span class="number">2</span> , ooooooh, my God<span class="operator">!</span></span><br></pre></td></tr></table></figure>

<p>我个人觉得这种写法的可读性更好一些（此外，Oracle 中还可以使用 <code>nvl()</code> 来替代 <code>coalesce()</code> 函数）。</p>
<h2 id="函数与存储过程"><a href="#函数与存储过程" class="headerlink" title="函数与存储过程"></a>函数与存储过程</h2><p>PostgreSQL 在使用 plpgsql 编写函数或存储过程时，字符串默认值为 <code>NULL</code>，因此，在进行字符串相关的操作时同样需要注意。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> public.tfunc()</span><br><span class="line"><span class="keyword">RETURNS</span> void</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    t <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">    r record;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">FOR</span> r <span class="keyword">IN</span> <span class="keyword">SELECT</span> id, data <span class="operator">||</span> t <span class="keyword">AS</span> data <span class="keyword">FROM</span> t1</span><br><span class="line">   LOOP</span><br><span class="line">       RAISE NOTICE <span class="string">&#x27;%, %&#x27;</span>, r.id, r.data;</span><br><span class="line">   <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>上述函数的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select tfunc();</span><br><span class="line">NOTICE:  1, &lt;NULL&gt;</span><br><span class="line">NOTICE:  2, &lt;NULL&gt;</span><br><span class="line"> tfunc</span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion#Empty_strings_and_NULL_values">https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion#Empty_strings_and_NULL_values</a></p>
<div class="just-for-fun">
笑林广记 - 强盗脚

<p>乡民初次入城，见有木桶悬于城上。<br>问人曰：“此中何物？”<br>应者曰：“强盗头。”<br>及至县前，见数个木匣钉于谯楼之上，皆前官既去，而所留遗爱之靴。<br>乡民不知，乃点首曰：“城上挂的强盗头，此处一定是强盗脚了。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>小米路由器刷 Breed 和 Padavan 固件</title>
    <url>/2020/07/miwifi-breed-padavan/</url>
    <content><![CDATA[<p>本文主要记录一下小米路由器 3G 刷 breed 和 padavan 的过程。</p>
<ul>
<li><a href="https://openwrt.org/docs/techref/bootloader/breed">Breed</a> 是嵌入式设备的引导和恢复环境的简称。</li>
<li>Padavan 是由俄罗斯人基于华硕源码开发的针对 mtk 芯片的固件。</li>
</ul>
<p>我将整个过程分为分为 5 个步骤，更新 ROM、开启 SSH、备份路由器、刷 breed、刷 padavan。</p>
<span id="more"></span>

<h2 id="更新路由器-ROM"><a href="#更新路由器-ROM" class="headerlink" title="更新路由器 ROM"></a>更新路由器 ROM</h2><p>首先，我们需要将小米路由器的 ROM 更新为开发版，在小米的 <a href="http://miwifi.com/miwifi_download.html">miwifi 下载页面</a>找到路由器对应的开发版 ROM（<a href="http://bigota.miwifi.com/xiaoqiang/rom/r3g/miwifi_r3g_firmware_12f97_2.25.124.bin">R3G ROM 开发版</a>）。</p>
<p>ROM 的升级有两种方式：</p>
<ol>
<li><p>登陆路由器后台在线升级，我采用的这种方式，简单快捷。</p>
</li>
<li><p>如果不行的话，可以将其拷贝到 U 盘根目录，并命名为 miwifi.bin。<strong>随后断开电源，插上 U 盘，并按住 reset 按钮后插入电源，等到指示灯变为黄色闪烁状态后松开 reset 键，之后路由器将更新 ROM 并重启进入正常状态（指示灯变为蓝色常亮）。</strong></p>
</li>
</ol>
<h2 id="开启-SSH"><a href="#开启-SSH" class="headerlink" title="开启 SSH"></a>开启 SSH</h2><p>接下来，我们开启路由器的 ssh 功能，在 <a href="http://miwifi.com/miwifi_open.html">miwifi 开放</a> 找到__开启 SSH 工具__下载 miwifi_ssh.bin，这里需要使用小米账号对路由器进行绑定，绑定了之后小米会给出一个 root 用户的密码。</p>
<p>接着将下载的 miwifi_ssh.bin 拷贝到 U 盘根目录（__名称必须为 miwifi_ssh.bin__），如果之前是用 U 盘升级的 ROM，建议将 miwifi.bin 删除。</p>
<p>最后，将路由器断电，插上 U 盘，并按住 reset 按钮后插入电源，等到指示灯变为黄色闪烁状态后松开 reset 键，待蓝灯亮起时表示 ssh 开启完成。我们便可以使用 <code>ssh root@192.168.1.1</code> 登陆路由器了。</p>
<h2 id="备份路由器"><a href="#备份路由器" class="headerlink" title="备份路由器"></a>备份路由器</h2><p>这个步骤我其实是没有做的，一开始我是按照<a href="https://blog.csdn.net/z619193774/article/details/81507917">参考文献 [1]</a> 来做的，现在想想还是挺后怕的，这就是所谓的无知者无谓吧！登陆路由器后，我们使用下面的命令对路由器进行备份。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /dev/sd*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mount /dev/sda1 /mnt <span class="comment"># 找到属于你的 U 盘</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> name <span class="keyword">in</span> $(grep -v <span class="string">&#x27;dev&#x27;</span> /proc/mtd | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>); <span class="keyword">do</span> dd <span class="keyword">if</span>=/dev/<span class="variable">$name</span> of=/mnt/<span class="variable">$name</span>.bin; <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<h2 id="刷-Breed"><a href="#刷-Breed" class="headerlink" title="刷 Breed"></a>刷 Breed</h2><p>在 <a href="https://breed.hackpascal.net/">Breed</a> 网址上找到对应的版本，小米路由器 R3G 对应的 breed 为 <a href="https://breed.hackpascal.net/breed-mt7621-xiaomi-r3g.bin">breed-mt7621-xiaomi-r3g.bin</a>。然后将其通过 <code>scp</code> 拷贝到路由器上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp breed-mt7621-xiaomi-r3g.bin root@192.168.1.1:/tmp/</span></span><br></pre></td></tr></table></figure>

<p>随后登陆到小米路由器，执行下面的命令刷入 breed：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mtd -r write /tmp/breed-mt7621-xiaomi-r3g.bin Bootloader</span></span><br></pre></td></tr></table></figure>

<p>刷入成功后，路由器将会重启，等到重启完成之后，拔掉电源，按住 reset 按钮，插电开机，等到路由器蓝灯闪烁时，在浏览器中输入 192.168.1.1，就可以进入 breed 的控制台了。</p>
<p>在 breed 控制台中，选择__固件备份__，备份 EEPRO 和编程固件，这样我们可以在之后刷回原来的系统。</p>
<h2 id="刷-Padavan-固件"><a href="#刷-Padavan-固件" class="headerlink" title="刷 Padavan 固件"></a>刷 Padavan 固件</h2><p>在 <a href="http://opt.cn2qq.com/padavan/">Padavan</a> 下载页面下载小米路由器 R3G 版本 <a href="http://opt.cn2qq.com/padavan/MI-R3G_3.4.3.9-099.trx">MI-R3G_3.4.3.9-099.trx</a>。登陆 breed，在__固件更新__中选择__固件__，随后浏览本地文件选择我们下载的 MI-R3G_3.4.3.9-099.trx 文件，点击上传，上传成功之后将自动更新固件，最后完成之后，我们可以通过访问 192.168.123.1 来登陆 padavan，用户名和密码默均为 <code>admin</code>，初始化的 wifi 名称为 <code>PCDN</code> 和 <code>PCDN_5G</code>，密码为 <code>1234567890</code>。</p>
<img src="/2020/07/miwifi-breed-padavan/padavan.jpg" class="" title="Padavan 管理界面">

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>在上文中使用的 U 盘需为 FAT/FTA32 格式化的。</li>
<li>可能需要使用网线连接路由器进行配置。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/z619193774/article/details/81507917">https://blog.csdn.net/z619193774/article/details/81507917</a><br>[2] <a href="https://schaepher.github.io/2019/10/12/xiaomi-router-r3-openwrt/">https://schaepher.github.io/2019/10/12/xiaomi-router-r3-openwrt/</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>R3G</tag>
        <tag>breed</tag>
        <tag>padavan</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT (v8.x) 主题添加近期文章</title>
    <url>/2020/08/next-8-0-0-recent-posts/</url>
    <content><![CDATA[<p>最近将博客由 NexT-v5.x 迁移到 NexT-v8.x 版本，这其中有很多东西已将发生变化了。本文简要介绍一下如何在新版中加入近期文章的功能。NexT-v8.x 版本将模版文件由原来的 <code>swig</code> 变更为 <code>njk</code> 后缀，因此，之前的近期文章的功能不再适用，我们需要稍作修改。</p>
<span id="more"></span>

<h2 id="创建自定义文件"><a href="#创建自定义文件" class="headerlink" title="创建自定义文件"></a>创建自定义文件</h2><p>NexT-v8.x 支持自定义 <code>njk</code> 文件，从而避免修改 NexT 的源码，见参考链接 [<a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=sideb">2</a>]。我们在站点的 <code>source</code> 目录下创建 <code>_data/sidebar.njk</code> 文件，并加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- recent posts --&gt;</span><br><span class="line">&#123;%- if theme.recent_posts %&#125;</span><br><span class="line">    &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;links-of-blogroll-title recent-posts-title&quot;&gt;</span><br><span class="line">	    &lt;i class=&quot;fa fa-history &#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class="line">            &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;ul class=&quot;links-of-blogroll-list recent-posts-list&quot;&gt;</span><br><span class="line">	    &#123;%- set posts = site.posts.sort(&#x27;-date&#x27;).toArray() %&#125;</span><br><span class="line">	    &#123;%- for post in posts.slice(&#x27;0&#x27;, &#x27;5&#x27;) %&#125;</span><br><span class="line">	        &lt;li class=&quot;my-links-of-blogroll-item&quot;&gt;</span><br><span class="line">		    &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;&quot;&gt;</span><br><span class="line">		    &#123;&#123; post.title &#125;&#125;</span><br><span class="line">		    &lt;/a&gt;</span><br><span class="line">		&lt;/li&gt;</span><br><span class="line">	    &#123;%- endfor %&#125;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>接着我们在站点目录下的主题配置文件（_config.next.yml）中加入如下内容开启近期文章功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recent_posts: true</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br></pre></td></tr></table></figure>

<p>接着重启服务，我们便可以看到如下所示的近期文章板块。</p>
<img src="/2020/08/next-8-0-0-recent-posts/recent-posts.jpg" class="">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://theme-next.js.org/next-8-0-0-rc-1-released/">https://theme-next.js.org/next-8-0-0-rc-1-released/</a><br>[2] <a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=sideb">https://theme-next.js.org/docs/advanced-settings/custom-files.html?highlight=sideb</a><br>[3] <a href="https://hasaik.com/posts/ab21860c.html">https://hasaik.com/posts/ab21860c.html</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 迁移 PostgreSQL - DESDecrypt 函数</title>
    <url>/2021/06/oracle-desdecrypt-to-postgresql/</url>
    <content><![CDATA[<p>最近在工作中遇到了 Oracle DES 加解密迁移到 PostgreSQL 中的问题，本文简要记录一下这个问题的解决过程。</p>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在客户环境中，被加密的内容来自于一个数据中心，而在迁移的数据库中有一个名为 <code>fn_decrypt_base64()</code> 的函数对其进行解密。函数定义如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> fn_decrypt_base64(input_str  <span class="keyword">IN</span> VARCHAR2,</span><br><span class="line">                                             encode_key <span class="keyword">IN</span> VARCHAR2)</span><br><span class="line"><span class="keyword">RETURN</span> VARCHAR2</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line">  output_string    varchar2(<span class="number">4000</span>);</span><br><span class="line">  encrypted_string varchar2(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(input_str)))</span><br><span class="line">    <span class="keyword">INTO</span> encrypted_string</span><br><span class="line">    <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- dbms_output.put_line(utl_raw.cast_to_raw(encrypted_string));</span></span><br><span class="line">  dbms_obfuscation_toolkit.DESDecrypt(input_string     <span class="operator">=</span><span class="operator">&gt;</span> encrypted_string,</span><br><span class="line">                                      key_string       <span class="operator">=</span><span class="operator">&gt;</span> encode_key,</span><br><span class="line">                                      decrypted_string <span class="operator">=</span><span class="operator">&gt;</span> output_string);</span><br><span class="line">  <span class="keyword">RETURN</span> output_string;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>其执行结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">SELECT</span> fn_decrypt_base64(<span class="string">&#x27;0MgFN1KCaNetLz2kCGfssLFrGCC2Hpaw&#x27;</span>, <span class="string">&#x27;identitynumber_com.ffcs.mss@123&#x27;</span>) <span class="keyword">AS</span> plaintext <span class="keyword">FROM</span> dual;</span><br><span class="line">     PLAINTEXT</span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"> <span class="number">340104198809053015</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>既然是加解密，那么迁移到 PostgreSQL 中来很自然的就想到了 <a href="">pgcrypto</a> 扩展。然而并没有那么简单。</p>
<p>下面是我迁移到 PostgreSQL 中对 <code>fn_decrypt_base64()</code> 函数的实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> pgcrypto;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> fn_decrypt_base64(input_str text,</span><br><span class="line">                                             encode_key bytea)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">varchar</span></span><br><span class="line"><span class="keyword">AS</span> $body$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  output_string <span class="type">varchar</span>(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> decrypt(decode(input_str, <span class="string">&#x27;base64&#x27;</span>), encode_key, <span class="string">&#x27;des&#x27;</span>)</span><br><span class="line">  <span class="keyword">INTO</span> output_string;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> output_string;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$body$ <span class="keyword">LANGUAGE</span> <span class="string">&#x27;plpgsql&#x27;</span> VOLATILE;</span><br></pre></td></tr></table></figure>

<p>其执行结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">SELECT</span> fn_decrypt_base64(<span class="string">&#x27;0MgFN1KCaNetLz2kCGfssLFrGCC2Hpaw&#x27;</span>, <span class="string">&#x27;identitynumber_com.ffcs.mss@123&#x27;</span>) <span class="keyword">AS</span> plaintext;</span><br><span class="line">                     plaintext</span><br><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line"> \x333430313034313938383039303533303135000000000000</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>这并不是我们想要的结果，但是已经非常接近了，可以看到其二进制格式实际上就是我们解密后的原文，但是后面附加了一些内容，当我们尝试将其转换为可读的字符串时，会遇到如下错误。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">SELECT</span> convert_from(fn_decrypt_base64(<span class="string">&#x27;0MgFN1KCaNetLz2kCGfssLFrGCC2Hpaw&#x27;</span>, <span class="string">&#x27;identitynumber_com.ffcs.mss@123&#x27;</span>)::bytea, <span class="string">&#x27;SQL_ASCII&#x27;</span>) <span class="keyword">AS</span> plaintext;</span><br><span class="line">ERROR:  invalid byte sequence <span class="keyword">for</span> encoding &quot;SQL_ASCII&quot;: <span class="number">0x00</span></span><br></pre></td></tr></table></figure>

<p>在 Oracle 的 <code>fn_decrypt_base64</code> 中加入 <code>dbms_output.put_line(utl_raw.cast_to_raw(encrypted_string));</code> 语句，可以看到两个数据库中解密后的数据的区别，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oracle      D0C80537528268D7AD2F3DA40867ECB0B16B1820B61E96B0</span><br><span class="line">plain text   3 4 0 1 0 4 1 9 8 8 0 9 0 5 3 0 1 5</span><br><span class="line">PostgreSQL  333430313034313938383039303533303135000000000000</span><br></pre></td></tr></table></figure>

<p>其长度都是一致的，但是在 Oracle 中，我看不出有什么规律，而在 PostgreSQL 中，可以发现非零部分就是我们解密后的明文的二进制形式。在 PostgreSQL 中，我们可以使用如下语句来达到与 Oracle 中类似的效果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">SELECT</span> convert_from(<span class="built_in">trim</span>(fn_decrypt_base64(<span class="string">&#x27;0MgFN1KCaNetLz2kCGfssLFrGCC2Hpaw&#x27;</span>, <span class="string">&#x27;identitynumber_com.ffcs.mss@123&#x27;</span>)::bytea, <span class="string">&#x27;\x00&#x27;</span>), <span class="string">&#x27;SQL_ASCII&#x27;</span>) <span class="keyword">AS</span> plaintext;</span><br><span class="line">     plaintext</span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"> <span class="number">340104198809053015</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>这只是 Oracle 中 <code>DESDecrypt</code> 迁移到 PostgreSQL 数据库中的一种临时解决方案，至于为什么 Oracle 和 PostgreSQL 中解密后的明文二进制表现不同，或许这个 Oracle 中 varchar2 类型的存储格式有关。</p>
<p>我们可以对 <code>fn_decrypt_base64</code> 函数进行封装，使其表现得更像 Oracle 一点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> fn_decrypt_base64(input_str text,</span><br><span class="line">                                             encode_key bytea)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">varchar</span></span><br><span class="line"><span class="keyword">AS</span> $body$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  output_string <span class="type">varchar</span>(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> convert_from(<span class="built_in">trim</span>(decrypt(decode(input_str, <span class="string">&#x27;base64&#x27;</span>), encode_key, <span class="string">&#x27;des&#x27;</span>), <span class="string">&#x27;\x00&#x27;</span>), <span class="string">&#x27;SQL_ASCII&#x27;</span>)</span><br><span class="line">  <span class="keyword">INTO</span> output_string;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> output_string;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$body$ <span class="keyword">LANGUAGE</span> <span class="string">&#x27;plpgsql&#x27;</span> VOLATILE;</span><br></pre></td></tr></table></figure>

<p>其结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">SELECT</span> fn_decrypt_base64(<span class="string">&#x27;0MgFN1KCaNetLz2kCGfssLFrGCC2Hpaw&#x27;</span>, <span class="string">&#x27;identitynumber_com.ffcs.mss@123&#x27;</span>) <span class="keyword">AS</span> plaintext;</span><br><span class="line">     plaintext</span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"> <span class="number">340104198809053015</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/12/pgcrypto.html">https://www.postgresql.org/docs/12/pgcrypto.html</a><br>[2] <a href="https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:13889233036637">https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:13889233036637</a></p>
<div class="just-for-fun">
笑林广记 - 仙女凡身

<p>董永行孝，上帝命一仙女嫁之。<br>众仙女送行，皆嘱咐曰：“去下方，若更有行孝者，千万寄个信来。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle VARCHAR2 与 PostgreSQL VARCHAR 异同</title>
    <url>/2021/11/oracle-varchar2-vs-postgresql-varchar/</url>
    <content><![CDATA[<p>在 Oracle 迁移到 PostgreSQL 数据库的过程中，我们通常使用 PostgreSQL 中的 <code>VARCHAR</code> 类型替换 Oracle 中的 <code>VARCHAR2</code> 类型。本文将针对 Oracle 中的 <code>VARCHAR2</code> 类型和 PostgreSQL 中的 <code>VARCHAR</code> 类型进行简要的比较。</p>
<span id="more"></span>

<h2 id="Oracle-VARCHAR2-类型"><a href="#Oracle-VARCHAR2-类型" class="headerlink" title="Oracle VARCHAR2 类型"></a>Oracle VARCHAR2 类型</h2><p>在 Oracle 数据库中，我们通常使用 <code>VARCHAR2</code> 类型存储变长数据。Oracle 中的 <code>VARCHAR2</code> 存储范围为 1 到 4000 个字节。</p>
<p>当我们创建表时，必须指定字符长度。Oracle 提供了两种方式。</p>
<ul>
<li><code>VARCHAR2(max_size BYTE)</code> - 以字节的方式给出最大值。</li>
<li><code>VARCHAR2(max_size CHAR)</code> - 以字的方式给出最大值。</li>
</ul>
<p>默认情况下，Oracle 是以字节的方式给出最大值的，即 <code>VARCHAR2(max_size)</code> 等同于 <code>VARCHAR2(max_size BYTE)</code>。</p>
<p>在 Oracle 12c 中，您可以指定 <code>max_size</code> 为 32767。Oracle 通过参数 <code>MAX_STRING_SIZE</code> 来控制这个值，如果 <code>MAX_STRING_SIZE = STANDARD</code>，那么 <code>VARCHAR2</code> 的最大值仍然只能最大为 4000；若 <code>MAX_STRING_SIZE = EXTENDED</code>，那么 <code>VARCHAR2</code> 的最大值则可以设置为 32767。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们创建一张表，并插入一条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (s1 varchar2(<span class="number">3</span>), s2 varchar2(<span class="number">3</span> <span class="type">char</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;您&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>通过 <code>length()</code> 函数查看其长度，我们发现 <code>s2</code> 的长度为 3，这里需要注意的是在 <code>VARCHAR2</code> 包含多字节编码的字时他将在末尾添加一个 <code>0x00</code> 字节。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> length(s1), length(s2) <span class="keyword">FROM</span> tbl;</span><br><span class="line"></span><br><span class="line">LENGTH(S1) LENGTH(S2)</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         <span class="number">1</span>          <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>当我们插入的字节大于指定的 <code>max_size</code> 将报错。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;您a&#x27;</span>)</span><br><span class="line">                              <span class="operator">*</span></span><br><span class="line">ERROR <span class="keyword">at</span> line <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-12899</span>: <span class="keyword">value</span> too <span class="keyword">large</span> <span class="keyword">for</span> <span class="keyword">column</span> &quot;SYS&quot;.&quot;TBL&quot;.&quot;S2&quot; (actual: <span class="number">4</span>, maximum: <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>此外，Oracle 中的 <code>length()</code> 针对 <code>VARCHAR2</code> 类型得到的是字节的长度，而不是字的长度。</p>
<p>以上测试基于 Oracle 12.1.0.2.0。</p>
<h2 id="PostgreSQL-VARCHAR-类型"><a href="#PostgreSQL-VARCHAR-类型" class="headerlink" title="PostgreSQL VARCHAR 类型"></a>PostgreSQL VARCHAR 类型</h2><p>PostgreSQL 中的 <code>VARCHAR</code> 类型与 Oracle 有所不同，它不支持指定不同的类型，PostgreSQL 的 <code>VARCHAR</code> 是按字来计算的而不是字节。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>创建一张测试表，并插入一条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (s1 <span class="type">varchar</span>(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="string">&#x27;你好啊&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>一切都正常。我们再次尝试插入更多的字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="string">&#x27;你好啊a&#x27;</span>);</span><br><span class="line">ERROR:  <span class="keyword">value</span> too long <span class="keyword">for</span> type <span class="type">character</span> <span class="type">varying</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="string">&#x27;你好啊啊&#x27;</span>);</span><br><span class="line">ERROR:  <span class="keyword">value</span> too long <span class="keyword">for</span> type <span class="type">character</span> <span class="type">varying</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>这是无论我们插入什么，PostgreSQL 都将报错，并指出超出长度限制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> length(s1), <span class="keyword">octet_length</span>(s1) <span class="keyword">FROM</span> TBL;</span><br><span class="line"> length <span class="operator">|</span> <span class="keyword">octet_length</span></span><br><span class="line"><span class="comment">--------+--------------</span></span><br><span class="line">      <span class="number">3</span> <span class="operator">|</span>            <span class="number">9</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>字符串 <code>你好啊</code> 的 <a href="https://www.browserling.com/tools/utf8-encode">UTF-8 编码</a>序列为 <code>\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x95\x8a</code>，包含 9 个字节。</p>
<p>PostgreSQL 中的最大长度为 <code>10485760</code>，10MB 的数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>数据库类型</th>
<th>最大长度</th>
<th>申明方式</th>
<th>length() 函数</th>
</tr>
</thead>
<tbody><tr>
<td>PostgreSQL VARCHAR</td>
<td>10485760</td>
<td>varchar(n)</td>
<td>以字计算</td>
</tr>
<tr>
<td>Oracle VARCHAR2</td>
<td>4000 or 32767 (12c)</td>
<td>varchar2(n byte), varchar2(n char)</td>
<td>以字节计算</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.oracletutorial.com/oracle-basics/oracle-varchar2/">https://www.oracletutorial.com/oracle-basics/oracle-varchar2/</a><br>[2] <a href="https://www.postgresql.org/docs/13/datatype-character.html">https://www.postgresql.org/docs/13/datatype-character.html</a></p>
<div class="just-for-fun">
笑林广记 - 州同

<p>一人好古董，有持文王鼎求售者，以百金买之。<br>又一人持一夜壶至，铜色斑驳陆离，云是武王时物，亦索重价。<br>曰：“铜色虽好，只是肚里甚臭。”<br>答曰：“腹中虽臭，难道不是个周铜？”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle wm_concat 函数说明</title>
    <url>/2021/03/oracle-wm-concat/</url>
    <content><![CDATA[<p>Oracle 数据库的 <code>wm_concat</code> 函数用于将多行数据聚合为单行，从而提供与特定值关联的数据列表，它将以逗号来分割列表。<br>本文主要介绍 <code>wm_concat</code> 函数的功能以及其在 PostgreSQL 数据库中的替换方法。</p>
<span id="more"></span>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>本文将使用下面的测试用例来测试 <code>wm_concat</code> 函数以及其替代方法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (col1 <span class="type">int</span>, col2 <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;this&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;is&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;wm_concat test&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p>在 Oracle 数据库中 <code>wm_concat</code> 没有相关的文档记录的，其输出如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> col1, wm_concat(col2) <span class="keyword">FROM</span> tbl <span class="keyword">GROUP</span> <span class="keyword">BY</span> (col1);</span><br><span class="line"></span><br><span class="line">      COL1 WM_CONCAT(COL2)</span><br><span class="line"><span class="comment">---------- --------------------------------------------------------------------------------</span></span><br><span class="line">         <span class="number">1</span> Hello,test,a,<span class="keyword">is</span>,this,world</span><br><span class="line">         <span class="number">2</span> wm_concat test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 <code>wm_concat</code> 没有相关的文档记录，因此不建议使用该函数。其次，在 Oracle 12c 中 <code>wm_concat</code> 已经被移除了。更好的写法是通过 <code>listagg</code> 函数对其进行替换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> col1, <span class="built_in">listagg</span>(col2, <span class="string">&#x27;,&#x27;</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col2) <span class="keyword">AS</span> agg <span class="keyword">FROM</span> tbl <span class="keyword">GROUP</span> <span class="keyword">BY</span> col1;</span><br><span class="line"></span><br><span class="line">      COL1 AGG</span><br><span class="line"><span class="comment">---------- --------------------------------------------------------------------------------</span></span><br><span class="line">         <span class="number">1</span> Hello,test,a,<span class="keyword">is</span>,this,world</span><br><span class="line">         <span class="number">2</span> wm_concat test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><p>当我们将其迁移到 PostgreSQL 时，我们可以使用 <code>string_agg</code> 函数来替换 Oracle 中的 <code>wm_concat</code> 和 <code>listagg</code> 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT col1, string_agg(col2, &#x27;,&#x27;) FROM tbl GROUP BY col1;</span><br><span class="line"> col1 |         string_agg</span><br><span class="line">------+----------------------------</span><br><span class="line">    2 | wm_concat test</span><br><span class="line">    1 | Hello,world,this,is,a,test</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres# SELECT col1, string_agg(col2, &#x27;,&#x27; ORDER BY col2) FROM tbl GROUP BY col1;</span><br><span class="line"> col1 |         string_agg</span><br><span class="line">------+----------------------------</span><br><span class="line">    1 | a,Hello,is,test,this,world</span><br><span class="line">    2 | wm_concat test</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>wm_concat</code> 函数是根据其聚合的列进行排序的，但是其排序的结果和 PostgreSQL 中不太一样，目前尚不清楚具体原因。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://psoug.org/definition/WM_CONCAT.htm">http://psoug.org/definition/WM_CONCAT.htm</a><br>[1] <a href="https://asktom.oracle.com/pls/apex/f?p=100:11:::NO:RP:P11_QUESTION_ID:9529613900346315631">https://asktom.oracle.com/pls/apex/f?p=100:11:::NO:RP:P11_QUESTION_ID:9529613900346315631</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ping 权限拒绝</title>
    <url>/2018/09/ping-permission-denied/</url>
    <content><![CDATA[<p>今天在 CentOS 上遇到一个奇怪的问题，ping 程序在 root 用户下能正常使用，但是在非 root 用户下则出现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user@host:~ $ ping 127.0.0.1</span><br><span class="line">ping: socket: Permission denied</span><br></pre></td></tr></table></figure>

<p>在 StackExchage 上也有人遇到了<a href="https://unix.stackexchange.com/questions/385980/ping-socket-permission-denied">类似的问题</a>，他需要在 PHP 中调用 ping 命令，并且他通过执行 <code>setenforce 0</code> 可以让 ping 命令正常使用，但是经我测试发现这种方法对我无效。</p>
<p>之后在 LinuxQuestions 上发现<a href="https://www.linuxquestions.org/questions/linux-embedded-and-single-board-computer-78/socket-permission-denied-915704/">有人</a>指出 ping 命名将创建原始套接字而非 TCP 套接字，然而 Linux 系统对于普通用户创建原开套接字是禁止的，因此我们就看到了文章开始的错误，针对这一问题他也提出了解决方案，即为 ping 命令添加 suid 权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user@host:~ $ chmod +s /bin/ping</span><br><span class="line">user@host:~ $ ls -al /bin/ping</span><br><span class="line">-rwsr-xr-x 1 root root 64424 Mar 10  2017 /bin/ping</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>那么什么是 suid 权限呢？我们所熟悉的文件权限包括读、写和可执行 (r/w/x) 三种权限，其实在 Linux 系统中对所有文件还有三种特殊的权限说明，即 SUID, SGID 和 Sticky Bits。</p>
<h3 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h3><p>由于 Unix 是多用户操作系统并且设计为多个用户可以同时使用，而 Sticky Bit 则告诉 Unix 系统一旦程序被执行，那么他将一直保留在内存当中，这样可以避免不同用户执行同一程序进行多次加载。在设置了 Sticky Bit 位后，当一个用户使用了这个程序，另一个用户再次使用时可以避免初始化该程序的过程。Sticky Bit 的概念在快速磁盘访问 (Fast Disk Access) 和内存访问技术 (Memory Access Technologies) 出现之前非常有用。随着技术的发展程序加载到内存的时间的减少，Sticky Bit 的概念逐渐被废弃，因此，目前 Sticky Bit 的作用不是很明显。需要注意的是 Sticky Bit 只能用于可执行文件。</p>
<h3 id="SUID-Set-User-ID-Bit"><a href="#SUID-Set-User-ID-Bit" class="headerlink" title="SUID (Set User ID) Bit"></a>SUID (Set User ID) Bit</h3><p>SUID (Set User ID) 意味着当执行应用程序时，用户的 ID 将被设置为文件或程序所有者的 ID 而不是当前用户的 ID。例如，假设我有一个应用程序他的所有者为 root 并且设置和了 SUID 位，那么当我以普通用户运行该应用程序时，该应用程序依然会以 root 身份运行。这是由于 SUID 位告诉 Linux 系统为该应用程序设置 root 用户的 ID，并且在运行时始终以 root 用户的身份去运行该应用程序 (此处文件的所有者为 root 用户)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置文件 SUID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u+s filename</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 去掉文件 SUID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u-s filename</span></span><br></pre></td></tr></table></figure>

<h3 id="SGID-Set-Group-ID-Bit"><a href="#SGID-Set-Group-ID-Bit" class="headerlink" title="SGID (Set Group ID) Bit"></a>SGID (Set Group ID) Bit</h3><p>SGID (Set Group ID) 与 SUID 类似，他意味着文件执行时设置其执行的用户组 ID。通常情况下，在 Linux/Unix 系统中程序运行时会继承当前登录用户的权限。SGID 则可以给运行的程序临时修改有效用户组为文件所属的组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 设置文件 SGID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod g+s filename</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 去掉文件 SGID 位</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod g-s filename</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.codecoffee.com/tipsforlinux/articles/028.html">What are the SUID, SGID and the Sticky Bits?</a></li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>ping</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL RelCache 和 SysCache 缓存</title>
    <url>/2022/07/postgres-relcache-and-syscache/</url>
    <content><![CDATA[<p>PostgreSQL 数据库大部分操作都依赖于系统表，因此为了加速访问，PostgreSQL 针对系统表提供了两种缓存：RelCache 和 SysCache。RelCache 和 SysCache 都是进程本地的，每个 backend 进程启动的时候都将创建自己的 RelCache 和 SysCache。本文将简要介绍一下这两类缓存。</p>
<ul>
<li>RelCache 用于缓存表的 RelationData 结构（关系描述符 - <code>reldesc</code>），该结构由系统表中的元组构成。</li>
<li>SysCache 用于缓存系统表的元组信息。</li>
</ul>
<span id="more"></span>

<h2 id="RelCache-缓存"><a href="#RelCache-缓存" class="headerlink" title="RelCache 缓存"></a>RelCache 缓存</h2><p>RelCache 缓存的相关实现在 <code>src/backend/utils/cache/relcache.c</code> 文件中，文件 <code>src/include/utils/relcache.h</code> 则包含了相关函数的声明。</p>
<p>RelCache 的初始化可以分为三个阶段：</p>
<ol>
<li><code>RelationCacheInitialize</code> - 初始化 <code>reldesc</code> 缓存（创建一个空的哈希表缓存），此阶段由于事务子系统还没有运行，因此不能访问数据库。</li>
<li><code>RelationCacheInitializePhase2</code> - 该阶段主要是准备在启动时需要访问的共享系统表，此阶段至少需要加载 <code>pg_database</code>、<code>pg_authid</code>、<code>pg_auth_members</code> 和 <code>pg_shseclabel</code> 系统表。理想情况下，我们也需要加载其相应的索引。该函数尝试从共享的 <code>global/pg_internal.init</code> 文件中加载 RelCache 内容，如果失败的话，那么将通过 <code>formrdesc()</code> 函数为其创建一个预定义的 <code>reldesc</code>。</li>
<li><code>RelationCacheInitializePhase3</code> - 当 CatCache 和事务系统正常运行，并且确定了数据库，则会调用该函数，在此之后，我们便可以从数据库的系统表中读取数据。</li>
</ol>
<p>下图是整个 RelCache 初始化的流程。</p>
<img src="/2022/07/postgres-relcache-and-syscache/relcache-flowchat.png" class="">

<p>RelCache 初始化完成之后，我们便可以通过 <code>RelationIdGetRelation()</code> 函数获取 <code>reldesc</code>，在使用完之后，调用 <code>RelationClose()</code> 函数进行清理。</p>
<p><code>RelationIdGetRelation()</code> 通过 OID 查找 <code>reldesc</code>，如果缓存中不存在则通过 <code>BuildRelationDesc()</code> 函数创建一个并加入到缓存，同时增加其引用计数。如下是其具体的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Relation</span></span><br><span class="line"><span class="function"><span class="title">RelationIdGetRelation</span><span class="params">(Oid relationId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Relation	rd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保处于有效的事务块中，即 TRANS_INPROGRESS */</span></span><br><span class="line">	Assert(IsTransactionState());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 从 RelationIdCache 缓存中查询，RelationIdCacheLookup() 是一个宏定义，</span></span><br><span class="line"><span class="comment">	 * 其本质是执行 hash_search() 进行查找，即</span></span><br><span class="line"><span class="comment">	 * hash_search(RelationIdCache, (void *) &amp;relationId, HASH_FIND, NULL);</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RelationIdCacheLookup(relationId, rd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RelationIsValid(rd))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果该 relation 已经被删除，则返回 NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rd-&gt;rd_droppedSubid != InvalidSubTransactionId)</span><br><span class="line">		&#123;</span><br><span class="line">			Assert(!rd-&gt;is_valid);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 增加引用计数 */</span></span><br><span class="line">		RelationIncrementReferenceCount(rd);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 是否需要重新验证有效性 */</span></span><br><span class="line">		<span class="keyword">if</span> (!rd-&gt;rd_isvalid)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 索引只有有限的几种可能的模式变化，我们不想使用完整的过程，</span></span><br><span class="line"><span class="comment">			 * 因为这对重载本身所依赖的索引来说是一个令人头痛的问题。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (rd-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||</span><br><span class="line">				rd-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)</span><br><span class="line">				RelationReloadIndexInfo(rd);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				RelationClearRelation(rd, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			Assert(rd-&gt;rd_isvalid ||</span><br><span class="line">					(rd-&gt;rd_isnailed &amp;&amp; !criticalRelcachesBuilt));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 缓存中不存在， 通过 RelationBuildDesc() 函数创建并加入到缓存 */</span></span><br><span class="line">	rd = RelationBuildDesc(relationId, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (RelationIsValid(rd))</span><br><span class="line">		RelationIncrementReferenceCount(rd);</span><br><span class="line">	<span class="keyword">return</span> rd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 RelCache 缓存的梳理暂时收住，后续找时间在整理关于 RelCache 失效、同步等流程。</p>
<h2 id="SysCache-缓存"><a href="#SysCache-缓存" class="headerlink" title="SysCache 缓存"></a>SysCache 缓存</h2><p>SysCache 用于缓存系统表的元组信息，它的初始化相对简单，但是其使用要比 RelCache 稍微复杂一些，它们的源码主要集中在以下 4 个文件中：</p>
<ul>
<li><code>src/backend/utils/cache/catcache.c</code></li>
<li><code>src/backend/utils/cache/syscache.c</code></li>
<li><code>src/include/utils/catcache.h</code></li>
<li><code>src/include/utils/syscache.h</code></li>
</ul>
<p>当然，还是从初始化开始，<code>InitCatalogCache()</code> 时 SysCache 初始化的入口，其实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">InitCatalogCache</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>		cacheId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保 SysCacheIdentifier 中的数量与 cacheinfo 中定义的数量相同 */</span></span><br><span class="line">	StaticAssertStmt(SysCacheSize == (<span class="keyword">int</span>) lengthof(cacheinfo),</span><br><span class="line">					 <span class="string">&quot;SysCacheSize does not match syscache.c&#x27;s array&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Assert(!CacheInitialized);</span><br><span class="line"></span><br><span class="line">	SysCacheRelationOidSize = SysCacheSupportingRelOidSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (cacheId = <span class="number">0</span>; cacheId &lt; SysCacheSize; cacheId++)</span><br><span class="line">	&#123;</span><br><span class="line">		SysCache[cacheId] = InitCatCache(cacheId,</span><br><span class="line">										 cacheinfo[cacheId].reloid,</span><br><span class="line">										 cacheinfo[cacheId].indoid,</span><br><span class="line">										 cacheinfo[cacheId].nkeys,</span><br><span class="line">										 cacheinfo[cacheId].key,</span><br><span class="line">										 cacheinfo[cacheId].nbuckets);</span><br><span class="line">		<span class="keyword">if</span> (!PointerIsValid(SysCache[cacheId]))</span><br><span class="line">			elog(ERROR, <span class="string">&quot;could not initialize cache %u (%d)&quot;</span>,</span><br><span class="line">				 cacheinfo[cacheId].reloid, cacheId);</span><br><span class="line">		<span class="comment">/* 记录 OID，之后可以通过二分查找加速查询 */</span></span><br><span class="line">		SysCacheRelationOid[SysCacheRelationOidSize++] =</span><br><span class="line">			cacheinfo[cacheId].reloid;</span><br><span class="line">		SysCacheSupportingRelOid[SysCacheSupportingRelOidSize++] =</span><br><span class="line">			cacheinfo[cacheId].reloid;</span><br><span class="line">		SysCacheSupportingRelOid[SysCacheSupportingRelOidSize++] =</span><br><span class="line">			cacheinfo[cacheId].indoid;</span><br><span class="line">		Assert(!RelationInvalidatesSnapshotsOnly(cacheinfo[cacheId].reloid));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Assert(SysCacheRelationOidSize &lt;= lengthof(SysCacheRelationOid));</span><br><span class="line">	Assert(SysCacheSupportingRelOidSize &lt;= lengthof(SysCacheSupportingRelOid));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 排序并去重，为二分查找做准备 */</span></span><br><span class="line">	pg_qsort(SysCacheRelationOid, SysCacheRelationOidSize,</span><br><span class="line">			 <span class="keyword">sizeof</span>(Oid), oid_compare);</span><br><span class="line">	SysCacheRelationOidSize =</span><br><span class="line">		qunique(SysCacheRelationOid, SysCacheRelationOidSize, <span class="keyword">sizeof</span>(Oid),</span><br><span class="line">				oid_compare);</span><br><span class="line"></span><br><span class="line">	pg_qsort(SysCacheSupportingRelOid, SysCacheSupportingRelOidSize,</span><br><span class="line">			 <span class="keyword">sizeof</span>(Oid), oid_compare);</span><br><span class="line">	SysCacheSupportingRelOidSize =</span><br><span class="line">		qunique(SysCacheSupportingRelOid, SysCacheSupportingRelOidSize,</span><br><span class="line">				<span class="keyword">sizeof</span>(Oid), oid_compare);</span><br><span class="line"></span><br><span class="line">	CacheInitialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心是 <code>InitCatCache()</code> 函数，该函数的主要任务就是分配内存，包括 <code>CacheHdr</code>、<code>CatCache</code> 和 <code>buckets</code> 的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CatCache *</span></span><br><span class="line"><span class="function"><span class="title">InitCatCache</span><span class="params">(<span class="keyword">int</span> id,</span></span></span><br><span class="line"><span class="params"><span class="function">			 Oid reloid,</span></span></span><br><span class="line"><span class="params"><span class="function">			 Oid indexoid,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">int</span> nkeys,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">const</span> <span class="keyword">int</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">int</span> nbuckets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CatCache	*cp;</span><br><span class="line">	MemoryContext oldcxt;</span><br><span class="line">	<span class="keyword">size_t</span>	sz;</span><br><span class="line">	<span class="keyword">int</span>		i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nbuckets 是在这个 catcache 中使用的哈希桶的初始数量。</span></span><br><span class="line"><span class="comment">	 * 如果太满，稍后会扩大。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * nbuckets 必须是 2 的幂。我们通过 Assert 而不是完整的运行</span></span><br><span class="line"><span class="comment">	 * 时检查来检查这一点，因为这些值将来自常量表。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Assert(nbuckets &gt; <span class="number">0</span> &amp;&amp; (nbuckets &amp; -nbuckets) == nbuckets);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 CacheMemoryContext 还没有创建，则先创建该内存上下文。</span></span><br><span class="line"><span class="comment">	 * 我们需要先切换到缓存上下文，这样我们的分配就不会在事务结束时消失。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!CacheMemoryContext)</span><br><span class="line">		CreateCacheMemoryContext();</span><br><span class="line"></span><br><span class="line">	oldcxt = MemoryContextSwitchTo(CacheMemoryContext);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一次运行，先初始化缓存组头 */</span></span><br><span class="line">	<span class="keyword">if</span> (CacheHdr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CacheHdr = (CatCacheHeader *) palloc(<span class="keyword">sizeof</span>(CatCacheHeader));</span><br><span class="line">		slist_init(&amp;CacheHdr-&gt;ch_caches);</span><br><span class="line">		CacheHdr-&gt;ch_ntup = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CATCACHE_STATS</span></span><br><span class="line">		<span class="comment">/* 设置进程退出时转储统计信息的回调函数 */</span></span><br><span class="line">		on_proc_exit(CatCachePrintStats, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 分配新的 CatCache 结构，并保持缓存对齐。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 注意：我们将内存置为 0 来正确初始化 dlist 头。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sz = <span class="keyword">sizeof</span>(CatCache) + PG_CACHE_LINE_SIZE;</span><br><span class="line">	cp = (CatCache *) CACHELINEALIGN(palloc0(sz));</span><br><span class="line">	cp-&gt;cc_bucket = palloc0(nbuckets * <span class="keyword">sizeof</span>(dlist_head));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 为这个缓存对应的关系初始化缓存的关系信息，并初始化一些新</span></span><br><span class="line"><span class="comment">	 * 缓存的其他内部字段。但暂时不要打开关系。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cp-&gt;id = id;</span><br><span class="line">	cp-&gt;cc_relname = <span class="string">&quot;(not known yet)&quot;</span>;</span><br><span class="line">	cp-&gt;cc_reloid = reloid;</span><br><span class="line">	cp-&gt;cc_indexoid = indexoid;</span><br><span class="line">	cp-&gt;cc_relisshared = <span class="literal">false</span>;	<span class="comment">/* temporary */</span></span><br><span class="line">	cp-&gt;cc_tupdesc = (TupleDesc) <span class="literal">NULL</span>;</span><br><span class="line">	cp-&gt;cc_ntup = <span class="number">0</span>;</span><br><span class="line">	cp-&gt;cc_nbuckets = nbuckets;</span><br><span class="line">	cp-&gt;cc_nkeys = nkeys;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nkeys; ++i)</span><br><span class="line">		cp-&gt;cc_keyno[i] = key[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调试信息，暂时可以不予理会 */</span></span><br><span class="line">	InitCatCache_DEBUG2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 头插法插入到缓存组头部 */</span></span><br><span class="line">	slist_push_head(&amp;CacheHdr-&gt;ch_caches, &amp;cp-&gt;cc_next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 返回前切换内存上下文 */</span></span><br><span class="line">	MemoryContextSwitchTo(oldcxt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程执行完成之后，其内存布局大致如下图所示：</p>
<img src="/2022/07/postgres-relcache-and-syscache/syscache-initialized.png" class="">

<p>上面的过程仅仅是分配内存和初始化缓存结构，在第一次使用该缓存时才会查询数据库以完成缓存的初始化。</p>
<p>接下来我们看看如何使用该缓存。PostgreSQL 提供了 <code>SearchSysCache()</code> 来查询缓存，它是对 <code>SearchCatCache()</code> 的封装，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HeapTuple</span></span><br><span class="line"><span class="function"><span class="title">SearchSysCache</span><span class="params">(<span class="keyword">int</span> cacheId</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum key1,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum key2,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum key3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum key4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Assert(cacheId &gt;= <span class="number">0</span> &amp;&amp; cacheId &lt; SysCacheSize &amp;&amp;</span><br><span class="line">		   PointerIsValid(SysCache[cacheId]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SearchCatCache(SysCache[cacheId], key1, key2, key3, key4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HeapTuple</span></span><br><span class="line"><span class="function"><span class="title">SearchCatCache</span><span class="params">(CatCache *cache,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum v1,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum v2,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum v3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   Datum v4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SearchCatCacheInternal(cache, cache-&gt;cc_nkeys, v1, v2, v3, v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的还有 <code>SearchSysCache1()</code>、<code>SearchSysCache2()</code>、<code>SearchSysCache3()</code> 和 <code>SearchSysCache4()</code>，它们将检查键的数量是否与其相等。它们最终会调用 <code>SearchCatCacheInternal()</code> 和 <code>SearchCatCacheMiss()</code> 函数，其调用关系如下图所示：</p>
<img src="/2022/07/postgres-relcache-and-syscache/syscache-call-flowchat.png" class="">

<p>不难看出其核心就在 <code>SearchCatCacheMiss()</code> 函数中，当缓存未命中时，它将读取表元组信息并将其加入到缓存中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pg_noinline HeapTuple</span></span><br><span class="line"><span class="function"><span class="title">SearchCatCacheMiss</span><span class="params">(CatCache *cache,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="keyword">int</span> nkeys,</span></span></span><br><span class="line"><span class="params"><span class="function">				   uint32 hashValue,</span></span></span><br><span class="line"><span class="params"><span class="function">				   Index hashIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">				   Datum v1,</span></span></span><br><span class="line"><span class="params"><span class="function">				   Datum v2,</span></span></span><br><span class="line"><span class="params"><span class="function">				   Datum v3,</span></span></span><br><span class="line"><span class="params"><span class="function">				   Datum v4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ScanKeyData	cur_skey[CATCACHE_MAXKEYS];</span><br><span class="line">	Relation	relation;</span><br><span class="line">	SysScanDesc	scandesc;</span><br><span class="line">	HeapTuple	ntp;</span><br><span class="line">	CatCTup	   *ct;</span><br><span class="line">	Datum		arguments[CATCACHE_MAXKEYS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化局部参数数组 */</span></span><br><span class="line">	arguments[<span class="number">0</span>] = v1;</span><br><span class="line">	arguments[<span class="number">1</span>] = v2;</span><br><span class="line">	arguments[<span class="number">2</span>] = v3;</span><br><span class="line">	arguments[<span class="number">3</span>] = v4;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 需要在关系中进行查找，复制 scankey 并填充键值。*/</span></span><br><span class="line">	<span class="built_in">memcpy</span>(cur_skey, cache-&gt;cc_skey, <span class="keyword">sizeof</span>(ScanKeyData) * nkeys);</span><br><span class="line">	cur_skey[<span class="number">0</span>].sk_argument = v1;</span><br><span class="line">	cur_skey[<span class="number">1</span>].sk_argument = v2;</span><br><span class="line">	cur_skey[<span class="number">2</span>].sk_argument = v3;</span><br><span class="line">	cur_skey[<span class="number">3</span>].sk_argument = v4;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 缓存中没有查找到 Tuple, 因此，我们需要打开表直接获取，如果找到，我们</span></span><br><span class="line"><span class="comment">	 * 会将其添加到缓存中；如果没有找到，我们将添加一个负缓存条目。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 负缓存条目是指 CatCTup 中没有关联的 tuple 的条目。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	relation = table_open(cache-&gt;cc_reloid, AccessShareLock);</span><br><span class="line"></span><br><span class="line">	scandesc = systable_beginscan(relation,</span><br><span class="line">								  cache-&gt;cc_indexoid,</span><br><span class="line">								  IndexScanOK(cache, cur_skey),</span><br><span class="line">								  <span class="literal">NULL</span>,</span><br><span class="line">								  nkeys,</span><br><span class="line">								  cur_skey);</span><br><span class="line"></span><br><span class="line">	ct = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (HeapTupleIsValid(ntp = systable_getnext(scandesc)))</span><br><span class="line">	&#123;</span><br><span class="line">		ct = CatalogCacheCreateEntry(cache, ntp, arguments,</span><br><span class="line">									 hashValue, hashIndex,</span><br><span class="line">									 <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">/* 立即增加引用计数 refcount = 1 */</span></span><br><span class="line">		ResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);</span><br><span class="line">		ct-&gt;refcount++;</span><br><span class="line">		ResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &amp;ct-&gt;tuple);</span><br><span class="line">		<span class="keyword">break</span>;	<span class="comment">/* 假设仅有一条记录匹配 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	systable_endscan(scandesc);</span><br><span class="line"></span><br><span class="line">	table_close(relation, AccessShareLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 tuple 没有找到，我们需要构建一个包含假元组的负缓存条目。</span></span><br><span class="line"><span class="comment">	 * 假元组具有正确的键列，但其他任何地方都为空。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 在 bootstrap 模式下，我们不需要构建负缓存条目，因为缓存失效机制不存在，</span></span><br><span class="line"><span class="comment">	 * 并且如果稍后创建元组则无法清除它们。（引导程序不执行更新，因此它不需</span></span><br><span class="line"><span class="comment">	 * 要缓存无效。）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ct == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (IsBootstrapProcessingMode())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		ct = CatalogCacheCreateEntry(cache, <span class="literal">NULL</span>, arguments,</span><br><span class="line">									 hashValue, hashIndex,</span><br><span class="line">									 <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		CACHE_elog(DEBUG2, <span class="string">&quot;SearchCatCache(%s): Contains %d/%d tuples&quot;</span>,</span><br><span class="line">				   cache-&gt;cc_relname, cache-&gt;cc_ntup, CacheHdr-&gt;ch_ntup);</span><br><span class="line">		CACHE_elog(DEBUG2, <span class="string">&quot;SearchCatCache(%s): put neg entry in bucket %d&quot;</span>,</span><br><span class="line">				   cache-&gt;cc_relname, hashIndex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 我们不返回负缓存条目给调用者，因此保持引用计数为 0。 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CACHE_elog(DEBUG2, <span class="string">&quot;SearchCatCache(%s): Contains %d/%d tuples&quot;</span>,</span><br><span class="line">			   cache-&gt;cc_relname, cache-&gt;cc_ntup, CacheHdr-&gt;ch_ntup);</span><br><span class="line">	CACHE_elog(DEBUG2, <span class="string">&quot;SearchCatCache(%s): put in bucket %d&quot;</span>,</span><br><span class="line">			   cache-&gt;cc_relname, hashIndex);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CATCACHE_STATS</span></span><br><span class="line">	cache-&gt;cc_newloads++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ct-&gt;tuple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CatalogCacheCreateEntry()</code> 负责创建一个 <code>CatCTup</code> 结构并将其加入到 <code>cache-&gt;cc_bucket</code>，其中 <code>hashIndex</code> 用于索引 <code>cache-&gt;cc_bucket</code>，下面是该函数主要流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CatCTup *</span></span><br><span class="line"><span class="function"><span class="title">CatalogCacheCreateEntry</span><span class="params">(CatCache *cache, HeapTuple ntp, Datum *arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">						uint32 hashValue, Index hashIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="keyword">bool</span> negative)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	[...]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ntp)</span><br><span class="line">	&#123;</span><br><span class="line">		[...]</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建一个正常的缓存条目 */</span></span><br><span class="line">		ct = (CatCTup *) palloc(<span class="keyword">sizeof</span>(CatCTup) +</span><br><span class="line">								MAXIMUM_ALIGNOF + dtp-&gt;t_len);</span><br><span class="line"></span><br><span class="line">		[...]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Assert(negative);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建一个负缓存条目 */</span></span><br><span class="line">		ct = (CatCTup *) palloc(<span class="keyword">sizeof</span>(CatCTup));</span><br><span class="line"></span><br><span class="line">		[...]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[...]</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 加入到缓存中 */</span></span><br><span class="line">	dlist_push_head(&amp;cache-&gt;cc_bucket[hashIndex], &amp;ct-&gt;cache_elem);</span><br><span class="line"></span><br><span class="line">	cache-&gt;cc_ntup++;</span><br><span class="line">	CacheHdr-&gt;ch_ntup++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当 hash 表的填充因子大于 2 时，我们需要增大桶数量。 */</span></span><br><span class="line">	<span class="keyword">if</span> (cache-&gt;cc_ntup &gt; cache-&gt;cc_nbuckets * <span class="number">2</span>)</span><br><span class="line">		RehashCatCache(cache);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们通过 <code>SearchSysCache()</code> 函数获取信息时，元组信息就会以 <code>CatCTup</code> 的形式缓存起来，其内存布局如下所示：</p>
<img src="/2022/07/postgres-relcache-and-syscache/syscache-read-tuple.png" class="">

<p>关于 SysCache 的分析暂时就到这里，这里面还有很多内容，如部分搜索（<code>CatCTup</code> 中 <code>struct catclist *c_list</code> 的处理，即 N 个键中前 K 个键的缓存处理）、缓存同步、失效等。</p>
<div class="just-for-fun">
笑林广记 - 哭麟

<p>孔子见死麟，哭之不置。<br>弟子谋所以慰之者，乃编钱挂牛体，告曰：“麟已活矣。”孔子观之曰：“这明明是一只村牛，不过多得几个钱耳。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 修改配置参数</title>
    <url>/2020/06/postgresql-alter-system/</url>
    <content><![CDATA[<p>今天在使用 <code>ALTER SYSTEM</code> 来修改 PostgreSQL 参数时遇到无法启动数据库的问题。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# ALTER SYSTEM SET shared_preload_libraries TO &#x27;pg_buffercache,passwordcheck&#x27;;</span><br><span class="line">ALTER SYSTEM</span><br><span class="line">postgres=# \q</span><br><span class="line">$ pg_ctl restart</span><br><span class="line">waiting for server to shut down.... done</span><br><span class="line">server stopped</span><br><span class="line">waiting for server to start....postgres: could not access directory &quot;/Users/japinli/Codes/postgresql/pg/data&quot;: No such file or directory</span><br><span class="line">Run initdb or pg_basebackup to initialize a PostgreSQL data directory.</span><br><span class="line"> stopped waiting</span><br><span class="line">pg_ctl: could not start server</span><br><span class="line">Examine the log output.</span><br></pre></td></tr></table></figure>

<p>你是否也遇到了这样的问题呢？其实这都是由于我们先入为主的思想导致的，<code>ALTER SYSTEM</code> 支持以逗号分割的列表，而这类参数的修改不需要使用引号。因此，正确的使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER SYSTEM SET shared_preload_libraries TO pg_buffercache, passwordcheck;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们看看 pg_ctl 在启动时是如何加载 <code>shared_preload_libraries</code> 配置文件的。这里我们需要注意的是 pg_ctl 最终还是调用 postgres 来启动。通过分析我们可以发现 <code>shared_preload_libraries</code> 参数是在 <code>PostmasterMain()</code> 函数中调用 <code>process_shared_preload_libraries()</code> 来处理的，该函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">process_shared_preload_libraries</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process_shared_preload_libraries_in_progress = <span class="literal">true</span>;</span><br><span class="line">    load_libraries(shared_preload_libraries_string,</span><br><span class="line">                   <span class="string">&quot;shared_preload_libraries&quot;</span>,</span><br><span class="line">                   <span class="literal">false</span>);</span><br><span class="line">    process_shared_preload_libraries_in_progress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，<code>shared_preload_libraries</code> 是通过 <code>load_libraries()</code> 函数处理的，<code>load_libraries()</code> 函数则是通过 <code>SplitDirectoriesString()</code> 函数来处理的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">SplitDirectoriesString</span><span class="params">(<span class="keyword">char</span> *rawstring, <span class="keyword">char</span> separator,</span></span></span><br><span class="line"><span class="params"><span class="function">                       List **namelist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>       *nextp = rawstring;</span><br><span class="line">    <span class="keyword">bool</span>        done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *namelist = NIL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scanner_isspace(*nextp))</span><br><span class="line">        nextp++;                <span class="comment">/* skip leading whitespace */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*nextp == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">/* allow empty string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* At the top of the loop, we are at start of a new directory. */</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>       *curname;</span><br><span class="line">        <span class="keyword">char</span>       *endp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*nextp == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Quoted name --- collapse quote-quote pairs */</span></span><br><span class="line">            curname = nextp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                endp = <span class="built_in">strchr</span>(nextp + <span class="number">1</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (endp == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">/* mismatched quotes */</span></span><br><span class="line">                <span class="keyword">if</span> (endp[<span class="number">1</span>] != <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;      <span class="comment">/* found end of quoted name */</span></span><br><span class="line">                <span class="comment">/* Collapse adjacent quotes into one quote, and look again */</span></span><br><span class="line">                memmove(endp, endp + <span class="number">1</span>, <span class="built_in">strlen</span>(endp));</span><br><span class="line">                nextp = endp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* endp now points at the terminating quote */</span></span><br><span class="line">            nextp = endp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Unquoted name --- extends to separator or end of string */</span></span><br><span class="line">            curname = endp = nextp;</span><br><span class="line">            <span class="keyword">while</span> (*nextp &amp;&amp; *nextp != separator)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* trailing whitespace should not be included in name */</span></span><br><span class="line">                <span class="keyword">if</span> (!scanner_isspace(*nextp))</span><br><span class="line">                    endp = nextp + <span class="number">1</span>;</span><br><span class="line">                nextp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curname == endp)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">/* empty unquoted name not allowed */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner_isspace(*nextp))</span><br><span class="line">            nextp++;            <span class="comment">/* skip trailing whitespace */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*nextp == separator)</span><br><span class="line">        &#123;</span><br><span class="line">            nextp++;</span><br><span class="line">            <span class="keyword">while</span> (scanner_isspace(*nextp))</span><br><span class="line">                nextp++;        <span class="comment">/* skip leading whitespace for next */</span></span><br><span class="line">            <span class="comment">/* we expect another name, so done remains false */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*nextp == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">/* invalid syntax */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now safe to overwrite separator with a null */</span></span><br><span class="line">        *endp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Truncate path if it&#x27;s overlength */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(curname) &gt;= MAXPGPATH)</span><br><span class="line">            curname[MAXPGPATH - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Finished isolating current name --- add it to list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        curname = pstrdup(curname);</span><br><span class="line">        canonicalize_path(curname);</span><br><span class="line">        *namelist = lappend(*namelist, curname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Loop back if we didn&#x27;t reach end of string */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的 22-38 行代码，我们可以看到，postgres 在处理带有双引号的内容是将其作为一个整体来处理的，因此，我们的 <code>shared_preload_libraries</code> 配置无法通过。</p>
<p>关于 <code>shared_preload_libraries</code> 的处理流程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; PostmasterMain()</span><br><span class="line">    |</span><br><span class="line">    +-&gt; process_shared_preload_libraries()</span><br><span class="line">         |</span><br><span class="line">         +-&gt; load_libraries()</span><br><span class="line">              |</span><br><span class="line">              +-&gt; SplitDirectoriesString()</span><br></pre></td></tr></table></figure>

<p>那么为什么 <code>ALTER SYSTEM</code> 在写入时要加上双引号呢？我们先看看 <code>share_preload_libraries</code> 参数的相关设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;shared_preload_libraries&quot;</span>, PGC_POSTMASTER, CLIENT_CONN_PRELOAD,</span><br><span class="line">        gettext_noop(<span class="string">&quot;Lists shared libraries to preload into server.&quot;</span>),</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY</span><br><span class="line">    &#125;,</span><br><span class="line">    &amp;shared_preload_libraries_string,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>参数 <code>shared_preload_libraries</code> 的 <code>flag</code> 为 <code>GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY</code>，而我们使用的 <code>&#39;pg_buffercache,passwordcheck&#39;</code> 是作为一个整体，而不是 LIST 来处理的，因此，在写入是由于有特殊的分割符，所以就需要加上双引号，从而导致错误。</p>
<p>关于 <code>ALTER SYSTEM</code> 命令的处理可以查看 <code>gram.y</code> 中的 <code>AlterSystemStmt</code> 定义，随后接着分析 <code>AlterSystemSetConfigFile()</code> 函数，其处理流程大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; AlterSystemSetConfigFile()</span><br><span class="line">    |</span><br><span class="line">    +-&gt; ExtractSetVariableArgs()</span><br><span class="line">         |</span><br><span class="line">         +-&gt; ExtractSetVariableArgs()</span><br><span class="line">              |</span><br><span class="line">              +-&gt; flatten_set_variable_args()</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/10/sql-altersystem.html">https://www.postgresql.org/docs/10/sql-altersystem.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL auto_explain 插件内存泄露</title>
    <url>/2021/02/postgresql-auto-explain-memory-leak/</url>
    <content><![CDATA[<p>最近看到 PostgreSQL 邮件列表中有人说 auto_explain 插件在特定情况下会导致 OOM 问题，经过一番分析发现原来是由于内存上下文的问题导致的。目前该泄露已经修复，并合并到代码库中。</p>
<img src="/2021/02/postgresql-auto-explain-memory-leak/fix_memory_leak_in_auto_explain.png" class="">

<span id="more"></span>

<h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><p>首先我们来看看如何重现这个问题。首先，我们需要一个已运行的 PostgreSQL 数据库服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql postgres -c &#x27;ALTER SYSTEM SET shared_preload_libraries TO auto_explain;&#x27;</span><br><span class="line">$ pg_ctl restart</span><br><span class="line">$ psql postgres -c &#x27;ALTER SYSTEM SET auto_explain.log_min_duration TO 0;&#x27;</span><br><span class="line">$ psql postgres -c &#x27;ALTER SYSTEM SET auto_explain.log_nested_statements TO on;&#x27;</span><br><span class="line">$ pg_ctl restart</span><br></pre></td></tr></table></figure>

<p>接着，我们通过 psql 连接数据库，并创建如下函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> gibberish(<span class="type">int</span>) <span class="keyword">RETURNS</span> text</span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span> <span class="keyword">AS</span> $_$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">left</span>(string_agg(md5(random()::text),$$$$),$<span class="number">1</span>) <span class="keyword">FROM</span> generate_series(<span class="number">0</span>,$<span class="number">1</span><span class="operator">/</span><span class="number">32</span>)</span><br><span class="line">$_$;</span><br></pre></td></tr></table></figure>

<p>接着我们执行下面的查询命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    x, md5(random()::text) <span class="keyword">as</span> t11,</span><br><span class="line">    gibberish(<span class="number">1500</span>) <span class="keyword">as</span> t12</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    generate_series(<span class="number">1</span>,<span class="number">20e6</span>) f(x);</span><br></pre></td></tr></table></figure>

<p>这个为了简化我省略了 <code>CREATE TABLE j1 AS</code>，因为这个不是内存泄露的关键。在执行上述命令的时候，我们可以通过 <code>top -p &lt;pid&gt;</code> 去观察，发现确实是内存一直在增长。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为了缩写范围，我尝试将 auto_explain 插件移除，并执行上面的查询，发现内存并不会增长。那么内存泄露的问题就被缩小到了 auto_explain 代码中了，通过查看 auto_explain 源码，我发现这里面有两个地方会显示的调用内存分配 <code>explain_ExecutorStart()</code> 函数和 <code>explain_ExecutorEnd()</code>。该 bug 的发现者指出该内存泄露是发生在 SQL function 内存上下文中，经过调试我发现确实在执行 <code>explain_ExecutorEnd()</code> 函数时该内存上下文为 SQL function。</p>
<p>那么 SQL function 的内存上下文是什么时候创建的呢？通过查找，我发现它是在 <code>src/backend/executor/functions.c</code> 文件中的 <code>init_sql_fcache()</code> 函数中创建的。然而，在调用函数时 <code>fmgr_sql()</code> 函数中有如下注释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">fmgr_sql</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fcache == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        init_sql_fcache(fcinfo, PG_GET_COLLATION(), lazyEvalOK);</span><br><span class="line">        fcache = (SQLFunctionCachePtr) fcinfo-&gt;flinfo-&gt;fn_extra;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Switch to context in which the fcache lives.  This ensures that our</span></span><br><span class="line"><span class="comment">     * tuplestore etc will have sufficient lifetime.  The sub-executor is</span></span><br><span class="line"><span class="comment">     * responsible for deleting per-tuple information.  (XXX in the case of a</span></span><br><span class="line"><span class="comment">     * long-lived FmgrInfo, this policy represents more memory leakage, but</span></span><br><span class="line"><span class="comment">     * it&#x27;s not entirely clear where to keep stuff instead.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    oldcontext = MemoryContextSwitchTo(fcache-&gt;fcontext);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，SQL function 的内存上下文可能会存在较长的生命周期，那么我们频繁的在该内存上下文上分配内存，就有可能导致内存泄露，而 <code>explain_ExecutorEnd()</code> 函数执行时的内存上下文就是在 SQL function 内存上下文中，对于相对简单的查询，可能这并不会有什么问题，这也是这个内存泄露没有被即使发现的原因，当我们执行上面的查询时这个问题就暴露出来了。</p>
<p><strong>备注：</strong> 这里的内存泄露主要是 <code>explain_ExecutorEnd()</code> 函数中 <code>ExplainState</code> 结构的分配导致的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>那么这个问题这么解决呢？在分析了之后，我发现这个内存的分配其实在执行完 <code>ExecutorEnd()</code> 之后就不再需要了，因此我们可以将其放在每个查询的内存上下文中（即 <code>queryDesc-&gt;estate-&gt;es_query_cxt</code> 中），那么每次执行完之后该内存就被回收了，从而避免了内存泄露。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/contrib/auto_explain/auto_explain.c b/contrib/auto_explain/auto_explain.c</span><br><span class="line">index faa6231d87..445bb37191 100644</span><br><span class="line">--- a/contrib/auto_explain/auto_explain.c</span><br><span class="line">+++ b/contrib/auto_explain/auto_explain.c</span><br><span class="line">@@ -371,8 +371,15 @@ explain_ExecutorEnd(QueryDesc *queryDesc)</span><br><span class="line"> &#123;</span><br><span class="line"> 	if (queryDesc-&gt;totaltime &amp;&amp; auto_explain_enabled())</span><br><span class="line"> 	&#123;</span><br><span class="line">+		MemoryContext oldcxt;</span><br><span class="line"> 		double		msec;</span><br><span class="line"></span><br><span class="line">+		/*</span><br><span class="line">+		 * Make sure we operate in the per-query context, so any cruft will be</span><br><span class="line">+		 * discarded later during ExecutorEnd.</span><br><span class="line">+		 */</span><br><span class="line">+		oldcxt = MemoryContextSwitchTo(queryDesc-&gt;estate-&gt;es_query_cxt);</span><br><span class="line">+</span><br><span class="line"> 		/*</span><br><span class="line"> 		 * Make sure stats accumulation is done.  (Note: it&#x27;s okay if several</span><br><span class="line"> 		 * levels of hook all do this.)</span><br><span class="line">@@ -424,9 +431,9 @@ explain_ExecutorEnd(QueryDesc *queryDesc)</span><br><span class="line"> 					(errmsg(&quot;duration: %.3f ms  plan:\n%s&quot;,</span><br><span class="line"> 							msec, es-&gt;str-&gt;data),</span><br><span class="line"> 					 errhidestmt(true)));</span><br><span class="line">-</span><br><span class="line">-			pfree(es-&gt;str-&gt;data);</span><br><span class="line"> 		&#125;</span><br><span class="line">+</span><br><span class="line">+		MemoryContextSwitchTo(oldcxt);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	if (prev_ExecutorEnd)</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[1] <a href="https://www.postgresql.org/message-id/CAMkU%3D1wCVtbeRn0s9gt12KwQ7PLXovbpM8eg25SYocKW3BT4hg%40mail.gmail.com">memory leak in auto_explain</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL COPY CSV 中的 \. 引用问题</title>
    <url>/2022/09/postgresql-backslash-dot-quoting-in-copy/</url>
    <content><![CDATA[<p>本文简要记录一个由 psql 提供的 <code>\copy</code> 元命令引发的错误，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># \<span class="keyword">copy</span> tbl <span class="keyword">FROM</span> <span class="string">&#x27;/tmp/tbl.csv&#x27;</span> <span class="keyword">WITH</span> csv;</span><br><span class="line">ERROR:  unterminated CSV quoted field</span><br><span class="line">CONTEXT:  <span class="keyword">COPY</span> tbl, line <span class="number">1</span>: &quot;&quot;</span><br><span class="line">\.</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们通过 <code>COPY</code> 命令导入数据是，PostgreSQL 默认使用 <code>\.</code> 作为数据的分隔符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl (info text);</span><br><span class="line"><span class="keyword">COPY</span> tbl <span class="keyword">FROM</span> stdin <span class="keyword">WITH</span> csv;</span><br><span class="line"><span class="operator">&gt;&gt;</span> hello world</span><br><span class="line"><span class="operator">&gt;&gt;</span> \.</span><br><span class="line"><span class="keyword">COPY</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>现在让我们来看看下面的示例。首先我们将表清空，然后在插入一条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> tbl;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="string">&#x27;</span></span><br><span class="line"><span class="string">\.</span></span><br><span class="line"><span class="string">&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> info</span><br><span class="line">------</span><br><span class="line">     +</span><br><span class="line"> \.  +</span><br><span class="line"></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>接着我们将其导出到文件中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span> tbl <span class="keyword">TO</span> <span class="string">&#x27;/tmp/tbl.csv&#x27;</span> <span class="keyword">WITH</span> csv;</span><br></pre></td></tr></table></figure>

<p>查看 <code>/tmp/tbl.csv</code>，数据成功导出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /tmp/tbl.csv</span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">\.</span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>PostgreSQL 支持 <code>COPY</code> 和 <code>\copy</code> 两种方式。<code>COPY</code> 的方式是在服务器端执行，而 <code>\copy</code> 是 psql 提供的命令，它是在客户端执行的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span> tbl <span class="keyword">FROM</span> <span class="string">&#x27;/tmp/tbl.csv&#x27;</span> <span class="keyword">WITH</span> csv;</span><br><span class="line"><span class="keyword">SELECT</span> ctid, <span class="operator">*</span> <span class="keyword">FROM</span> tbl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ctid  | info</span><br><span class="line">-------+------</span><br><span class="line"> (0,1) |     +</span><br><span class="line">       | \.  +</span><br><span class="line">       |</span><br><span class="line"> (0,2) |     +</span><br><span class="line">       | \.  +</span><br><span class="line">       |</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>当我们使用 <code>\copy</code> 导入时，数据将无法导入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">copy</span> tbl <span class="keyword">FROM</span> <span class="string">&#x27;/tmp/tbl.csv&#x27;</span> <span class="keyword">WITH</span> csv;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:  unterminated CSV quoted field</span><br><span class="line">CONTEXT:  COPY tbl, line 1: &quot;&quot;</span><br><span class="line">\.</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过调试，我们可以看到无论是 <code>COPY</code> 还是 <code>\copy</code>，最后都是执行 <code>CopyGetData()</code> 函数，其堆栈如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  CopyGetData (cstate=0x555743f07418, databuf=0x555743faaf50, minread=1, maxread=65536)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:247</span><br><span class="line">#1  0x00005557425c18da in CopyLoadRawBuf (cstate=0x555743f07418)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:627</span><br><span class="line">#2  0x00005557425c1a95 in CopyLoadInputBuf (cstate=0x555743f07418)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:689</span><br><span class="line">#3  0x00005557425c2df2 in CopyReadLineText (cstate=0x555743f07418)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:1186</span><br><span class="line">#4  0x00005557425c29cf in CopyReadLine (cstate=0x555743f07418)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:1044</span><br><span class="line">#5  0x00005557425c1f20 in NextCopyFromRawFields (cstate=0x555743f07418,</span><br><span class="line">    fields=0x7ffd4b9f0d88, nfields=0x7ffd4b9f0d64)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:820</span><br><span class="line">#6  0x00005557425c21f3 in NextCopyFrom (cstate=0x555743f07418, econtext=0x555743fbb298,</span><br><span class="line">    values=0x555743fa69f8, nulls=0x555743fa6a00)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfromparse.c:882</span><br><span class="line">#7  0x00005557425bebfc in CopyFrom (cstate=0x555743f07418)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copyfrom.c:859</span><br><span class="line">#8  0x00005557425bb88d in DoCopy (pstate=0x555743f01840, stmt=0x555743ee1518,</span><br><span class="line">    stmt_location=0, stmt_len=29, processed=0x7ffd4b9f11a0)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/commands/copy.c:298</span><br><span class="line">#9  0x0000555742905c21 in standard_ProcessUtility (pstmt=0x555743ee18e0,</span><br><span class="line">    queryString=0x555743ee09d0 &quot;COPY  tbl FROM STDIN WITH csv;&quot;, readOnlyTree=false,</span><br><span class="line">    context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x555743ee19d0,</span><br><span class="line">    qc=0x7ffd4b9f1510)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/tcop/utility.c:742</span><br><span class="line">#10 0x00005557429055b9 in ProcessUtility (pstmt=0x555743ee18e0,</span><br><span class="line">    queryString=0x555743ee09d0 &quot;COPY  tbl FROM STDIN WITH csv;&quot;, readOnlyTree=false,</span><br><span class="line">    context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x555743ee19d0,</span><br><span class="line">    qc=0x7ffd4b9f1510)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/tcop/utility.c:530</span><br></pre></td></tr></table></figure>

<p>函数 <code>CopyGetData()</code> 将根据数据的来源不同获取数据，具体来说，上面的 <code>COPY</code> 和 <code>\copy</code> 两条语句的数据来源分别为 <code>COPY_FILE</code> 和 <code>COPY_FRONTEND</code>。<code>COPY_FILE</code> 的方式是读本地文件（服务器端的），而 <code>COPY_FRONTEND</code> 则是读取客户端的数据（由 <code>pq_getmessage()</code> 函数完成）。</p>
<p>现在，我们可以将问题范围的缩小到 psql 端了。那么我们看看 psql 端是如何处理 <code>\copy</code> 命令。其执行的堆栈信息如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  handleCopyIn (conn=0x5618b20ac2b0, copystream=0x5618b20b5390, isbinary=false,</span><br><span class="line">    res=0x7ffcd76cf5b0) at /mnt/workspace/postgresql/build/../src/bin/psql/copy.c:514</span><br><span class="line">#1  0x00005618b053aa9d in HandleCopyResult (resultp=0x7ffcd76cf608)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/bin/psql/common.c:939</span><br><span class="line">#2  0x00005618b053bc79 in ExecQueryAndProcessResults (</span><br><span class="line">    query=0x5618b20da760 &quot;COPY  tbl FROM STDIN WITH csv;&quot;, elapsed_msec=0x7ffcd76cf698,</span><br><span class="line">    svpt_gone_p=0x7ffcd76cf68c, is_watch=false, opt=0x0, printQueryFout=0x0)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/bin/psql/common.c:1565</span><br><span class="line">#3  0x00005618b053b19f in SendQuery (</span><br><span class="line">    query=0x5618b20da760 &quot;COPY  tbl FROM STDIN WITH csv;&quot;)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/bin/psql/common.c:1172</span><br><span class="line">#4  0x00005618b053e4e0 in do_copy (</span><br><span class="line">    args=0x5618b20da4c0 &quot;tbl FROM &#x27;/tmp/tbl.csv&#x27; WITH csv;&quot;)</span><br></pre></td></tr></table></figure>

<p>从上面的信息我们可以得知，<code>\copy</code> 命令被转换成 <code>COPY ... FROM STDIN WITH csv;</code>，随后在 <code>handleCopyIn()</code> 函数中读取文件内容并发送到服务器端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">handleCopyIn</span><span class="params">(PGconn *conn, FILE *copystream, <span class="keyword">bool</span> isbinary, PGresult **res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">            fgresult = fgets(&amp;buf[buflen], COPYBUFSIZ - buflen, copystream);</span><br><span class="line"></span><br><span class="line">            sigint_interrupt_enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!fgresult)</span><br><span class="line">                copydone = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>         linelen;</span><br><span class="line"></span><br><span class="line">                linelen = <span class="built_in">strlen</span>(fgresult);</span><br><span class="line">                buflen += linelen;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* current line is done? */</span></span><br><span class="line">                <span class="keyword">if</span> (buf[buflen - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* check for EOF marker, but not on a partial line */</span></span><br><span class="line">                    <span class="keyword">if</span> (at_line_begin)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * This code erroneously assumes &#x27;\.&#x27; on a line alone</span></span><br><span class="line"><span class="comment">                         * inside a quoted CSV string terminates the \copy.</span></span><br><span class="line"><span class="comment">                         * https://www.postgresql.org/message-id/E1TdNVQ-0001ju-GO@wrigleys.postgresql.org</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((linelen == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(fgresult, <span class="string">&quot;\\.\n&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>) ||</span><br><span class="line">                            (linelen == <span class="number">4</span> &amp;&amp; <span class="built_in">memcmp</span>(fgresult, <span class="string">&quot;\\.\r\n&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            copydone = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (copystream == pset.cur_cmd_source)</span><br><span class="line">                    &#123;</span><br><span class="line">                        pset.lineno++;</span><br><span class="line">                        pset.stmt_lineno++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    at_line_begin = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    at_line_begin = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看到，psql 中的 <code>\copy</code> 命令是按行读取（fgets() 函数），然后判断是否为 <code>\.</code>，若是则代表结束，它无法处理当前内容是否在引号内，因此，psql 只发送了部分数据到服务器从而导致了错误。</p>
<p>下面是 Tom Lane 对于这个问题的看法。大意就是在文档中添加一个警告事项。</p>
<blockquote>
<p>A documentation warning might be the appropriate response.  I don’t see any plausible way for psql to actually fix the problem, short of a protocol change to allow the backend to tell it how the data stream is going to be parsed.</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/flat/E1TdNVQ-0001ju-GO%40wrigleys.postgresql.org">https://www.postgresql.org/message-id/flat/E1TdNVQ-0001ju-GO%40wrigleys.postgresql.org</a><br>[2] <a href="https://www.postgresql.org/message-id/10e3eff6-eb04-4b3f-aeb4-b920192b977a%40manitou-mail.org">https://www.postgresql.org/message-id/10e3eff6-eb04-4b3f-aeb4-b920192b977a%40manitou-mail.org</a></p>
<div class="just-for-fun">
笑林广记 - 训子

<p>富翁子不识字，人劝以延师训子。先学一字是一画，次二字是二画，次三字三画。<br>其子便欣然投笔告父曰：“儿已都晓字义，何用师为？”<br>父喜之乃谢去。一日父欲招万姓者饮，命子晨起治状，至午不见写成。<br>父往询之，子恚曰：“姓亦多矣，如何偏姓万，自早至今才得五百画哩！”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 13 - backtrace 功能预览</title>
    <url>/2020/08/postgresql-backtrace/</url>
    <content><![CDATA[<p>目前在 Greenplum、MySQL 数据库中均支持 backtrace 功能，现在 PostgreSQL 13-devel 版本中也新增了这个功能，我们可以在服务器日志中记录堆栈信息。</p>
<img src="/2020/08/postgresql-backtrace/backtrace.png" class="" title="Backtrace 提交记录">

<p>本文将对该功能进行简要介绍。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PostgreSQL 13 数据库提供了一个参数 <code>backtrace_functions</code> 来控制堆栈信息的生成，该参数是包含C函数名称的逗号分隔列表。如果出现错误，并且该错误是由 <code>backtrace_functions</code> 中的 C 函数引发的，那么将会把堆栈信息记录到服务器日志文件中。这个选项可以方便我们调试特定区域的源代码。</p>
<p>目前并非所有平台都支持 backtrace 功能，并且其堆栈信息的质量也取决于编译选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET backtrace_functions TO &#x27;ProcessUtility,ExecutorStart&#x27;;</span><br></pre></td></tr></table></figure>

<p>该参数仅超级用户可以设置，它可以在 postgresql.conf 中进行全局设置，也可以针对某个会话进行设置。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在这里我们通过创建一个不存在的类型来演示如何使用 backtrace 功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE TABLE foo(id invalidtype);</span><br><span class="line">ERROR:  type &quot;invalidtype&quot; does not exist</span><br><span class="line">LINE 1: CREATE TABLE foo(id invalidtype);</span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，我们输入的数据类型不存在，下面是服务器端的日志信息。总的来说信息是很有限的，我们无法得知更多的细节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-08-15 18:03:35.857 CST [1666] ERROR:  type &quot;invalidtype&quot; does not exist at character 21</span><br><span class="line">2020-08-15 18:03:35.857 CST [1666] STATEMENT:  CREATE TABLE foo(id invalidtype);</span><br></pre></td></tr></table></figure>

<p>现在我们来试试 backtrace 大法。首先我们可以通过搜索源码的方法确定当前错误是来自那个内部的 C 函数。这里我们确定它是由 <code>typenameType()</code> 函数抱出来的。那么我们可以按如下方式进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SET backtrace_functions TO &#x27;typenameType&#x27;;</span><br><span class="line">SET</span><br><span class="line">postgres=# CREATE TABLE foo(id invalidtype);</span><br><span class="line">ERROR:  type &quot;invalidtype&quot; does not exist</span><br><span class="line">LINE 1: CREATE TABLE foo(id invalidtype);</span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure>

<p>虽然在用户看来并没有什么区别，但是服务器日志里面多出了一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-08-15 18:09:25.079 CST [1666] ERROR:  type &quot;invalidtype&quot; does not exist at character 21</span><br><span class="line">2020-08-15 18:09:25.079 CST [1666] BACKTRACE:</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(typenameType+0xb9) [0x563456c5f509]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x1dcbbc) [0x563456c60bbc]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(transformCreateStmt+0x4da) [0x563456c6412a]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d88c8) [0x563456e5c8c8]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(standard_ProcessUtility+0x230) [0x563456e5b7e0]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d5012) [0x563456e59012]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d5a93) [0x563456e59a93]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(PortalRun+0x161) [0x563456e5a611]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x3d2017) [0x563456e56017]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(PostgresMain+0x1ede) [0x563456e5842e]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(+0x355cda) [0x563456dd9cda]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(PostmasterMain+0xeff) [0x563456ddadef]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(main+0x4a4) [0x563456b45e94]</span><br><span class="line">        /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7) [0x7f5502994b97]</span><br><span class="line">        postgres: japin postgres [local] CREATE TABLE(_start+0x2a) [0x563456b45f5a]</span><br><span class="line">2020-08-15 18:09:25.079 CST [1666] STATEMENT:  CREATE TABLE foo(id invalidtype);</span><br></pre></td></tr></table></figure>

<p>从上面的 backtrace 可以看到整个流程是如何一步一步走到 <code>typenameType()</code> 函数的。Backtrace 的每一行都包含函数的名称，函数内的偏移位置，以及栈帧的返回地址。在某些栈帧上，函数名称并没有出现，取而代之的是一个地址，这些函数是静态函数，它们的名字不会被导出，不过我们也可能通过它们的地址来获取其对应的函数名称。例如，<code>typenameType()</code> 函数的上层函数只是一个地址，我们并不知道其对应的函数是什么，这时我们可以使用下面的命令来进行转换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> addr2line 0x1dcbbc -a -f -e `<span class="built_in">which</span> postgres`</span></span><br><span class="line">0x00000000001dcbbc</span><br><span class="line">transformColumnDefinition</span><br><span class="line">parse_utilcmd.c:?</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>0x1dcbbc</code> 这个地址对应的是 <code>transformColumnDefinition()</code> 函数，它位于 <code>parse_utilcmd.c</code> 文件中。由于这里是采用的 <code>-O2</code> 优化，没能查看到更多的信息，如果我们使用 <code>-O0</code>，那么其查询的信息将更为丰富，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> addr2line +0x2525e6 -a -f -e `<span class="built_in">which</span> postgres`</span></span><br><span class="line">0x00000000002525e6</span><br><span class="line">transformColumnDefinition</span><br><span class="line">/home/japin/Codes/postgresql/Debug/../src/backend/parser/parse_utilcmd.c:568</span><br></pre></td></tr></table></figure>

<p>上面两次查看的地址不一致是因为重新编译生成的文件不同导致的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们对于 backtrace 的功能有了基本的了解，接下来我们来看看它是如何实现的。</p>
<p>该功能是通过 <code>backtrace()</code> 和 <code>backtrace_symbols()</code> 这两个简单的函数来生成堆栈信息，<code>backtrace()</code> 函数仅返回所有栈帧的返回地址，接着调用 <code>backtrace_symbols()</code> 函数来将这些地址转换为描述这个函数的字符串，PostgreSQL backtrace功能的其核心代码主要集中在 <code>set_backtrace()</code> 函数中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compute backtrace data and add it to the supplied ErrorData.  num_skip</span></span><br><span class="line"><span class="comment"> * specifies how many inner frames to skip.  Use this to avoid showing the</span></span><br><span class="line"><span class="comment"> * internal backtrace support functions in the backtrace.  This requires that</span></span><br><span class="line"><span class="comment"> * this and related functions are not inlined.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">set_backtrace</span><span class="params">(ErrorData *edata, <span class="keyword">int</span> num_skip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StringInfoData errtrace;</span><br><span class="line"></span><br><span class="line">	initStringInfo(&amp;errtrace);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE_SYMBOLS</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">void</span>	   *buf[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span>			nframes;</span><br><span class="line">		<span class="keyword">char</span>	  **strfrms;</span><br><span class="line"></span><br><span class="line">		nframes = backtrace(buf, lengthof(buf));</span><br><span class="line">		strfrms = backtrace_symbols(buf, nframes);</span><br><span class="line">		<span class="keyword">if</span> (strfrms == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = num_skip; i &lt; nframes; i++)</span><br><span class="line">			appendStringInfo(&amp;errtrace, <span class="string">&quot;\n%s&quot;</span>, strfrms[i]);</span><br><span class="line">		<span class="built_in">free</span>(strfrms);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	appendStringInfoString(&amp;errtrace,</span><br><span class="line">						   <span class="string">&quot;backtrace generation is not supported by this installation&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	edata-&gt;backtrace = errtrace.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set_backtrace()</code> 函数通过 <code>backtrace()</code> 和 <code>backtrace_symbols()</code> 函数来获取堆栈信息，并将其添加到 <code>edata-&gt;backtrace</code> 字段中（方便后续处理），<code>num_skip</code> 参数指定了需要跳过的内部栈的数量，这是由于我们报错的地方实际上并不是 <code>set_backtrace()</code> 函数位置，而是在调用该函数的位置（可能是一层或多层），因此，我们需要定位到真实报错的地方，从这个地方开始输出堆栈信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://amitdkhan-pg.blogspot.com/2020/07/backtraces-in-postgresql.html">https://amitdkhan-pg.blogspot.com/2020/07/backtraces-in-postgresql.html</a><br>[2] <a href="https://www.postgresql.org/docs/devel/runtime-config-developer.html">https://www.postgresql.org/docs/devel/runtime-config-developer.html</a><br>[3] <a href="https://github.com/postgres/postgres/commit/71a8a4f6e36547bb060dbcc961ea9b57420f7190">https://github.com/postgres/postgres/commit/71a8a4f6e36547bb060dbcc961ea9b57420f7190</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 15 特性 - 基础备份存储位置</title>
    <url>/2022/01/postgresql-basebackup-target/</url>
    <content><![CDATA[<p>最近 Robert Haas 提交了一个关于 pg_basebackup 指定备份存储位置的功能，详细信息如下：</p>
<pre><code>commit 3500ccc39b0dadd1068a03938e4b8ff562587ccc
Author: Robert Haas &lt;rhaas@postgresql.org&gt;
Date:   Tue Nov 16 15:20:50 2021 -0500

    Support base backup targets.

    pg_basebackup now has a --target=TARGET[:DETAIL] option. If specfied,
    it is sent to the server as the value of the TARGET option to the
    BASE_BACKUP command. If DETAIL is included, it is sent as the value of
    the new TARGET_DETAIL option to the BASE_BACKUP command.  If the
    target is anything other than &#39;client&#39;, pg_basebackup assumes that it
    will now be the server&#39;s job to write the backup in a location somehow
    defined by the target, and that it therefore needs to write nothing
    locally. However, the server will still send messages to the client
    for progress reporting purposes.

    On the server side, we now support two additional types of backup
    targets.  There is a &#39;blackhole&#39; target, which just throws away the
    backup data without doing anything at all with it. Naturally, this
    should only be used for testing and debugging purposes, since you will
    not actually have a backup when it finishes running. More usefully,
    there is also a &#39;server&#39; target, so you can now use something like
    &#39;pg_basebackup -Xnone -t server:/SOME/PATH&#39; to write a backup to some
    location on the server. We can extend this to more types of targets
    in the future, and might even want to create an extensibility
    mechanism for adding new target types.

    Since WAL fetching is handled with separate client-side logic, it&#39;s
    not part of this mechanism; thus, backups with non-default targets
    must use -Xnone or -Xfetch.

    Patch by me, with a bug fix by Jeevan Ladhe.  The patch set of which
    this is a part has also had review and/or testing from Tushar Ahuja,
    Suraj Kharage, Dipesh Pandit, and Mark Dilger.

    Discussion: http://postgr.es/m/CA+TgmoaYZbz0=Yk797aOJwkGJC-LK3iXn+wzzMx7KdwNpZhS5g@mail.gmail.com
</code></pre>
<span id="more"></span>

<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>该提交为 pg_basebackup 命令引入了一个新的选项 <code>--target=target, -t target</code>。该选择可以指定备份的存储的位置，可能的值为：</p>
<ul>
<li><code>client</code> - 备份到运行 pg_basebackup 命令所在的机器，这是默认选项。</li>
<li><code>server</code> - 备份到运行数据库服务所在的机器，该选项还需给出记录的备份目录, 即 <code>server:/some/path</code>，在数据库服务器上备份需要超级用户权限。</li>
<li><code>blackhole</code> - 备份文件将被丢弃并不会被存储，这仅用于测试目的。</li>
</ul>
<p><strong>注意：</strong>由于 WAL 日志流是在 pg_basebackup 端，而不是数据库服务端实现的，因此这个选项不能和 <code>-Xstream</code> 一起使用。<code>-Xstream</code> 是默认选项，因此当使用该选项时，您需要指定 <code>-Xfetch</code> 或 <code>-Xnone</code> 选项。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先简要介绍一下环境，如下所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>数据库主机</td>
<td>172.16.105.2</td>
<td>数据库服务器</td>
</tr>
<tr>
<td>备份主机</td>
<td>172.16.105.3</td>
<td>pg_basebackup</td>
</tr>
</tbody></table>
<p>关于数据库的远程访问以及流复制的相关配置就不再细说了，直接进入主题。</p>
<h3 id="服务器端备份"><a href="#服务器端备份" class="headerlink" title="服务器端备份"></a>服务器端备份</h3><p>我们首先来验证一下 <code>server</code> 模式的备份。首先在备份主机上执行 pg_basebackup 命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -v -h 172.16.105.2 -t server:/tmp/pgdata01 -d <span class="string">&quot;dbname=postgres&quot;</span> -Xfetch</span></span><br><span class="line">Password:</span><br><span class="line">pg_basebackup: initiating base backup, waiting for checkpoint to complete</span><br><span class="line">pg_basebackup: checkpoint completed</span><br><span class="line">pg_basebackup: write-ahead log start point: 0/6000028 on timeline 1</span><br><span class="line">pg_basebackup: write-ahead log end point: 0/6000100</span><br><span class="line">pg_basebackup: base backup completed</span><br></pre></td></tr></table></figure>

<p>接着我们在数据库主机上查看是否创建相关的备份文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp/pgdata01/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">backup_manifest  base.tar</span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xf base.tar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">PG_VERSION        pg_commit_ts   pg_notify     pg_subtrans           postgresql.conf</span><br><span class="line">backup_label.old  pg_dynshmem    pg_replslot   pg_tblspc             postmaster.opts</span><br><span class="line">backup_manifest   pg_hba.conf    pg_serial     pg_twophase           tablespace_map.old</span><br><span class="line">base              pg_ident.conf  pg_snapshots  pg_wal</span><br><span class="line">global            pg_logical     pg_stat       pg_xact</span><br><span class="line">log_backup        pg_multixact   pg_stat_tmp   postgresql.auto.conf</span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l log_backup start</span></span><br><span class="line">waiting for server to start.... done</span><br><span class="line">server started</span><br></pre></td></tr></table></figure>

<p>一切正常。当我们尝试用 <code>-Xstream</code> 来进行服务器端备份，可以看到如文档所说，不支持这种方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -v -h 172.16.105.2 -t server:/tmp/pgdata02 -d <span class="string">&quot;dbname=postgres&quot;</span></span></span><br><span class="line">pg_basebackup: error: WAL cannot be streamed when a backup target is specified</span><br><span class="line">Try &quot;pg_basebackup --help&quot; for more information.</span><br></pre></td></tr></table></figure>

<h3 id="客户端备份"><a href="#客户端备份" class="headerlink" title="客户端备份"></a>客户端备份</h3><p>接着我们尝试客户端备份，在备份主机上执行 pg_basebackup 命令进行备份，随后在该主机上查看备份结果。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -v -h 172.16.105.2 -t client -D /tmp/pgdata01 -d <span class="string">&quot;dbname=postgres&quot;</span> -Xfetch</span></span><br><span class="line">Password:</span><br><span class="line">pg_basebackup: initiating base backup, waiting for checkpoint to complete</span><br><span class="line">pg_basebackup: checkpoint completed</span><br><span class="line">pg_basebackup: write-ahead log start point: 0/8000028 on timeline 1</span><br><span class="line">pg_basebackup: write-ahead log end point: 0/8000100</span><br><span class="line">pg_basebackup: syncing data to disk ...</span><br><span class="line">pg_basebackup: renaming backup_manifest.tmp to backup_manifest</span><br><span class="line">pg_basebackup: base backup completed</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /tmp/pgdata01/</span></span><br><span class="line">PG_VERSION       global        pg_ident.conf  pg_replslot   pg_stat_tmp  pg_wal</span><br><span class="line">backup_label     pg_commit_ts  pg_logical     pg_serial     pg_subtrans  pg_xact</span><br><span class="line">backup_manifest  pg_dynshmem   pg_multixact   pg_snapshots  pg_tblspc    postgresql.auto.conf</span><br><span class="line">base             pg_hba.conf   pg_notify      pg_stat       pg_twophase  postgresql.conf</span><br></pre></td></tr></table></figure>

<p><strong>这里需要注意的是，客户端备份的结果是目录结构（可以通过 <code>-F format</code> 或 <code>--format=format</code> 选项来进行指定），而服务端备份的结果是压缩文件（服务端备份不能和 <code>-F format</code> 或 <code>--format=format</code> 选项一起使用）。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -v -h 172.16.105.2 -t server:/tmp/pgdata02 -d <span class="string">&quot;dbname=postgres&quot;</span> -Xfetch -Fp</span></span><br><span class="line">pg_basebackup: error: cannot specify both format and backup target</span><br><span class="line">Try &quot;pg_basebackup --help&quot; for more information.</span><br></pre></td></tr></table></figure>

<p>客户端备份与 <code>-F format</code> 选项结合使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -v -h 172.16.105.2 -t client -D /tmp/pgdata02 -d <span class="string">&quot;dbname=postgres&quot;</span> -Xfetch -Ft</span></span><br><span class="line">Password:</span><br><span class="line">pg_basebackup: initiating base backup, waiting for checkpoint to complete</span><br><span class="line">pg_basebackup: checkpoint completed</span><br><span class="line">pg_basebackup: write-ahead log start point: 0/A000028 on timeline 1</span><br><span class="line">pg_basebackup: write-ahead log end point: 0/A000100</span><br><span class="line">pg_basebackup: syncing data to disk ...</span><br><span class="line">pg_basebackup: renaming backup_manifest.tmp to backup_manifest</span><br><span class="line">pg_basebackup: base backup completed</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /tmp/pgdata02/</span></span><br><span class="line">backup_manifest  base.tar</span><br></pre></td></tr></table></figure>

<h3 id="黑洞备份"><a href="#黑洞备份" class="headerlink" title="黑洞备份"></a>黑洞备份</h3><p>顾名思义，这种备份方式就好比数据掉进了黑洞，这种备份方式仅用于测试的目的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -v -h 172.16.105.2 -t blackhole -d <span class="string">&quot;dbname=postgres&quot;</span> -Xfetch</span></span><br><span class="line">Password:</span><br><span class="line">pg_basebackup: initiating base backup, waiting for checkpoint to complete</span><br><span class="line">pg_basebackup: checkpoint completed</span><br><span class="line">pg_basebackup: write-ahead log start point: 0/C000028 on timeline 1</span><br><span class="line">pg_basebackup: write-ahead log end point: 0/C000100</span><br><span class="line">pg_basebackup: base backup completed</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pg_basebackup 新增的备份功能在使用时有如下限制的：</p>
<ul>
<li>不能与 <code>-Xstream</code> 选项结合使用；</li>
<li>不能与 <code>-F format</code> 选项结合使用；</li>
<li>使用 <code>-t client</code> 需要结合 <code>-D /some/path</code> 给出数据存储目录。</li>
</ul>
<p>此外，在 PostgreSQL 15 版本中对 pg_basebackup 的压缩选项也做了部分修改，支持指定压缩算法的压缩级别，扩展了原有的 <code>-Z level</code> 和 <code>--compress=level</code> 选项，<code>-Z method[:level]</code> 和 <code>--compress=method[:level]</code>。</p>
<ul>
<li><code>-z/gizp</code> 是 <code>--compress=gzip</code> 的同义词。</li>
<li><code>--compress=NUM</code> 有如下含义：<ul>
<li>当 <code>NUM = 0</code> 时，等同于 <code>--compress=none</code>。</li>
<li>当 <code>NUM &gt; 0</code> 时，等同于 <code>--compress=gzip:NUM</code>。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://postgresql.org/docs/devel/app-pgbasebackup.html">https://postgresql.org/docs/devel/app-pgbasebackup.html</a><br>[2] <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=3500ccc39b0dadd1068a03938e4b8ff562587ccc">https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=3500ccc39b0dadd1068a03938e4b8ff562587ccc</a><br>[3] <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=5c649fe153367cdab278738ee4aebbfd158e0546">https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=5c649fe153367cdab278738ee4aebbfd158e0546</a></p>
<div class="just-for-fun">
笑林广记 - 纳粟诗

<p>赠纳粟诗曰：“革车（言三百两）买得截然高（言大也），周子窗前满腹包（言草也）。有朝若遇高曾祖（言考也），焕乎其有没分毫（言文章）。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>PG15</tag>
        <tag>pg_basebackup</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL buffer usage 溢出</title>
    <url>/2022/02/postgresql-buffer-usage-overflow/</url>
    <content><![CDATA[<p>今天灿灿（微信公众号：PostgreSQL 学徒）发来一个问题，说是日志中 <code>buffer usage</code> 出现了负数，如下所示。</p>
<img src="/2022/02/postgresql-buffer-usage-overflow/buffer-usage-overflow.png" class="">

<span id="more"></span>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>其实这就是一个数据类型溢出的问题，我第一时间想到的时查看一下这个变量的类型，然而，我发现 <code>VacuumPageHit</code> 是 <code>int64</code> 类型（$2^{63} = 9223372036854775808$），那这个溢出的概率就很小了，在结合其运行的时间来看，几乎不可能发生溢出。</p>
<p>随后又询问了一下他当前的数据库版本，发现是 11.9 版本，而我查看的是 master 分支代码，因此，存在一定的误差。通过查看 11.9 的源码，发现 <code>VacuumPageHit</code> 被定义为 <code>int</code> 类型（$2^{31} = 2147483648$），那么这个溢出就有很大的概率发生。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ag <span class="string">&#x27;VacuumPageHit&#x27;</span></span></span><br><span class="line">src/backend/utils/init/globals.c</span><br><span class="line">142:int                 VacuumPageHit = 0;</span><br><span class="line"></span><br><span class="line">src/backend/storage/buffer/bufmgr.c</span><br><span class="line">762:                    VacuumPageHit++;</span><br><span class="line"></span><br><span class="line">src/backend/commands/vacuum.c</span><br><span class="line">327:            VacuumPageHit = 0;</span><br><span class="line"></span><br><span class="line">src/backend/commands/vacuumlazy.c</span><br><span class="line">399:                                                     VacuumPageHit,</span><br><span class="line"></span><br><span class="line">src/include/miscadmin.h</span><br><span class="line">253:extern int  VacuumPageHit;</span><br></pre></td></tr></table></figure>

<p>这说明在最新的版本中针对这个问题进行了修改，那可以确定这个 bug 被记录在案。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 270,272 src/include/miscadmin.h</span></span><br><span class="line">15d13e82911 (Alvaro Herrera 2020-02-05 16:59:29 -0300 270) extern int64 VacuumPageHit;</span><br><span class="line">15d13e82911 (Alvaro Herrera 2020-02-05 16:59:29 -0300 271) extern int64 VacuumPageMiss;</span><br><span class="line">15d13e82911 (Alvaro Herrera 2020-02-05 16:59:29 -0300 272) extern int64 VacuumPageDirty;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到 <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=15d13e82911f7cc9f04f0bf419a96fd827fd1a9d">15d13e82911</a> 这个提交针对 <code>VacuumPageHit</code> 的类型进行了修改，那么这个溢出的问题必定是在这个提交中被修复了，详细的提交信息如下所示。</p>
<pre><code>commit 15d13e82911f7cc9f04f0bf419a96fd827fd1a9d
Author: Alvaro Herrera &lt;alvherre@alvh.no-ip.org&gt;
Date:   Wed Feb 5 16:59:29 2020 -0300

    Make vacuum buffer counters 64 bits wide

    Using 32 bit counters means they can now realistically wrap around when
    vacuuming extremely large tables.  Because they&#39;re signed integers,
    stats printed by vacuum look very odd when they do.

    We&#39;d love to backpatch this, but refrain because the variables are
    exported and could cause third-party code to break.

    Reviewed-by: Julien Rouhaud, Tom Lane, Michael Paquier
    Discussion: https://postgr.es/m/20200131205926.GA16367@alvherre.pgsql
</code></pre>
<p>提交信息验证了我的猜想，为了避免不必要的兼容性问题，这个 patch 并没有 backpatch 回其它分支，这个提交是在 13devel 中引入的，那么说明在 13 及其之后的版本都不会存在这个问题（前提是没有超过 <code>int64</code> 的范围）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/20200131205926.GA16367@alvherre.pgsql">https://www.postgresql.org/message-id/20200131205926.GA16367@alvherre.pgsql</a></p>
<div class="just-for-fun">
笑林广记 - 监生自大

<p>城里监生与乡下监生各要争大，城里者耻之曰：“我们见多识广，你乡里人孤陋寡闻。”<br>两人争辩不已，因往大街同行各见所长。<br>到一大第门首，匾上“大中丞”三字，城里监生倒看指谓曰：“这岂不是‘丞中大’乃一徵验。”<br>又到一宅，匾额是“大理卿”，乡下监生以“卿”字认做“乡”字，忙亦倒念指之曰：“这是‘乡里大’了。”<br>两人各不见高下。又来一寺门首，上题“大士阁”，彼此平心和议曰：“原来阁（各）士（自）大。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 聚簇索引</title>
    <url>/2019/11/postgresql-cluster-index/</url>
    <content><![CDATA[<p>聚簇索引是按照数据存放的物理位置为顺序的，每个表仅有一个聚簇索引。</p>
<p>MySQL 数据库中的 InnoDB 引擎中的主键即为聚簇索引，当我们在表上定义主键时，InnoDB 会将其用作聚簇索引，如果表上没有定义主键，那么 InnoDB 将会使用第一个全不为空的唯一性索引作为聚簇索引，如果表上即没有主键、也没有唯一性索引，那么 InnoDB 将会自动生成一个隐藏的 <code>GEN_CLUST_INDEX</code> 索引作为聚簇索引。</p>
<p>PostgreSQL 在创建表时并不能指定聚簇索引，但是我们可以通过 <code>CLUSTER</code> 来创建聚簇索引，本文主要介绍 PostgreSQL 数据库中的聚簇索引。</p>
<span id="more"></span>

<p>我们首先建立一个数据表，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE TABLE account (id integer, nickname text, password text);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres=# \d account</span><br><span class="line">               Table &quot;public.account&quot;</span><br><span class="line">  Column  |  Type   | Collation | Nullable | Default</span><br><span class="line">----------+---------+-----------+----------+---------</span><br><span class="line"> id       | integer |           |          |</span><br><span class="line"> nickname | text    |           |          |</span><br><span class="line"> password | text    |           |          |</span><br></pre></td></tr></table></figure>

<p>随后，我们随机插入一些数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# INSERT INTO account SELECT id, &#x27;user&#x27; || id::text, md5(id::text)</span><br><span class="line">postgres-# FROM generate_series(1, 100) id ORDER BY random();</span><br><span class="line">INSERT 0 100</span><br><span class="line">postgres=# SELECT ctid, * FROM account LIMIT 20;</span><br><span class="line">  ctid  | id | nickname |             password</span><br><span class="line">--------+----+----------+----------------------------------</span><br><span class="line"> (0,1)  | 85 | user85   | 3ef815416f775098fe977004015c6193</span><br><span class="line"> (0,2)  | 22 | user22   | b6d767d2f8ed5d21a44b0e5886680cb9</span><br><span class="line"> (0,3)  | 43 | user43   | 17e62166fc8586dfa4d1bc0e1742c08b</span><br><span class="line"> (0,4)  | 89 | user89   | 7647966b7343c29048673252e490f736</span><br><span class="line"> (0,5)  | 75 | user75   | d09bf41544a3365a46c9077ebb5e35c3</span><br><span class="line"> (0,6)  | 81 | user81   | 43ec517d68b6edd3015b3edc9a11367b</span><br><span class="line"> (0,7)  | 91 | user91   | 54229abfcfa5649e7003b83dd4755294</span><br><span class="line"> (0,8)  | 65 | user65   | fc490ca45c00b1249bbe3554a4fdf6fb</span><br><span class="line"> (0,9)  | 67 | user67   | 735b90b4568125ed6c3f678819b6e058</span><br><span class="line"> (0,10) | 11 | user11   | 6512bd43d9caa6e02c990b0a82652dca</span><br><span class="line"> (0,11) | 72 | user72   | 32bb90e8976aab5298d5da10fe66f21d</span><br><span class="line"> (0,12) | 36 | user36   | 19ca14e7ea6328a42e0eb13d585e4c22</span><br><span class="line"> (0,13) | 69 | user69   | 14bfa6bb14875e45bba028a21ed38046</span><br><span class="line"> (0,14) | 32 | user32   | 6364d3f0f495b6ab9dcf8d3b5c6e0b01</span><br><span class="line"> (0,15) | 17 | user17   | 70efdf2ec9b086079795c442636b55fb</span><br><span class="line"> (0,16) | 15 | user15   | 9bf31c7ff062936a96d3c8bd1f8f2ff3</span><br><span class="line"> (0,17) | 46 | user46   | d9d4f495e875a2e075a1a4a6e1b9770f</span><br><span class="line"> (0,18) | 83 | user83   | fe9fc289c3ff0af142b6d3bead98a923</span><br><span class="line"> (0,19) | 82 | user82   | 9778d5d219c5080b9a6a17bef029331c</span><br><span class="line"> (0,20) | 20 | user20   | 98f13708210194c475687be6106a3b84</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 在创建表的时候无法指定聚簇索引，我们必须使用 <code>CLUSTER</code> 命令来创建聚簇索引，此外，我们在初次创建聚簇索引时，需要指定使用的索引名。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CLUSTER account;</span><br><span class="line">ERROR:  there is no previously clustered index for table &quot;account&quot;</span><br></pre></td></tr></table></figure>

<p>上面我们没有指定索引名，因为我们还没有对其创建索引。接下来，我们在 <code>accout</code> 表上创建一个索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE INDEX account_id_idx ON account(id);</span><br><span class="line">CREATE INDEX</span><br><span class="line">postgres=# SELECT ctid, * FROM account LIMIT 20;</span><br><span class="line">  ctid  | id | nickname |             password</span><br><span class="line">--------+----+----------+----------------------------------</span><br><span class="line"> (0,1)  | 85 | user85   | 3ef815416f775098fe977004015c6193</span><br><span class="line"> (0,2)  | 22 | user22   | b6d767d2f8ed5d21a44b0e5886680cb9</span><br><span class="line"> (0,3)  | 43 | user43   | 17e62166fc8586dfa4d1bc0e1742c08b</span><br><span class="line"> (0,4)  | 89 | user89   | 7647966b7343c29048673252e490f736</span><br><span class="line"> (0,5)  | 75 | user75   | d09bf41544a3365a46c9077ebb5e35c3</span><br><span class="line"> (0,6)  | 81 | user81   | 43ec517d68b6edd3015b3edc9a11367b</span><br><span class="line"> (0,7)  | 91 | user91   | 54229abfcfa5649e7003b83dd4755294</span><br><span class="line"> (0,8)  | 65 | user65   | fc490ca45c00b1249bbe3554a4fdf6fb</span><br><span class="line"> (0,9)  | 67 | user67   | 735b90b4568125ed6c3f678819b6e058</span><br><span class="line"> (0,10) | 11 | user11   | 6512bd43d9caa6e02c990b0a82652dca</span><br><span class="line"> (0,11) | 72 | user72   | 32bb90e8976aab5298d5da10fe66f21d</span><br><span class="line"> (0,12) | 36 | user36   | 19ca14e7ea6328a42e0eb13d585e4c22</span><br><span class="line"> (0,13) | 69 | user69   | 14bfa6bb14875e45bba028a21ed38046</span><br><span class="line"> (0,14) | 32 | user32   | 6364d3f0f495b6ab9dcf8d3b5c6e0b01</span><br><span class="line"> (0,15) | 17 | user17   | 70efdf2ec9b086079795c442636b55fb</span><br><span class="line"> (0,16) | 15 | user15   | 9bf31c7ff062936a96d3c8bd1f8f2ff3</span><br><span class="line"> (0,17) | 46 | user46   | d9d4f495e875a2e075a1a4a6e1b9770f</span><br><span class="line"> (0,18) | 83 | user83   | fe9fc289c3ff0af142b6d3bead98a923</span><br><span class="line"> (0,19) | 82 | user82   | 9778d5d219c5080b9a6a17bef029331c</span><br><span class="line"> (0,20) | 20 | user20   | 98f13708210194c475687be6106a3b84</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，创建索引之后，数据的物理位置并没有发生变化。现在我们使用 <code>account_id_idx</code> 作为 <code>account</code> 表的聚簇索引，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CLUSTER account USING account_id_idx;</span><br><span class="line">CLUSTER</span><br><span class="line">postgres=# SELECT ctid, * FROM account LIMIT 20;</span><br><span class="line">  ctid  | id | nickname |             password</span><br><span class="line">--------+----+----------+----------------------------------</span><br><span class="line"> (0,1)  |  1 | user1    | c4ca4238a0b923820dcc509a6f75849b</span><br><span class="line"> (0,2)  |  2 | user2    | c81e728d9d4c2f636f067f89cc14862c</span><br><span class="line"> (0,3)  |  3 | user3    | eccbc87e4b5ce2fe28308fd9f2a7baf3</span><br><span class="line"> (0,4)  |  4 | user4    | a87ff679a2f3e71d9181a67b7542122c</span><br><span class="line"> (0,5)  |  5 | user5    | e4da3b7fbbce2345d7772b0674a318d5</span><br><span class="line"> (0,6)  |  6 | user6    | 1679091c5a880faf6fb5e6087eb1b2dc</span><br><span class="line"> (0,7)  |  7 | user7    | 8f14e45fceea167a5a36dedd4bea2543</span><br><span class="line"> (0,8)  |  8 | user8    | c9f0f895fb98ab9159f51fd0297e236d</span><br><span class="line"> (0,9)  |  9 | user9    | 45c48cce2e2d7fbdea1afc51c7c6ad26</span><br><span class="line"> (0,10) | 10 | user10   | d3d9446802a44259755d38e6d163e820</span><br><span class="line"> (0,11) | 11 | user11   | 6512bd43d9caa6e02c990b0a82652dca</span><br><span class="line"> (0,12) | 12 | user12   | c20ad4d76fe97759aa27a0c99bff6710</span><br><span class="line"> (0,13) | 13 | user13   | c51ce410c124a10e0db5e4b97fc2af39</span><br><span class="line"> (0,14) | 14 | user14   | aab3238922bcc25a6f606eb525ffdc56</span><br><span class="line"> (0,15) | 15 | user15   | 9bf31c7ff062936a96d3c8bd1f8f2ff3</span><br><span class="line"> (0,16) | 16 | user16   | c74d97b01eae257e44aa9d5bade97baf</span><br><span class="line"> (0,17) | 17 | user17   | 70efdf2ec9b086079795c442636b55fb</span><br><span class="line"> (0,18) | 18 | user18   | 6f4922f45568161a8cdf4ad2299f6d23</span><br><span class="line"> (0,19) | 19 | user19   | 1f0e3dad99908345f7439f8ffabdffc4</span><br><span class="line"> (0,20) | 20 | user20   | 98f13708210194c475687be6106a3b84</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，数据的物理位置发生了变化，数据的物理位置与索引相同。虽然，我们对 <code>account</code> 表创建了聚簇索引，但是在新插入数据时，PostgreSQL 并不会维护索引的正确性（即后续插入的数据并不是按照聚簇索引的顺序在物理上排序），我们需要再次使用 <code>CLUSTER</code> 命令来维护聚簇索引的正确性。</p>
<p>下面的示例展示了 PostgreSQL 在创建聚簇索引后再次插入数据后，数据的物理顺序，并再次进行 <code>CLUSTER</code> 后的物理顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# INSERT INTO account SELECT id, &#x27;test&#x27;||id::text, md5(id::text)</span><br><span class="line">postgres-# FROM generate_series(200, 300) id ORDER BY random();</span><br><span class="line">INSERT 0 101</span><br><span class="line">postgres=# SELECT ctid, * FROM account WHERE nickname ~ &#x27;test&#x27; LIMIT 20;</span><br><span class="line">  ctid   | id  | nickname |             password</span><br><span class="line">---------+-----+----------+----------------------------------</span><br><span class="line"> (0,101) | 296 | test296  | d296c101daa88a51f6ca8cfc1ac79b50</span><br><span class="line"> (0,102) | 292 | test292  | 1700002963a49da13542e0726b7bb758</span><br><span class="line"> (0,103) | 208 | test208  | 091d584fced301b442654dd8c23b3fc9</span><br><span class="line"> (0,104) | 210 | test210  | 6f3ef77ac0e3619e98159e9b6febf557</span><br><span class="line"> (0,105) | 240 | test240  | 335f5352088d7d9bf74191e006d8e24c</span><br><span class="line"> (0,106) | 211 | test211  | eb163727917cbba1eea208541a643e74</span><br><span class="line"> (0,107) | 265 | test265  | e56954b4f6347e897f954495eab16a88</span><br><span class="line"> (1,1)   | 269 | test269  | 06138bc5af6023646ede0e1f7c1eac75</span><br><span class="line"> (1,2)   | 222 | test222  | bcbe3365e6ac95ea2c0343a2395834dd</span><br><span class="line"> (1,3)   | 252 | test252  | 03c6b06952c750899bb03d998e631860</span><br><span class="line"> (1,4)   | 230 | test230  | 6da9003b743b65f4c0ccd295cc484e57</span><br><span class="line"> (1,5)   | 282 | test282  | 6a9aeddfc689c1d0e3b9ccc3ab651bc5</span><br><span class="line"> (1,6)   | 235 | test235  | 577ef1154f3240ad5b9b413aa7346a1e</span><br><span class="line"> (1,7)   | 213 | test213  | 979d472a84804b9f647bc185a877a8b5</span><br><span class="line"> (1,8)   | 249 | test249  | 077e29b11be80ab57e1a2ecabb7da330</span><br><span class="line"> (1,9)   | 200 | test200  | 3644a684f98ea8fe223c713b77189a77</span><br><span class="line"> (1,10)  | 267 | test267  | eda80a3d5b344bc40f3bc04f65b7a357</span><br><span class="line"> (1,11)  | 247 | test247  | 3cec07e9ba5f5bb252d13f5f431e4bbb</span><br><span class="line"> (1,12)  | 228 | test228  | 74db120f0a8e5646ef5a30154e9f6deb</span><br><span class="line"> (1,13)  | 262 | test262  | 36660e59856b4de58a219bcf4e27eba3</span><br><span class="line">(20 rows)</span><br><span class="line"></span><br><span class="line">postgres=# CLUSTER account ;</span><br><span class="line">CLUSTER</span><br><span class="line">postgres=# SELECT ctid, * FROM account WHERE nickname ~ &#x27;test&#x27; LIMIT 20;</span><br><span class="line">  ctid   | id  | nickname |             password</span><br><span class="line">---------+-----+----------+----------------------------------</span><br><span class="line"> (0,101) | 200 | test200  | 3644a684f98ea8fe223c713b77189a77</span><br><span class="line"> (0,102) | 201 | test201  | 757b505cfd34c64c85ca5b5690ee5293</span><br><span class="line"> (0,103) | 202 | test202  | 854d6fae5ee42911677c739ee1734486</span><br><span class="line"> (0,104) | 203 | test203  | e2c0be24560d78c5e599c2a9c9d0bbd2</span><br><span class="line"> (0,105) | 204 | test204  | 274ad4786c3abca69fa097b85867d9a4</span><br><span class="line"> (0,106) | 205 | test205  | eae27d77ca20db309e056e3d2dcd7d69</span><br><span class="line"> (0,107) | 206 | test206  | 7eabe3a1649ffa2b3ff8c02ebfd5659f</span><br><span class="line"> (1,1)   | 207 | test207  | 69adc1e107f7f7d035d7baf04342e1ca</span><br><span class="line"> (1,2)   | 208 | test208  | 091d584fced301b442654dd8c23b3fc9</span><br><span class="line"> (1,3)   | 209 | test209  | b1d10e7bafa4421218a51b1e1f1b0ba2</span><br><span class="line"> (1,4)   | 210 | test210  | 6f3ef77ac0e3619e98159e9b6febf557</span><br><span class="line"> (1,5)   | 211 | test211  | eb163727917cbba1eea208541a643e74</span><br><span class="line"> (1,6)   | 212 | test212  | 1534b76d325a8f591b52d302e7181331</span><br><span class="line"> (1,7)   | 213 | test213  | 979d472a84804b9f647bc185a877a8b5</span><br><span class="line"> (1,8)   | 214 | test214  | ca46c1b9512a7a8315fa3c5a946e8265</span><br><span class="line"> (1,9)   | 215 | test215  | 3b8a614226a953a8cd9526fca6fe9ba5</span><br><span class="line"> (1,10)  | 216 | test216  | 45fbc6d3e05ebd93369ce542e8f2322d</span><br><span class="line"> (1,11)  | 217 | test217  | 63dc7ed1010d3c3b8269faf0ba7491d4</span><br><span class="line"> (1,12)  | 218 | test218  | e96ed478dab8595a7dbda4cbcbee168f</span><br><span class="line"> (1,13)  | 219 | test219  | c0e190d8267e36708f955d7ab048990d</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.guru99.com/clustered-vs-non-clustered-index.html">https://www.guru99.com/clustered-vs-non-clustered-index.html</a><br>[2] <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL Common Table Expressions</title>
    <url>/2019/03/postgresql-common-table-expressions/</url>
    <content><![CDATA[<p>本文将介绍 PostgreSQL 中的 Common Table Expressions, CTE，也叫做公用表表达式。在介绍 CTE 之前，我们需要先了解 WITH 查询。WITH 查询是 PostgreSQL 针对复杂查询，允许用户在该查询内容编写辅助语句的功能，其中用户编写的辅助语句就是今天介绍的 CTE，你可以将 CTE 视为在当前查询中的一个临时表。CTE 的一大优点就是我们可将查询中的较为耗时且多次重复使用的部分通过 CTE 缓存起来，从而避免多次执行。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>下面是一个基本的 CTE 使用示列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line"> relkind <span class="operator">|</span> count</span><br><span class="line"><span class="comment">---------+-------</span></span><br><span class="line"> r       <span class="operator">|</span>    <span class="number">69</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Time</span>: <span class="number">1.515</span> ms</span><br></pre></td></tr></table></figure>

<p>上述示列中 CTE 的名称为 <code>x</code>，实质上就是由一个 <code>SELECT</code> 语句定义出来的，返回的结果是 <code>relkind</code> 以及该类型的表的数量。外围的 SQL 语句会将其视为一个临时表来使用。其实上述查询等价于下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line"> relkind <span class="operator">|</span> count</span><br><span class="line"><span class="comment">---------+-------</span></span><br><span class="line"> r       <span class="operator">|</span>    <span class="number">69</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Time</span>: <span class="number">0.954</span> ms</span><br></pre></td></tr></table></figure>

<h2 id="CTE-的缺点"><a href="#CTE-的缺点" class="headerlink" title="CTE 的缺点"></a>CTE 的缺点</h2><p>从上面的查询结果可以看到，采用 CTE 的查询方式其执行的时间反而比子查询的方式要慢。这是为什么呢？我们先来看看他们之间的查询计划有什么不一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (analyze <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">by</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                     QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> CTE Scan <span class="keyword">on</span> x  (cost<span class="operator">=</span><span class="number">17.17</span>.<span class="number">.17</span><span class="number">.26</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.678</span>.<span class="number">.0</span><span class="number">.687</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>::&quot;char&quot;)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">3</span></span><br><span class="line">   CTE x</span><br><span class="line">     <span class="operator">-</span><span class="operator">&gt;</span>  HashAggregate  (cost<span class="operator">=</span><span class="number">17.13</span>.<span class="number">.17</span><span class="number">.17</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.670</span>.<span class="number">.0</span><span class="number">.675</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">           <span class="keyword">Group</span> Key: pg_class.relkind</span><br><span class="line">           <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> pg_class  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.15</span><span class="number">.42</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">342</span> width<span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.011</span>.<span class="number">.0</span><span class="number">.150</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">342</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">1.025</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">1.054</span> ms</span><br><span class="line">(<span class="number">9</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">EXPLAIN (analyze <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> GroupAggregate  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.16</span><span class="number">.66</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.291</span>.<span class="number">.0</span><span class="number">.292</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Group</span> Key: pg_class.relkind</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> pg_class  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.16</span><span class="number">.27</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">69</span> width<span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.018</span>.<span class="number">.0</span><span class="number">.261</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">69</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         <span class="keyword">Filter</span>: (relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>::&quot;char&quot;)</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">273</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.249</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.395</span> ms</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>目前，PostgreSQL 会将 CTE 的结构进行物化 (Materialize)，这就意味着创建一个临时表来存储其返回的结果，随后在该临时表上面进行过滤，正如查询计划中展示的一样。由于过滤条件不能直接应用到 CTE 中，PostgreSQL 也就无法在将上层的过滤条件下推到 CTE 中执行。然而，通过子查询的方式，PostgreSQL 可以很自然的将过滤条件下推到子查询中。从上面的结果可以看到，子查询的方式显然优于 CTE 的查询方式，这是因为 CTE 的查询方式执行了两次全表扫描以及需要额外的存储空间来存放 CTE 返回的结果。</p>
<p>而在 PostgreSQL 的官方文档中也存在如下描述：</p>
<blockquote>
<p>A useful property of WITH queries is that they are evaluated only once per<br>execution of the parent query, even if they are referred to more than once by<br>the parent query or sibling WITH queries. Thus, expensive calculations that<br>are needed in multiple places can be placed within a WITH query to avoid<br>redundant work. Another possible application is to prevent unwanted multiple<br>evaluations of functions with side-effects. However, the other side of this<br>coin is that the optimizer is less able to push restrictions from the parent<br>query down into a WITH query than an ordinary subquery. The WITH query will<br>generally be evaluated as written, without suppression of rows that the parent<br>query might discard afterwards. (But, as mentioned above, evaluation might stop<br>early if the reference(s) to the query demand only a limited number of rows.)</p>
</blockquote>
<p>因此，我们在使用 CTE 时需要特别注意，正确的使用 CTE 将会带来性能的提升；如果使用不当，则很可能影响数据库性能。</p>
<h2 id="禁止-CTE-物化？"><a href="#禁止-CTE-物化？" class="headerlink" title="禁止 CTE 物化？"></a>禁止 CTE 物化？</h2><p>那么我们是否能禁止 CTE 物化结果呢？就目前 PostgreSQL 来说，这是不可能的。但是在 2019 年 2 月 16 日 Tom Lane 提交了一个<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=608b167f9f9c4553c35bb1ec0eab9ddae643989b">补丁</a>来解决该问题。</p>
<blockquote>
<p>Historically we’ve always materialized the full output of a CTE query,<br>treating WITH as an optimization fence (so that, for example, restrictions<br>from the outer query cannot be pushed into it).  This is appropriate when<br>the CTE query is INSERT/UPDATE/DELETE, or is recursive; but when the CTE<br>query is non-recursive and side-effect-free, there’s no hazard of changing<br>the query results by pushing restrictions down.</p>
<p>Another argument for materialization is that it can avoid duplicate<br>computation of an expensive WITH query — but that only applies if<br>the WITH query is called more than once in the outer query.  Even then<br>it could still be a net loss, if each call has restrictions that<br>would allow just a small part of the WITH query to be computed.</p>
<p>Hence, let’s change the behavior for WITH queries that are non-recursive<br>and side-effect-free.  By default, we will inline them into the outer<br>query (removing the optimization fence) if they are called just once.<br>If they are called more than once, we will keep the old behavior by<br>default, but the user can override this and force inlining by specifying<br>NOT MATERIALIZED.  Lastly, the user can force the old behavior by<br>specifying MATERIALIZED; this would mainly be useful when the query had<br>deliberately been employing WITH as an optimization fence to prevent a<br>poor choice of plan.</p>
<p>Andreas Karlsson, Andrew Gierth, David Fetter</p>
<p>Discussion: <a href="https://postgr.es/m/87sh48ffhb.fsf@news-spur.riddles.org.uk">https://postgr.es/m/87sh48ffhb.fsf@news-spur.riddles.org.uk</a></p>
</blockquote>
<p>这让用户禁止 CTE 物化结果成为可能，该功能预计在 PostgreSQL 12 版本中推出。</p>
<p>下面是在 PostgreSQL 12 开发版中的测试结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (analyze <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">by</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> GroupAggregate  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.18</span><span class="number">.21</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.103</span>.<span class="number">.0</span><span class="number">.103</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Group</span> Key: pg_class.relkind</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> pg_class  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.17</span><span class="number">.82</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">69</span> width<span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.009</span>.<span class="number">.0</span><span class="number">.092</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">69</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         <span class="keyword">Filter</span>: (relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>::&quot;char&quot;)</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">317</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.406</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.196</span> ms</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">EXPLAIN (analyze <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">BY</span> relkind</span><br><span class="line">) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> GroupAggregate  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.18</span><span class="number">.21</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.118</span>.<span class="number">.0</span><span class="number">.118</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Group</span> Key: pg_class.relkind</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> pg_class  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.17</span><span class="number">.82</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">69</span> width<span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.011</span>.<span class="number">.0</span><span class="number">.106</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">69</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         <span class="keyword">Filter</span>: (relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>::&quot;char&quot;)</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">317</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.120</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.151</span> ms</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">EXPLAIN (analyze <span class="keyword">on</span>, timing <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">WITH</span> x <span class="keyword">AS</span>  MATERIALIZED (</span><br><span class="line">    <span class="keyword">SELECT</span> relkind, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_class <span class="keyword">GROUP</span> <span class="keyword">by</span> relkind</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> x <span class="keyword">WHERE</span> relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                                                     QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> CTE Scan <span class="keyword">on</span> x  (cost<span class="operator">=</span><span class="number">18.83</span>.<span class="number">.18</span><span class="number">.92</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.174</span>.<span class="number">.0</span><span class="number">.176</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>::&quot;char&quot;)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">3</span></span><br><span class="line">   CTE x</span><br><span class="line">     <span class="operator">-</span><span class="operator">&gt;</span>  HashAggregate  (cost<span class="operator">=</span><span class="number">18.79</span>.<span class="number">.18</span><span class="number">.83</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> width<span class="operator">=</span><span class="number">9</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.171</span>.<span class="number">.0</span><span class="number">.172</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">           <span class="keyword">Group</span> Key: pg_class.relkind</span><br><span class="line">           <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> pg_class  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.16</span><span class="number">.86</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">386</span> width<span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.005</span>.<span class="number">.0</span><span class="number">.042</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">386</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.185</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.249</span> ms</span><br><span class="line">(<span class="number">9</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 12 版中为 CTE 新增了 <code>MATERIALIZED | NOT MATERIALIZED</code> 选项，这样用户就可以通过选项控制是否对 CTE 进行物化，而默认情况下是不对 CTE 进行物化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CTE 可以使我们编写的 SQL 查询更易于阅读且能通过物化的方式将结果缓存到起来从而提升查询性能；但是，CTE 的使用不当甚至有可能导致性能的降低，例如在查询中仅使用一次的情况。当我们使用 CTE 时，需要考虑以下几个问题:</p>
<ol>
<li>该 CTE 是否会被重复使用？</li>
<li>查询中的条件是否能在 CTE 中应用?</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.depesz.com/2019/02/19/waiting-for-postgresql-12-allow-user-control-of-cte-materialization-and-change-the-default-behavior/#more-3491">Allow user control of CTE materialization, and change the default behavior</a><br>[2] <a href="https://medium.com/@hakibenita/be-careful-with-cte-in-postgresql-fca5e24d2119">Be careful with CTE in PostgreSQL</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>CTE</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 持续归档</title>
    <url>/2018/10/postgresql-continuous-archiving/</url>
    <content><![CDATA[<p>无论何时，PostgreSQL 总是在集群的数据目录 pg_wal 下面维护一个 <em>Write Ahead Log</em> 日志记录。该日志记录了数据文件的所有变化。当数据库系统发生崩溃时，数据库系统可以通过重放最新检查点之后的 WAL 日志条目来恢复数据库的一致性。在 PostgreSQL 中，我们通过将文件系统级的备份与 WAL 日志的备份相结合可以实现三种策略的数据库备份。当需要进行数据库恢复时，我们先恢复文件系统的备份，随后通过重放备份的 WAL 日志使得数据库进入到当前状态。尽管该方法过于复杂，但是它拥有以下好处：</p>
<ul>
<li>我们不需要完全一致的文件系统备份作为起点。备份中的任何内部不一致都将通过日志重放进行更正 (这与崩溃恢复期间发生的情况没有显着差异)。因此，我们不需要文件系统快照功能，只需要 tar 或类似的归档工具。</li>
<li>没有必要一直重放 WAL 条目到最后。我们可以在任何时候停止重放并拥有当时数据库的一致快照。因此，该技术支持时间点恢复 (Point-in-Time Recovery, PITR)。为此，我们可以将数据库还原到自从进行基本备份以后的任何状态。</li>
<li>如果我们持续地将一系列 WAL 日志文件提供给另一台已加载相同基本备份文件的计算机，此时，我们就拥有了一个热备系统：在任何时候我们都可以启动这台机器，它将拥有与原数据库几乎一致的状态。</li>
</ul>
<p>与普通文件系统备份技术一样，该方法只能支持恢复整个数据库集群，而不能用于恢复其子集。同时，它也需要更多的归档空间：基本的文件系统备份可能很庞大，繁忙的系统将生成许多必须归档的 WAL 流量。尽管如此，在多数情况下，它仍然是需要高可靠性的首选备份技术。</p>
<p>我们需要一系列连续归档 WAL 日志文件，这些文件至少可以延伸到备份的开始时间，从而确保连续归档 (许多数据库供应商也称为“在线备份”) 成功恢复。</p>
<span id="more"></span>

<h2 id="WAL-日志归档"><a href="#WAL-日志归档" class="headerlink" title="WAL 日志归档"></a>WAL 日志归档</h2><p>从抽象的意义上说，PostgreSQL 数据库系统会产生无限长的 WAL 日志记录序列。PostgreSQL 数据库该序列划分 WAL 段文件，通常每个段文件为 16MB (在构建 PostgreSQL 时可以更改段大小)。段文件的数字名称反映了它们在抽象 WAL 序列中的位置。当不使用 WAL 归档时，PostgreSQL 通常只需要创建几个段文件，然后通过将不再需要的段文件重命名为更高的段号来“回收”它们。</p>
<p>当使用 WAL 日志归档时，我们需要在每个段文件填充后捕获它们的内容，并在段文件被回收再利用之前将该数据保存在其他某处。PostgreSQL 允许管理员指定要执行的 shell 命令，以将已完成的段文件复制到需要的位置。该命令可以简单的 cp 命令，也可以是复杂的 shell 脚步，一切都取决于用户。</p>
<p>我们需要设置三个选项以便启用 WAL 日志归档： wal_level，archive_mode 和 archive_command。</p>
<p><strong>wal_level</strong> - 必须为 replica 或者更高的级别。<br><strong>archive_mode</strong> - 设置为 on。<br><strong>archive_command</strong> - 通常为归档命令，其中 <code>%p</code> 被替换为要归档的文件的路径名，<code>%f</code> 被替换为要归档的文件的文件名。如果需要在命令中嵌入实际的 <code>％</code> 字符，请使用 <code>%%</code>。</p>
<p>接下来我们尝试配置 WAL 日志归档，首先进行相关的准备工作，编译 PostgreSQL 10.4，初始化数据库，建立归档日志存储路径 (本例旨在使用 WAL 日志归档，因此就在本地建立目录来存储备份的 WAL 日志，通常的做法时备份到其他主机)，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/home/postgres/postgresql-10.4</span><br><span class="line">$ ls</span><br><span class="line">drwxr-xr-x  2 postgres postgres 4096 Oct 24 13:36 bin</span><br><span class="line">drwx------ 19 postgres postgres 4096 Oct 24 13:49 data</span><br><span class="line">drwxr-xr-x  6 postgres postgres 4096 Oct 24 13:36 include</span><br><span class="line">drwxr-xr-x  4 postgres postgres 4096 Oct 24 13:36 lib</span><br><span class="line">-rw-rw-r--  1 postgres postgres  177 Oct 24 13:39 pg-env.sh</span><br><span class="line">drwxr-xr-x  6 postgres postgres 4096 Oct 24 13:36 share</span><br><span class="line">$ cat pg-env.sh</span><br><span class="line">export PGHOME=/home/postgres/postgresql-10.4</span><br><span class="line">export PGDATA=/home/postgres/postgresql-10.4/data</span><br><span class="line">export PATH=$PGHOME/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PGHOME/lib:$LD_LIBRARY_PATH</span><br><span class="line">$ mkdir wals            # 建立 WAL 日志备份目录</span><br><span class="line">$ . pg-env.sh           # 初始化环境变量</span><br><span class="line">$ initdb -D data        # 初始化数据库集群</span><br></pre></td></tr></table></figure>

<p>接着修改 data/postgresql.conf 文件中的 wal_level，archive_mode 和 archive_command 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wal_level = replica</span><br><span class="line">archive_mode = on</span><br><span class="line">archive_command = &#x27;test ! -f /home/postgres/postgresql-10.4/wals/%f &amp;&amp; cp %p /home/postgres/postgresql-10.4/wals/%f&#x27;</span><br></pre></td></tr></table></figure>

<p>按照上述操作进行，我们目前已经配置好了 WAL 日志归档，接下来我们运行数据库并创建一个基本备份 (即文件系统级备份) 并保存在当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pg_ctl -D data -l logfile start</span><br><span class="line">$ psql -c &quot;SELECT pg_start_backup(&#x27;label&#x27;);&quot; postgres</span><br><span class="line">$ tar -C data -czvf pg_basebackup_backup.tar.gz .</span><br><span class="line">$ psql -c &quot;SELECT pg_stop_backup();&quot; postgres</span><br></pre></td></tr></table></figure>

<p>此时，我们创建好了数据库集群的基本备份，之后我们便可以通过该基本备份并结合 WAL 日志备份进行恢复。紧接着，我们对数据库做一些修改，并停止数据库然后删除 data 目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=# create table test (id int, name varchar(10));</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres=# insert into test values (1, &#x27;postgres&#x27;);</span><br><span class="line">INSERT 0 1</span><br><span class="line">postgres=# select * from test ;</span><br><span class="line"> id |   name</span><br><span class="line"> ----+----------</span><br><span class="line">   1 | postgres</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# \q</span><br><span class="line">$ pg_ctl -D data -l logfile stop</span><br><span class="line">$ rm -rf data</span><br></pre></td></tr></table></figure>

<p>下面将演示如何使用基础备份及 WAL 日志备份恢复数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> initdb -D data1                    <span class="comment"># 重新初始化一个数据库集群</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -C data1 -xvf pg_basebackup_backup.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;<span class="string">END &gt; data1/recovery.conf    # 创建恢复脚步</span></span></span><br><span class="line">restore_command = &#x27;cp /home/postgres/postgresql-10.4/wals/%f %p&#x27;</span><br><span class="line">END</span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string"> pg_ctl -D data1 -l logfile start   # 恢复</span></span></span><br></pre></td></tr></table></figure>

<p>在恢复完成之后，PostgreSQL 将把 recovery.conf 文件重命名为 recovery.done。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/10/static/continuous-archiving.html">https://www.postgresql.org/docs/10/static/continuous-archiving.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL CREATE TABLE 查询计划树及执行计划树的生成</title>
    <url>/2019/05/postgresql-create-table-query-plan/</url>
    <content><![CDATA[<p>在<a href="/2019/05/postgresql-create-table-syntax-analysis/" title="上一篇文章">上一篇文章</a>中，我们主要分析了 <code>CREATE TABLE</code> 语句的的词法和语法，并简要说明了 PostgreSQL 的执行流程。本文将介绍 PostgreSQL 是如何将解析树转化为执行计划的。</p>
<span id="more"></span>

<h2 id="查询计划树"><a href="#查询计划树" class="headerlink" title="查询计划树"></a>查询计划树</h2><p>PostgreSQL 在获取到原始解析树之后将通过函数 <code>pg_analyze_and_rewrite()</code> 对解析树进行解析分析并进行规则重写，分析器或规则重写器可能会将一个查询扩展为多个查询，因此可能返回多个查询节点。其函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Given a raw parsetree (gram.y output), and optionally information about</span></span><br><span class="line"><span class="comment"> * types of parameter symbols ($n), perform parse analysis and rule rewriting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A list of Query nodes is returned, since either the analyzer or the</span></span><br><span class="line"><span class="comment"> * rewriter might expand one query to several.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> for reasons mentioned above, this must be separate from raw parsing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List *</span></span><br><span class="line"><span class="function"><span class="title">pg_analyze_and_rewrite</span><span class="params">(RawStmt *parsetree, <span class="keyword">const</span> <span class="keyword">char</span> *query_string,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Oid *paramTypes, <span class="keyword">int</span> numParams,</span></span></span><br><span class="line"><span class="params"><span class="function">                       QueryEnvironment *queryEnv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Query      *query;</span><br><span class="line">    List       *querytree_list;</span><br><span class="line"></span><br><span class="line">    TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (1) Perform parse analysis.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (log_parser_stats)</span><br><span class="line">        ResetUsage();</span><br><span class="line"></span><br><span class="line">    query = parse_analyze(parsetree, query_string, paramTypes, numParams,</span><br><span class="line">                          queryEnv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_parser_stats)</span><br><span class="line">        ShowUsage(<span class="string">&quot;PARSE ANALYSIS STATISTICS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (2) Rewrite the queries, as necessary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    querytree_list = pg_rewrite_query(query);</span><br><span class="line"></span><br><span class="line">    TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> querytree_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从函数的定义可以看到，该函数分为两个阶段：(1) 解析分析；(2) 规则重写。其中规则重写阶段不是必须进行的。</p>
<h3 id="解析分析"><a href="#解析分析" class="headerlink" title="解析分析"></a>解析分析</h3><p>解析分析通过 <code>parse_analyze()</code> 函数进行处理，它将原始解析树转换为一棵查询树。查询树的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Query -</span></span><br><span class="line"><span class="comment"> *    Parse analysis turns all statements into a Query tree</span></span><br><span class="line"><span class="comment"> *    for further processing by the rewriter and planner.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Utility statements (i.e. non-optimizable statements) have the</span></span><br><span class="line"><span class="comment"> *    utilityStmt field set, and the rest of the Query is mostly dummy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Planning converts a Query tree into a Plan tree headed by a PlannedStmt</span></span><br><span class="line"><span class="comment"> *    node --- the Query structure is not used by the executor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line"></span><br><span class="line">    CmdType     commandType;    <span class="comment">/* select|insert|update|delete|utility */</span></span><br><span class="line"></span><br><span class="line">    QuerySource querySource;    <span class="comment">/* where did I come from? */</span></span><br><span class="line"></span><br><span class="line">    uint64      queryId;        <span class="comment">/* query identifier (can be set by plugins) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>        canSetTag;      <span class="comment">/* do I set the command result tag? */</span></span><br><span class="line"></span><br><span class="line">    Node       *utilityStmt;    <span class="comment">/* non-null if commandType == CMD_UTILITY */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         resultRelation; <span class="comment">/* rtable index of target relation for</span></span><br><span class="line"><span class="comment">                                 * INSERT/UPDATE/DELETE; 0 for SELECT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>        hasAggs;        <span class="comment">/* has aggregates in tlist or havingQual */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasWindowFuncs; <span class="comment">/* has window functions in tlist */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasTargetSRFs;  <span class="comment">/* has set-returning functions in tlist */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasSubLinks;    <span class="comment">/* has subquery SubLink */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasDistinctOn;  <span class="comment">/* distinctClause is from DISTINCT ON */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasRecursive;   <span class="comment">/* WITH RECURSIVE was specified */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasModifyingCTE;    <span class="comment">/* has INSERT/UPDATE/DELETE in WITH */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasForUpdate;   <span class="comment">/* FOR [KEY] UPDATE/SHARE was specified */</span></span><br><span class="line">    <span class="keyword">bool</span>        hasRowSecurity; <span class="comment">/* rewriter has applied some RLS policy */</span></span><br><span class="line"></span><br><span class="line">    List       *cteList;        <span class="comment">/* WITH list (of CommonTableExpr&#x27;s) */</span></span><br><span class="line"></span><br><span class="line">    List       *rtable;         <span class="comment">/* list of range table entries */</span></span><br><span class="line">    FromExpr   *jointree;       <span class="comment">/* table join tree (FROM and WHERE clauses) */</span></span><br><span class="line"></span><br><span class="line">    List       *targetList;     <span class="comment">/* target list (of TargetEntry) */</span></span><br><span class="line"></span><br><span class="line">    OverridingKind <span class="keyword">override</span>;    <span class="comment">/* OVERRIDING clause */</span></span><br><span class="line"></span><br><span class="line">    OnConflictExpr *onConflict; <span class="comment">/* ON CONFLICT DO [NOTHING | UPDATE] */</span></span><br><span class="line"></span><br><span class="line">    List       *returningList;  <span class="comment">/* return-values list (of TargetEntry) */</span></span><br><span class="line"></span><br><span class="line">    List       *groupClause;    <span class="comment">/* a list of SortGroupClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    List       *groupingSets;   <span class="comment">/* a list of GroupingSet&#x27;s if present */</span></span><br><span class="line"></span><br><span class="line">    Node       *havingQual;     <span class="comment">/* qualifications applied to groups */</span></span><br><span class="line"></span><br><span class="line">    List       *windowClause;   <span class="comment">/* a list of WindowClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    List       *distinctClause; <span class="comment">/* a list of SortGroupClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    List       *sortClause;     <span class="comment">/* a list of SortGroupClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    Node       *limitOffset;    <span class="comment">/* # of result tuples to skip (int8 expr) */</span></span><br><span class="line">    Node       *limitCount;     <span class="comment">/* # of result tuples to return (int8 expr) */</span></span><br><span class="line"></span><br><span class="line">    List       *rowMarks;       <span class="comment">/* a list of RowMarkClause&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    Node       *setOperations;  <span class="comment">/* set-operation tree if this is top level of</span></span><br><span class="line"><span class="comment">                                 * a UNION/INTERSECT/EXCEPT query */</span></span><br><span class="line"></span><br><span class="line">    List       *constraintDeps; <span class="comment">/* a list of pg_constraint OIDs that the query</span></span><br><span class="line"><span class="comment">                                 * depends on to be semantically valid */</span></span><br><span class="line"></span><br><span class="line">    List       *withCheckOptions;   <span class="comment">/* a list of WithCheckOption&#x27;s (added</span></span><br><span class="line"><span class="comment">                                     * during rewrite) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following two fields identify the portion of the source text string</span></span><br><span class="line"><span class="comment">     * containing this query.  They are typically only populated in top-level</span></span><br><span class="line"><span class="comment">     * Queries, not in sub-queries.  When not set, they might both be zero, or</span></span><br><span class="line"><span class="comment">     * both be -1 meaning &quot;unknown&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_location;  <span class="comment">/* start location, or -1 if unknown */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_len;       <span class="comment">/* length in bytes; 0 means &quot;rest of string&quot; */</span></span><br><span class="line">&#125; Query;</span><br></pre></td></tr></table></figure>

<p>当所处理的语句为 DDL 时 <code>Query</code> 结构使用 <code>utilityStmt</code> 成员来存储 DDL 原始解析树，而对于非 DDL 语句，解析分析则会将原始解析树中对应的结构解析到 <code>Query</code> 相应的成员中，本文暂时不做介绍。</p>
<p><code>parse_analyze()</code> 函数通过调用 <code>transformTopLevelStmt()</code> 函数将原始解析树转换为查询树，在转换过程中，PostgreSQL 通过 <code>ParseState</code> 结构维护解析过程的中间状态。实际上 <code>transformTopLevelStmt()</code> 函数是通过调用 <code>transformOptionalSelectInto()</code> 函数进行处理，该函数针对 <code>SELECT ... INTO</code> 这种语句进行处理，随后使用 <code>transformStmt()</code> 函数进行所有语句的处理。</p>
<p><code>transformStmt()</code> 函数内部通过一个 <code>switch</code> 语句进行处理，PostgreSQL 将 SQL 语句分为三大类：</p>
<ul>
<li><strong>Optimizable statements</strong> - 可以优化的语句，包括 <code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code> 和 <code>SELECT</code> 语句。</li>
<li><strong>Special cases</strong> - 特殊语句，包括 <code>DECLARE CURSOR</code>, <code>EXPLAIN</code>, <code>CREATE TABLE AS</code> 和 <code>CALL</code> 语句。</li>
<li><strong>Utility statements</strong> - 功能性语句，主要包括 <code>CREATE TABLE</code>, <code>CREATE FUNCTION</code> 等 DDL 语句。</li>
</ul>
<p>函数 <code>parse_analyze()</code> 的函数定义如下（节选部分代码）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * transformStmt -</span></span><br><span class="line"><span class="comment"> *    recursively transform a Parse tree into a Query tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Query *</span></span><br><span class="line"><span class="function"><span class="title">transformStmt</span><span class="params">(ParseState *pstate, Node *parseTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Query      *result;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (nodeTag(parseTree))</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Optimizable statements</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">case</span> T_InsertStmt:</span><br><span class="line">            result = transformInsertStmt(pstate, (InsertStmt *) parseTree);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Special cases</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">case</span> T_DeclareCursorStmt:</span><br><span class="line">            result = transformDeclareCursorStmt(pstate,</span><br><span class="line">                                                (DeclareCursorStmt *) parseTree);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * other statements don&#x27;t require any transformation; just return</span></span><br><span class="line"><span class="comment">             * the original parsetree with a Query node plastered on top.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            result = makeNode(Query);</span><br><span class="line">            result-&gt;commandType = CMD_UTILITY;</span><br><span class="line">            result-&gt;utilityStmt = (Node *) parseTree;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark as original query until we learn differently */</span></span><br><span class="line">    result-&gt;querySource = QSRC_ORIGINAL;</span><br><span class="line">    result-&gt;canSetTag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文针对 <code>CREATE TABLE</code> 语句进行介绍，从上面的代码可以看到，针对 <code>CREATE TABLE</code> 这类 DDL 语句其实只是将原始解析树保存到 <code>Query-&gt;utilityStmt</code> 结构中。</p>
<h3 id="规则重写"><a href="#规则重写" class="headerlink" title="规则重写"></a>规则重写</h3><p>规则重写则是通过函数 <code>pg_rewrite_query()</code> 进行处理，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform rewriting of a query produced by parse analysis.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: query must just have come from the parser, because we do not do</span></span><br><span class="line"><span class="comment"> * AcquireRewriteLocks() on it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List *</span></span><br><span class="line"><span class="function"><span class="title">pg_rewrite_query</span><span class="params">(Query *query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List       *querytree_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Debug_print_parse)</span><br><span class="line">        elog_node_display(LOG, <span class="string">&quot;parse tree&quot;</span>, query,</span><br><span class="line">                          Debug_pretty_print);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_parser_stats)</span><br><span class="line">        ResetUsage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query-&gt;commandType == CMD_UTILITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* don&#x27;t rewrite utilities, just dump &#x27;em into result list */</span></span><br><span class="line">        querytree_list = list_make1(query);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* rewrite regular queries */</span></span><br><span class="line">        querytree_list = QueryRewrite(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> querytree_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到，类似于 <code>parse_analyze()</code> 函数，<code>pg_rewrite_query()</code> 函数针对 DDL 语句也不会进行重写，而只是将其存放到查询树链表中。</p>
<h2 id="执行计划树"><a href="#执行计划树" class="headerlink" title="执行计划树"></a>执行计划树</h2><p>执行计划树则是通过 <code>pg_plan_queries()</code> 的生成的，其函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate plans for a list of already-rewritten queries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For normal optimizable statements, invoke the planner.  For utility</span></span><br><span class="line"><span class="comment"> * statements, just make a wrapper PlannedStmt node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The result is a list of PlannedStmt nodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List *</span></span><br><span class="line"><span class="function"><span class="title">pg_plan_queries</span><span class="params">(List *querytrees, <span class="keyword">int</span> cursorOptions, ParamListInfo boundParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List       *stmt_list = NIL;</span><br><span class="line">    ListCell   *query_list;</span><br><span class="line"></span><br><span class="line">    foreach(query_list, querytrees)</span><br><span class="line">    &#123;</span><br><span class="line">        Query      *query = lfirst_node(Query, query_list);</span><br><span class="line">        PlannedStmt *stmt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (query-&gt;commandType == CMD_UTILITY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Utility commands require no planning. */</span></span><br><span class="line">            stmt = makeNode(PlannedStmt);</span><br><span class="line">            stmt-&gt;commandType = CMD_UTILITY;</span><br><span class="line">            stmt-&gt;canSetTag = query-&gt;canSetTag;</span><br><span class="line">            stmt-&gt;utilityStmt = query-&gt;utilityStmt;</span><br><span class="line">            stmt-&gt;stmt_location = query-&gt;stmt_location;</span><br><span class="line">            stmt-&gt;stmt_len = query-&gt;stmt_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stmt = pg_plan_query(query, cursorOptions, boundParams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stmt_list = lappend(stmt_list, stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stmt_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pg_plan_queries()</code> 函数的处理于解析分析与规则重写相同，针对 DDL 语句就是将查询计划书的封装到执行计划树中，而非 DDL 的语句处理则通过 <code>pg_plan_query()</code> 函数进行处理，其过程相对比较复杂。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL CREATE TABLE 语法分析</title>
    <url>/2019/05/postgresql-create-table-syntax-analysis/</url>
    <content><![CDATA[<p>PostgreSQL 采用 flex 进行词法分析，随后利用 yacc 进行语法分析，其词法与语法分析在 scan.l 和 gram.y 文件中实现。本文主要针对 PostgreSQL 的建表语句 <code>CREATE TABLE</code> 来分析 PostgreSQL 数据库的词法、语法分析，并简要介绍整个 PostgreSQL 数据库的执行过程。</p>
<span id="more"></span>

<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>PostgreSQL 的词法以及语法分析相关的文件存放在 <code>src/include/parser/</code> 和 <code>src/backend/parser</code> 目录下，上文所介绍的 scan.l 和 gram.y 文件即在 <code>src/backend/parser</code> 目录中。本文对于词法分析不做详细介绍，PostgreSQL 将词法分析的结果交给语法分析模块进行语法分析，而语法分析的关键代码即在 gram.y 文件中。下面我们来看看 gram.y 文件的组成，该文件分为三个部分：声明部分 (declarations)、语法规则 (rules) 以及程序实现 (programs)。在声明部分其引入了 PostgreSQL 相关的头文件、函数声明等；第二部分规则给出了 PostgreSQL 数据库中 SQL 语句的定义；第三部分则包含了语法解析的初始化实现、节点的创建等函数定义。</p>
<p>现在，我们主要来看看规则部分的定义。PostgreSQL 关于 SQL 的规则定义开始于 stmtblock，其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  The target production for the whole parse.</span><br><span class="line"> */</span><br><span class="line">stmtblock:  stmtmulti</span><br><span class="line">            &#123;</span><br><span class="line">                pg_yyget_extra(yyscanner)-&gt;parsetree = $1;</span><br><span class="line">            &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * At top level, we wrap each stmt with a RawStmt node carrying start location</span><br><span class="line"> * and length of the stmt&#x27;s text.  Notice that the start loc/len are driven</span><br><span class="line"> * entirely from semicolon locations (@2).  It would seem natural to use</span><br><span class="line"> * @1 or @3 to get the true start location of a stmt, but that doesn&#x27;t work</span><br><span class="line"> * for statements that can start with empty nonterminals (opt_with_clause is</span><br><span class="line"> * the main offender here); as noted in the comments for YYLLOC_DEFAULT,</span><br><span class="line"> * we&#x27;d get -1 for the location in such cases.</span><br><span class="line"> * We also take care to discard empty statements entirely.</span><br><span class="line"> */</span><br><span class="line">stmtmulti:  stmtmulti &#x27;;&#x27; stmt</span><br><span class="line">                &#123;</span><br><span class="line">                    if ($1 != NIL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        /* update length of previous stmt */</span><br><span class="line">                        updateRawStmtEnd(llast_node(RawStmt, $1), @2);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ($3 != NULL)</span><br><span class="line">                        $$ = lappend($1, makeRawStmt($3, @2 + 1));</span><br><span class="line">                    else</span><br><span class="line">                        $$ = $1;</span><br><span class="line">                &#125;</span><br><span class="line">            | stmt</span><br><span class="line">                &#123;</span><br><span class="line">                    if ($1 != NULL)</span><br><span class="line">                        $$ = list_make1(makeRawStmt($1, 0));</span><br><span class="line">                    else</span><br><span class="line">                        $$ = NIL;</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 的规则从 <code>stmtblock</code> 开始，它被定义为 <code>stmtmulti</code> 对象，其中 <code>$1</code> 即代表 <code>stmtmulti</code>，它最终被复制给 <code>base_yy_extra_type</code> 的 <code>parsetree</code> 成员，而 <code>parsetree</code> 是一个链表，它存储的是解析之后的原始解析树对象。<code>stmtmulti</code> 的定义则采用递归的方式进行定义，它可以是 <code>stmtmulti</code> 加上 <code>stmt</code> 也可以是单独的 <code>stmt</code>，但最终是以 <code>stmt</code> 对象来解析，而多个 <code>stmt</code> 对象则是通过链表链接起来的。</p>
<p>接下来，我们看看 <code>stmt</code> 是如何定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stmt :</span><br><span class="line">            AlterEventTrigStmt</span><br><span class="line">            | AlterCollationStmt</span><br><span class="line">            | AlterDatabaseStmt</span><br><span class="line">            | AlterDatabaseSetStmt</span><br><span class="line">            | AlterDefaultPrivilegesStmt</span><br><span class="line">            | AlterDomainStmt</span><br><span class="line">            | AlterEnumStmt</span><br><span class="line">            | AlterExtensionStmt</span><br><span class="line">            | AlterExtensionContentsStmt</span><br><span class="line">            | AlterFdwStmt</span><br><span class="line">            | AlterForeignServerStmt</span><br><span class="line">            | AlterForeignTableStmt</span><br><span class="line">              ...</span><br><span class="line">            | CopyStmt</span><br><span class="line">            | CreateAmStmt</span><br><span class="line">            | CreateAsStmt</span><br><span class="line">            | CreateAssertionStmt</span><br><span class="line">            | CreateCastStmt</span><br><span class="line">            | CreateConversionStmt</span><br><span class="line">            | CreateDomainStmt</span><br><span class="line">            | CreateExtensionStmt</span><br><span class="line">            | CreateFdwStmt</span><br><span class="line">            | CreateForeignServerStmt</span><br><span class="line">            | CreateForeignTableStmt</span><br><span class="line">            | CreateFunctionStmt</span><br><span class="line">              ...</span><br><span class="line">            | SelectStmt</span><br><span class="line">            | TransactionStmt</span><br><span class="line">            | TruncateStmt</span><br><span class="line">            | UnlistenStmt</span><br><span class="line">            | UpdateStmt</span><br><span class="line">            | VacuumStmt</span><br><span class="line">            | VariableResetStmt</span><br><span class="line">            | VariableSetStmt</span><br><span class="line">            | VariableShowStmt</span><br><span class="line">            | ViewStmt</span><br><span class="line">            | /*EMPTY*/</span><br><span class="line">                &#123; $$ = NULL; &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>当你看到这个的时候是否有中似曾相识的感觉？<code>stmt</code> 包含了 PostgreSQL 所支持的 SQL 语句的语法定义，例如我们输入 <code>SELECT * FROM pg_class;</code> 时，它将通过 <code>stmt</code> 转到 <code>SelectStmt</code> 的定义处进行解析，而语句在解析完之后都会转换为对应的 <code>SelectStmt</code> 结构用于后续进行查询计划的生成。</p>
<p>现在我们针对 PostgreSQL 的建表语句进行分析，关于 <a href="https://www.postgresql.org/docs/devel/sql-createtable.html"><code>CREATE TABLE</code></a> 的语法可以在官方文档上查询。<code>CREATE TABLE</code> 的语法分析如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateStmt: CREATE OptTemp TABLE qualified_name &#x27;(&#x27; OptTableElementList &#x27;)&#x27;</span><br><span class="line">            OptInherit OptPartitionSpec table_access_method_clause OptWith</span><br><span class="line">            OnCommitOption OptTableSpace</span><br><span class="line">                &#123;</span><br><span class="line">                    CreateStmt *n = makeNode(CreateStmt);</span><br><span class="line">                    $4-&gt;relpersistence = $2;</span><br><span class="line">                    n-&gt;relation = $4;</span><br><span class="line">                    n-&gt;tableElts = $6;</span><br><span class="line">                    n-&gt;inhRelations = $8;</span><br><span class="line">                    n-&gt;partspec = $9;</span><br><span class="line">                    n-&gt;ofTypename = NULL;</span><br><span class="line">                    n-&gt;constraints = NIL;</span><br><span class="line">                    n-&gt;accessMethod = $10;</span><br><span class="line">                    n-&gt;options = $11;</span><br><span class="line">                    n-&gt;oncommit = $12;</span><br><span class="line">                    n-&gt;tablespacename = $13;</span><br><span class="line">                    n-&gt;if_not_exists = false;</span><br><span class="line">                    $$ = (Node *)n;</span><br><span class="line">                &#125;</span><br><span class="line">				...</span><br></pre></td></tr></table></figure>

<p>如上所示，<code>CREATE TABLE</code> 由关键字 <code>CREATE</code> 和 <code>TABLE</code> 以及其他一些语法解析对象组成。</p>
<ul>
<li><strong>OptTemp</strong> - 临时表的选项，表明该表是否为临时表，此外该选项还可以指定创建无日志表。</li>
<li><strong>qualified_name</strong> - 表名，可以指定表所在的 schema。</li>
<li><strong>OptTableElementList</strong> - 由链表构成的表属性列。</li>
<li><strong>OptInherit</strong> - 表继承相关信息。</li>
<li><strong>OptPartitionSpec</strong> - 表分区相关信息。</li>
<li><strong>table_access_method_clause</strong> - 该选项是计划在 PostgreSQL 12 版本中给出的用于替换存储引擎的选项。</li>
<li><strong>OptWith</strong> - <code>WITH</code> 选项，用于指定表的一些特定选项，例如 <code>fillfactor</code>、<code>parallel_workers</code> 等。</li>
<li><strong>OnCommitOption</strong> - 指定数据在提交时的行为。</li>
<li><strong>OptTableSpace</strong> - 指定表空间信息。</li>
</ul>
<p>从上面的语法分析可以看到，<code>CREATE TABLE</code> 语句在执行完语法分析之后将转换为 <code>CreateStmt</code> 对象，其定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ----------------------</span></span><br><span class="line"><span class="comment"> *      Create Table Statement</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> in the raw gram.y output, ColumnDef and Constraint nodes are</span></span><br><span class="line"><span class="comment"> * intermixed in tableElts, and constraints is NIL.  After parse analysis,</span></span><br><span class="line"><span class="comment"> * tableElts contains just ColumnDefs, and constraints contains just</span></span><br><span class="line"><span class="comment"> * Constraint nodes (in fact, only CONSTR_CHECK nodes, in the present</span></span><br><span class="line"><span class="comment"> * implementation).</span></span><br><span class="line"><span class="comment"> * ----------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CreateStmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    RangeVar   *relation;       <span class="comment">/* relation to create */</span></span><br><span class="line">    List       *tableElts;      <span class="comment">/* column definitions (list of ColumnDef) */</span></span><br><span class="line">    List       *inhRelations;   <span class="comment">/* relations to inherit from (list of</span></span><br><span class="line"><span class="comment">                                 * inhRelation) */</span></span><br><span class="line">    PartitionBoundSpec *partbound;  <span class="comment">/* FOR VALUES clause */</span></span><br><span class="line">    PartitionSpec *partspec;    <span class="comment">/* PARTITION BY clause */</span></span><br><span class="line">    TypeName   *ofTypename;     <span class="comment">/* OF typename */</span></span><br><span class="line">    List       *constraints;    <span class="comment">/* constraints (list of Constraint nodes) */</span></span><br><span class="line">    List       *options;        <span class="comment">/* options from WITH clause */</span></span><br><span class="line">    OnCommitAction oncommit;    <span class="comment">/* what do we do at COMMIT? */</span></span><br><span class="line">    <span class="keyword">char</span>       *tablespacename; <span class="comment">/* table space to use, or NULL */</span></span><br><span class="line">    <span class="keyword">char</span>       *accessMethod;   <span class="comment">/* table access method */</span></span><br><span class="line">    <span class="keyword">bool</span>        if_not_exists;  <span class="comment">/* just do nothing if it already exists? */</span></span><br><span class="line">&#125; CreateStmt;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 在实现时对于内部节点采用了继承的思想，拿我们上面的 <code>CreateStmt</code> 结构体来说，它的第一个成员为 <code>NodeTag</code> 类型，当我们通过 <code>makeNode(CreateStmt)</code> 函数创建 <code>CreateStmt</code> 对象时，其内部通过一个 <code>switch</code> 来判断具体的节点类型，并分配存储空间，而在之后都转换为 <code>Node</code> 类型进行使用，如来 <code>$$ = (Node *) n;</code> 所示。</p>
<p>假如我们有如下的建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (id <span class="type">int</span>, info text);</span><br></pre></td></tr></table></figure>

<p>根据上面的语法规则，由于 <code>OptTemp</code> 部分没有指定因此其值为 <code>RELPERSISTENCE_PERMANENT</code>，<code>qualified_name</code> 则是一个 <code>RangeVar</code> 对象，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RangeVar - range variable, used in FROM clauses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also used to represent table names in utility statements; there, the alias</span></span><br><span class="line"><span class="comment"> * field is not used, and inh tells whether to apply the operation</span></span><br><span class="line"><span class="comment"> * recursively to child tables.  In some contexts it is also useful to carry</span></span><br><span class="line"><span class="comment"> * a TEMP table indication here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RangeVar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    <span class="keyword">char</span>       *catalogname;    <span class="comment">/* the catalog (database) name, or NULL */</span></span><br><span class="line">    <span class="keyword">char</span>       *schemaname;     <span class="comment">/* the schema name, or NULL */</span></span><br><span class="line">    <span class="keyword">char</span>       *relname;        <span class="comment">/* the relation/sequence name */</span></span><br><span class="line">    <span class="keyword">bool</span>        inh;            <span class="comment">/* expand rel by inheritance? recursively act</span></span><br><span class="line"><span class="comment">                                 * on children? */</span></span><br><span class="line">    <span class="keyword">char</span>        relpersistence; <span class="comment">/* see RELPERSISTENCE_* in pg_class.h */</span></span><br><span class="line">    Alias      *alias;          <span class="comment">/* table alias &amp; optional column aliases */</span></span><br><span class="line">    <span class="keyword">int</span>         location;       <span class="comment">/* token location, or -1 if unknown */</span></span><br><span class="line">&#125; RangeVar;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 在解析完表名之后会将表名 <code>test</code> 存放到 <code>RangeVar</code> 对象的 <code>relname</code> 成员中，随后使用<br><code>OptTemp</code> 的值更新 <code>RangeVar</code> 的 <code>relpersistence</code> 成员。</p>
<p>接着，PostgreSQL 对表的属性列进行解析，即 <code>OptTableElementList</code>，它对应的定义为 <code>TableElementList</code>，而 <code>TableElementList</code> 被定义为 <code>TableElement</code> 和 <code>TableElementList &#39;,&#39; TableElement</code>。<code>TableElement</code> 的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TableElement:</span><br><span class="line">            columnDef                           &#123; $$ = $1; &#125;</span><br><span class="line">            | TableLikeClause                   &#123; $$ = $1; &#125;</span><br><span class="line">            | TableConstraint                   &#123; $$ = $1; &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>从定义可以看出，SQL 语句中表的每个属性列在解析完之后都对应一个 <code>columnDef</code> 对象，如果我们为表指定了约束条件，那么就有一个对应的 <code>TableConstraint</code> 对象，如果在其中使用了 <code>LIKE</code> 的话，就对应有一个 <code>TableLikeClause</code> 对象。在本文中我们只关注第一种情况，后面两种情况的分析其实与此类似，故不做详细分析。</p>
<p>在解析阶段，属性列由 <code>ColumnDef</code> 进行表示，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ColumnDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    <span class="keyword">char</span>       *colname;        <span class="comment">/* name of column */</span></span><br><span class="line">    TypeName   *typeName;       <span class="comment">/* type of column */</span></span><br><span class="line">    <span class="keyword">int</span>         inhcount;       <span class="comment">/* number of times column is inherited */</span></span><br><span class="line">    <span class="keyword">bool</span>        is_local;       <span class="comment">/* column has local (non-inherited) def&#x27;n */</span></span><br><span class="line">    <span class="keyword">bool</span>        is_not_null;    <span class="comment">/* NOT NULL constraint specified? */</span></span><br><span class="line">    <span class="keyword">bool</span>        is_from_type;   <span class="comment">/* column definition came from table type */</span></span><br><span class="line">    <span class="keyword">char</span>        storage;        <span class="comment">/* attstorage setting, or 0 for default */</span></span><br><span class="line">    Node       *raw_default;    <span class="comment">/* default value (untransformed parse tree) */</span></span><br><span class="line">    Node       *cooked_default; <span class="comment">/* default value (transformed expr tree) */</span></span><br><span class="line">    <span class="keyword">char</span>        identity;       <span class="comment">/* attidentity setting */</span></span><br><span class="line">    RangeVar   *identitySequence;   <span class="comment">/* to store identity sequence name for</span></span><br><span class="line"><span class="comment">                                     * ALTER TABLE ... ADD COLUMN */</span></span><br><span class="line">    <span class="keyword">char</span>        generated;      <span class="comment">/* attgenerated setting */</span></span><br><span class="line">    CollateClause *collClause;  <span class="comment">/* untransformed COLLATE spec, if any */</span></span><br><span class="line">    Oid         collOid;        <span class="comment">/* collation OID (InvalidOid if not set) */</span></span><br><span class="line">    List       *constraints;    <span class="comment">/* other constraints on column */</span></span><br><span class="line">    List       *fdwoptions;     <span class="comment">/* per-column FDW options */</span></span><br><span class="line">    <span class="keyword">int</span>         location;       <span class="comment">/* parse location, or -1 if none/unknown */</span></span><br><span class="line">&#125; ColumnDef;</span><br></pre></td></tr></table></figure>

<p><code>columnDef</code> 的语法解析如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">columnDef:  ColId Typename create_generic_options ColQualList</span><br><span class="line">                &#123;</span><br><span class="line">                    ColumnDef *n = makeNode(ColumnDef);</span><br><span class="line">                    n-&gt;colname = $1;</span><br><span class="line">                    n-&gt;typeName = $2;</span><br><span class="line">                    n-&gt;inhcount = 0;</span><br><span class="line">                    n-&gt;is_local = true;</span><br><span class="line">                    n-&gt;is_not_null = false;</span><br><span class="line">                    n-&gt;is_from_type = false;</span><br><span class="line">                    n-&gt;storage = 0;</span><br><span class="line">                    n-&gt;raw_default = NULL;</span><br><span class="line">                    n-&gt;cooked_default = NULL;</span><br><span class="line">                    n-&gt;collOid = InvalidOid;</span><br><span class="line">                    n-&gt;fdwoptions = $3;</span><br><span class="line">                    SplitColQualList($4, &amp;n-&gt;constraints, &amp;n-&gt;collClause,</span><br><span class="line">                                     yyscanner);</span><br><span class="line">                    n-&gt;location = @1;</span><br><span class="line">                    $$ = (Node *)n;</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>例如，上面的示例语句将产生两个 <code>ColumnDef</code> 对象，它们通过链表组织在一起，链表的第一个节点的 <code>colname</code> 和 <code>typeName</code> 分别为 <code>id</code> 和 <code>int</code>；第二节点的 <code>colname</code> 和 <code>typeName</code> 分别为 <code>info</code> 和 <code>text</code>。</p>
<p>上面基本上就将示例给出的建表语法介绍完了，<code>CREATE TABLE</code> 语句解析完之后创建的 <code>CreateStmt</code> 对象将通过 <code>makeRawStmt()</code> 函数包装到 <code>RawStmt</code> 结构中，<code>RawStmt</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      RawStmt --- container for any one statement&#x27;s raw parse tree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parse analysis converts a raw parse tree headed by a RawStmt node into</span></span><br><span class="line"><span class="comment"> * an analyzed statement headed by a Query node.  For optimizable statements,</span></span><br><span class="line"><span class="comment"> * the conversion is complex.  For utility statements, the parser usually just</span></span><br><span class="line"><span class="comment"> * transfers the raw parse tree (sans RawStmt) into the utilityStmt field of</span></span><br><span class="line"><span class="comment"> * the Query node, and all the useful work happens at execution time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stmt_location/stmt_len identify the portion of the source text string</span></span><br><span class="line"><span class="comment"> * containing this raw statement (useful for multi-statement strings).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RawStmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line">    Node       *stmt;           <span class="comment">/* raw parse tree */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_location;  <span class="comment">/* start location, or -1 if unknown */</span></span><br><span class="line">    <span class="keyword">int</span>         stmt_len;       <span class="comment">/* length in bytes; 0 means &quot;rest of string&quot; */</span></span><br><span class="line">&#125; RawStmt;</span><br></pre></td></tr></table></figure>

<p>从 <code>RawStmt</code> 的定义可以看出，所有语句最后都被转换为 <code>Node *</code> 的指针被存放到 <code>stmt</code> 成员中。根据 <code>makeRowStmt()</code> 函数的定义也验证的我们的看法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RawStmt *</span></span><br><span class="line"><span class="function"><span class="title">makeRawStmt</span><span class="params">(Node *stmt, <span class="keyword">int</span> stmt_location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RawStmt    *rs = makeNode(RawStmt);</span><br><span class="line"></span><br><span class="line">    rs-&gt;stmt = stmt;</span><br><span class="line">    rs-&gt;stmt_location = stmt_location;</span><br><span class="line">    rs-&gt;stmt_len = <span class="number">0</span>;           <span class="comment">/* might get changed later */</span></span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>上面我们分析了 PostgreSQL 的语法分析部分，接下来我们简要介绍一下 PostgreSQL 的执行流程。首先，我们需要明确 PostgreSQL 是基于多进程开发的，每当一个连接请求过来，PostgreSQL 都将创建一个新的 <code>postgres</code> 进程用于处理用户请求，在用户将需要执行的 SQL 语句发送到后端之后，<code>postgres</code> 进程将从 <code>exec_simple_query()</code> 函数开始进行处理，其主要的流程如下：</p>
<ol>
<li>调用 <code>pg_parse_query()</code> 函数进行词法、语法分析，即我们上面介绍的内容；</li>
<li>循环遍历解析树链表对每个语句进行处理，如果没有查询语句转步骤 7；</li>
<li>调用 <code>pg_analyze_and_rewrite()</code> 函数对解析树分析并重写并生成查询计划；</li>
<li>调用 <code>pg_plan_queries()</code> 对查询树进行优化并选择一条最优路径生成执行计划；</li>
<li>创建 <code>Portal</code> 对象并调用 <code>PortalRun()</code> 函数执行查询计划。</li>
<li>执行 <code>Portal</code> 的清理工作并转步骤 2；</li>
<li>退出。</li>
</ol>
<p>需要注意的是 DDL 在步骤 3 和步骤 4 时不会被重写或优化，而只是简单的在原始解析树外面包装对应的结构而已，只有到了步骤 5 时才会执行转换并生成查询计划。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/devel/sql-createtable.html">https://www.postgresql.org/docs/devel/sql-createtable.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 数据库大小监控</title>
    <url>/2019/09/postgresql-database-size-monitor/</url>
    <content><![CDATA[<p>最近在客户那边了解到一个需求，想要监控 PostgreSQL 数据库每天的大小变化。其实这个功能挺简单的，PostgreSQL 可以通过函数 <code>pg_database_size()</code> 来获取数据库的大小，而客户需要做的就是每天去执行一下，并与上次的结果进行比较就可以得到了。当然，手动执行的效率不是很高，因此，我利用业余时间整理了一下，将这个需求通过 PostgreSQL 插件的形式提供出来。本文主要介绍一下如何实现这个功能。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这个功能的思路挺简单的，首先记录数据库大小，然后定期获取数据库大小，并与上一次数据库的大小相减获取这个数据库的增量，就这么简单。那么，我们需要通过什么技术来实现这个功能呢？当然，我们需要一个定时器；其次，我们需要一个结构来维护数据库的大小历史变更。</p>
<p>当然我们可以通过 shell 来实现这个功能，利用 crontab 添加一个定时器，然后将数据库的大小保存下来，再次获取时数据库大小时减去保存下来的数据库大小值便能获取增量。这里有一个问题就是数据库的大小历史如何来维护？</p>
<p>如果是通过数据库插件来实现，我们可以直接将这些历史变更记录在数据表中，这样做也可以方便后续查询。那么定时器如何实现了？这个其实 PostgreSQL 已经为我们提供了。我们可以通过创建一个后台进程来定期获取数据库的大小，并维护数据库增量信息。</p>
<h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>PostgreSQL 扩展可以在单独的进程中运行用户提供的代码。这些进程由 postgres 启动、停止和监控，这使得它们的生命周期与服务器的状态紧密相关。这些进程可以选择附加到 PostgreSQL 的共享内存区域并在内部连接到数据库。PostgreSQL 后台工作进程由 <code>BackgroundWorker</code> 结构来定义（如下所示），它需要在 <code>_PG_init()</code> 函数中通过 <code>RegisterBackgroundWorker()</code> 来注册。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bgworker_main_type)</span><span class="params">(Datum main_arg)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BackgroundWorker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>        bgw_name[BGW_MAXLEN];</span><br><span class="line">    <span class="keyword">char</span>        bgw_type[BGW_MAXLEN];</span><br><span class="line">    <span class="keyword">int</span>         bgw_flags;</span><br><span class="line">    BgWorkerStartTime bgw_start_time;</span><br><span class="line">    <span class="keyword">int</span>         bgw_restart_time;       <span class="comment">/* in seconds, or BGW_NEVER_RESTART */</span></span><br><span class="line">    <span class="keyword">char</span>        bgw_library_name[BGW_MAXLEN];</span><br><span class="line">    <span class="keyword">char</span>        bgw_function_name[BGW_MAXLEN];</span><br><span class="line">    Datum       bgw_main_arg;</span><br><span class="line">    <span class="keyword">char</span>        bgw_extra[BGW_EXTRALEN];</span><br><span class="line">    <span class="keyword">int</span>         bgw_notify_pid;</span><br><span class="line">&#125; BackgroundWorker;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 该结构在不同的版本之间可能有所不同，请以<a href="https://www.postgresql.org/docs/11/bgworker.html">官网文档</a>为准，本文基于 PostgreSQL 11 版本。</p>
<ul>
<li><code>bgw_name</code> 和 <code>bgw_type</code> 是在日志消息，进程列表和类似上下文中使用的字符串。</li>
<li><code>bgw_flags</code> 是一个按位或位掩码，表示模块想要的功能。目前该域有两个值：<code>BGWORKER_SHMEM_ACCESS</code> - 请求共享内存访问；<code>BGWORKER_BACKEND_DATABASE_CONNECTION</code> - 请求能够建立数据库连接，以便以后可以运行事务和查询(需要与 <code>BGWORKER_SHMEM_ACCESS</code> 联合使用)。</li>
<li><code>bgw_start_time</code> 是 postgres 启动进程的服务器状态。目前该域有三个值：<code>BgWorkerStart_PostmasterStart</code> - postgres 本身完成自己的初始化后立即开始，请求此进程的进程不符合数据库连接的条件；<code>BgWorkerStart_ConsistentState</code> - 在热备用数据库中达到一致状态后立即启动，允许进程以只读的方式连接到数据库；<code>BgWorkerStart_RecoveryFinished</code> - 系统进入正常读写状态后立即启动。最后两个值在不是热备用的服务器中是等效的。此设置仅指示何时启动进程；当达到不同的状态时，它们不会停止。</li>
<li><code>bgw_restart_time</code> 是 postgres 在重新启动进程之前应该等待的时间间隔（以秒为单位）。当设置为 <code>BGW_NEVER_RESTART</code> 则表示崩溃后不重新启动进程。</li>
<li><code>bgw_library_name</code> - 是库的名称，在该库中应该包含后台工作进程的入口点。如果是从核心代码中加载函数，需要将其设置为 “postgres”。</li>
<li><code>bgw_function_name</code> 是动态加载库中函数的名称，该函数是新后台工作进程的入口点。</li>
<li><code>bgw_main_arg</code> 是后台进程入口函数的参数，参数类型为 <code>Datum</code>。</li>
</ul>
<p>更多关于该结构的介绍请看官方文档，任何时候您都应该以官方文档为主。</p>
<p>我们可以在后台进程中通过定时器来定时执行相应的 SQL 来查询数据库大小并计算数据库的增量。PostgreSQL 提供了 Latch 机制，我们可以利用它很方便地实现定时器功能。</p>
<h2 id="扩展插件"><a href="#扩展插件" class="headerlink" title="扩展插件"></a>扩展插件</h2><p>关于如何编写 PostgreSQL 可以参考<a href="/2018/12/write-postgresql-extension/" title="这里">这里</a>，当然第一手资料还是<a href="https://www.postgresql.org/docs/11/extend-pgxs.html">官方文档</a>。我们首先新建一个 <code>pg_dbsm</code> 目录用于存放该插件源码，其内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  pg_dbsm ls -l</span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--  1 japinli  staff   277 Sep  4 22:32 Makefile</span><br><span class="line">-rw-r--r--  1 japinli  staff   244 Sep  4 22:29 README.md</span><br><span class="line">-rw-r--r--  1 japinli  staff   402 Sep  4 22:24 pg_dbsm--0.0.1.sql</span><br><span class="line">-rw-r--r--  1 japinli  staff  7785 Sep  4 22:38 pg_dbsm.c</span><br><span class="line">-rw-r--r--  1 japinli  staff    98 Sep  4 22:23 pg_dbsm.control</span><br></pre></td></tr></table></figure>

<p>为了方便配置定时器的时间，我们将定时器的值以参数的形式给出，与此同时，我们需要连接一个数据库用于创建需要存储数据库大小历史记录，为此，我们增加了一个数据库参数，我们将在该数据库中建立一个名为 <code>dbsm</code> 的数据表，其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# \d+ dbsm</span><br><span class="line">                                            Table &quot;public.dbsm&quot;</span><br><span class="line"> Column  |           Type           | Collation | Nullable | Default | Storage | Stats target | Description</span><br><span class="line">---------+--------------------------+-----------+----------+---------+---------+--------------+-------------</span><br><span class="line"> datname | name                     |           | not null |         | plain   |              |</span><br><span class="line"> created | timestamp with time zone |           |          | now()   | plain   |              |</span><br><span class="line"> datsize | bigint                   |           | not null |         | plain   |              |</span><br><span class="line"> incsize | bigint                   |           |          |         | plain   |              |</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;idx_datname_created&quot; btree (datname, created)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后台进程的处理流程如下：</p>
<ol>
<li>设置信号处理函数；</li>
<li>连接 <code>dbsm_database</code> 指定的数据库，默认为 <code>postgres</code>；</li>
<li>初始化数据库表对象，即 <code>dbsm</code>，并建立索引；</li>
<li>构建查询 SQL 语句；</li>
<li>循环执行查询 SQL 语句并更新 <code>dbsm</code> 表。</li>
</ol>
<p>上面的流程主要在函数 <code>dbsm_main()</code> 中体现，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">dbsm_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringInfoData    buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish signal handlers before unblocking signals. */</span></span><br><span class="line">    pqsignal(SIGHUP, dbsm_sighup);</span><br><span class="line">    pqsignal(SIGTERM, dbsm_sigterm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We&#x27;re now ready to receive signals */</span></span><br><span class="line">    BackgroundWorkerUnblockSignals();</span><br><span class="line"></span><br><span class="line">    BackgroundWorkerInitializeConnection(dbsm_database, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    initialize_dbsm_object();</span><br><span class="line"></span><br><span class="line">    initStringInfo(&amp;buf);</span><br><span class="line">    appendStringInfo(&amp;buf,</span><br><span class="line">                     <span class="string">&quot;WITH m AS (SELECT DISTINCT ON (datname) datname, &quot;</span></span><br><span class="line">                     <span class="string">&quot;datsize FROM dbsm ORDER BY datname, created DESC) &quot;</span></span><br><span class="line">                     <span class="string">&quot;INSERT INTO dbsm SELECT d.datname, now(), &quot;</span></span><br><span class="line">                     <span class="string">&quot;pg_database_size(d.datname) AS datsize, &quot;</span></span><br><span class="line">                     <span class="string">&quot;CASE WHEN m.datsize = NULL THEN 0 &quot;</span></span><br><span class="line">                     <span class="string">&quot;ELSE pg_database_size(d.datname) - m.datsize END AS incsize &quot;</span></span><br><span class="line">                     <span class="string">&quot;FROM pg_database d LEFT JOIN m ON m.datname = d.datname;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Main loop: do this until the SIGTERM handler tells us to terminate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!got_sigterm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>    ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Background workers mustn&#x27;t call usleep() or any direct equivalent:</span></span><br><span class="line"><span class="comment">         * instead, they may wait on their process latch, which sleeps as</span></span><br><span class="line"><span class="comment">         * necessary, but is awakened if postmaster dies.  That way the</span></span><br><span class="line"><span class="comment">         * background process goes away immediately in an emergency.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        (<span class="keyword">void</span>) WaitLatch(MyLatch,</span><br><span class="line">                         WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH,</span><br><span class="line">                         dbsm_naptime * <span class="number">1000L</span>,</span><br><span class="line">                         PG_WAIT_EXTENSION);</span><br><span class="line">        ResetLatch(MyLatch);</span><br><span class="line"></span><br><span class="line">        CHECK_FOR_INTERRUPTS();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In case of a SIGHUP, just reload the configuration.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (got_sighup)</span><br><span class="line">        &#123;</span><br><span class="line">            got_sighup = <span class="literal">false</span>;</span><br><span class="line">            ProcessConfigFile(PGC_SIGHUP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Start a transaction on which we can run queries.  Note that each</span></span><br><span class="line"><span class="comment">         * StartTransactionCommand() call should be preceded by a</span></span><br><span class="line"><span class="comment">         * SetCurrentStatementStartTimestamp() call, which sets both the time</span></span><br><span class="line"><span class="comment">         * for the statement we&#x27;re about the run, and also the transaction</span></span><br><span class="line"><span class="comment">         * start time.  Also, each other query sent to SPI should probably be</span></span><br><span class="line"><span class="comment">         * preceded by SetCurrentStatementStartTimestamp(), so that statement</span></span><br><span class="line"><span class="comment">         * start time is always up to date.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The SPI_connect() call lets us run queries through the SPI manager,</span></span><br><span class="line"><span class="comment">         * and the PushActiveSnapshot() call creates an &quot;active&quot; snapshot</span></span><br><span class="line"><span class="comment">         * which is necessary for queries to have MVCC data to work on.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The pgstat_report_activity() call makes our activity visible</span></span><br><span class="line"><span class="comment">         * through the pgstat views.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SetCurrentStatementStartTimestamp();</span><br><span class="line">        StartTransactionCommand();</span><br><span class="line">        SPI_connect();</span><br><span class="line">        PushActiveSnapshot(GetTransactionSnapshot());</span><br><span class="line">        pgstat_report_activity(STATE_RUNNING, buf.data);</span><br><span class="line"></span><br><span class="line">        ret = SPI_execute(buf.data, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != SPI_OK_INSERT)</span><br><span class="line">            elog(FATAL, <span class="string">&quot;execute: \&quot;%s\&quot; failed&quot;</span>, buf.data);</span><br><span class="line"></span><br><span class="line">        SPI_finish();</span><br><span class="line">        PopActiveSnapshot();</span><br><span class="line">        CommitTransactionCommand();</span><br><span class="line">        pgstat_report_stat(<span class="literal">false</span>);</span><br><span class="line">        pgstat_report_activity(STATE_IDLE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pfree(buf.data);</span><br><span class="line">    proc_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当启动数据库后，我们运行一段时间后查询表 <code>dbsm</code> 便可以看到如图所示的结果。</p>
<img src="/2019/09/postgresql-database-size-monitor/result.png" class="" title="效果图">

<p>完整代码在<a href="https://github.com/japinli/pg_dbsm">这里</a>。当然，这个代码目前还不完善，可能存在一些问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/11/bgworker.html">https://www.postgresql.org/docs/11/bgworker.html</a><br>[2] <a href="https://www.postgresql.org/docs/11/extend-pgxs.html">https://www.postgresql.org/docs/11/extend-pgxs.html</a><br>[3] <a href="https://tapoueh.org/images/confs/extension-tutoriel.pdf">https://tapoueh.org/images/confs/extension-tutoriel.pdf</a><br>[4] <a href="https://github.com/postgres/postgres/blob/REL_11_STABLE/src/test/modules/worker_spi/worker_spi.c">https://github.com/postgres/postgres/blob/REL_11_STABLE/src/test/modules/worker_spi/worker_spi.c</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 动态库加载过程</title>
    <url>/2022/07/postgresql-dynamic-libraries-loading-process/</url>
    <content><![CDATA[<blockquote>
<p>在使用 pg_backtrace 插件时，必须执行 <code>SELECT pg_backtrace_init();</code>，不执行该函数插件就不生效，官方文档也特别说明了，而实际上该函数是一个空函数，为什么必须要执行该函数才生效呢？</p>
</blockquote>
<p>这是一个朋友问我关于 pg_backtrace 的问题，这主要涉及到 PostgreSQL 中动态库的加载过程。本文在分析问题的基础之上，简要梳理一下 PostgreSQL 中动态库的加载过程。</p>
<span id="more"></span>

<h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><p>首先编译安装 PostgreSQL 数据库（16devel），随后下载 <a href="https://github.com/TsinghuaLucky912/pg_backtrace">pg_backtrace</a> 编译安装。接着初始化数据库并启动，最后添加 pg_backtrace 插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ initdb -D testdb</span><br><span class="line">$ pg_ctl -l <span class="built_in">log</span> -D testdb start</span><br><span class="line">$ psql postgres -c <span class="string">&#x27;CREATE EXTENSION pg_backtrace&#x27;</span></span><br></pre></td></tr></table></figure>

<p>一切准备就绪，我们来重现一下问题，使用 psql 登录数据库，并执行下面的 SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">/</span> <span class="number">0</span>;</span><br><span class="line">ERROR:  division <span class="keyword">by</span> zero</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> pg_backtrace_init();</span><br><span class="line"> pg_backtrace_init</span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">/</span> <span class="number">0</span>;</span><br><span class="line">ERROR:  division <span class="keyword">by</span> zero</span><br><span class="line">CONTEXT:        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(int4div<span class="operator">+</span><span class="number">0x6e</span>) [<span class="number">0x564f9872a279</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x386543</span>) [<span class="number">0x564f983e3543</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(ExecInterpExprStillValid<span class="operator">+</span><span class="number">0x53</span>) [<span class="number">0x564f983e56be</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x51553a</span>) [<span class="number">0x564f9857253a</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(evaluate_expr<span class="operator">+</span><span class="number">0xa1</span>) [<span class="number">0x564f9857a364</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x51c4ca</span>) [<span class="number">0x564f985794ca</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x51b627</span>) [<span class="number">0x564f98578627</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x518b5d</span>) [<span class="number">0x564f98575b5d</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(expression_tree_mutator<span class="operator">+</span><span class="number">0x1500</span>) [<span class="number">0x564f984ad27f</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x51af88</span>) [<span class="number">0x564f98577f88</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(expression_tree_mutator<span class="operator">+</span><span class="number">0x197b</span>) [<span class="number">0x564f984ad6fa</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x51af88</span>) [<span class="number">0x564f98577f88</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(eval_const_expressions<span class="operator">+</span><span class="number">0x6f</span>) [<span class="number">0x564f98575168</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x4ee403</span>) [<span class="number">0x564f9854b403</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(subquery_planner<span class="operator">+</span><span class="number">0x56a</span>) [<span class="number">0x564f9854a8b8</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(standard_planner<span class="operator">+</span><span class="number">0x2b8</span>) [<span class="number">0x564f98549a86</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(planner<span class="operator">+</span><span class="number">0x58</span>) [<span class="number">0x564f985497c4</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(pg_plan_query<span class="operator">+</span><span class="number">0x7f</span>) [<span class="number">0x564f9868e277</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(pg_plan_queries<span class="operator">+</span><span class="number">0xfa</span>) [<span class="number">0x564f9868e3c1</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x63179f</span>) [<span class="number">0x564f9868e79f</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(PostgresMain<span class="operator">+</span><span class="number">0x7b5</span>) [<span class="number">0x564f986933ef</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x55e0c2</span>) [<span class="number">0x564f985bb0c2</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x55d9b0</span>) [<span class="number">0x564f985ba9b0</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x559c28</span>) [<span class="number">0x564f985b6c28</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(PostmasterMain<span class="operator">+</span><span class="number">0x1367</span>) [<span class="number">0x564f985b63d9</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(<span class="operator">+</span><span class="number">0x41d5f5</span>) [<span class="number">0x564f9847a5f5</span>]</span><br><span class="line">        <span class="operator">/</span>lib<span class="operator">/</span>x86_64<span class="operator">-</span>linux<span class="operator">-</span>gnu<span class="operator">/</span>libc.so<span class="number">.6</span>(__libc_start_main<span class="operator">+</span><span class="number">0xe7</span>) [<span class="number">0x7f3feebc2c87</span>]</span><br><span class="line">        postgres: japin postgres [<span class="keyword">local</span>] <span class="keyword">SELECT</span>(_start<span class="operator">+</span><span class="number">0x2a</span>) [<span class="number">0x564f981282ba</span>]</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看到我们需要执行 <code>pg_backtrace()</code> 函数，才能在错误消息中打印出详细的堆栈信息。那么它做了什么呢？我前面已经提到了，它什么都没有做，其实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum <span class="title">pg_backtrace_init</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PG_RETURN_VOID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然它什么都没有做，为什么前后两次的执行效果不一致呢？它必然在后面做了一些操作。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>既然是 <code>pg_backtrace_init()</code> 函数引起的不同，那么我们就针对这个函数来看看它都干了什么，我们可以通过 gdb 附加进程并在该函数打断点从而确定其调用栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b pg_backtrace_init</span><br><span class="line">Function &quot;pg_backtrace_init&quot; not defined.</span><br><span class="line">Make breakpoint pending on future shared library load? (y or [n]) y</span><br><span class="line">Breakpoint 1 (pg_backtrace_init) pending.</span><br></pre></td></tr></table></figure>

<p>从上面的提示，您是否已经猜到答案了？如果没有请继续看下面的分析。</p>
<p>设置好断点之后，我们来执行 <code>SELECT pg_backtrace_init();</code>，可以看到程序在 <code>pg_backtrace_init()</code> 处停止下来，查看堆栈发现并没有什么特别的，我们在继续执行也没有什么有关 pg_backtrace 的特殊处理。这是怎么回事呢？我们在回头来看看 gdb 下断点时给出的提示信息，在当前的代码中没有找到 <code>pg_backtrace_init()</code> 函数，使断点在将来的共享库加载时挂起。我们实际上也在 <code>pg_backtrace_init()</code> 处停止下来了，那么这个动态库肯定是加载了。它又是何时加载的呢？</p>
<p>既然会加载动态库，我们知道 PostgreSQL 在加载动态库时会执行 <code>_PG_init()</code> 函数，我们看看 pg_backtrace 中该函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _PG_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	signal_handlers[SIGSEGV] = pqsignal(SIGSEGV, backtrace_handler);</span><br><span class="line">	signal_handlers[SIGBUS] = pqsignal(SIGBUS, backtrace_handler);</span><br><span class="line">	signal_handlers[SIGFPE] = pqsignal(SIGFPE, backtrace_handler);</span><br><span class="line">	signal_handlers[SIGINT] = pqsignal(SIGINT, backtrace_handler);</span><br><span class="line">	prev_executor_run_hook = ExecutorRun_hook;</span><br><span class="line">	ExecutorRun_hook = backtrace_executor_run_hook;</span><br><span class="line"></span><br><span class="line">	prev_utility_hook = ProcessUtility_hook;</span><br><span class="line">	ProcessUtility_hook = backtrace_utility_hook;</span><br><span class="line"></span><br><span class="line">	prev_post_parse_analyze_hook = post_parse_analyze_hook;</span><br><span class="line">	post_parse_analyze_hook = backtrace_post_parse_analyze_hook;</span><br><span class="line"></span><br><span class="line">	DefineCustomEnumVariable(<span class="string">&quot;pg_backtrace.level&quot;</span>,</span><br><span class="line">							 <span class="string">&quot;Set error level for dumping backtrace&quot;</span>,</span><br><span class="line">							 <span class="literal">NULL</span>,</span><br><span class="line">							 &amp;backtrace_level,</span><br><span class="line">							 ERROR,</span><br><span class="line">							 backtrace_level_options,</span><br><span class="line">							 PGC_USERSET, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它添加了三个 hook，拦截了 4 个信号，同时定义了一个配置参数。看到这里我们就能猜到为什么执行 <code>pg_backtrace_init()</code> 之后结果不一样了。空函数 <code>pg_backtrace_init()</code> 主要的作用是加载 <code>pg_backtracs.so</code> 动态库，一旦该动态库加载之后，pg_backtrace 就可以执行自定义 hook 来进行处理。这里就不在对 hook 的具体实现做分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b _PG_init</span><br><span class="line">Function &quot;_PG_init&quot; not defined.</span><br><span class="line">Make breakpoint pending on future shared library load? (y or [n]) y</span><br><span class="line">Breakpoint 1 (_PG_init) pending.</span><br><span class="line">(gdb) b pg_backtrace_init</span><br><span class="line">Function &quot;pg_backtrace_init&quot; not defined.</span><br><span class="line">Make breakpoint pending on future shared library load? (y or [n]) y</span><br><span class="line">Breakpoint 2 (pg_backtrace_init) pending.</span><br></pre></td></tr></table></figure>

<p>当我们再次执行 <code>SELECT pg_backtrace_init()</code> 时，您可以看到如下的堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  _PG_init () at pg_backtrace.c:142</span><br><span class="line">#1  0x0000564f98857ec5 in internal_load_library (</span><br><span class="line">    libname=0x564f9924a198 &quot;/mnt/workspace/postgresql/build/pg/lib/pg_backtrace.so&quot;)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/utils/fmgr/dfmgr.c:289</span><br><span class="line">#2  0x0000564f98857873 in load_external_function (</span><br><span class="line">    filename=0x564f9924a0c8 &quot;$libdir/pg_backtrace&quot;,</span><br><span class="line">    funcname=0x564f9924a090 &quot;pg_backtrace_init&quot;, signalNotFound=true,</span><br><span class="line">    filehandle=0x7fff9a88fde8)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/utils/fmgr/dfmgr.c:116</span><br><span class="line">#3  0x0000564f9885963d in fmgr_info_C_lang (functionId=16385, finfo=0x564f9924a000,</span><br><span class="line">    procedureTuple=0x7f3fe59defd8)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/utils/fmgr/fmgr.c:400</span><br><span class="line">#4  0x0000564f9885912d in fmgr_info_cxt_security (functionId=16385,</span><br><span class="line">    finfo=0x564f9924a000, mcxt=0x564f99249800, ignore_security=false)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/utils/fmgr/fmgr.c:248</span><br><span class="line">#5  0x0000564f98858dcf in fmgr_info (functionId=16385, finfo=0x564f9924a000)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/utils/fmgr/fmgr.c:128</span><br><span class="line">#6  0x0000564f983dde2a in ExecInitFunc (scratch=0x7fff9a890400, node=0x564f991835f0,</span><br><span class="line">    args=0x0, funcid=16385, inputcollid=0, state=0x564f99249f70)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/executor/execExpr.c:2748</span><br><span class="line">#7  0x0000564f983d9fda in ExecInitExprRec (node=0x564f991835f0, state=0x564f99249f70,</span><br></pre></td></tr></table></figure>

<p>即 pg_backtrace 插件是通过 <code>internal_load_library()</code> 函数加载的，我们在 gdb 中执行<br><code>continue</code>，它会执行 <code>pg_backtrace_init()</code> 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, pg_backtrace_init (fcinfo=0x564f9924a058) at pg_backtrace.c:182</span><br><span class="line">182             PG_RETURN_VOID();</span><br></pre></td></tr></table></figure>

<p>分析到这里，我们已经清楚了为什么 <code>pg_backtrace_init()</code> 函数为空，而 pg_backtrace 却能在执行该函数之后输出堆栈信息了。</p>
<h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>根据上面的分析，要想使用使用 pg_backtrace 提供的功能，我们仅需要加载动态库即可。我们知道 PostgreSQL 提供了 <code>shared_preload_libraries</code> 和 <code>session_preload_libraries</code> 来个参数指定需要添加的动态库。其中 <code>shared_preload_libraries</code> 是所有后端进程（backend）共享的，而 <code>session_preload_libraries</code> 则是单个会话的。那我们将其添加到这个两个参数中的其中一个是否不需要执行 <code>pg_backtrace_init()</code> 函数即可使用 pg_backtrace 提供的功能呢？答案当然是不需要了。</p>
<p>但是，当我将其配置在 <code>shared_preload_libraries</code> 参数中时，我通过 <code>pg_ctl stop [-m fast]</code> 却不能将数据库停下，这又是为什么呢？如果使用 <code>pg_ctl stop -m &#123; smart | immediate &#125;</code> 则可以将数据库停下。</p>
<p>通过查看源码，我们知道 <code>pg_ctl stop [-m fast]</code> 实际上是发送的 <code>SIGINT</code> 信号给主进程，我们注意到 pg_backtrace 在加载时拦截了 <code>SIGINT</code> 信息，其信号处理函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">backtrace_handler</span><span class="params">(SIGNAL_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inside_signal_handler = <span class="literal">true</span>;</span><br><span class="line">	elog(LOG, <span class="string">&quot;Caught signal %d&quot;</span>, postgres_signal_arg);</span><br><span class="line">	inside_signal_handler = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (postgres_signal_arg != SIGINT &amp;&amp; signal_handlers[postgres_signal_arg])</span><br><span class="line">		signal_handlers[postgres_signal_arg](postgres_signal_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到 <code>SIGINT</code> 信号时，pg_backtrace 直接将其忽略了，这就是为什么主进程在执行 <code>pg_ctl stop [-m fast]</code> 不能停机的原因。</p>
<p>那么为什么设置在 <code>session_preload_libraries</code> 中又可以呢？这就涉及到两个参数加载的时机问题以及 PostgreSQL 父子进程对于 <code>SIGINT</code> 信号的处理了。下图简要给出了这两个参数的处理流程：</p>
<img src="/2022/07/postgresql-dynamic-libraries-loading-process/postgres-dynamic-libraries-loading-process.png" class="">

<p>PostgreSQL 在主进程中使用 <code>SIGINT</code> 作为停机的一种方式，它会其子进程发送 <code>SIGTERM</code> 信号，而子进程（不一定是所有的子进程）则使用 <code>SIGINT</code> 作为取消查询的一种方式。因此，即便我们将 pg_backtrace 设置在 <code>session_preload_libraries</code> 中，依然会导致问题。当然，只要您使用了该插件，都会遇到这个问题，要么是无法使用 <code>pg_ctl stop [-m fast]</code> 正常停机（配置在 <code>shared_preload_libraries</code> 中），要么是无法取消正在执行的查询（配置在 <code>session_preload_libraries</code> 或 <code>local_preload_libraries</code> 或者执行 <code>pg_backtrace_init()</code>）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这个过程中，我们对 PostgreSQL 的动态库加载有了一个基本的认识，它提供了三种加载方式。</p>
<ol>
<li>通过 <code>process_shared_preload_libraries()</code> 全局加载。</li>
<li>通过 <code>process_session_preload_libraries()</code> 仅在后端进程中加载。</li>
<li>通过 <code>load_external_function()</code> 按需动态加载。</li>
</ol>
<div class="just-for-fun">
笑林广记 - 借牛

<p>有走柬借牛于富翁者，翁方对客，讳不识字，伪启缄视之，对来使曰：“知道了，少刻我自来也。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 自定义参数的标识符问题</title>
    <url>/2022/02/postgresql-custom-variables-identifier/</url>
    <content><![CDATA[<p>PostgreSQL 提供了自定义参数的功能，您可以使用 <a href="https://www.postgresql.org/docs/14/sql-set.html"><code>SET</code></a> 或 <a href="https://www.postgresql.org/docs/14/functions-admin.html#FUNCTIONS-ADMIN-SET"><code>set_config()</code></a> 函数来定义参数，本文介绍一下在 PG14（14.1 和 14.2）中引入的关于自定义参数标识符的的问题 <a href="https://www.postgresql.org/message-id/17415-ebdb683d7e09a51c%40postgresql.org">BUG #17415</a>。</p>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>既然说在 PG13 上可以正常工作，那么我们先测试 PG13，看看具体是什么样的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> version();</span><br><span class="line">                                               version</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> PostgreSQL <span class="number">13.6</span> <span class="keyword">on</span> x86_64<span class="operator">-</span>pc<span class="operator">-</span>linux<span class="operator">-</span>gnu, compiled <span class="keyword">by</span> gcc (Ubuntu <span class="number">9.3</span><span class="number">.0</span><span class="number">-17</span>ubuntu1<span class="operator">~</span><span class="number">20.04</span>) <span class="number">9.3</span><span class="number">.0</span>, <span class="number">64</span><span class="operator">-</span>bit</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SET</span> custom._my_guc <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SHOW</span> custom._my_guc;</span><br><span class="line"> custom._my_guc</span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> <span class="number">50</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>接着，我们在 PG14 上面来进行测试。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> version();</span><br><span class="line">                                               version</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> PostgreSQL <span class="number">14.2</span> <span class="keyword">on</span> x86_64<span class="operator">-</span>pc<span class="operator">-</span>linux<span class="operator">-</span>gnu, compiled <span class="keyword">by</span> gcc (Ubuntu <span class="number">9.3</span><span class="number">.0</span><span class="number">-17</span>ubuntu1<span class="operator">~</span><span class="number">20.04</span>) <span class="number">9.3</span><span class="number">.0</span>, <span class="number">64</span><span class="operator">-</span>bit</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SET</span> custom._my_guc <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">ERROR:  invalid configuration <span class="keyword">parameter</span> name &quot;custom._my_guc&quot;</span><br><span class="line">DETAIL:  Custom <span class="keyword">parameter</span> names must be two <span class="keyword">or</span> more simple identifiers separated <span class="keyword">by</span> dots.</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，PG14 中以 <code>_</code> 开头的自定义变量将触发语法错误。</p>
<p>在 PostgreSQL 中，参数可以包含一个或多个<a href="https://www.postgresql.org/docs/14/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">标识符</a>，多个标识符由 <code>.</code> 连接。而标识符则是由字母（<code>a-z</code> 以及带变音符号的字母和非拉丁字母）和 <code>_</code> 组成的，按照这个说法那么以 <code>_</code> 开头是可以接受的，为什么触发了语法错误呢？</p>
<p>通过错误信息我们可以定位到 <code>guc.c</code> 这个文件中的 <code>find_option()</code> 函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct config_generic *</span></span><br><span class="line"><span class="function"><span class="title">find_option</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> create_placeholders, <span class="keyword">bool</span> skip_errors,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> elevel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_placeholders)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check if the name is valid, and if so, add a placeholder.  If it</span></span><br><span class="line"><span class="comment">         * doesn&#x27;t contain a separator, don&#x27;t assume that it was meant to be a</span></span><br><span class="line"><span class="comment">         * placeholder.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(name, GUC_QUALIFIER_SEPARATOR) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_custom_variable_name(name))</span><br><span class="line">                <span class="keyword">return</span> add_placeholder_variable(name, elevel);</span><br><span class="line">            <span class="comment">/* A special error message seems desirable here */</span></span><br><span class="line">            <span class="keyword">if</span> (!skip_errors)</span><br><span class="line">                ereport(elevel,</span><br><span class="line">                        (errcode(ERRCODE_INVALID_NAME),</span><br><span class="line">                         errmsg(<span class="string">&quot;invalid configuration parameter name \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                                name),</span><br><span class="line">                         errdetail(<span class="string">&quot;Custom parameter names must be two or more simple identifiers separated by dots.&quot;</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的逻辑可以看到，当 <code>valid_custom_variable_name()</code> 函数验证失败之后才有可能进入到下面的错误处理中，因此，可以断定问题出在 <code>valid_custom_variable_name()</code> 函数中，接着我们看看该函数的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decide whether a proposed custom variable name is allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It must be two or more identifiers separated by dots, where the rules</span></span><br><span class="line"><span class="comment"> * for what is an identifier agree with scan.l.  (If you change this rule,</span></span><br><span class="line"><span class="comment"> * adjust the errdetail in find_option().)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">valid_custom_variable_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span>        saw_sep = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span>        name_start = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = name; *p; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == GUC_QUALIFIER_SEPARATOR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (name_start)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">/* empty name component */</span></span><br><span class="line">            saw_sep = <span class="literal">true</span>;</span><br><span class="line">            name_start = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">                        <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, *p) != <span class="literal">NULL</span> ||</span><br><span class="line">                 IS_HIGHBIT_SET(*p))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* okay as first or non-first character */</span></span><br><span class="line">            name_start = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!name_start &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;0123456789_$&quot;</span>, *p) != <span class="literal">NULL</span>)</span><br><span class="line">             <span class="comment">/* okay as non-first character */</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name_start)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">/* empty name component */</span></span><br><span class="line">    <span class="comment">/* OK if we found at least one separator */</span></span><br><span class="line">    <span class="keyword">return</span> saw_sep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码不是特别复杂，该函数是用于检查自定义参数是否合法的，自定义参数必须是由 <code>.</code> 分割的两个或多个标识符，该标识符与 <code>scan.l</code> 中的标识符相同。那么我们看看 <code>scan.l</code> 中是如何定义标识符的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ident_start     [A-Za-z\200-\377_]</span><br><span class="line">ident_cont      [A-Za-z\200-\377_0-9\$]</span><br><span class="line"></span><br><span class="line">identifier      &#123;ident_start&#125;&#123;ident_cont&#125;*</span><br></pre></td></tr></table></figure>

<p>这与上面提到的标识符定义相吻合。<code>ident_start</code> 中包含了 <code>_</code>，然而在 <code>valid_custom_variable_name()</code> 函数中，处理标识符的第一个字符（循环中第一个 <code>eles if</code> 语句）时忽略了 <code>_</code>，因此导致语法错误。我们可以利用 <code>git blame</code> 来查看该函数的更改记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L :valid_custom_variable_name $(find . -name guc.c)</span></span><br><span class="line">[...]</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5473)              else if (strchr(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5474)                                              &quot;abcdefghijklmnopqrstuvwxyz&quot;, *p) != NULL ||</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5475)                               IS_HIGHBIT_SET(*p))</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5476)              &#123;</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5477)                      /* okay as first or non-first character */</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5478)                      name_start = false;</span><br><span class="line">3db826bd55c (Tom Lane      2021-04-07 11:22:22 -0400 5479)              &#125;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>3db826bd55c 这个提交导致了这个问题，通过测试 3db826bd55c 之前的一个记录发现 <code>SET custom._my_guc = 50;</code> 可以正常使用，而这个提交之后的便出现语法错误。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个问题相对比较简单，主要就是 <code>_</code> 这个字符放错了位置，我们将其从第二个 <code>else if</code> 移到第一个中即可解决。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="comment">index e4afd07bfe..bf7ec0d466 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="meta">@@ -5474,13 +5474,13 @@</span> valid_custom_variable_name(const char *name)</span><br><span class="line">                        name_start = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (strchr(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line"><span class="deletion">-                                               &quot;abcdefghijklmnopqrstuvwxyz&quot;, *p) != NULL ||</span></span><br><span class="line"><span class="addition">+                                               &quot;abcdefghijklmnopqrstuvwxyz_&quot;, *p) != NULL ||</span></span><br><span class="line">                                 IS_HIGHBIT_SET(*p))</span><br><span class="line">                &#123;</span><br><span class="line">                        /* okay as first or non-first character */</span><br><span class="line">                        name_start = false;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="deletion">-               else if (!name_start &amp;&amp; strchr(&quot;0123456789_$&quot;, *p) != NULL)</span></span><br><span class="line"><span class="addition">+               else if (!name_start &amp;&amp; strchr(&quot;0123456789$&quot;, *p) != NULL)</span></span><br><span class="line">                         /* okay as non-first character */ ;</span><br><span class="line">                else</span><br><span class="line">                        return false;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/14/sql-set.html">https://www.postgresql.org/docs/14/sql-set.html</a><br>[2] <a href="https://www.postgresql.org/docs/14/functions-admin.html#FUNCTIONS-ADMIN-SET">https://www.postgresql.org/docs/14/functions-admin.html#FUNCTIONS-ADMIN-SET</a><br>[3] <a href="https://www.postgresql.org/docs/14/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">https://www.postgresql.org/docs/14/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a><br>[4] <a href="https://www.postgresql.org/message-id/17415-ebdb683d7e09a51c%40postgresql.org">https://www.postgresql.org/message-id/17415-ebdb683d7e09a51c%40postgresql.org</a></p>
<div class="just-for-fun">
笑林广记 - 书低

<p>一生赁僧房读书，每日游玩，午后归房。<br>呼童取书来，童持《文选》，视之曰低；持《汉书》，视之曰低；又持《史记》，视之曰低。<br>僧大诧曰：“此三书熟其一，足称饱学，俱云低何也？”<br>生曰：“我要睡，取书作枕头耳。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>BUG</tag>
        <tag>PG14</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 编辑查询缓冲区</title>
    <url>/2020/05/postgresql-edit-query-buffer/</url>
    <content><![CDATA[<p>我们经常需要在 psql 中修改查询语句，例如，我们编辑了几行查询语句，然后需要修改之前的内容，我之前额做法就是 Ctrl-C 然后在重新输入。其实，我们可以不必这么复杂。我们可以使用 <code>\e</code> 命令来编辑查询缓冲区。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT * FROM</span><br><span class="line">postgres-# pg_calss</span><br><span class="line">postgres-# WHERE relname = &#x27;pg_class&#x27;</span><br><span class="line">postgres-#</span><br></pre></td></tr></table></figure>

<p>此时，我们发现 <code>pg_calss</code> 拼写错了，那么我们可以通过 <code>\e</code> 对其进行修改。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres-# WHERE relname = &#x27;pg_class&#x27;</span><br><span class="line">postgres-# \e</span><br><span class="line">  1 SELECT * FROM</span><br><span class="line">  2 pg_class</span><br><span class="line">  3 WHERE relname = &#x27;pg_class&#x27;</span><br></pre></td></tr></table></figure>

<p><code>\e</code> 命令将会创建一个临时文件，然后我们便可以通过编辑文件的方式对其进行修改了，当保存之后，psql 将会把文件内容存放到查询缓冲区中。</p>
<p><code>\e [ filename ] [ line_number ]</code> 命令还可以接文件和行号，文件指定了我们想要编辑的文件，行号则表明文件打开时光标所处的位置。注意，如果仅跟一个数字，该命令将其视为行号，例如 <code>\e 3</code> 表示编辑查询缓冲区，并将光标移动到第三行。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 快照导出和导入</title>
    <url>/2022/09/postgresql-export-snapshot/</url>
    <content><![CDATA[<p>PostgreSQL 允许数据库会话同步它们的快照。快照确定哪些数据对使用快照的事务可见。当两个或多个会话需要查看数据库中的相同内容时，需要同步快照。如果两个会话只是独立地开始它们的事务，在两个 <code>START TRANSACTION</code> 命令的执行之间总是有可能提交第三个事务，这样一个会话可以看到该事务的效果，而另一个则看不到。</p>
<p>为了解决这个问题，PostgreSQL 允许事务导出它正在使用的快照。只要导出快照的事务保持打开状态，其他事务就可以导入这个快照，从而保证它们看到的数据库视图与第一个事务看到的完全相同。</p>
<p>快照可以通过 <a href="https://www.postgresql.org/docs/14/functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE"><code>pg_export_snapshot()</code></a> 函数导出，并通过 <a href="https://www.postgresql.org/docs/14/sql-set-transaction.html"><code>SET TRANSACTION</code></a> 命令导入。本文我将从源码角度分析一下快照导出和导入的流程。</p>
<span id="more"></span>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><a href="https://www.postgresql.org/docs/14/functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE"><code>pg_export_snapshot()</code></a> 的使用非常简单，直接在事务中调用该函数即可，如果需要，您可以在同一个事务中多次导出快照（仅在 <code>READ COMMITTED</code> 级别下非常有用，在 <code>REPEATABLE READ</code> 和更高的隔离级别中，事务在其整个生命周期中使用相同的快照）。如下所示，我们在 <code>READ COMMITTED</code> 隔离级别下导出了一个名为 <code>00000003-00000009-1</code> 的快照。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span>;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_export_snapshot();</span><br><span class="line"> pg_export_snapshot</span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"> <span class="number">00000003</span><span class="number">-00000009</span><span class="number">-1</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>此时，我们在开启另一个事务来导入快照。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION snapshot <span class="string">&#x27;00000003-00000009-1&#x27;</span>;  <span class="comment">-- 在执行任何查询之前</span></span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span>;  <span class="comment">-- 等效于上面的</span></span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION snapshot <span class="string">&#x27;00000003-00000009-1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>快照的导出、导入需要注意以下几点：</p>
<ol>
<li><p>在导出快照的事务中不能使用 <a href="https://www.postgresql.org/docs/14/sql-prepare-transaction.html"><code>PREPARE TRANSACTION</code></a> 语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span>;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_export_snapshot();</span><br><span class="line"> pg_export_snapshot</span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"> <span class="number">00000003</span><span class="number">-0000000</span>A<span class="number">-1</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">PREPARE</span> TRANSACTION <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">ERROR:  cannot <span class="keyword">PREPARE</span> a transaction that has exported snapshots</span><br></pre></td></tr></table></figure></li>
<li><p>在子事务中不能导出快照。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span>;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SAVEPOINT</span> s1;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">select</span> pg_export_snapshot();</span><br><span class="line">ERROR:  cannot export a snapshot <span class="keyword">from</span> a subtransaction</span><br></pre></td></tr></table></figure></li>
<li><p>快照的导入必须在任何查询执行之前进行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span>;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"> ?<span class="keyword">column</span>?</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION SNAPSHOT <span class="string">&#x27;00000003-0000000C-1&#x27;</span>;</span><br><span class="line">ERROR:  <span class="keyword">SET</span> TRANSACTION SNAPSHOT must be <span class="keyword">called</span> before <span class="keyword">any</span> query</span><br></pre></td></tr></table></figure></li>
<li><p>导入快照的事务隔离级别必须是 <code>REPEATABLE READ</code> 或更高的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION SNAPSHOT <span class="string">&#x27;00000003-0000000C-1&#x27;</span>;</span><br><span class="line">ERROR:  a snapshot<span class="operator">-</span>importing transaction must have isolation level SERIALIZABLE <span class="keyword">or</span> REPEATABLE READ</span><br></pre></td></tr></table></figure></li>
<li><p>如果导入事务使用 <code>SERIALIZABLE</code> 隔离级别，则导出快照的事务也必须使用该隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION SNAPSHOT <span class="string">&#x27;00000003-0000000C-1&#x27;</span>;</span><br><span class="line">ERROR:  a serializable transaction cannot import a snapshot <span class="keyword">from</span> a non<span class="operator">-</span>serializable transaction</span><br></pre></td></tr></table></figure></li>
<li><p>非只读可序列化事务无法从只读事务导入快照。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">postgres<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION SNAPSHOT <span class="string">&#x27;00000003-0000000D-1&#x27;</span>;</span><br><span class="line">ERROR:  a non<span class="operator">-</span>read<span class="operator">-</span><span class="keyword">only</span> serializable transaction cannot import a snapshot <span class="keyword">from</span> a read<span class="operator">-</span><span class="keyword">only</span> transaction</span><br></pre></td></tr></table></figure></li>
<li><p>导出的快照不能导入到其他数据库中，即导出、导入快照的数据库必须相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">testdb<span class="operator">=</span># <span class="keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">testdb<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SET</span> TRANSACTION SNAPSHOT <span class="string">&#x27;00000003-0000000D-1&#x27;</span>;</span><br><span class="line">ERROR:  cannot import a snapshot <span class="keyword">from</span> a different database</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>备注：</strong>在事务中慎用 psql 的 TAB 补全功能，因为它可能会去查询系统表。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在了解了基本的使用之后，我们来看看 PostgreSQL 是如何实现快照的导出、导入的。</p>
<h3 id="快照导出"><a href="#快照导出" class="headerlink" title="快照导出"></a>快照导出</h3><p>首先我们看看导出的实现，由于它是一个函数，我们可以通过查看 <code>pg_proc</code> 系统表来获取到其对应的代码实现函数名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> proname, prosrc <span class="keyword">FROM</span> pg_proc <span class="keyword">WHERE</span> proname <span class="operator">=</span> <span class="string">&#x27;pg_export_snapshot&#x27;</span>;</span><br><span class="line">      proname       <span class="operator">|</span>       prosrc</span><br><span class="line"><span class="comment">--------------------+--------------------</span></span><br><span class="line"> pg_export_snapshot <span class="operator">|</span> pg_export_snapshot</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>随后我们可以到源码中找到 <code>pg_export_snapshot()</code> 函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pg_export_snapshot</span></span><br><span class="line"><span class="comment"> *      SQL-callable wrapper for ExportSnapshot.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">pg_export_snapshot</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>       *snapshotName;</span><br><span class="line"></span><br><span class="line">    snapshotName = ExportSnapshot(GetActiveSnapshot());</span><br><span class="line">    PG_RETURN_TEXT_P(cstring_to_text(snapshotName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，核心在 <code>GetActiveSnapshot()</code> 和 <a href="https://github.com/postgres/postgres/blob/REL_14_STABLE/src/backend/utils/time/snapmgr.c#L1116"><code>ExportSnapshot()</code></a> 两个函数中，<code>GetActiveSnapshot()</code> 用于获取当前活跃的快照（本文将不在此处详细说明），本文主要关注 <a href="https://github.com/postgres/postgres/blob/REL_14_STABLE/src/backend/utils/time/snapmgr.c#L1116"><code>ExportSnapshot()</code></a> 函数导出快照的处理。</p>
<p><a href="https://github.com/postgres/postgres/blob/REL_14_STABLE/src/backend/utils/time/snapmgr.c#L1116"><code>ExportSnapshot()</code></a> 函数主要做了以下几件事情：</p>
<ol>
<li>复制快照、封装为 <code>ExportedSnapshot</code> 对象并将其链接到 <code>exportedSnapshots</code> 链表中；</li>
<li>格式化快照信息；</li>
<li>打开文件并将格式化后的快照信息写入到 <code>pg_snapshots</code> 目录下面。</li>
</ol>
<p>下面是一个导出快照的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat pg_snapshots/00000003-00000010-2</span><br><span class="line">vxid:3/16</span><br><span class="line">pid:31163</span><br><span class="line">dbid:5</span><br><span class="line">iso:1</span><br><span class="line">ro:0</span><br><span class="line">xmin:740</span><br><span class="line">xmax:744</span><br><span class="line">xcnt:2</span><br><span class="line">xip:740</span><br><span class="line">xip:742</span><br><span class="line">sof:0</span><br><span class="line">sxcnt:1</span><br><span class="line">sxp:741</span><br><span class="line">rec:0</span><br></pre></td></tr></table></figure>

<p>上面的文件包含了导出快照的完整信息，下面是对其的解读：</p>
<ul>
<li>虚拟事务 ID，后端进程 ID 和本地事务 ID 组成 (<code>MyProc-&gt;backendId</code> 和 <code>MyProc-&gt;lxid</code>)</li>
<li>进程 ID，<code>MyProcPid</code></li>
<li>数据库 OID，<code>MyDatabaseId</code></li>
<li>事务隔离级别<ul>
<li><code>XACT_READ_UNCOMMITTED</code> -&gt; 0</li>
<li><code>XACT_READ_COMMITTED</code> -&gt; 1</li>
<li><code>XACT_REPEATABLE_READ</code> -&gt; 2</li>
<li><code>XACT_SERIALIZABLE</code> -&gt; 3</li>
</ul>
</li>
<li>事务模式<ul>
<li><code>READ ONLY</code> -&gt; 0</li>
<li><code>READ WRITE</code> -&gt; 1</li>
</ul>
</li>
<li><code>xmin</code>，最早正在运行的事务 ID</li>
<li><code>xmax</code>，最近已完成的事务 ID + 1</li>
<li>正在运行的事务数量</li>
<li>正在运行的事务列表，换行符分割每个事务</li>
<li>子事务是否溢出<ul>
<li>子事务溢出则没有子事务相关的信息</li>
<li>子事务没有溢出则包含<ul>
<li>子事务的数量</li>
<li>子事务列表</li>
</ul>
</li>
</ul>
</li>
<li>快照是否在恢复时获取的</li>
</ul>
<h3 id="快照导入"><a href="#快照导入" class="headerlink" title="快照导入"></a>快照导入</h3><p>上述就是快照导出的内容，接下来我们看看快照导入，<a href="https://github.com/postgres/postgres/blob/REL_14_STABLE/src/backend/utils/time/snapmgr.c#L1387"><code>ImportSnapshot()</code></a> 负责快照的导入工作（对应 <a href="https://www.postgresql.org/docs/14/sql-set-transaction.html"><code>SET TRANSACTION SANPSHOT snapshot_id</code></a> 语法），该函数的主要工作是从 <code>pg_snapshots</code> 目录下读取快照文件，并将文件内容解析到 <code>SnapshotData</code> 对象中，随后进行一些必要的检查，最后在交由 <a href="https://github.com/postgres/postgres/blob/REL_14_STABLE/src/backend/utils/time/snapmgr.c#L502"><code>SetTransactionSnapshot()</code></a> 函数处理，<a href="https://github.com/postgres/postgres/blob/REL_14_STABLE/src/backend/utils/time/snapmgr.c#L502"><code>SetTransactionSnapshot()</code></a> 函数主要做了以下几件事情：</p>
<ol>
<li>调用 <code>GetSnapshotData()</code> 函数获取当前快照信息，虽然在这里不会使用该函数计算的快照，但是通过这个函数可以帮助我们做以下两件事：<ul>
<li>确保 <code>CurrentSnapshotData</code> 的事务 ID 数组已经分配</li>
<li>更新快照中有关 <code>GlobalVis*</code> 的信息</li>
</ul>
</li>
<li>复制快照信息到 <code>CurrentSnapshot</code> 中，包括：<ul>
<li>最早正在运行的事务 ID（<code>xmin</code>）</li>
<li>最近已完成的事务 ID + 1（<code>xmax</code>）</li>
<li>活跃事务信息（<code>xcnt</code>, <code>xip</code>）</li>
<li>子事务信息（<code>subxcnt</code>, <code>subxip</code>）</li>
<li>子事务是否溢出（<code>suboverflowed</code>）</li>
<li>快照是否在恢复时获取的（<code>takenDuringRecovey</code>）</li>
</ul>
</li>
<li>设置第一个事务快照 <code>FirstXactSanpshot</code>（在 <code>REPEATABLE READ</code> 或更高的隔离级别下，我们需要保证事务快照在整个事务生命周期可见）</li>
</ol>
<p>PostgreSQL 中的快照导出、导入流程并不复杂，但实现的功能却比较强大。例如在 <a href="https://www.postgresql.org/docs/14/app-pgdump.html"><code>pg_dump</code></a> 应用程序中，当使用并行模式备份时，就需要利用到这个功能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/14/functions-admin.html">https://www.postgresql.org/docs/14/functions-admin.html</a><br>[2] <a href="https://www.postgresql.org/docs/14/sql-set-transaction.html">https://www.postgresql.org/docs/14/sql-set-transaction.html</a></p>
<div class="just-for-fun">
笑林广记 - 田主见鸡

<p>一富人有余田数亩，租与张三者种，每亩索鸡一只。<br>张三将鸡藏于背后，田主遂作吟哦之声曰：“此田不与张三种。”<br>张三忙将鸡献出，田主又吟曰：“不与张三却与谁？”<br>张三曰：“初问不与我，后又与我何也？”<br>田主曰：“初乃无稽（鸡）之谈，后乃见机（鸡）而作也。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 分组集：ROLLUP &amp; CUBE</title>
    <url>/2021/08/postgresql-grouping-sets-rollup-cube/</url>
    <content><![CDATA[<p>PostgreSQL 是世界上最好的 OLTP 数据库（<a href="https://en.wikipedia.org/wiki/Online_transaction_processing">OLTP</a>，即在线事务处理）之一。然而，它可以做的不仅仅是 OLTP。PostgreSQL 提供了许多与更具 OLAP 风格的工作负载相关的附加功能。其中一个特性称为“GROUPING SETS”（GROUPING SETS，即分组集）。</p>
<span id="more"></span>

<p>在我们深入研究细节之前，我提供了一些示例数据，您可以轻松地将它们加载到您的 SQL 数据库中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_sales</span><br><span class="line">(</span><br><span class="line">    country        text,</span><br><span class="line">    product_name   text,</span><br><span class="line">    <span class="keyword">year</span>           <span class="type">int</span>,</span><br><span class="line">    amount_sold    <span class="type">numeric</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_sales <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Argentina&#x27;</span>, <span class="string">&#x27;Shoes&#x27;</span>, <span class="number">2020</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="string">&#x27;Argentina&#x27;</span>, <span class="string">&#x27;Shoes&#x27;</span>, <span class="number">2021</span>, <span class="number">14</span>),</span><br><span class="line">    (<span class="string">&#x27;Argentina&#x27;</span>, <span class="string">&#x27;Hats&#x27;</span>, <span class="number">2020</span>, <span class="number">54</span>),</span><br><span class="line">    (<span class="string">&#x27;Argentina&#x27;</span>, <span class="string">&#x27;Hats&#x27;</span>, <span class="number">2021</span>, <span class="number">57</span>),</span><br><span class="line">    (<span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;Shoes&#x27;</span>, <span class="number">2020</span>, <span class="number">34</span>),</span><br><span class="line">    (<span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;Shoes&#x27;</span>, <span class="number">2021</span>, <span class="number">29</span>),</span><br><span class="line">    (<span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;Hats&#x27;</span>, <span class="number">2020</span>, <span class="number">19</span>),</span><br><span class="line">    (<span class="string">&#x27;Germany&#x27;</span>, <span class="string">&#x27;Hats&#x27;</span>, <span class="number">2021</span>, <span class="number">22</span>),</span><br><span class="line">    (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Shoes&#x27;</span>, <span class="number">2020</span>, <span class="number">99</span>),</span><br><span class="line">    (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Shoes&#x27;</span>, <span class="number">2021</span>, <span class="number">103</span>),</span><br><span class="line">    (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Hats&#x27;</span>, <span class="number">2020</span>, <span class="number">81</span>),</span><br><span class="line">    (<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Hats&#x27;</span>, <span class="number">2021</span>, <span class="number">90</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>请注意，您在本博客中看到的所有内容都非常符合 SQL 标准，因此您可以预期大部分内容也适用于其他专业SQL数据库。</p>
<p>让我们从一个简单的聚合开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT  country, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY 1;</span><br><span class="line"> country   | sum</span><br><span class="line">-----------+-----</span><br><span class="line"> USA       | 373</span><br><span class="line"> Germany   | 104</span><br><span class="line"> Argentina | 137</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>这里没什么好说的，除了我们将为每个小组得到一个总数。然而，有一点哲学上的讨论正在进行。<code>GROUP BY 1</code> 基本上是指 <code>GROUP BY country</code>，相当于 SELECT 子句中的第一列。因此，<code>GROUP BY country</code> 和 <code>GROUP BY 1</code> 是一回事：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT  country, product_name, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY 1, 2</span><br><span class="line">       ORDER BY 1, 2;</span><br><span class="line"> country   | product_name | sum</span><br><span class="line">-----------+--------------+-----</span><br><span class="line"> Argentina | Hats         | 111</span><br><span class="line"> Argentina | Shoes        |  26</span><br><span class="line"> Germany   | Hats         |  41</span><br><span class="line"> Germany   | Shoes        |  63</span><br><span class="line"> USA       | Hats         | 171</span><br><span class="line"> USA       | Shoes        | 202</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>当然，这也适用于不止一列。不过，我想指出一点。考虑以下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT CASE WHEN country = &#x27;USA&#x27;</span><br><span class="line">                THEN &#x27;USA&#x27;</span><br><span class="line">                ELSE &#x27;non-US&#x27;</span><br><span class="line">              END,</span><br><span class="line">              sum(amount_sold)</span><br><span class="line">       FROM t_sales</span><br><span class="line">       GROUP BY 1;</span><br><span class="line"> case   | sum</span><br><span class="line">--------+-----</span><br><span class="line"> USA    | 373</span><br><span class="line"> non-US | 241</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>大多数人按列名分组。在某些情况下，按表达式分组是有意义的。在我的例子中，我们是在运行中形成组（即一个组用于美国销售，一个组用于非美国销售）。这个功能往往没有得到重视。然而，它在许多现实世界的场景中是很有用的。请记住，您将要看到的所有东西也可以与表达式一起工作，这意味着可以进行更灵活的分组。</p>
<h2 id="分组集：基本构建块"><a href="#分组集：基本构建块" class="headerlink" title="分组集：基本构建块"></a>分组集：基本构建块</h2><p><code>GROUP BY</code> 将把一列中每一个不同的条目变成一个组。有时您可能想一次做更多的分组。为什么有这个必要呢？假设你正在处理一个 10TB 的表。显然，读取这些数据通常是性能方面的限制因素。因此，一次读取数据并一次产生更多的结果是很有吸引力的。这正是您可以用 <code>GROUP BY GROUP SETS</code> 做的事情。假设我们想一次产生两个结果：</p>
<ul>
<li><code>GROUP BY country</code></li>
<li><code>GROUP BY product_name</code></li>
</ul>
<p>这是它如何工作的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT  country, product_name, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY GROUPING SETS ((1), (2))</span><br><span class="line">       ORDER BY 1, 2;</span><br><span class="line"> country   | product_name | sum</span><br><span class="line">-----------+--------------+-----</span><br><span class="line"> Argentina |              | 137</span><br><span class="line"> Germany   |              | 104</span><br><span class="line"> USA       |              | 373</span><br><span class="line">           | Hats         | 323</span><br><span class="line">           | Shoes        | 291</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，PostgreSQL 只是简单地附加结果。前三行代表 <code>GROUP BY country</code>。接下来的两行包含 <code>GROUP BY product_name</code> 的结果。从逻辑上讲，它相当于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT  NULL AS country , product_name, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY  1, 2</span><br><span class="line">       UNION ALL</span><br><span class="line">       SELECT  country, NULL, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY  1, 2</span><br><span class="line">       ORDER BY 1, 2;</span><br><span class="line"> country   | product_name | sum</span><br><span class="line">-----------+--------------+-----</span><br><span class="line"> Argentina |              | 137</span><br><span class="line"> Germany   |              | 104</span><br><span class="line"> USA       |              | 373</span><br><span class="line">           | Hats         | 323</span><br><span class="line">           | Shoes        | 291</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>

<p>但是，<code>GROUPING SETS</code> 版本的效率更高，因为它只需要读取一次数据。</p>
<h2 id="ROLLUP-添加“底线”"><a href="#ROLLUP-添加“底线”" class="headerlink" title="ROLLUP: 添加“底线”"></a>ROLLUP: 添加“底线”</h2><p>在创建报告时，您通常需要“底线”来总结表中显示的内容。在 SQL 中这样做的方法是使用 <code>GROUP BY ROLLUP</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT  country, product_name, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY ROLLUP (1, 2)</span><br><span class="line">       ORDER BY 1, 2;</span><br><span class="line"> country   | product_name | sum</span><br><span class="line">-----------+--------------+-----</span><br><span class="line"> Argentina | Hats         | 111</span><br><span class="line"> Argentina | Shoes        |  26</span><br><span class="line"> Argentina |              | 137</span><br><span class="line"> Germany   | Hats         |  41</span><br><span class="line"> Germany   | Shoes        |  63</span><br><span class="line"> Germany   |              | 104</span><br><span class="line"> USA       | Hats         | 171</span><br><span class="line"> USA       | Shoes        | 202</span><br><span class="line"> USA       |              | 373</span><br><span class="line">           |              | 614</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 将在结果中注入几行。如您所见，<code>Argentina</code> 返回了 3 行，而不仅仅是 2 行记录。<code>product_name = NULL</code> 记录是由 <code>ROLLUP</code> 添加的。它包含了所有 <code>Argentina</code> 销售额的总和（<code>116 + 27 = 137</code>）。其他两个国家都有额外的行被注入。最后，为全球总销售额添加了一行。</p>
<p>通常，这些空记录不是人们希望看到的，因此用其他类型的条目替换它们是有意义的。实现这一点的方法是使用一个 <code>subselect</code> 来检查 <code>NULL</code> 记录并进行替换。下面是它的工作原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT   CASE WHEN country IS NULL</span><br><span class="line">                      THEN &#x27;TOTAL&#x27; ELSE country END,</span><br><span class="line">                CASE WHEN product_name IS NULL</span><br><span class="line">                      THEN &#x27;TOTAL&#x27; ELSE product_name END,</span><br><span class="line">                sum</span><br><span class="line">       FROM (SELECT    country, product_name, sum(amount_sold)</span><br><span class="line">             FROM      t_sales</span><br><span class="line">             GROUP BY ROLLUP (1, 2)</span><br><span class="line">             ORDER BY 1, 2</span><br><span class="line">           ) AS x;</span><br><span class="line"> country   | product_name | sum</span><br><span class="line">-----------+--------------+-----</span><br><span class="line"> Argentina | Hats         | 111</span><br><span class="line"> Argentina | Shoes        |  26</span><br><span class="line"> Argentina | TOTAL        | 137</span><br><span class="line"> Germany   | Hats         |  41</span><br><span class="line"> Germany   | Shoes        |  63</span><br><span class="line"> Germany   | TOTAL        | 104</span><br><span class="line"> USA       | Hats         | 171</span><br><span class="line"> USA       | Shoes        | 202</span><br><span class="line"> USA       | TOTAL        | 373</span><br><span class="line"> TOTAL     | TOTAL        | 614</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<p>如您所见，所有 <code>NULL</code> 记录都已替换为 <code>TOTAL</code>，__这在许多情况下是显示此数据的更理想方式__。</p>
<h2 id="CUBE-在-PostgreSQL-中高效创建数据立方体"><a href="#CUBE-在-PostgreSQL-中高效创建数据立方体" class="headerlink" title="CUBE: 在 PostgreSQL 中高效创建数据立方体"></a>CUBE: 在 PostgreSQL 中高效创建数据立方体</h2><p>如果您想添加“底线”，<code>ROLLUP</code> 很有用。<strong>但是，您通常希望查看国家和产品的所有组合。<code>GROUP BY CUBE</code> 将做到这一点：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT  country, product_name, sum(amount_sold)</span><br><span class="line">       FROM    t_sales</span><br><span class="line">       GROUP BY CUBE (1, 2)</span><br><span class="line">       ORDER BY 1, 2;</span><br><span class="line"> country   | product_name | sum</span><br><span class="line">-----------+--------------+-----</span><br><span class="line"> Argentina | Hats         | 111</span><br><span class="line"> Argentina | Shoes        |  26</span><br><span class="line"> Argentina |              | 137</span><br><span class="line"> Germany   | Hats         |  41</span><br><span class="line"> Germany   | Shoes        |  63</span><br><span class="line"> Germany   |              | 104</span><br><span class="line"> USA       | Hats         | 171</span><br><span class="line"> USA       | Shoes        | 202</span><br><span class="line"> USA       |              | 373</span><br><span class="line">           | Hats         | 323</span><br><span class="line">           | Shoes        | 291</span><br><span class="line">           |              | 614</span><br><span class="line">(12 rows)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们有所有的组合。从技术上讲，它等同于：<code>GROUP BY country</code> + <code>GROUP BY product_name</code> + <code>GROUP BY country_product_name</code> + <code>GROUP BY()</code>。我们可以使用多个语句来做到这一点，但一次做起来更容易——而且效率更高。</p>
<p>同样，添加 <code>NULL</code> 值以指示各种聚合级别。</p>
<h2 id="分组集：执行计划"><a href="#分组集：执行计划" class="headerlink" title="分组集：执行计划"></a>分组集：执行计划</h2><p>分组集不只是简单地重写查询以将其转换为 <code>UNION ALL</code> —— 数据库引擎中实际上有特定的代码来执行这些聚合。</p>
<p>您将看到的是一个 <code>MixedAggregate</code>，它能够同时在各个级别进行聚合。下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# explain SELECT country, product_name, sum(amount_sold)</span><br><span class="line">           FROM t_sales</span><br><span class="line">           GROUP BY CUBE (1, 2)</span><br><span class="line">           ORDER BY 1, 2;</span><br><span class="line">                          QUERY PLAN</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"> Sort  (cost=64.15..65.65 rows=601 width=96)</span><br><span class="line">   Sort Key: country, product_name</span><br><span class="line">   -&gt;  MixedAggregate  (cost=0.00..36.41 rows=601 width=96)</span><br><span class="line">     Hash Key: country, product_name</span><br><span class="line">     Hash Key: country</span><br><span class="line">     Hash Key: product_name</span><br><span class="line">     Group Key: ()</span><br><span class="line">     -&gt;  Seq Scan on t_sales ...</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>

<p>查看 <code>MixedAggregate</code> 还揭示了哪些聚合是作为分组集的一部分执行的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一般来说，分组集是一个非常酷的功能，但通常不为人所知或被忽视。我们强烈建议使用这个很棒的东西来加速你的聚合。如果您正在处理大型数据集，它特别有用。</p>
<p>如果您想了解更多关于 PostgreSQL 和 SQL 的一般信息，您可能还会喜欢我关于“<a href="https://www.cybertec-postgresql.com/en/finding-patterns-in-timeseries-a-poor-mans-method/">使用 SQL 进行字符串编码</a>”的文章。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><ul>
<li>本文翻译自 Hans-Jürgen Schönig 的 <a href="https://www.cybertec-postgresql.com/en/postgresql-grouping-sets-rollup-cube/">POSTGRESQL GROUPING SETS: ROLLUP &amp; CUBE</a>。</li>
<li>您也可以在《由浅入深 PostgreSQL》一书的“第 4 章-处理高级 SQL”中查看有关分组集的使用。</li>
</ul>
<div class="just-for-fun">
笑林广记 - 启奏

<p>一官被妻踏破纱帽。怒奏曰：“臣启陛下，臣妻罗唣，昨日相争，踏破臣的纱帽。”<br>上传旨云：“卿须忍耐，皇后有些惫赖，与朕一言不合，平天冠打得粉碎。你的纱帽只算得个卵袋。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL HASH 索引拾遗</title>
    <url>/2020/02/postgresql-hash-index/</url>
    <content><![CDATA[<p>PostgreSQL 的 HASH 索引在 9.6 和 10 版本中有所不同，主要的区别在于 HASH 索引在 9.6 及其之前的版本中不会记录在 WAL 日志中，然而在 10 及其之后的版本这个已经被修复了。</p>
<p>例如，下面是在 PostgreSQL 9.6.17 中创建 HASH 索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE INDEX id_hash_index ON hash_table USING hash(id);</span><br><span class="line">WARNING:  hash indexes are not WAL-logged and their use is discouraged</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>

<p>从警告中可以看到，PostgreSQL 已经给出了明确提示。然而在 PostgreSQL 12.2 中，创建 HASH 索引则没有上述提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# create index idx_hash_id on hash_table using hash(id);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先我们通过 ruby 创建测试数据：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ruby -e <span class="string">&#x27;(1..1000).each &#123; |i| puts i.to_s.rjust(20, &quot;0&quot;) &#125;&#x27;</span> &gt; data.txt</span><br></pre></td></tr></table></figure>

<p>我们采用 PG9.6.17 搭建主从同步流复制，随后在主库上创建 <code>hash_table</code> 表，然后插入数据，并在从库查询，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# create table hash_table(id varchar(256));</span><br><span class="line">postgres=# copy hash_table from &#x27;/path/to/data.txt&#x27;;</span><br><span class="line">postgres=# create index idx_hash_table_id on hash_table using hash(id);</span><br></pre></td></tr></table></figure>

<p>接着，我们分别在主库和从库上查看，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select count(*) from hash_table;  -- 主库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select * from hash_table where id = &#x27;00000000000000000023&#x27;;</span><br><span class="line">          id</span><br><span class="line">----------------------</span><br><span class="line"> 00000000000000000023</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select pg_size_pretty(pg_relation_size(&#x27;idx_hash_table_id));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 528 kB</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select count(*) from hash_table;  -- 从库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select * from hash_table where id = &#x27;00000000000000000023&#x27;;</span><br><span class="line">ERROR:  could not read block 0 in file &quot;base/12407/24577&quot;: read only 0 of 8192 bytes</span><br><span class="line"></span><br><span class="line">postgres=# select pg_size_pretty(pg_relation_size(&#x27;idx_hash_table_id));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 0 bytes</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>从上面的输出结果也可以看到，HASH 索引并没有记录到 WAL 日志中，因此有关 HASH 索引的操作都不会在从节点进行重放。</p>
<p>同样地，我们也可以在 PG12.2 中进行测试。其结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select count(*) from hash_table;  -- 主库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select * from hash_table where id = &#x27;00000000000000000023&#x27;;</span><br><span class="line">          id</span><br><span class="line">----------------------</span><br><span class="line"> 00000000000000000023</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select pg_size_pretty(pg_relation_size(&#x27;idx_hash_table_id&#x27;));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 592 kB</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select count(*) from hash_table;  -- 从库</span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 10000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select * from hash_table where id = &#x27;00000000000000000023&#x27;;</span><br><span class="line">          id</span><br><span class="line">----------------------</span><br><span class="line"> 00000000000000000023</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select pg_size_pretty(pg_relation_size(&#x27;idx_hash_table_id&#x27;));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 592 kB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://postgrespro.com/blog/pgsql/4161321">https://postgrespro.com/blog/pgsql/4161321</a><br>[2] <a href="https://www.postgresql.org/docs/9.6/continuous-archiving.html">https://www.postgresql.org/docs/9.6/continuous-archiving.html</a><br>[3] <a href="https://www.postgresql.org/docs/10/continuous-archiving.html">https://www.postgresql.org/docs/10/continuous-archiving.html</a><br>[4] <a href="https://blog.andrebarbosa.co/hash-indexes-on-postgres/">https://blog.andrebarbosa.co/hash-indexes-on-postgres/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 在 btree_gist 索引上 Index Only 扫描问题</title>
    <url>/2022/01/postgresql-index-only-scan-on-btree-gist-index/</url>
    <content><![CDATA[<p>最近在邮件列表中发现一个 <a href="https://www.postgresql.org/message-id/696c995b-b37f-5526-f45d-04abe713179f@gmail.com">btree_gist 索引上的 Index Only 扫描问题</a>，该问题由 Alexander Lakhin 提交，在 <code>char(n)</code> 数据类型的 <code>btree_gist</code> 索引上会出现，本文简要记录一下该问题。</p>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>首先，我们来复现这个问题，该问题依赖于 <code>btree_gist</code> 插件，我们先安装该插件，随后新建 <code>chartmp</code> 表并向其中插入一条记录，最后我们在该列上创建一个 <code>gist</code> 索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION btree_gist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> chartmp (a <span class="type">char</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> chartmp <span class="keyword">VALUES</span>(<span class="string">&#x27;31b0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX charidx <span class="keyword">ON</span> chartmp <span class="keyword">USING</span> gist (a);</span><br></pre></td></tr></table></figure>

<p>我们先看看查询出来的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># EXPLAIN VERBOSE <span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="keyword">octet_length</span>(a) <span class="keyword">FROM</span> chartmp <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="string">&#x27;31a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;31c&#x27;</span>;</span><br><span class="line">                                QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> public.chartmp  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">136</span>)</span><br><span class="line">   Output: a, <span class="keyword">octet_length</span>(a)</span><br><span class="line">   <span class="keyword">Filter</span>: ((chartmp.a <span class="operator">&gt;=</span> <span class="string">&#x27;31a&#x27;</span>::bpchar) <span class="keyword">AND</span> (chartmp.a <span class="operator">&lt;=</span> <span class="string">&#x27;31c&#x27;</span>::bpchar))</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="keyword">octet_length</span>(a) <span class="keyword">FROM</span> chartmp <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="string">&#x27;31a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;31c&#x27;</span>;</span><br><span class="line">                a                 <span class="operator">|</span> <span class="keyword">octet_length</span></span><br><span class="line"><span class="comment">----------------------------------+--------------</span></span><br><span class="line"> <span class="number">31</span>b0                             <span class="operator">|</span>           <span class="number">32</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>从查询计划可以看到，现在是顺序扫描（肯定是顺序扫描啦，毕竟才一条数据嘛），由于问题是在 Index Only 扫描上，那我们势必要走 Index Only 扫描才可以复现问题，因此，我们这里禁用顺序扫描，然后在看执行结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SET</span> enable_seqscan <span class="keyword">TO</span> off;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">postgres<span class="operator">=</span># EXPLAIN VERBOSE <span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="keyword">octet_length</span>(a) <span class="keyword">FROM</span> chartmp <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="string">&#x27;31a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;31c&#x27;</span>;</span><br><span class="line">                                     QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------</span></span><br><span class="line"> Index <span class="keyword">Only</span> Scan <span class="keyword">using</span> charidx <span class="keyword">on</span> public.chartmp  (cost<span class="operator">=</span><span class="number">0.12</span>.<span class="number">.8</span><span class="number">.15</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">136</span>)</span><br><span class="line">   Output: a, <span class="keyword">octet_length</span>(a)</span><br><span class="line">   Index Cond: ((chartmp.a <span class="operator">&gt;=</span> <span class="string">&#x27;31a&#x27;</span>::bpchar) <span class="keyword">AND</span> (chartmp.a <span class="operator">&lt;=</span> <span class="string">&#x27;31c&#x27;</span>::bpchar))</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="keyword">octet_length</span>(a) <span class="keyword">FROM</span> chartmp <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="string">&#x27;31a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;31c&#x27;</span>;</span><br><span class="line">  a   <span class="operator">|</span> <span class="keyword">octet_length</span></span><br><span class="line"><span class="comment">------+--------------</span></span><br><span class="line"> <span class="number">31</span>b0 <span class="operator">|</span>            <span class="number">4</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到这里出来的结果与顺序扫描结果不一致。这里的主要问题是，在索引存储中将会删除末尾的空白，而 Index Only 扫描在找到匹配的键时并不会回表来获取数据，从而导致数据不一致。我们可以通过索引扫描来验证这一点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># EXPLAIN VERBOSE <span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="keyword">octet_length</span>(a) <span class="keyword">FROM</span> chartmp <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="string">&#x27;31a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;31c&#x27;</span>;</span><br><span class="line">                                   QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> charidx <span class="keyword">on</span> public.chartmp  (cost<span class="operator">=</span><span class="number">0.12</span>.<span class="number">.8</span><span class="number">.15</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">136</span>)</span><br><span class="line">   Output: a, <span class="keyword">octet_length</span>(a)</span><br><span class="line">   Index Cond: ((chartmp.a <span class="operator">&gt;=</span> <span class="string">&#x27;31a&#x27;</span>::bpchar) <span class="keyword">AND</span> (chartmp.a <span class="operator">&lt;=</span> <span class="string">&#x27;31c&#x27;</span>::bpchar))</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="keyword">octet_length</span>(a) <span class="keyword">FROM</span> chartmp <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="string">&#x27;31a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;31c&#x27;</span>;</span><br><span class="line">                a                 <span class="operator">|</span> <span class="keyword">octet_length</span></span><br><span class="line"><span class="comment">----------------------------------+--------------</span></span><br><span class="line"> <span class="number">31</span>b0                             <span class="operator">|</span>           <span class="number">32</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在构建 <code>char(n)</code> 类型的 <code>btree_gist</code> 索引时，将调用 <code>gbt_bpchar_compress()</code> 函数来对将进行处理（感谢 Tom Lane 提供的分析），其定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">gbt_bpchar_compress</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="number">0</span>);</span><br><span class="line">    GISTENTRY  *retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tinfo.eml == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tinfo.eml = pg_database_encoding_max_length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;leafkey)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Datum       d = DirectFunctionCall1(rtrim1, entry-&gt;key);</span><br><span class="line">        GISTENTRY   trim;</span><br><span class="line"></span><br><span class="line">        gistentryinit(trim, d,</span><br><span class="line">                      entry-&gt;rel, entry-&gt;page,</span><br><span class="line">                      entry-&gt;offset, <span class="literal">true</span>);</span><br><span class="line">        retval = gbt_var_compress(&amp;trim, &amp;tinfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        retval = entry;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_POINTER(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，到是叶子节点时，将对键调用 <code>rtrim1()</code> 函数删除键最右边的空白字符，因此在 Index Only 扫描的时候我们获取不到的数据后面的空白填充。我们可以通过避免删除键最右边的空白字符来解决这个问题。在尝试移除 <code>gbt_bpchar_compress()</code> 中针对键的操作之后，我发现当使用等值查询时查不到结果。这是由于 <code>btree_gist</code> 在对 <code>bpchar</code> 类型的操作使用的是 <code>text</code> 类型的操作，例如等值查询将使用 <code>texteq()</code> 函数，这是在 <code>tinfo</code> 变量中定义的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">gbt_texteq</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b, Oid collation, FmgrInfo *flinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DatumGetBool(DirectFunctionCall2Coll(texteq,</span><br><span class="line">                                                collation,</span><br><span class="line">                                                PointerGetDatum(a),</span><br><span class="line">                                                PointerGetDatum(b)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> gbtree_vinfo tinfo =</span><br><span class="line">&#123;</span><br><span class="line">    gbt_t_text,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    gbt_textgt,</span><br><span class="line">    gbt_textge,</span><br><span class="line">    gbt_texteq,</span><br><span class="line">    gbt_textle,</span><br><span class="line">    gbt_textlt,</span><br><span class="line">    gbt_textcmp,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而针对 <code>bpchar</code> (i.e. <code>char(n)</code>) 类型，实际上应该使用 <code>bpchareq()</code> 函数，该函数在比较是会将参数最右侧的空白字符删除，因此可以正常执行等值比较。<code>bpchareq()</code> 函数里面的 <code>bcTruelen()</code> 是关键，从下面可以看到，它在计算长度时忽略了末尾的空白字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;True&quot; length (not counting trailing blanks) of a BpChar */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bcTruelen</span><span class="params">(BpChar *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpchartruelen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>         i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note that we rely on the assumption that &#x27; &#x27; is a singleton unit on</span></span><br><span class="line"><span class="comment">     * every supported multibyte server encoding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我给出的 patch 只能说可以解决这个问题，但是不够优雅，最后 Tom Lane 给出了解决该问题的 patch，如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/contrib/btree_gist/btree_text.c b/contrib/btree_gist/btree_text.c</span></span><br><span class="line"><span class="comment">index 8019d11281..be0eac7975 100644</span></span><br><span class="line"><span class="comment">--- a/contrib/btree_gist/btree_text.c</span></span><br><span class="line"><span class="comment">+++ b/contrib/btree_gist/btree_text.c</span></span><br><span class="line"><span class="meta">@@ -90,6 +90,76 @@</span> static gbtree_vinfo tinfo =</span><br><span class="line"> 	NULL</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+/* bpchar needs its own comparison rules */</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static bool</span></span><br><span class="line"><span class="addition">+gbt_bpchargt(const void *a, const void *b, Oid collation, FmgrInfo *flinfo)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	return DatumGetBool(DirectFunctionCall2Coll(bpchargt,</span></span><br><span class="line"><span class="addition">+												collation,</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(a),</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(b)));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static bool</span></span><br><span class="line"><span class="addition">+gbt_bpcharge(const void *a, const void *b, Oid collation, FmgrInfo *flinfo)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	return DatumGetBool(DirectFunctionCall2Coll(bpcharge,</span></span><br><span class="line"><span class="addition">+												collation,</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(a),</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(b)));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static bool</span></span><br><span class="line"><span class="addition">+gbt_bpchareq(const void *a, const void *b, Oid collation, FmgrInfo *flinfo)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	return DatumGetBool(DirectFunctionCall2Coll(bpchareq,</span></span><br><span class="line"><span class="addition">+												collation,</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(a),</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(b)));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static bool</span></span><br><span class="line"><span class="addition">+gbt_bpcharle(const void *a, const void *b, Oid collation, FmgrInfo *flinfo)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	return DatumGetBool(DirectFunctionCall2Coll(bpcharle,</span></span><br><span class="line"><span class="addition">+												collation,</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(a),</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(b)));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static bool</span></span><br><span class="line"><span class="addition">+gbt_bpcharlt(const void *a, const void *b, Oid collation, FmgrInfo *flinfo)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	return DatumGetBool(DirectFunctionCall2Coll(bpcharlt,</span></span><br><span class="line"><span class="addition">+												collation,</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(a),</span></span><br><span class="line"><span class="addition">+												PointerGetDatum(b)));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static int32</span></span><br><span class="line"><span class="addition">+gbt_bpcharcmp(const void *a, const void *b, Oid collation, FmgrInfo *flinfo)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	return DatumGetInt32(DirectFunctionCall2Coll(bpcharcmp,</span></span><br><span class="line"><span class="addition">+												 collation,</span></span><br><span class="line"><span class="addition">+												 PointerGetDatum(a),</span></span><br><span class="line"><span class="addition">+												 PointerGetDatum(b)));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+static gbtree_vinfo bptinfo =</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	gbt_t_bpchar,</span></span><br><span class="line"><span class="addition">+	0,</span></span><br><span class="line"><span class="addition">+	false,</span></span><br><span class="line"><span class="addition">+	gbt_bpchargt,</span></span><br><span class="line"><span class="addition">+	gbt_bpcharge,</span></span><br><span class="line"><span class="addition">+	gbt_bpchareq,</span></span><br><span class="line"><span class="addition">+	gbt_bpcharle,</span></span><br><span class="line"><span class="addition">+	gbt_bpcharlt,</span></span><br><span class="line"><span class="addition">+	gbt_bpcharcmp,</span></span><br><span class="line"><span class="addition">+	NULL</span></span><br><span class="line"><span class="addition">+&#125;;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"></span><br><span class="line"> /**************************************************</span><br><span class="line">  * Text ops</span><br><span class="line"><span class="meta">@@ -112,29 +182,8 @@</span> gbt_text_compress(PG_FUNCTION_ARGS)</span><br><span class="line"> Datum</span><br><span class="line"> gbt_bpchar_compress(PG_FUNCTION_ARGS)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-	GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);</span></span><br><span class="line"><span class="deletion">-	GISTENTRY  *retval;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	if (tinfo.eml == 0)</span></span><br><span class="line"><span class="deletion">-	&#123;</span></span><br><span class="line"><span class="deletion">-		tinfo.eml = pg_database_encoding_max_length();</span></span><br><span class="line"><span class="deletion">-	&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	if (entry-&gt;leafkey)</span></span><br><span class="line"><span class="deletion">-	&#123;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-		Datum		d = DirectFunctionCall1(rtrim1, entry-&gt;key);</span></span><br><span class="line"><span class="deletion">-		GISTENTRY	trim;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-		gistentryinit(trim, d,</span></span><br><span class="line"><span class="deletion">-					  entry-&gt;rel, entry-&gt;page,</span></span><br><span class="line"><span class="deletion">-					  entry-&gt;offset, true);</span></span><br><span class="line"><span class="deletion">-		retval = gbt_var_compress(&amp;trim, &amp;tinfo);</span></span><br><span class="line"><span class="deletion">-	&#125;</span></span><br><span class="line"><span class="deletion">-	else</span></span><br><span class="line"><span class="deletion">-		retval = entry;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	PG_RETURN_POINTER(retval);</span></span><br><span class="line"><span class="addition">+	/* This should never have been distinct from gbt_text_compress */</span></span><br><span class="line"><span class="addition">+	return gbt_text_compress(fcinfo);</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -179,18 +228,17 @@</span> gbt_bpchar_consistent(PG_FUNCTION_ARGS)</span><br><span class="line"> 	bool		retval;</span><br><span class="line"> 	GBT_VARKEY *key = (GBT_VARKEY *) DatumGetPointer(entry-&gt;key);</span><br><span class="line"> 	GBT_VARKEY_R r = gbt_var_key_readable(key);</span><br><span class="line"><span class="deletion">-	void	   *trim = (void *) DatumGetPointer(DirectFunctionCall1(rtrim1, PointerGetDatum(query)));</span></span><br><span class="line"></span><br><span class="line"> 	/* All cases served by this function are exact */</span><br><span class="line"> 	*recheck = false;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (tinfo.eml == 0)</span></span><br><span class="line"><span class="addition">+	if (bptinfo.eml == 0)</span></span><br><span class="line"> 	&#123;</span><br><span class="line"><span class="deletion">-		tinfo.eml = pg_database_encoding_max_length();</span></span><br><span class="line"><span class="addition">+		bptinfo.eml = pg_database_encoding_max_length();</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	retval = gbt_var_consistent(&amp;r, trim, strategy, PG_GET_COLLATION(),</span></span><br><span class="line"><span class="deletion">-								GIST_LEAF(entry), &amp;tinfo, fcinfo-&gt;flinfo);</span></span><br><span class="line"><span class="addition">+	retval = gbt_var_consistent(&amp;r, query, strategy, PG_GET_COLLATION(),</span></span><br><span class="line"><span class="addition">+								GIST_LEAF(entry), &amp;bptinfo, fcinfo-&gt;flinfo);</span></span><br><span class="line"> 	PG_RETURN_BOOL(retval);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/contrib/btree_gist/expected/char.out b/contrib/btree_gist/expected/char.out</span></span><br><span class="line"><span class="comment">index d715c045cc..45cf9f38d6 100644</span></span><br><span class="line"><span class="comment">--- a/contrib/btree_gist/expected/char.out</span></span><br><span class="line"><span class="comment">+++ b/contrib/btree_gist/expected/char.out</span></span><br><span class="line"><span class="meta">@@ -75,8 +75,8 @@</span> SELECT * FROM chartmp WHERE a BETWEEN &#x27;31a&#x27; AND &#x27;31c&#x27;;</span><br><span class="line"> (2 rows)</span><br><span class="line"></span><br><span class="line"> SELECT * FROM chartmp WHERE a BETWEEN &#x27;31a&#x27; AND &#x27;31c&#x27;;</span><br><span class="line"><span class="deletion">-  a</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="deletion">- 31b0</span></span><br><span class="line"><span class="addition">+                a</span></span><br><span class="line"><span class="addition">+----------------------------------</span></span><br><span class="line"><span class="addition">+ 31b0</span></span><br><span class="line"> (1 row)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/contrib/btree_gist/expected/char_1.out b/contrib/btree_gist/expected/char_1.out</span></span><br><span class="line"><span class="comment">index 867318002b..7b7824b717 100644</span></span><br><span class="line"><span class="comment">--- a/contrib/btree_gist/expected/char_1.out</span></span><br><span class="line"><span class="comment">+++ b/contrib/btree_gist/expected/char_1.out</span></span><br><span class="line"><span class="meta">@@ -75,8 +75,8 @@</span> SELECT * FROM chartmp WHERE a BETWEEN &#x27;31a&#x27; AND &#x27;31c&#x27;;</span><br><span class="line"> (2 rows)</span><br><span class="line"></span><br><span class="line"> SELECT * FROM chartmp WHERE a BETWEEN &#x27;31a&#x27; AND &#x27;31c&#x27;;</span><br><span class="line"><span class="deletion">-  a</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="deletion">- 31b0</span></span><br><span class="line"><span class="addition">+                a</span></span><br><span class="line"><span class="addition">+----------------------------------</span></span><br><span class="line"><span class="addition">+ 31b0</span></span><br><span class="line"> (1 row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong>上面的 diff 文件中末尾的空白被移除了，因此不能直接用，您需要在<a href="https://www.postgresql.org/message-id/attachment/129615/fix-btree_gist-bpchar-trimming.patch">这里</a>获取 patch 文件。</p>
<p><del>目前，该 patch 还未合并到主分支，尚待验证。</del> 2022 年 01 月 08 日已被合并到主分支，并 back-patch 回所有支持的分支。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/flat/696c995b-b37f-5526-f45d-04abe713179f%40gmail.com">https://www.postgresql.org/message-id/flat/696c995b-b37f-5526-f45d-04abe713179f%40gmail.com</a></p>
<div class="just-for-fun">
笑林广记 - 嘲武举诗

<p>头戴银雀顶，脚踏粉底皂。<br>也去参主考，也来谒孔庙。<br>颜渊喟然叹，夫子莞尔笑。<br>子路愠见曰：“这般呆狗屎，我若行三军，都去喂马料。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 行类型规则导出错误</title>
    <url>/2022/01/postgresql-invalid-dump-for-rules/</url>
    <content><![CDATA[<p>最近在浏览邮件列表时发现通过 pg_dump 导出带有行类型的规则导出之后无法导入到数据库中，已确认为 bug，目前已被修复。</p>
<pre><code>commit 43c2175121c829c8591fc5117b725f1f22bfb670
Author: Tom Lane &lt;tgl@sss.pgh.pa.us&gt;
Date:   Thu Jan 13 17:49:25 2022 -0500

    Fix ruleutils.c&#39;s dumping of whole-row Vars in more contexts.

    Commit 7745bc352 intended to ensure that whole-row Vars would be
    printed with &quot;::type&quot; decoration in all contexts where plain
    &quot;var.*&quot; notation would result in star-expansion, notably in
    ROW() and VALUES() constructs.  However, it missed the case of
    INSERT with a single-row VALUES, as reported by Timur Khanjanov.

    Nosing around ruleutils.c, I found a second oversight: the
    code for RowCompareExpr generates ROW() notation without benefit
    of an actual RowExpr, and naturally it wasn&#39;t in sync :-(.
    (The code for FieldStore also does this, but we don&#39;t expect that
    to generate strictly parsable SQL anyway, so I left it alone.)

    Back-patch to all supported branches.

    Discussion: https://postgr.es/m/efaba6f9-4190-56be-8ff2-7a1674f9194f@intrans.baku.az
</code></pre>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>首先我们创建两张表和一条规则，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(a <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_log(<span class="keyword">old</span> test);</span><br><span class="line"><span class="keyword">CREATE</span> RULE del <span class="keyword">AS</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">TO</span> test DO <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_log <span class="keyword">VALUES</span>(<span class="keyword">old</span>);</span><br></pre></td></tr></table></figure>

<p>当我们向其中插入、删除数据一切正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mydb=# INSERT INTO test VALUES (1);</span><br><span class="line">INSERT 0 1</span><br><span class="line">mydb=# DELETE FROM test;</span><br><span class="line">DELETE 1</span><br><span class="line">mydb=# SELECT * FROM test_log;</span><br><span class="line"> old</span><br><span class="line">-----</span><br><span class="line"> (1)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>当我们尝试使用 pg_dump 导出时，一切正常，但是通过 psql 导入时则出现错误了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pg_dump mydb -f mydb.sql</span><br><span class="line">$ psql tdb -f mydb.sql</span><br><span class="line">[...]</span><br><span class="line">psql:mydb.sql:68: ERROR:  column &quot;old&quot; is of type public.test but expression is of type integer</span><br><span class="line">LINE 3:   VALUES (old.*);</span><br><span class="line">                  ^</span><br><span class="line">HINT:  You will need to rewrite or cast the expression.</span><br></pre></td></tr></table></figure>

<p>从 mydb.sql 文件中可以看到错误正好发生在 <code>CREATE RULE</code> 位置处，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> RULE del <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">TO</span> public.test DO  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.test_log (<span class="keyword">old</span>)</span><br><span class="line">  <span class="keyword">VALUES</span> (old.<span class="operator">*</span>);</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>正如 Tom Lane 在提交日志中所说，提交记录 7745bc352 确保在所有上下文中，当纯 <code>var.*</code> 符号会导致 <code>*</code> 扩展时，尤其是在 row() 和 VALUES() 构造中时，使用 <code>::type</code> 装饰来打印整行变量。然而，正如 Timur Khanjanov 所报告的那样，它忽略了使用单行值插入的情况。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/utils/adt/ruleutils.c b/src/backend/utils/adt/ruleutils.c</span></span><br><span class="line"><span class="comment">index 51391f6a4e..3388f7c17e 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/adt/ruleutils.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/adt/ruleutils.c</span></span><br><span class="line"><span class="meta">@@ -391,6 +391,8 @@</span> static void appendContextKeyword(deparse_context *context, const char *str,</span><br><span class="line"> static void removeStringInfoSpaces(StringInfo str);</span><br><span class="line"> static void get_rule_expr(Node *node, deparse_context *context,</span><br><span class="line"> 			  bool showimplicit);</span><br><span class="line"><span class="addition">+static void get_rule_expr_toplevel(Node *node, deparse_context *context,</span></span><br><span class="line"><span class="addition">+					   bool showimplicit);</span></span><br><span class="line"> static void get_oper_expr(OpExpr *expr, deparse_context *context);</span><br><span class="line"> static void get_func_expr(FuncExpr *expr, deparse_context *context,</span><br><span class="line"> 			  bool showimplicit);</span><br><span class="line"><span class="meta">@@ -4347,10 +4349,10 @@</span> get_values_def(List *values_lists, deparse_context *context)</span><br><span class="line"></span><br><span class="line"> 			/*</span><br><span class="line"> 			 * Strip any top-level nodes representing indirection assignments,</span><br><span class="line"><span class="deletion">-			 * then print the result.</span></span><br><span class="line"><span class="addition">+			 * then print the result.  Whole-row Vars need special treatment.</span></span><br><span class="line"> 			 */</span><br><span class="line"><span class="deletion">-			get_rule_expr(processIndirection(col, context, false),</span></span><br><span class="line"><span class="deletion">-						  context, false);</span></span><br><span class="line"><span class="addition">+			get_rule_expr_toplevel(processIndirection(col, context, false),</span></span><br><span class="line"><span class="addition">+								   context, false);</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 		appendStringInfoChar(buf, &#x27;)&#x27;);</span><br><span class="line"> 	&#125;</span><br><span class="line"><span class="meta">@@ -4771,7 +4773,8 @@</span> get_target_list(List *targetList, deparse_context *context,</span><br><span class="line"> 		 * the top level of a SELECT list it&#x27;s not right (the parser will</span><br><span class="line"> 		 * expand that notation into multiple columns, yielding behavior</span><br><span class="line"> 		 * different from a whole-row Var).  We need to call get_variable</span><br><span class="line"><span class="deletion">-		 * directly so that we can tell it to do the right thing.</span></span><br><span class="line"><span class="addition">+		 * directly so that we can tell it to do the right thing, and so that</span></span><br><span class="line"><span class="addition">+		 * we can get the attribute name which is the default AS label.</span></span><br><span class="line"> 		 */</span><br><span class="line"> 		if (tle-&gt;expr &amp;&amp; (IsA(tle-&gt;expr, Var)))</span><br><span class="line"> 		&#123;</span><br><span class="line"><span class="meta">@@ -7515,7 +7518,8 @@</span> get_rule_expr(Node *node, deparse_context *context,</span><br><span class="line"> 						!tupdesc-&gt;attrs[i]-&gt;attisdropped)</span><br><span class="line"> 					&#123;</span><br><span class="line"> 						appendStringInfoString(buf, sep);</span><br><span class="line"><span class="deletion">-						get_rule_expr(e, context, true);</span></span><br><span class="line"><span class="addition">+						/* Whole-row Vars need special treatment here */</span></span><br><span class="line"><span class="addition">+						get_rule_expr_toplevel(e, context, true);</span></span><br><span class="line"> 						sep = &quot;, &quot;;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 					i++;</span><br><span class="line"><span class="meta">@@ -7941,6 +7945,27 @@</span> get_rule_expr(Node *node, deparse_context *context,</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * get_rule_expr_toplevel		- Parse back a toplevel expression</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Same as get_rule_expr(), except that if the expr is just a Var, we pass</span></span><br><span class="line"><span class="addition">+ * istoplevel = true not false to get_variable().  This causes whole-row Vars</span></span><br><span class="line"><span class="addition">+ * to get printed with decoration that will prevent expansion of &quot;*&quot;.</span></span><br><span class="line"><span class="addition">+ * We need to use this in contexts such as ROW() and VALUES(), where the</span></span><br><span class="line"><span class="addition">+ * parser would expand &quot;foo.*&quot; appearing at top level.  (In principle we&#x27;d</span></span><br><span class="line"><span class="addition">+ * use this in get_target_list() too, but that has additional worries about</span></span><br><span class="line"><span class="addition">+ * whether to print AS, so it needs to invoke get_variable() directly anyway.)</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+static void</span></span><br><span class="line"><span class="addition">+get_rule_expr_toplevel(Node *node, deparse_context *context,</span></span><br><span class="line"><span class="addition">+					   bool showimplicit)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	if (node &amp;&amp; IsA(node, Var))</span></span><br><span class="line"><span class="addition">+		(void) get_variable((Var *) node, 0, true, context);</span></span><br><span class="line"><span class="addition">+	else</span></span><br><span class="line"><span class="addition">+		get_rule_expr(node, context, showimplicit);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure>

<p>从代码层面来看，主要的修改在于针对 <code>get_rule_expr()</code> 函数进行了封装，当 <code>node</code> 参数仅仅是一个 <code>Var</code> 时，函数 <code>get_variable()</code> 的 <code>istoplevel</code> 参数被设置为 <code>true</code>，以便其被正确的处理。</p>
<div class="just-for-fun">
笑林广记 - 公子封君

<p>有公子兼封君者，父对之乃欣羡不已。<br>讶问其故，曰：“你的爷既胜过我的爷，你的儿又胜过我的儿。”</p>
</div>


]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 索引扫描排序运算符</title>
    <url>/2022/01/postgresql-index-scan-ordering-operators/</url>
    <content><![CDATA[<p><a href="https://pgfans.cn/q/649">最近看到一个问题</a>，说是在 <code>ExecIndexBuildScanKeys()</code> 函数中的 <code>isorderby</code> 参数在有 <code>ORDER BY</code> 字句时，<code>IndexScan</code> 中的 <code>indexorderby</code> 也为空。例如下面两个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> index_key op const LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> col <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> index_key op const;</span><br></pre></td></tr></table></figure>

<p>这两个查询在执行 <code>ExecIndexBuildScanKeys()</code> 时 <code>IndexScan</code> 结构中的 <code>indexorderby</code> 均为空。然而，<code>IndexScan-&gt;indexorderby</code> 的注释为 <code>list of index ORDER BY exprs</code>，即 <code>ORDER BY</code> 语句后面的索引表达式，第一个 SQL 语句明显有 <code>ORDER BY</code> 字句，那么为什么此时的 <code>indexorderby</code> 为空呢？</p>
<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们首先来看看 <a href="https://github.com/postgres/postgres/blob/master/src/include/nodes/plannodes.h#L367"><code>IndexScan</code></a> 结构体的定义（代码比较长，仅截取部分内容）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ----------------</span></span><br><span class="line"><span class="comment"> *      index scan node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * indexorderbyorig is similarly the original form of any ORDER BY expressions</span></span><br><span class="line"><span class="comment"> * that are being implemented by the index, while indexorderby is modified to</span></span><br><span class="line"><span class="comment"> * have index column Vars on the left-hand side.  Here, multiple expressions</span></span><br><span class="line"><span class="comment"> * must appear in exactly the ORDER BY order, and this is not necessarily the</span></span><br><span class="line"><span class="comment"> * index column order.  Only the expressions are provided, not the auxiliary</span></span><br><span class="line"><span class="comment"> * sort-order information from the ORDER BY SortGroupClauses; it&#x27;s assumed</span></span><br><span class="line"><span class="comment"> * that the sort ordering is fully determinable from the top-level operators.</span></span><br><span class="line"><span class="comment"> * indexorderbyorig is used at runtime to recheck the ordering, if the index</span></span><br><span class="line"><span class="comment"> * cannot calculate an accurate ordering.  It is also needed for EXPLAIN.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ----------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexScan</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Scan        scan;</span><br><span class="line">    Oid         indexid;        <span class="comment">/* OID of index to scan */</span></span><br><span class="line">    List       *indexqual;      <span class="comment">/* list of index quals (usually OpExprs) */</span></span><br><span class="line">    List       *indexqualorig;  <span class="comment">/* the same in original form */</span></span><br><span class="line">    List       *indexorderby;   <span class="comment">/* list of index ORDER BY exprs */</span></span><br><span class="line">    List       *indexorderbyorig;   <span class="comment">/* the same in original form */</span></span><br><span class="line">    List       *indexorderbyops;    <span class="comment">/* OIDs of sort ops for ORDER BY exprs */</span></span><br><span class="line">    ScanDirection indexorderdir;    <span class="comment">/* forward or backward or don&#x27;t care */</span></span><br><span class="line">&#125; IndexScan;</span><br></pre></td></tr></table></figure>

<p>从上面来看好像没有什么问题，<code>ORDER BY</code> 字句中的表达式包含索引时，那么 <code>indexorderby</code> 就不应该为空。那么这个是不是一个 bug 呢？我们接着分析。既然这个地方 <code>indexorderby</code> 为空，那么我们来看看何时创建的 <code>IndexScan</code> 结构，针对 <code>indexorderby</code> 又进行了什么处理。</p>
<p>通过调试，我发现在 <code>create_indexscan_plan()</code> 函数中有处理，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Scan *</span></span><br><span class="line"><span class="function"><span class="title">create_indexscan_plan</span><span class="params">(PlannerInfo *root,</span></span></span><br><span class="line"><span class="params"><span class="function">                      IndexPath *best_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                      List *tlist,</span></span></span><br><span class="line"><span class="params"><span class="function">                      List *scan_clauses,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">bool</span> indexonly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract the index qual expressions (stripped of RestrictInfos) from the</span></span><br><span class="line"><span class="comment">     * IndexClauses list, and prepare a copy with index Vars substituted for</span></span><br><span class="line"><span class="comment">     * table Vars.  (This step also does replace_nestloop_params on the</span></span><br><span class="line"><span class="comment">     * fixed_indexquals.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fix_indexqual_references(root, best_path,</span><br><span class="line">                             &amp;stripped_indexquals,</span><br><span class="line">                             &amp;fixed_indexquals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Likewise fix up index attr references in the ORDER BY expressions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fixed_indexorderbys = fix_indexorderby_references(root, best_path);</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>fix_indexorderby_references()</code> 定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fix_indexorderby_references</span><br><span class="line"> *    Adjust indexorderby clauses to the form the executor&#x27;s index</span><br><span class="line"> *    machinery needs.</span><br><span class="line"> *</span><br><span class="line"> * This is a simplified version of fix_indexqual_references.  The input is</span><br><span class="line"> * bare clauses and a separate indexcol list, instead of IndexClauses.</span><br><span class="line"> */</span><br><span class="line">static List *</span><br><span class="line">fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)</span><br><span class="line">&#123;</span><br><span class="line">    IndexOptInfo *index = index_path-&gt;indexinfo;</span><br><span class="line">    List       *fixed_indexorderbys;</span><br><span class="line">    ListCell   *lcc,</span><br><span class="line">               *lci;</span><br><span class="line"></span><br><span class="line">    fixed_indexorderbys = NIL;</span><br><span class="line"></span><br><span class="line">    forboth(lcc, index_path-&gt;indexorderbys, lci, index_path-&gt;indexorderbycols)</span><br><span class="line">    &#123;</span><br><span class="line">        Node       *clause = (Node *) lfirst(lcc);</span><br><span class="line">        int         indexcol = lfirst_int(lci);</span><br><span class="line"></span><br><span class="line">        clause = fix_indexqual_clause(root, index, indexcol, clause, NIL);</span><br><span class="line">        fixed_indexorderbys = lappend(fixed_indexorderbys, clause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fixed_indexorderbys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这里的 <code>index_path-&gt;indexorderbys</code> 和 <code>index_path-&gt;indexorderbycols</code> 均为空，我们接着分析 <code>index_path</code>。<code>IndexPath</code> 定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * &#x27;indexorderbys&#x27;, if not NIL, is a list of ORDER BY expressions that have</span></span><br><span class="line"><span class="comment"> * been found to be usable as ordering operators for an amcanorderbyop index.</span></span><br><span class="line"><span class="comment"> * The list must match the path&#x27;s pathkeys, ie, one expression per pathkey</span></span><br><span class="line"><span class="comment"> * in the same order.  These are not RestrictInfos, just bare expressions,</span></span><br><span class="line"><span class="comment"> * since they generally won&#x27;t yield booleans.  It&#x27;s guaranteed that each</span></span><br><span class="line"><span class="comment"> * expression has the index key on the left side of the operator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;indexorderbycols&#x27; is an integer list of index column numbers (zero-based)</span></span><br><span class="line"><span class="comment"> * of the same length as &#x27;indexorderbys&#x27;, showing which index column each</span></span><br><span class="line"><span class="comment"> * ORDER BY expression is meant to be used with.  (There is no restriction</span></span><br><span class="line"><span class="comment"> * on which index column each ORDER BY can be used with.)</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IndexPath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Path        path;</span><br><span class="line">    IndexOptInfo *indexinfo;</span><br><span class="line">    List       *indexclauses;</span><br><span class="line">    List       *indexorderbys;</span><br><span class="line">    List       *indexorderbycols;</span><br><span class="line">    ScanDirection indexscandir;</span><br><span class="line">    Cost        indextotalcost;</span><br><span class="line">    Selectivity indexselectivity;</span><br><span class="line">&#125; IndexPath;</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看到一个关键的信息 <code>ordering operators</code>，在官网上搜索 <code>ordering operators</code> 关键字，我们可以找到 <a href="https://www.postgresql.org/docs/current/index-scanning.html">Index Scanning</a> 和 <a href="https://www.postgresql.org/docs/current/xindex.html">Interfacing Extensions to Indexes</a> 里面有相关的描述。</p>
<blockquote>
<p>Some access methods return index entries in a well-defined order, others do not. There are actually two different ways that an access method can support sorted output:</p>
<ul>
<li><p>Access methods that always return entries in the natural ordering of their data (such as btree) should set amcanorder to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</p>
</li>
<li><p>Access methods that support ordering operators should set amcanorderbyop to true. This indicates that the index is capable of returning entries in an order satisfying ORDER BY index_key operator constant. Scan modifiers of that form can be passed to amrescan as described previously.</p>
</li>
</ul>
</blockquote>
<p>一些访问方法以明确定义的顺序返回索引条目，而另一些则没有。实际上，访问方法可以支持排序输出有两种不同的方式：</p>
<ul>
<li>始终以数据的自然顺序返回条目的访问方法（例如 btree）应将 <code>amcanorder</code> 设置为 <code>true</code>。目前，此类访问方法必须使用与 btree 兼容的策略编号作为其相等和排序运算符</li>
<li>支持排序运算符的访问方法应将 <code>amcanorderbyop</code> 设置为 <code>true</code>。这表明索引能够以满足 <code>ORDER BY index_key</code> 运算符常量的顺序返回条目。</li>
</ul>
<blockquote>
<p>Some index access methods (currently, only GiST and SP-GiST) support the concept of ordering operators. What we have been discussing so far are search operators. A search operator is one for which the index can be searched to find all rows satisfying <code>WHERE indexed_column operator constant</code>. Note that nothing is promised about the order in which the matching rows will be returned. In contrast, an ordering operator does not restrict the set of rows that can be returned, but instead determines their order. An ordering operator is one for which the index can be scanned to return rows in the order represented by <code>ORDER BY indexed_column operator constant</code>. The reason for defining ordering operators that way is that it supports nearest-neighbor searches, if the operator is one that measures distance. For example, a query like</p>
<pre><code>SELECT * FROM places ORDER BY location &lt;-&gt; point &#39;(101,456)&#39; LIMIT 10;
</code></pre>
<p>finds the ten places closest to a given target point. A GiST index on the location column can do this efficiently because &lt;-&gt; is an ordering operator.</p>
<p>While search operators have to return Boolean results, ordering operators usually return some other type, such as float or numeric for distances. This type is normally not the same as the data type being indexed. To avoid hard-wiring assumptions about the behavior of different data types, the definition of an ordering operator is required to name a B-tree operator family that specifies the sort ordering of the result data type. As was stated in the previous section, B-tree operator families define PostgreSQL’s notion of ordering, so this is a natural representation. Since the point <code>&lt;-&gt;</code> operator returns float8, it could be specified in an operator class creation command like this:</p>
<pre><code>OPERATOR 15    &lt;-&gt; (point, point) FOR ORDER BY float_ops
</code></pre>
<p>where <code>float_ops</code> is the built-in operator family that includes operations on float8. This declaration states that the index is able to return rows in order of increasing values of the <code>&lt;-&gt;</code> operator.</p>
</blockquote>
<p>一些索引访问方法（目前只有 GiST 和 SP-GiST）支持排序运算符的概念。搜索运算符是一种可以搜索索引以找到满足 <code>WHERE indexed_column operator constant</code> 的所有行的运算符。对于返回的记录其顺序可能是随机的。相反，排序运算符不限制可以返回的记录，而是确定它们的顺序。排序运算符是一种可以扫描其索引以按 <code>ORDER BY indexed_column operator constant</code> 表示的顺序返回行的运算符。以这种方式定义排序运算符的原因是，如果运算符是测量距离的运算符，它可以支持最近邻搜索。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> places <span class="keyword">ORDER</span> <span class="keyword">BY</span> location <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> point <span class="string">&#x27;(101,456)&#x27;</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>找到最接近给定目标点的十个地点。<code>location</code> 列上的 GiST 索引可以有效地做到这一点，因为 <code>&lt;-&gt;</code> 是一个排序运算符。</p>
<p>搜索运算符必须返回 <code>boolean</code> 类型的值，排序运算符通常返回其它类型，如代表距离的 <code>float</code> 或 <code>numeric</code> 类型。这种类型通常与被索引的数据类型不同。</p>
<p>分析到这里我们大致可以知道为什么之前的 <code>ORDER BY index_key op constant</code> 这里在 <code>IndexScan</code> 中的 <code>indexorderby</code> 为空了，因为之前的示例中的索引上面的操作并不支持排序运算符，因此为空。我们可以通过下面的示例来进行验证。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl01(id <span class="type">int</span> <span class="keyword">primary</span> key, location point);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl01 <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;(40, 50)&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl01 <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;(30, 20)&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl01 <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;(10, 24)&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> tbl01 <span class="keyword">USING</span> gist(location);</span><br></pre></td></tr></table></figure>

<p>基于上面的示例，当我们执行 <code>SELECT * FROM tbl01 ORDER BY location &lt;-&gt; point &#39;(0, 0)&#39;</code> 查询时，<code>IndexScan</code> 中的 <code>indexorderby</code> 将不为空。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照文档来说，PostgreSQL 索引有查找运算符（Search Operator）和排序运算符（Ordering Operator）。我们通常使用到的是查找运算符，排序运算符接触的比较少（至少对于我来说是这样的）。</p>
<ul>
<li>查找运算符：用于查询符合条件的记录，返回记录的顺序是随机的，即有多个记录的值等于查找键，这些记录在第一次可能以 <code>a, b, c</code> 的顺序返回，第二次则以 <code>c, a, b</code> 的顺序返回。查找运算符的返回值是 <code>boolean</code> 类型。</li>
<li>排序运算符：用于对记录进行排序，返回记录的顺序是确定的，多次执行都是一样的。排序运算符的返回值通常是其它类型，如代表距离的 <code>float</code> 或 <code>numeric</code> 类型。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/current/index-scanning.html">https://www.postgresql.org/docs/current/index-scanning.html</a><br>[2] <a href="https://www.postgresql.org/docs/current/xindex.html">https://www.postgresql.org/docs/current/xindex.html</a><br>[3] 《PostgreSQL 修炼之道 - 从小工到专家》</p>
<div class="just-for-fun">
笑林广记 - 考监

<p>一监生过国学门，闻祭酒方盛怒两生而治之，问门上人者，然则打欤？罚欤？镦锁欤？<br>答曰：“出题考文。”<br>生即咈然，曰：“咦，罪不至此。”</p>
</div>


]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 类型转换时无效的类型输入</title>
    <url>/2021/05/postgresql-invalid-input-syntax-for-type-numeric-null/</url>
    <content><![CDATA[<p>最近在做 Oracle 迁移的时候发现一个类型错误，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:  invalid input syntax for type numeric: &quot;null&quot;</span><br></pre></td></tr></table></figure>

<p>这个问题其实很简单，就是原始数据里面包含 <code>&#39;null&#39;</code> 的字符串导致的。解决这个问题的办法就是将数据中为 <code>&#39;null&#39;</code> 的异常数据转换为正常数据。</p>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这个问题是我们想要将 <code>varchar</code> 类型的字段转为 <code>numeric</code> 类型时出现的。原始数据有大约 60w 行记录，其中大部分都是可以之间通过 <code>cast</code> 转换为 <code>numeric</code> 类型的。通过下面的查询我们可以看到有 4 条记录存储了 <code>null</code> 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id, total_year FROM contract_export WHERE total_year !~ &#x27;[0-9.]+&#x27;;</span><br><span class="line">        id        | total_year</span><br><span class="line">------------------+------------</span><br><span class="line"> PG202006173J2995 | null</span><br><span class="line"> PG202007074K5842 | null</span><br><span class="line"> PG202005181L4194 | null</span><br><span class="line"> PG202005186D1908 | null</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然是数据异常，那么我们就要想法将异常数据转换为正常数据，这个可能就需要根据业务来确定异常的数据该如何进行转换。不过可以确定的是，我们可以通过 <code>CASE WHEN</code> 语句来处理异常数据。那么如果异常的数据过多怎么办？我们是否需要提供很多的 <code>WHEN</code> 分支呢？</p>
<p>这里我们就需要查看异常数据是否有共性？如果有共性，那么我们可以通过正则表达式将其刷选出来。如果异常数据没有共性呢？那么我们是否可以方向思考呢？通过正常数据的共性来匹配正常数据，从而达到刷选异常数据的目的。</p>
<p>这个问题的解决方法其实在上面的 SQL 查询中已经给出了，我们可以使用下面的语句来进行处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  id,</span><br><span class="line">  (<span class="keyword">CASE</span></span><br><span class="line">     <span class="keyword">WHEN</span> total_year <span class="keyword">LIKE</span> <span class="string">&#x27;%null%&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">     <span class="keyword">ELSE</span> total_year</span><br><span class="line">   <span class="keyword">END</span>)::<span class="type">numeric</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  contract_export;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  id,</span><br><span class="line">  (<span class="keyword">CASE</span></span><br><span class="line">     <span class="keyword">WHEN</span> total_year <span class="operator">!</span><span class="operator">~</span> <span class="string">&#x27;[0-9.]+&#x27;</span> <span class="keyword">THEN</span> total_year</span><br><span class="line">	 <span class="keyword">ELSE</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">   <span class="keyword">END</span>)::<span class="type">numeric</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  contract_export;</span><br></pre></td></tr></table></figure>

<p>为了防止其出现 <code>NULL</code> 值导致类型转换失败，我们可以使用 <code>COALESCE</code> 来处理 <code>NULL</code> 值。</p>
<div class="just-for-fun">
笑林广记 - 狗父

<p>陆某，善说话，有邻妇性不好笑，<br>其友谓之曰：“汝能说一字令彼妇笑，又说一字令彼妇骂，则吾愿以酒菜享汝。”<br>一日，妇立门前，适门前卧一犬，陆向之长跪曰：“爷！”<br>妇见之不觉好笑，陆复仰首向妇曰：“娘！”<br>妇闻之大骂。</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 使用 JDBC 调用存储过程错误</title>
    <url>/2021/11/postgresql-jdbc-call-procedure/</url>
    <content><![CDATA[<p>最近在迁移 Oracle 数据库到 PostgreSQL 时遇到了 PostgreSQL 中调用存储过程异常的情况。本文简要记录以下定位及其修复过程。</p>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在将 Oracle 中的存储过程迁移到 PostgreSQL 中，我们遇到了一个如下的存储过程（经过了简化）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> proc(a <span class="keyword">INOUT</span> <span class="type">bigint</span>)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span>(a);</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>随后在 Java 程序中使用 JDBC 去调用这个存储过程，调用代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CallableStatement proc = conn.prepareCall(<span class="string">&quot;&#123;call proc( ? )&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行时程序报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.postgresql.util.PSQLException: ERROR: proc(integer) is a procedure</span><br><span class="line">  Hint: To call a procedure, use CALL.</span><br><span class="line">  Position: 15</span><br><span class="line">        at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2674)</span><br><span class="line">        at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2364)</span><br><span class="line">        at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:354)</span><br><span class="line">        at org.postgresql.jdbc.PgStatement.executeInternal(PgStatement.java:484)</span><br><span class="line">        at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:404)</span><br><span class="line">        at org.postgresql.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:162)</span><br><span class="line">        at org.postgresql.jdbc.PgCallableStatement.executeWithFlags(PgCallableStatement.java:83)</span><br><span class="line">        at org.postgresql.jdbc.PgPreparedStatement.execute(PgPreparedStatement.java:151)</span><br><span class="line">        at PGTest.main(PGTest.java:52)</span><br><span class="line">org.postgresql.util.PSQLException: ERROR: proc(integer) is a procedure</span><br><span class="line">  Hint: To call a procedure, use CALL.</span><br><span class="line">  Position: 15</span><br></pre></td></tr></table></figure>

<p>错误提示我们调用的是一个存储过程，应该使用 <code>CALL</code> 来调用存储过程？WTF? 难道我在程序里使用的不是 <code>CALL</code> 么？真的是老眼昏花了吗？</p>
<p>经过一番尝试之后发现还是不能解决这个问题，当时由于敢进度，就选择了曲线救国的思路，将存储过程改为函数，折腾了一番之后总算是可以用了。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>晚上回来继续研究，这次选择了查看<a href="https://jdbc.postgresql.org/documentation/head/callproc.html">官方文档</a>，浏览了一下发现 PostgreSQL 的 JDBC 在处理存储过程没有返回值的时候需要设置 <code>escapeSyntaxCallMode</code> 参数。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ensure EscapeSyntaxCallmode property set to support procedures if no return value</span></span><br><span class="line">props.setProperty(<span class="string">&quot;escapeSyntaxCallMode&quot;</span>, <span class="string">&quot;callIfNoReturn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>根据注释来看，设置 <code>escapeSyntaxCallMode</code> 为 <code>callIfNoReturn</code> 可以确保存储过程在没有返回值的时候依然正常工作，经验证，通过这个设置，存储过程便能正确执行了。</p>
<p>这个问题虽然不大，但是对于不懂 Java 的我来说定位还是比较费事的，不过还好 PostgreSQL 的 jdbc 文档比较完善，虽然走了一些弯路，从这个也能看出，官方文档才是第一手资料，其他的都是浮云啊。</p>
<p>此外，<a href="https://jdbc.postgresql.org/documentation/head/connect.html">这里</a> 包含了 PostgreSQL 数据库 jdbc 连接的所有参数信息。拿上面的 <code>escapeSyntaxCallMode</code> 来说，您可以看到如下内容：</p>
<blockquote>
<ul>
<li><p>escapeSyntaxCallMode = String</p>
<p>Specifies how the driver transforms JDBC escape call syntax into underlying SQL, for invoking procedures or functions. In escapeSyntaxCallMode=select mode (the default), the driver always uses a SELECT statement (allowing function invocation only). In escapeSyntaxCallMode=callIfNoReturn mode, the driver uses a CALL statement (allowing procedure invocation) if there is no return parameter specified, otherwise the driver uses a SELECT statement. In escapeSyntaxCallMode=call mode, the driver always uses a CALL statement (allowing procedure invocation only).</p>
<p>The default is select</p>
</li>
</ul>
</blockquote>
<p>从上面的说明可以看到，<code>escapeSyntaxCallMode</code> 参数制定了如何调用底层的函数和存储过程，它有三种模式：</p>
<ul>
<li><strong>select</strong> - 默认值，jdbc 驱动使用 <code>SELECT</code> 来调用函数和存储过程。</li>
<li><strong>callIfNoReturn</strong> - 当存储过程没有返回值时使用 <code>CALL</code> 来调用，其他情况则使用 <code>SELECT</code> 来调用。</li>
<li><strong>call</strong> - 所有的函数和存储过程都使用 <code>CALL</code> 来调用。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://jdbc.postgresql.org/documentation/head/callproc.html">https://jdbc.postgresql.org/documentation/head/callproc.html</a><br>[2] <a href="https://jdbc.postgresql.org/documentation/head/connect.html">https://jdbc.postgresql.org/documentation/head/connect.html</a></p>
<div class="just-for-fun">
笑林广记 - 进士第

<p>一介弟横行于乡，怨家骂曰：“兄登黄甲，与汝何干，而豪横若此？”<br>答曰：“尔不见匾额上面写着‘进士第（弟）’么？”</p>
</div>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 15 特性 - jsonlog 日志</title>
    <url>/2022/01/postgresql-jsonlog/</url>
    <content><![CDATA[<p>PostgreSQL 15 新增了 jsonlog 日志选项，即可以将日志存储为 json 格式，下面是详细的提交信息。</p>
<pre><code>commit dc686681e0799b12c40f44f85fc5bfd7fed4e57f
Author: Michael Paquier &lt;michael@paquier.xyz&gt;
Date:   Mon Jan 17 10:16:53 2022 +0900

    Introduce log_destination=jsonlog

    &quot;jsonlog&quot; is a new value that can be added to log_destination to provide
    logs in the JSON format, with its output written to a file, making it
    the third type of destination of this kind, after &quot;stderr&quot; and
    &quot;csvlog&quot;.  The format is convenient to feed logs to other applications.
    There is also a plugin external to core that provided this feature using
    the hook in elog.c, but this had to overwrite the output of &quot;stderr&quot; to
    work, so being able to do both at the same time was not possible.  The
    files generated by this log format are suffixed with &quot;.json&quot;, and use
    the same rotation policies as the other two formats depending on the
    backend configuration.

    This takes advantage of the refactoring work done previously in ac7c807,
    bed6ed3, 8b76f89 and 2d77d83 for the backend parts, and 72b76f7 for the
    TAP tests, making the addition of any new file-based format rather
    straight-forward.

    The documentation is updated to list all the keys and the values that
    can exist in this new format.  pg_current_logfile() also required a
    refresh for the new option.

    Author: Sehrope Sarkuni, Michael Paquier
    Reviewed-by: Nathan Bossart, Justin Pryzby
    Discussion: https://postgr.es/m/CAH7T-aqswBM6JWe4pDehi1uOiufqe06DJWaU5=X7dDLyqUExHg@mail.gmail.com
</code></pre>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>PostgreSQL 新增的 jsonlog 日志与 csvlog 日志类似，使用时我们需要将 <code>logging_collector</code> 设置为 <code>on</code>，当然 <code>log_destination</code> 需要设置为 <code>jsonlog</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER SYSTEM SET logging_collector TO on;</span><br><span class="line">ALTER SYSTEM SET log_destination TO jsonlog;</span><br></pre></td></tr></table></figure>

<p>重启数据库之后，我们可以看得到 <code>log</code> 目录下新建了以 <code>json</code> 结尾的的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l <span class="variable">$PGDATA</span>/<span class="built_in">log</span></span></span><br><span class="line">total 8</span><br><span class="line">-rw------- 1 px px 2480 Jan 17 22:33 postgresql-2022-01-17_222830.json</span><br><span class="line">-rw------- 1 px px  173 Jan 17 22:28 postgresql-2022-01-17_222830.log</span><br></pre></td></tr></table></figure>

<p>我们可以结合 <code>jq</code> 工具来查看日志文件内容，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="variable">$PGDATA</span>/<span class="built_in">log</span>/postgresql-2022-01-17_222830.json | jq</span></span><br><span class="line">[...]</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2022-01-17 22:28:30.529 CST&quot;,</span><br><span class="line">  &quot;pid&quot;: 1936315,</span><br><span class="line">  &quot;session_id&quot;: &quot;61e57d0e.1d8bbb&quot;,</span><br><span class="line">  &quot;line_num&quot;: 1,</span><br><span class="line">  &quot;session_start&quot;: &quot;2022-01-17 22:28:30 CST&quot;,</span><br><span class="line">  &quot;txid&quot;: 0,</span><br><span class="line">  &quot;error_severity&quot;: &quot;LOG&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;database system was shut down at 2022-01-17 22:28:30 CST&quot;,</span><br><span class="line">  &quot;backend_type&quot;: &quot;startup&quot;,</span><br><span class="line">  &quot;query_id&quot;: 0</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2022-01-17 22:28:30.532 CST&quot;,</span><br><span class="line">  &quot;pid&quot;: 1936311,</span><br><span class="line">  &quot;session_id&quot;: &quot;61e57d0e.1d8bb7&quot;,</span><br><span class="line">  &quot;line_num&quot;: 5,</span><br><span class="line">  &quot;session_start&quot;: &quot;2022-01-17 22:28:30 CST&quot;,</span><br><span class="line">  &quot;txid&quot;: 0,</span><br><span class="line">  &quot;error_severity&quot;: &quot;LOG&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;database system is ready to accept connections&quot;,</span><br><span class="line">  &quot;backend_type&quot;: &quot;postmaster&quot;,</span><br><span class="line">  &quot;query_id&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以结合 <code>jq</code> 的命令选项来快速查找日志信息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jq <span class="string">&#x27;select(.error_severity == &quot;ERROR&quot;)&#x27;</span> <span class="variable">$PGDATA</span>/<span class="built_in">log</span>/postgresql-2022-01-18_121035.json</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2022-01-18 12:17:48.640 CST&quot;,</span><br><span class="line">  &quot;user&quot;: &quot;px&quot;,</span><br><span class="line">  &quot;dbname&quot;: &quot;postgres&quot;,</span><br><span class="line">  &quot;pid&quot;: 1944761,</span><br><span class="line">  &quot;remote_host&quot;: &quot;[local]&quot;,</span><br><span class="line">  &quot;session_id&quot;: &quot;61e63dbd.1dacb9&quot;,</span><br><span class="line">  &quot;line_num&quot;: 1,</span><br><span class="line">  &quot;ps&quot;: &quot;DROP TABLE&quot;,</span><br><span class="line">  &quot;session_start&quot;: &quot;2022-01-18 12:10:37 CST&quot;,</span><br><span class="line">  &quot;vxid&quot;: &quot;3/4&quot;,</span><br><span class="line">  &quot;txid&quot;: 0,</span><br><span class="line">  &quot;error_severity&quot;: &quot;ERROR&quot;,</span><br><span class="line">  &quot;state_code&quot;: &quot;42P01&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;table \&quot;t\&quot; does not exist&quot;,</span><br><span class="line">  &quot;statement&quot;: &quot;drop table t;&quot;,</span><br><span class="line">  &quot;application_name&quot;: &quot;psql&quot;,</span><br><span class="line">  &quot;backend_type&quot;: &quot;client backend&quot;,</span><br><span class="line">  &quot;query_id&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的命令通过 <code>jq</code> 的 <code>select</code> 来查看日志级别为 <code>ERROR</code> 的日志信息。您还可以定制更为详细、精准的过滤条件。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>PostgreSQL 中 <code>jsonlog</code> 可以包含以下字段：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp</td>
<td>string</td>
<td>以毫秒为单位的时间戳</td>
</tr>
<tr>
<td>user</td>
<td>string</td>
<td>用户名</td>
</tr>
<tr>
<td>dbname</td>
<td>string</td>
<td>数据库名</td>
</tr>
<tr>
<td>pid</td>
<td>number</td>
<td>进程 ID</td>
</tr>
<tr>
<td>remote_host</td>
<td>string</td>
<td>客户端主机</td>
</tr>
<tr>
<td>remote_port</td>
<td>number</td>
<td>客户端端口</td>
</tr>
<tr>
<td>session_id</td>
<td>string</td>
<td>会话 ID</td>
</tr>
<tr>
<td>line_num</td>
<td>number</td>
<td>每个会话的行号</td>
</tr>
<tr>
<td>ps</td>
<td>string</td>
<td>当前 ps 的显示内容</td>
</tr>
<tr>
<td>session_start</td>
<td>string</td>
<td>会话开始时间</td>
</tr>
<tr>
<td>vxid</td>
<td>string</td>
<td>虚拟事务 ID</td>
</tr>
<tr>
<td>txid</td>
<td>string</td>
<td>常规事务 ID</td>
</tr>
<tr>
<td>error_severity</td>
<td>string</td>
<td>错误严重程度（日志级别）</td>
</tr>
<tr>
<td>state_code</td>
<td>string</td>
<td>SQLSTATE 代码</td>
</tr>
<tr>
<td>message</td>
<td>string</td>
<td>错误信息</td>
</tr>
<tr>
<td>detail</td>
<td>string</td>
<td>错误详细信息</td>
</tr>
<tr>
<td>hint</td>
<td>string</td>
<td>错误提示信息</td>
</tr>
<tr>
<td>internal_query</td>
<td>string</td>
<td>导致错误的内部查询</td>
</tr>
<tr>
<td>internal_position</td>
<td>number</td>
<td>光标索引到内部查询错误位置</td>
</tr>
<tr>
<td>context</td>
<td>string</td>
<td>错误上下文</td>
</tr>
<tr>
<td>statement</td>
<td>string</td>
<td>客户端提供的查询字符串</td>
</tr>
<tr>
<td>cursor_position</td>
<td>string</td>
<td>光标索引到查询字符串错误位置</td>
</tr>
<tr>
<td>func_name</td>
<td>string</td>
<td>错误定位函数名称</td>
</tr>
<tr>
<td>file_name</td>
<td>string</td>
<td>错误位置的文件名</td>
</tr>
<tr>
<td>file_line_num</td>
<td>number</td>
<td>错误位置的文件行号</td>
</tr>
<tr>
<td>application_name</td>
<td>string</td>
<td>客户端应用程序名称</td>
</tr>
<tr>
<td>backend_type</td>
<td>string</td>
<td>后端进程类型</td>
</tr>
<tr>
<td>leader_pid</td>
<td>number</td>
<td>活动并行工作者的领导者进程 ID</td>
</tr>
<tr>
<td>query_id</td>
<td>number</td>
<td>查询 ID</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/devel/runtime-config-logging.html">https://www.postgresql.org/docs/devel/runtime-config-logging.html</a><br>[2] <a href="https://www.postgresql.org/docs/devel/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-JSONLOG">https://www.postgresql.org/docs/devel/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-JSONLOG</a><br>[3] <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=dc686681e0799b12c40f44f85fc5bfd7fed4e57f">https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=dc686681e0799b12c40f44f85fc5bfd7fed4e57f</a></p>
<div class="just-for-fun">
笑林广记 - 送父上学

<p>一人问：“公子与封君孰乐？”<br>答曰：“做封君虽乐，齿已衰矣。惟公子年少最乐。”<br>其人急趋而去，追问其故，答曰：“买了书，好送家父去上学。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 作业调度器 - pg_cron</title>
    <url>/2021/11/postgresql-job-scheduler-pg-cron/</url>
    <content><![CDATA[<p><a href="https://github.com/citusdata/pg_cron">pg_cron</a> 是 PostgreSQL 数据库的一个作业调度器插件，通过该插件我们可以定时的执行一些特殊的任务。它遵循 Linux crontab 的配置语法，您可以通过在线工具 <a href="http://crontab.guru/">crontab.guru</a> 来验证您的 cron 表达式。目前，pg_cron 仅支持 PostgreSQL 10 及其之后的版本。本文将简要介绍 pg_cron 的安装及其使用。</p>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在开始之前，我们需要安装 pg_cron 插件，这里采用源码编译的方式安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/citusdata/pg_cron.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> pg_cron</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p>在执行上面的命令之前，您需要配置好 PostgreSQL 的环境变量，以便 <code>make</code> 执行的时候可以找到 <code>pg_config</code> 命令来获取相关的信息（包括编译选项、安装路径等）。</p>
<p>接着，我们需要修改 PostgreSQL 的配置参数，并重启数据库，最后在创建 pg_cron 插件，您可以使用如下的命令来完成这些工作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ psql postgres <span class="operator">-</span>c <span class="string">&#x27;ALTER SYSTEM SET shared_preload_libraries TO pg_cron;&#x27;</span></span><br><span class="line">$ pg_ctl restart</span><br><span class="line">$ psql postgres <span class="operator">-</span>c <span class="string">&#x27;CREATE EXTENSION pg_cron;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当我们成功执行上述命令之后，pg_cron 将创建一个 <code>cron</code> 的模式，并在该模式下创建如下函数：</p>
<ul>
<li><strong>alter_job</strong> - 修改 job 信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">void cron.alter_job(</span><br><span class="line">    job_id <span class="type">bigint</span>,</span><br><span class="line"> schedule text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>::text,</span><br><span class="line"> command text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>::text,</span><br><span class="line"> database text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>::text,</span><br><span class="line"> username text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>::text,</span><br><span class="line"> active <span class="type">boolean</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>::<span class="type">boolean</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>job_cache_invalidate</strong> - 清除 job 缓存信息触发器<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trigger</span> cron.job_cache_invalidate();</span><br></pre></td></tr></table></figure></li>
<li><strong>schedule</strong> - 创建 job 任务，支持匿名 job 和命名 job 两种类型<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">bigint</span> cron.schedule(schedule text, command text);</span><br><span class="line"><span class="type">bigint</span> cron.schedule(job_name text, schedule text, command text);</span><br></pre></td></tr></table></figure></li>
<li><strong>schedule_in_database</strong> - 为其他数据库创建 job<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">bigint</span> cron.schedule_in_database(</span><br><span class="line">    job_name text,</span><br><span class="line"> schedule text,</span><br><span class="line"> command text,</span><br><span class="line"> database text,</span><br><span class="line"> username text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>::text,</span><br><span class="line"> active <span class="type">boolean</span> <span class="keyword">DEFAULT</span> <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>unschedule</strong> - 删除 job 任务，支持以 job id 和 job 名字两种方式来删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> cron.unschedule(job_id <span class="type">bigint</span>);</span><br><span class="line"><span class="type">boolean</span> cron.unschedule(job_name name);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以及 <code>job</code> 和 <code>job_run_details</code> 表。</p>
<ul>
<li><strong>job</strong> - job 信息表，记录当前创建的所有 job 信息</li>
<li><strong>job_run_details</strong> - job 运行信息表，用于记录 job 运行后的状态及其相关信息</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们创建一个 <code>mylog</code> 表来记录日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mylog(create_date <span class="type">timestamp</span>, info text);</span><br></pre></td></tr></table></figure>

<p>随后创建一个函数来向 <code>mylog</code> 中插入数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> insert_log_job() <span class="keyword">RETURNS</span> void</span><br><span class="line"><span class="keyword">AS</span> $body$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> mylog <span class="keyword">VALUES</span> (now(), <span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$body$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>接下来我们创建便可以创建 job 了，这里我们将创建一个匿名 job 和一个命令 job。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cron.schedule(</span><br><span class="line">    <span class="string">&#x27;*/1 * * * *&#x27;</span>,</span><br><span class="line">	$$ <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>; $$</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的命令创建的 job 存在语法问题，我们可以通过 <code>alter_job</code> 来对其进行修改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cron.alter_job(<span class="number">1</span>, <span class="string">&#x27;*/1 * * * *&#x27;</span>, <span class="string">&#x27;SELECT insert_log_job();&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们可以在 <code>job_run_details</code> 中看到 job 的详细信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cron.job_run_details \gx</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">1</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1392744</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span>  <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>;</span><br><span class="line">status         <span class="operator">|</span> failed</span><br><span class="line">return_message <span class="operator">|</span> ERROR:  syntax error <span class="keyword">at</span> <span class="keyword">or</span> near &quot;SELECT&quot;    <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span> LINE <span class="number">1</span>:  <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>; <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span>                <span class="operator">^</span>                            <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">00.018493</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">00.02138</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">2</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">2</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1392892</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span>  <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>;</span><br><span class="line">status         <span class="operator">|</span> failed</span><br><span class="line">return_message <span class="operator">|</span> ERROR:  syntax error <span class="keyword">at</span> <span class="keyword">or</span> near &quot;SELECT&quot;    <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span> LINE <span class="number">1</span>:  <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>; <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span>                <span class="operator">^</span>                            <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">00.018235</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">00.020252</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">3</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">3</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1393038</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span>  <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>;</span><br><span class="line">status         <span class="operator">|</span> failed</span><br><span class="line">return_message <span class="operator">|</span> ERROR:  syntax error <span class="keyword">at</span> <span class="keyword">or</span> near &quot;SELECT&quot;    <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span> LINE <span class="number">1</span>:  <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> insert_log_job() <span class="keyword">END</span>; <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span>                <span class="operator">^</span>                            <span class="operator">+</span></span><br><span class="line">               <span class="operator">|</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">00.02294</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">00.02633</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">4</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">4</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1393183</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job();</span><br><span class="line">status         <span class="operator">|</span> succeeded</span><br><span class="line">return_message <span class="operator">|</span> <span class="number">1</span> <span class="type">row</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">00.011896</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">00.016711</span><span class="operator">+</span><span class="number">08</span></span><br></pre></td></tr></table></figure>

<p>同时，我们也可以看到在 <code>mylog</code> 表中插入了一条新的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mylog;</span><br><span class="line">        create_date         <span class="operator">|</span>    info</span><br><span class="line"><span class="comment">----------------------------+-------------</span></span><br><span class="line"> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">00.011996</span> <span class="operator">|</span> hello world</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>随后，我们修改一下其执行的周期，将 1 分钟执行一次改为 10 分钟执行一次（避免过多的日志）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> cron.alter_job(<span class="number">1</span>, <span class="string">&#x27;*/10 * * * *&#x27;</span>);</span><br><span class="line"> alter_job</span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>现在，我们再来创建一个命名的 job。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> cron.schedule(<span class="string">&#x27;job1&#x27;</span>, <span class="string">&#x27;*/5 * * * *&#x27;</span>, <span class="string">&#x27;SELECT insert_log_job()&#x27;</span>);</span><br><span class="line"> schedule</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">        <span class="number">2</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cron.job;</span><br><span class="line"> jobid <span class="operator">|</span>   schedule   <span class="operator">|</span>         command          <span class="operator">|</span> nodename  <span class="operator">|</span> nodeport <span class="operator">|</span> database <span class="operator">|</span> username <span class="operator">|</span> active <span class="operator">|</span> jobname</span><br><span class="line"><span class="comment">-------+--------------+--------------------------+-----------+----------+----------+----------+--------+---------</span></span><br><span class="line">     <span class="number">1</span> <span class="operator">|</span> <span class="operator">*</span><span class="operator">/</span><span class="number">10</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job(); <span class="operator">|</span> localhost <span class="operator">|</span>     <span class="number">5432</span> <span class="operator">|</span> postgres <span class="operator">|</span> px       <span class="operator">|</span> t      <span class="operator">|</span></span><br><span class="line">     <span class="number">2</span> <span class="operator">|</span> <span class="operator">*</span><span class="operator">/</span><span class="number">5</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span>  <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job()  <span class="operator">|</span> localhost <span class="operator">|</span>     <span class="number">5432</span> <span class="operator">|</span> postgres <span class="operator">|</span> px       <span class="operator">|</span> t      <span class="operator">|</span> job1</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>等待 job 执行后，我们可以查看 <code>job_run_details</code> 来验证 job 的执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cron.job_run_details \gx</span><br><span class="line">...</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">4</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">4</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1393183</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job();</span><br><span class="line">status         <span class="operator">|</span> succeeded</span><br><span class="line">return_message <span class="operator">|</span> <span class="number">1</span> <span class="type">row</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">00.011896</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">00.016711</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">5</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">2</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">5</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1394493</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job()</span><br><span class="line">status         <span class="operator">|</span> succeeded</span><br><span class="line">return_message <span class="operator">|</span> <span class="number">1</span> <span class="type">row</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">00.021353</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">00.033443</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">6</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">6</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1394494</span></span><br><span class="line">database       <span class="operator">|</span> postgres</span><br><span class="line">username       <span class="operator">|</span> px</span><br><span class="line">command        <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job();</span><br><span class="line">status         <span class="operator">|</span> succeeded</span><br><span class="line">return_message <span class="operator">|</span> <span class="number">1</span> <span class="type">row</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">00.025503</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">00.039575</span><span class="operator">+</span><span class="number">08</span></span><br></pre></td></tr></table></figure>

<p>最后，我们来看看如何删除 job。pg_cron 提供了两种方式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> cron.unschedule(<span class="number">1</span>);  <span class="comment">-- 以 job id 的方式删除 job</span></span><br><span class="line"> unschedule</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cron.job;</span><br><span class="line"> jobid <span class="operator">|</span>   schedule   <span class="operator">|</span>         command          <span class="operator">|</span> nodename  <span class="operator">|</span> nodeport <span class="operator">|</span> database <span class="operator">|</span> username <span class="operator">|</span> active <span class="operator">|</span> jobname</span><br><span class="line"><span class="comment">-------+--------------+--------------------------+-----------+----------+----------+----------+--------+---------</span></span><br><span class="line">     <span class="number">2</span> <span class="operator">|</span> <span class="operator">*</span><span class="operator">/</span><span class="number">5</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span>  <span class="operator">|</span> <span class="keyword">SELECT</span> insert_log_job()  <span class="operator">|</span> localhost <span class="operator">|</span>     <span class="number">5432</span> <span class="operator">|</span> postgres <span class="operator">|</span> px       <span class="operator">|</span> t      <span class="operator">|</span> job1</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> cron.unschedule(<span class="string">&#x27;job1&#x27;</span>); <span class="comment">-- 以 job 名字的方式删除 job，仅支持命名 job</span></span><br><span class="line"> unschedule</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cron.job;</span><br><span class="line"> jobid <span class="operator">|</span> schedule <span class="operator">|</span> command <span class="operator">|</span> nodename <span class="operator">|</span> nodeport <span class="operator">|</span> database <span class="operator">|</span> username <span class="operator">|</span> active <span class="operator">|</span> jobname</span><br><span class="line"><span class="comment">-------+----------+---------+----------+----------+----------+----------+--------+---------</span></span><br><span class="line">(<span class="number">0</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>在了解了 pg_cron 的基本使用之后，我们来看看其他的一些使用，我们首先创建一个用户和数据库，并切换到该数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">USER</span> japin <span class="keyword">WITH</span> ENCRYPTED PASSWORD <span class="string">&#x27;japin&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE</span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> DATABASE testdb OWNER japin;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE</span><br><span class="line">postgres<span class="operator">=</span># \c testdb japin</span><br><span class="line">You <span class="keyword">are</span> now connected <span class="keyword">to</span> database &quot;testdb&quot; <span class="keyword">as</span> <span class="keyword">user</span> &quot;japin&quot;.</span><br></pre></td></tr></table></figure>

<p>随后在 <code>testdb</code> 中新建表和函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="built_in">log</span>(info text, <span class="keyword">at</span> timestmap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> testdb_insert_log_job() <span class="keyword">RETURNS</span> void</span><br><span class="line"><span class="keyword">AS</span> $body$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> log <span class="keyword">VALUES</span> (<span class="string">&#x27;hello, testdb&#x27;</span>, now());</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$body$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>接着我们切回到超级用户并执行下面的语句，它将为 <code>testdb</code> 创建一个 job。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cron.schedule_in_database(</span><br><span class="line">    <span class="string">&#x27;testdb_job1&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;*/1 * * * *&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;SELECT testdb_insert_log_job()&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;testdb&#x27;</span>, <span class="comment">-- 指定目标数据库</span></span><br><span class="line">	<span class="string">&#x27;japin&#x27;</span>,  <span class="comment">-- 指定登录目标数据库的用户</span></span><br><span class="line">	<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>pg_cron 是通过 libpq 连接到目标数据库上去执行任务的，因此我们指定的用户需要在目标数据库上有足够的权限执行 job 指定的任务。因此您可能需要配置 <code>pg_hba.conf</code> 文件以及 <code>~/.pgpass</code> 文件中提供连接信息。</p>
<p>我们同样可以通过 <code>cron.job</code> 表查看 job 的信息，以及 <code>cron.job_run_details</code> 查看运行状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cron.job;</span><br><span class="line"> jobid <span class="operator">|</span>  schedule   <span class="operator">|</span>            command             <span class="operator">|</span> nodename  <span class="operator">|</span> nodeport <span class="operator">|</span> database <span class="operator">|</span> username <span class="operator">|</span> active <span class="operator">|</span>   jobname</span><br><span class="line"><span class="comment">-------+-------------+--------------------------------+-----------+----------+----------+----------+--------+-------------</span></span><br><span class="line">     <span class="number">4</span> <span class="operator">|</span> <span class="operator">*</span><span class="operator">/</span><span class="number">1</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">*</span> <span class="operator">|</span> <span class="keyword">SELECT</span> testdb_insert_log_job() <span class="operator">|</span> localhost <span class="operator">|</span>     <span class="number">5432</span> <span class="operator">|</span> testdb   <span class="operator">|</span> japin    <span class="operator">|</span> t      <span class="operator">|</span> testdb_job1</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cron.job_run_details \gx</span><br><span class="line">...</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">8</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">3</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">8</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1397538</span></span><br><span class="line">database       <span class="operator">|</span> testdb</span><br><span class="line">username       <span class="operator">|</span> japin</span><br><span class="line">command        <span class="operator">|</span> <span class="keyword">SELECT</span> testdb_insert_log_job()</span><br><span class="line">status         <span class="operator">|</span> succeeded</span><br><span class="line">return_message <span class="operator">|</span> <span class="number">1</span> <span class="type">row</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">00.028916</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">00.03695</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">9</span> ]<span class="comment">--+---------------------------------------------</span></span><br><span class="line">jobid          <span class="operator">|</span> <span class="number">3</span></span><br><span class="line">runid          <span class="operator">|</span> <span class="number">9</span></span><br><span class="line">job_pid        <span class="operator">|</span> <span class="number">1397689</span></span><br><span class="line">database       <span class="operator">|</span> testdb</span><br><span class="line">username       <span class="operator">|</span> japin</span><br><span class="line">command        <span class="operator">|</span> <span class="keyword">SELECT</span> testdb_insert_log_job()</span><br><span class="line">status         <span class="operator">|</span> succeeded</span><br><span class="line">return_message <span class="operator">|</span> <span class="number">1</span> <span class="type">row</span></span><br><span class="line">start_time     <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">42</span>:<span class="number">00.028686</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">end_time       <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">42</span>:<span class="number">00.033203</span><span class="operator">+</span><span class="number">08</span></span><br></pre></td></tr></table></figure>

<p>最后我们查看 <code>log</code> 表来验证 job 是否执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">testdb<span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> log;</span><br><span class="line">     info      <span class="operator">|</span>             <span class="keyword">at</span></span><br><span class="line"><span class="comment">---------------+----------------------------</span></span><br><span class="line"> hello, testdb <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">40</span>:<span class="number">00.022578</span></span><br><span class="line"> hello, testdb <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-18</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">00.029197</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>最后，还需要主要的是，pg_cron 的定时时间是基于 GMT 的，因此，您可能需要换算时区。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/citusdata/pg_cron">https://github.com/citusdata/pg_cron</a></p>
<div class="just-for-fun">
笑林广记 - 武弁夜巡

<p>一武弁夜巡。<br>有犯夜者，自称书生会课归迟。<br>武弁曰：“既是书生，且考你一考。”<br>生请题，武弁思之不得，喝曰：“造化了你，今夜幸而没有题目。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 大对象</title>
    <url>/2020/04/postgresql-large-object/</url>
    <content><![CDATA[<p>我们知道在 Oracle 数据库中，大对象有三种类型，分别是 CLOB，BLOB 和 BFILE。在 Oracle 数据库中大对象最大存储根据配置可以达到 8TB 到 128TB。然而在 PostgreSQL 数据库中并没有提供这三种数据类型。因此在进行迁移的时候，我们需要做类型的映射。在参考文献 [2] 中提到可以将 CLOB 和 BLOB 分别映射到 text 和 bytea 数据类型上。此外，PostgreSQL 的插件 pg_largeobject 也提供了一种大对象的支持。本文简要介绍这两种大对象的使用。</p>
<span id="more"></span>

<h2 id="text-amp-bytea"><a href="#text-amp-bytea" class="headerlink" title="text &amp; bytea"></a>text &amp; bytea</h2><p>CLOB 和 BLOB 分别用于存储字符大对象和二进制大对象，这与 PostgreSQL 中的 text 和 bytea 很类似，因此在迁移 Oracle 数据库的时候也就将他们分别对应起来。在 PostgreSQL 源码（c.h）中我们可以看到如下的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">varlena</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>        vl_len_[<span class="number">4</span>];     <span class="comment">/* Do not touch this field directly! */</span></span><br><span class="line">    <span class="keyword">char</span>        vl_dat[FLEXIBLE_ARRAY_MEMBER];  <span class="comment">/* Data content is here */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARHDRSZ        ((int32) sizeof(int32))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These widely-used datatypes are just a varlena header and the data bytes.</span></span><br><span class="line"><span class="comment"> * There is no terminating null or anything like that --- the data length is</span></span><br><span class="line"><span class="comment"> * always VARSIZE_ANY_EXHDR(ptr).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">varlena</span> <span class="title">bytea</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">varlena</span> <span class="title">text</span>;</span></span><br></pre></td></tr></table></figure>

<p>从上面的定义，我们可以发现，text 和 bytea 的定义都是 varlena 类型，即变长数据类型，所不同的是，text 用于存储可打印字符，而 bytea 用于存储二进制字符，这与 Oracle 的 CLOB 和 BLOB 是一致的。<br>varlena 类型在 PostgreSQL 的存储可能触发 <a href="https://www.postgresql.org/docs/12/storage-toast.html">TOAST 机制</a>，而采用 TOAST 机制存储的数据最大支持 1GB 的存储空间，因此这导致其存储空间和 Oracle 中的大对象不一致。</p>
<p>此外，Oracle 中的大对象支持随机读写，但是采用 text 和 bytea 类型的大对象对随机读写的支持不是很好，对于随机读可以使用如下的方式进行替代：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select name, substring(name from 1 for 2) from people ;</span><br><span class="line"> name | substring</span><br><span class="line">------+-----------</span><br><span class="line"> Jon  | Jo</span><br><span class="line"> Jane | Ja</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>然而，对于随机写貌似没有很好的替代方案。</p>
<h2 id="pg-largeobject"><a href="#pg-largeobject" class="headerlink" title="pg_largeobject"></a>pg_largeobject</h2><p>pg_largeobject 是 PostgreSQL 插件提供的一个大对象解决方案。在 pg_largeobject 中，所有的大对象都存储在系统表 <code>pg_largeobject</code> 中；此外，每个大对象在系统表 <code>pg_largeobject_metadata</code> 中也会有一条记录大对象的相关元信息，他们的定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# \d pg_largeobject</span><br><span class="line">         Table &quot;pg_catalog.pg_largeobject&quot;</span><br><span class="line"> Column |  Type   | Collation | Nullable | Default</span><br><span class="line">--------+---------+-----------+----------+---------</span><br><span class="line"> loid   | oid     |           | not null |</span><br><span class="line"> pageno | integer |           | not null |</span><br><span class="line"> data   | bytea   |           | not null |</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;pg_largeobject_loid_pn_index&quot; UNIQUE, btree (loid, pageno)</span><br><span class="line"></span><br><span class="line">postgres=# \d pg_largeobject_metadata</span><br><span class="line">      Table &quot;pg_catalog.pg_largeobject_metadata&quot;</span><br><span class="line">  Column  |   Type    | Collation | Nullable | Default</span><br><span class="line">----------+-----------+-----------+----------+---------</span><br><span class="line"> oid      | oid       |           | not null |</span><br><span class="line"> lomowner | oid       |           | not null |</span><br><span class="line"> lomacl   | aclitem[] |           |          |</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;pg_largeobject_metadata_oid_index&quot; UNIQUE, btree (oid)</span><br></pre></td></tr></table></figure>

<p>采用 pg_largeobject 所存储的大对象最大可以达到 4TB 的存储空间，并且__支持随机读写__。pg_largeobject 采用 OID 的方式来引用 <code>pg_largeobject</code> 表中的大对象。例如，我们创建一个表来存储图片数据，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE image(name text, raster oid);</span><br></pre></td></tr></table></figure>

<p>pg_largeobject 提供了一系列函数用于创建、导入和导出大对象，见官方文档<a href="https://www.postgresql.org/docs/12/lo-funcs.html">服务端函数</a>。下图是简单的大对象插入导出的测试输出：</p>
<img src="/2020/04/postgresql-large-object/lo-test.jpg" class="" title="Large Object Test">

<p>需要注意的是，在使用 pg_largeobject 来管理大对象时，我们需要额外的操作来管理大对象。例如，上面的示例中，如果我们想要删除表 <code>image</code> 中名称为 <code>image1</code> 的记录，我们还需在 <code>pg_largeobject</code> 中删除 <code>loid = 24598</code> 的记录。如下图所示：</p>
<img src="/2020/04/postgresql-large-object/lo-delete.jpg" class="" title="Large Object Deletion Test">

<p>通常，我们会创建一个触发器来进行 OID 的删除。此外，pg_largeobject 提供了 lo_put 和 lo_get 函数来随机读写大对象。需要注意的是，我们在使用 libpq 对大对象进行读写时必须在事务中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的说明，我们可以发现在 PostgreSQL 中的大对象处理各自存在优缺点：</p>
<table>
<thead>
<tr>
<th></th>
<th>text &amp; bytea</th>
<th>pg_largeobject</th>
</tr>
</thead>
<tbody><tr>
<td>随机读</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>随机写</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>存储限制</td>
<td>1GB</td>
<td>4TB</td>
</tr>
<tr>
<td>需要事务</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>跟踪 OID</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/cd/B28359_01/appdev.111/b28393/adlob_intro.htm#ADLOB001">https://docs.oracle.com/cd/B28359_01/appdev.111/b28393/adlob_intro.htm#ADLOB001</a><br>[2] <a href="https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion">https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion</a><br>[3] <a href="https://wiki.postgresql.org/wiki/Largeobject_Enhancement">https://wiki.postgresql.org/wiki/Largeobject_Enhancement</a><br>[4] <a href="https://www.postgresql.org/docs/12/largeobjects.html">https://www.postgresql.org/docs/12/largeobjects.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL LIMIT 与 FETCH FIRST ROWS ... WITH TIES</title>
    <url>/2021/07/postgresql-limit-vs-fetch-first-rows-with-ties/</url>
    <content><![CDATA[<p>在 SQL 和 PostgreSQL 社区中，大多数人都使用过许多数据库引擎提供的 <code>LIMIT</code> 子句。然而，很多人不知道的是，<code>LIMIT/OFFSET</code> 是不符合标准的，因此不能移植。处理 LIMIT 的正确方法基本上是使用 <code>SELECT ... FETCH FIRST ROWS</code>。然而，还有更多的东西没有被发现。</p>
<span id="more"></span>

<h2 id="LIMIT-vs-FETCH-FIRST-ROWS"><a href="#LIMIT-vs-FETCH-FIRST-ROWS" class="headerlink" title="LIMIT vs. FETCH FIRST ROWS"></a>LIMIT vs. FETCH FIRST ROWS</h2><p>在我们深入研究一些更高级的功能之前，我们需要看看如何使用 <code>LIMIT</code> 和 <code>FETCH FIRST ROWS</code>。为了演示这个功能，我编译了一个简单的数据集：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_test (id <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_test</span><br><span class="line"><span class="keyword">VALUES</span>  (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>), (<span class="number">3</span>),</span><br><span class="line">(<span class="number">4</span>), (<span class="number">4</span>), (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">7</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">TABLE</span> t_test;</span><br><span class="line"> id</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>我们的数据集有 7 条简单的行。让我们看看如果我们使用 <code>LIMIT</code> 会发生什么：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test LIMIT <span class="number">3</span>;</span><br><span class="line"> id</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，将返回前三条记录。请注意，我们在这里讨论的是任何行。只要能先找到的就会被返回。没有什么特别的顺序。</p>
<p>与 ANSI SQL 兼容的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span>  t_test</span><br><span class="line">           <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">3</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"> id</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>许多人可能以前从未使用过或见过这种语法，但这实际上是处理 <code>LIMIT</code> 的“正确”方法。</p>
<p>然而，还有一点。如果在 <code>LIMIT</code> 子句中使用 <code>NULL</code> 会怎样？其结果可能会让你吃惊：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test LIMIT <span class="keyword">NULL</span>;</span><br><span class="line"> id</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>数据库引擎不知道什么时候停止返回行。记住，<code>NULL</code> 是未定义的，所以它并不意味着零。因此，所有的行都会被返回。你必须牢记这一点，以避免不愉快的意外……</p>
<h2 id="FETCH-FIRST-…-ROWS-WITH-TIES"><a href="#FETCH-FIRST-…-ROWS-WITH-TIES" class="headerlink" title="FETCH FIRST … ROWS WITH TIES"></a>FETCH FIRST … ROWS WITH TIES</h2><p><code>WITH TIES</code> 功能是在 PostgreSQL 13 版本中引入的，它修复了一个常见的问题：处理重复的数据。如果你取了前几行，PostgreSQL 会在固定的行数上停止。然而，如果同样的数据一次又一次地出现，会发生什么？这里有一个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span>  t_test</span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">           <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">3</span> <span class="keyword">ROWS</span> <span class="keyword">WITH</span> TIES;</span><br><span class="line"> id</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们实际上得到了 4 行记录，而不仅仅是 3 行。原因是最后一个值在第 3 行之后又出现了，所以 PostgreSQL 觉得把它也包括进去。这里需要注意的是，<code>ORDER BY</code> 字句是需要的，如果没有，其结果是随机的。因此，如果你想要包括某一类的所有记录，而不是停留在一个固定的行数上，这时 <code>WITH TIES</code> 就很重要了。</p>
<p>假设再增加一行记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_test <span class="keyword">VALUES</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span>  t_test</span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">           <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">3</span> <span class="keyword">ROWS</span> <span class="keyword">WITH</span> TIES;</span><br><span class="line"> id</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们确实得到了 3 行记录，因为它不是关于值为 3 类型的数据，而是真正关于数据集末尾的额外的、相同的数据。</p>
<h2 id="WITH-TIES-管理附加列"><a href="#WITH-TIES-管理附加列" class="headerlink" title="WITH TIES - 管理附加列"></a>WITH TIES - 管理附加列</h2><p>到目前为止，我们已经了解了一些关于只使用一列的最简单情况。然而，这与真实情况相差甚远。在真正的工作应用中，你肯定会有不止一列。因此，让我们增加一个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_test</span><br><span class="line">           <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> x <span class="type">numeric</span> <span class="keyword">DEFAULT</span> random();</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">TABLE</span> t_test;</span><br><span class="line"> id <span class="operator">|</span>       x</span><br><span class="line"><span class="comment">----+--------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>  <span class="number">0.258814135879447</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>  <span class="number">0.561647200043165</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span>  <span class="number">0.340481941960185</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span>  <span class="number">0.999635345010109</span></span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span>  <span class="number">0.467043266494571</span></span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span>  <span class="number">0.742426363498449</span></span><br><span class="line">  <span class="number">5</span> <span class="operator">|</span> <span class="number">0.0611112678267247</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>  <span class="number">0.496917052156565</span></span><br><span class="line">(<span class="number">8</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在 <code>LIMIT</code> 的情况下，没有任何变化。然而，<code>WITH TIES</code> 在这里有点特殊：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">            <span class="keyword">FROM</span>  t_test</span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">            <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">4</span> <span class="keyword">ROWS</span> <span class="keyword">WITH</span> TIES;</span><br><span class="line"> id <span class="operator">|</span>       x</span><br><span class="line"><span class="comment">----+-------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> <span class="number">0.258814135879447</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> <span class="number">0.561647200043165</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> <span class="number">0.496917052156565</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> <span class="number">0.999635345010109</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> <span class="number">0.340481941960185</span></span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在这里你得到了 5 行记录。第 5 行被添加是因为 <code>id = 3</code> 出现了不止一次。注意 <code>ORDER BY</code> 子句：我们按 <code>id</code> 排序。因此，<code>id</code> 列与 <code>WITH TIES</code> 有关。</p>
<p>我们来看看当 <code>ORDER BY</code> 子句被扩展时会发生什么：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span>  t_test</span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> id, x</span><br><span class="line">           <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">4</span> <span class="keyword">ROWS</span> <span class="keyword">WITH</span> TIES;</span><br><span class="line"> id <span class="operator">|</span>       x</span><br><span class="line"><span class="comment">----+-------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> <span class="number">0.258814135879447</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> <span class="number">0.496917052156565</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> <span class="number">0.561647200043165</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> <span class="number">0.340481941960185</span></span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>我们按两列进行排序。因此，只有在两列都相同的情况下，<code>WITH TIES</code> 才会增加行数，而在我们的例子中，情况并非如此。</p>
<p><code>WITH TIES</code> 是 PostgreSQL 提供的一个奇妙的新功能。然而，它不仅仅是用来限制数据的。如果你是一个窗口函数的爱好者，你也可以利用 <code>WITH TIES</code>，就像我的<a href="https://www.cybertec-postgresql.com/en/timeseries-exclude-ties-current-row-and-group/">另一篇博文</a>中所展示的那样，它涵盖了 PostgreSQL 所提供的高级 SQL 功能。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><ul>
<li>本文翻译自 Hans-Jürgen Schönig 的 <a href="https://www.cybertec-postgresql.com/en/postgresql-limit-vs-fetch-first-rows-with-ties/">POSTGRESQL: LIMIT VS FETCH FIRST ROWS … WITH TIES</a>。</li>
<li><strong>Hans-Jürgen Schönig</strong> 从 90 年代起就有使用 PostgreSQL 的经验。他是 CYBERTEC 的首席执行官和技术负责人，该公司是该领域的市场领导者之一，自 2000 年以来为全球无数的客户提供服务。</li>
</ul>
<div class="just-for-fun">
笑林广记 - 比职

<p>甲乙两同年初中。甲选馆职，乙授县令。<br>甲一日乃骄语之曰：“吾位列清华，身依宸禁，与年兄做有司者，资格悬殊。他不具论，即选拜客用大字帖儿，身份体面，何啻天渊。”<br>乙曰：“你帖上能用几字，岂如我告示中的字，不更大许多？晓谕通告，百姓无不凛遵恪守，年兄却无用处。”<br>甲曰：“然则金瓜黄盖，显赫炫耀，兄可有否？”<br>乙曰：“弟牌棍清道，列满街衢，何止多兄数倍？”<br>甲曰：“太史图章，名标上苑，年兄能无羡慕乎？”<br>乙曰：“弟有朝廷印信，生杀之权，惟吾操纵，视年兄身居冷曹，图章私刻，谁来惧你？”<br>甲不觉词遁，乃曰：“总之翰林声价值千金。”<br>乙笑曰：“吾坐堂时百姓口称青天老爷，岂仅千金而已耶！”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL locale 设置更改</title>
    <url>/2022/01/postgresql-local-data-changes/</url>
    <content><![CDATA[<p>以下信息侧重于使用 GNU C 库 (glibc) 的操作系统，其中包括最流行的 Linux 发行版。所有版本的 PostgreSQL 都会受到影响。其他操作系统原则上可能存在相同的问题，但我们尚未收集任何相关信息。</p>
<p>PostgreSQL 使用操作系统的 C 库提供的语言环境数据对文本进行排序。排序发生在各种上下文中，包括用户输出、合并连接、B 树索引和范围分区。在后两种情况下，排序后的数据被持久化到磁盘。如果 C 库中的语言环境在数据库的生命周期中发生变化，则持久化的数据可能会与预期的排序顺序不一致，从而导致错误的查询结果和其他不正确的行为。例如，如果索引未按照索引扫描所期望的方式进行排序，则查询可能无法找到实际存在的数据，并且更新可能会插入不应允许的重复数据。同样，在分区表中，查询可能会在错误的分区中查找，而更新可能会写入错误的分区。<em>因此，对于数据库的正确操作，避免语言环境在数据库的生命周期内发生不兼容的变化是至关重要的。</em></p>
<p>操作系统供应商，尤其是 GNU C 库的作者，不时地以较小的方式更改语言环境以纠正错误或添加对更多语言的支持。虽然这在理论上违反了上述规则，但从历史上看，它影响的用户很少，也没有受到广泛关注。但是，<strong>在 2018-08-01 发布的 glibc 版本 2.28 中，包含了对语言环境数据的重大更新，这可能会影响许多用户的数据</strong>。需要注意的是，更新本身是合法的，因为它使语言环境符合当前的国际标准。但是，如果将这些更新应用于现有的 PostgreSQL 系统，则必然会出现问题。</p>
<p>操作系统供应商负责将 glibc 更新集成到 Linux 发行版中。我们希望长期支持 Linux 发行版的供应商不会在给定版本中对其发行版应用不兼容的语言环境更新，但这只是一种预期，因为我们无法预测或影响未来的行动。此外，PostgreSQL 目前无法检测到不兼容的 glibc 更新。因此，在规划任何更新或升级时需要一些手动操作。</p>
<span id="more"></span>

<h2 id="哪些将受到影响"><a href="#哪些将受到影响" class="headerlink" title="哪些将受到影响"></a>哪些将受到影响</h2><p>可能受到影响的情况涉及将更改的语言环境应用于现有实例或二进制等效实例，特别是：</p>
<ul>
<li>更改正在运行的实例上的语言环境（即使重新启动）。<ul>
<li>这尤其包括将 Linux 发行版升级到新的主要版本，同时保留 PostgreSQL 数据目录。</li>
<li>使用 pg_upgrade（例如同时升级操作系统和 PostgreSQL 专业时）并不能避免问题。</li>
</ul>
</li>
<li>使用流式复制到具有不同区域设置数据的备用实例。（然后备用数据库可能已损坏，但主数据库不受影响。）</li>
<li>在具有不同语言环境的系统上恢复二进制备份（例如 pg_basebackup）。</li>
<li>不受影响的是数据以逻辑（非二进制）方式传输的情况，包括：<ul>
<li>使用 pg_dump 备份/升级</li>
<li>逻辑复制</li>
</ul>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用操作系统 <code>sort</code> 实用程序是查看排序规则是否已更改的简单方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">( echo &quot;1-1&quot;; echo &quot;11&quot; ) | LC_COLLATE=en_US.UTF-8 sort</span><br></pre></td></tr></table></figure>

<p>这两个字符串将在不同的语言环境版本上进行不同的排序。比较新旧操作系统版本的输出。</p>
<p><strong>注意：</strong>如果这两个排序相同，则可能还有其他差异。</p>
<h2 id="该如何应对"><a href="#该如何应对" class="headerlink" title="该如何应对"></a>该如何应对</h2><p>当实例需要升级到新的 glibc 版本时，例如升级操作系统，则在升级后：</p>
<ul>
<li>所有涉及 <code>text</code>、<code>varchar</code>、<code>char</code> 和 <code>citext</code> 类型列的索引都应在实例投入生产之前重新建立索引。</li>
<li>应检查在分区键中使用这些类型的范围分区表，以验证所有行是否仍在正确的分区中。 （这不太可能成为问题，只有特别模糊的分区界限。）</li>
<li>为避免因重新索引或重新分区而导致停机，请考虑使用逻辑复制进行升级。</li>
<li>使用 C 或 POSIX 语言环境的数据库或表列不受影响。所有其他语言环境都可能受到影响。</li>
<li>使用 ICU 提供程序的排序规则的表列不受影响。</li>
</ul>
<h3 id="哪些索引受到了影响"><a href="#哪些索引受到了影响" class="headerlink" title="哪些索引受到了影响"></a>哪些索引受到了影响</h3><p>我们可以在每个数据库中使用下面 SQL 查询来找出受影响的索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    indrelid::regclass::text,</span><br><span class="line">    indexrelid::regclass::text,</span><br><span class="line">    collname,</span><br><span class="line">    pg_get_indexdef(indexrelid)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">         indexrelid,</span><br><span class="line">         indrelid,</span><br><span class="line">         indcollation[i] coll</span><br><span class="line">     <span class="keyword">FROM</span></span><br><span class="line">         pg_index,</span><br><span class="line">         generate_subscripts(indcollation, <span class="number">1</span>) g(i)</span><br><span class="line">    ) s <span class="keyword">JOIN</span> pg_collation c <span class="keyword">ON</span> coll <span class="operator">=</span> c.oid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    collprovider <span class="keyword">IN</span> (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="keyword">AND</span> collname <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;POSIX&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="哪些-Linux-发行版受到影响"><a href="#哪些-Linux-发行版受到影响" class="headerlink" title="哪些 Linux 发行版受到影响"></a>哪些 Linux 发行版受到影响</h2><p>为了帮助用户评估他们当前操作系统的情况，我们收集了以下信息。再次注意，这只是当前情况的报告，我们无法影响这些供应商在未来做什么或可能做什么。</p>
<h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><p>版本 8 (jessie) 和 9 (stretch) 使用旧的语言环境。我们预计这些版本中不会有任何不兼容的更改。从版本 8 升级到 9 是安全的。<br><em>版本 10 (buster) 使用新的语言环境</em>，因此，升级时需要谨慎。</p>
<p>参看：<a href="https://lists.debian.org/debian-glibc/2019/03/msg00030.html">https://lists.debian.org/debian-glibc/2019/03/msg00030.html</a></p>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>Ubuntu 最高版本 18.04（bionic）使用旧的语言环境。<br>新的 glibc 2.28 语言环境数据是在版本 18.10（cosmic）（不是 LTS）中引入的。从 bionic 或旧版本升级到 cosmic 或更新版本需要上述缓解步骤。</p>
<h3 id="RHEL-CentOS"><a href="#RHEL-CentOS" class="headerlink" title="RHEL/CentOS"></a>RHEL/CentOS</h3><p>版本 6 和 7 使用旧的语言环境。从版本 6 升级到 7 是安全的，<i>除非使用 <code>de_DE.UTF-8</code> 语言环境</i>，这在这些版本之间看到了类似的变化。（所有其他语言环境，包括其他 <code>de_*.UTF-8</code> 语言环境，如 <code>de_AT</code>，都是安全的。）<br><strong>版本 8 使用新的语言环境</strong>。因此，升级时需要谨慎。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://postgresql.verite.pro/blog/2018/08/27/glibc-upgrade.html">https://postgresql.verite.pro/blog/2018/08/27/glibc-upgrade.html</a><br>[2] Work is being done to track collation versions on the PostgreSQL side: <a href="https://wiki.postgresql.org/wiki/Collations">Collations</a></p>
<div class="just-for-fun">
笑林广记 - 封君

<p>有市井获封者，初见县官，甚跼蹐，坚辞上坐。<br>官曰：“叨为令郎同年，论理还该侍坐。”<br>封君乃张目问曰：“你也是属狗的么？”</p>
</div>
]]></content>
  </entry>
  <entry>
    <title>【译】PostgreSQL 锁 - Row Locks</title>
    <url>/2022/01/postgresql-locking-row-locks/</url>
    <content><![CDATA[<p>了解 PostgreSQL 锁对于构建可扩展的应用程序和避免停机很重要。现代计算机和服务器有许多 CPU 内核，可以并行执行多个查询。包含许多由查询或并行运行的后台进程进行更改的一致结构的数据库可能会使数据库崩溃甚至损坏数据。因此，我们需要能够防止来自并发进程的访问，同时更改共享内存结构或行。一个线程更新结构而所有其他线程等待（排他锁），或者多个线程读取结构并且所有写入等待。等待的副作用是锁争用和服务器资源浪费。因此，重要的是要了解为什么会发生等待以及涉及哪些锁。在本文中，我回顾了 PostgreSQL 行级锁（Row Level Locking）。</p>
<p>在后续文章中，我将研究保护内部数据库结构的<a href="https://www.percona.com/blog/2018/10/24/postgresql-locking-part-2-heavyweight-locks/">表级锁（Table Level Locks）</a>和 <a href="https://www.percona.com/blog/2018/10/30/postgresql-locking-part-3-lightweight-locks/">latches 锁</a>。</p>
<span id="more"></span>

<h2 id="行级锁-概述"><a href="#行级锁-概述" class="headerlink" title="行级锁 - 概述"></a>行级锁 - 概述</h2><p>PostgreSQL 有许多不同抽象级别的锁。应用程序最重要的锁与 <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a> 实现有关 — 行级锁。其次 — 在维护任务期间出现的锁（在备份/数据库迁移模式更改期间）— 表级锁。也有可能（但很少见）看到等待低级 PostgreSQL 锁。更常见的情况是 CPU 使用率很高，同时运行了许多并发查询，但与正常并行运行的查询数量相比，整体服务器性能降低了。</p>
<h3 id="示例环境"><a href="#示例环境" class="headerlink" title="示例环境"></a>示例环境</h3><p>接下来，您需要一个 PostgreSQL 服务器，其中包含一个拥有多行记录的单列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE TABLE locktest (c INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres=# INSERT INTO locktest VALUES (1), (2);</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>

<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>场景：两个并发事务试图选择一行进行更新。</p>
<p>在这种情况下，PostgreSQL 使用行级锁。行级锁与 MVCC 实现紧密集成，并使用隐藏的 <code>xmin</code> 和 <code>xmax</code> 字段。<code>xmin</code> 和 <code>xmax</code> 存储了事务 ID。所有需要行级锁的语句都会修改 <code>xmax</code> 字段（甚至是 <code>SELECT FOR UPDATE</code>）。修改发生在查询返回结果之后，因此为了查看 <code>xmax</code> 变化，我们需要运行 <code>SELECT FOR UPDATE</code> 两次。通常，<code>xmax</code> 字段用于将行标记为已过期（被某些事务完全删除或支持更新的行版本），但它也用于行级锁基础结构。</p>
<p>如果您需要有关 <code>xmin</code> 和 <code>xmax</code> 隐藏字段以及 MVCC 实现的更多详细信息，请查看我们的 “<a href="https://www.percona.com/blog/2018/08/06/basic-understanding-bloat-vacuum-postgresql-mvcc/">Basic Understanding of Bloat and VACUUM in PostgreSQL</a>” 博客文章。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# BEGIN;</span><br><span class="line">postgres=# SELECT xmin,xmax, txid_current(), c FROM locktest WHERE c=1 FOR UPDATE;</span><br><span class="line">BEGIN</span><br><span class="line"> xmin | xmax | txid_current | c</span><br><span class="line">------+------+--------------+---</span><br><span class="line">  579 |  581 |          583 | 1</span><br><span class="line">(1 row)</span><br><span class="line">postgres=# SELECT xmin,xmax, txid_current(), c FROM locktest WHERE c=1 FOR UPDATE;</span><br><span class="line"> xmin | xmax | txid_current | c</span><br><span class="line">------+------+--------------+---</span><br><span class="line">  579 |  583 |          583 | 1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>如果一条语句试图修改同一行，它会检查未完成事务的列表。该语句必须等待修改，直到 <code>id=xmax</code> 的事务完成。</p>
<p>没有等待特定行的基础设施，但事务可以等待事务 id。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- second connection</span><br><span class="line">SELECT xmin,xmax,txid_current() FROM locktest WHERE c=1 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>在第二个连接中运行的 <code>SELECT FOR UPDATE</code> 查询未完成，正在等待第一个事务完成。</p>
<h3 id="pg-locks"><a href="#pg-locks" class="headerlink" title="pg_locks"></a>pg_locks</h3><p>通过查询 pg_locks 可以看到这样的等待和锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT locktype,transactionid,virtualtransaction,pid,mode,granted,fastpath</span><br><span class="line">postgres-#  FROM pg_locks WHERE transactionid=583;</span><br><span class="line">   locktype    | transactionid | virtualtransaction |  pid  |     mode      | granted | fastpath</span><br><span class="line">---------------+---------------+--------------------+-------+---------------+---------+----------</span><br><span class="line"> transactionid |           583 | 4/107              | 31369 | ShareLock     | f       | f</span><br><span class="line"> transactionid |           583 | 3/11               | 21144 | ExclusiveLock | t       | f</span><br></pre></td></tr></table></figure>

<p>您可以看到 <code>locktype=transactionid == 583</code> 的写入者事务 id。让我们获取持有锁的 pid 和后端 id：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT id,pg_backend_pid() FROM pg_stat_get_backend_idset() AS t(id)</span><br><span class="line">postgres-#  WHERE pg_stat_get_backend_pid(id) = pg_backend_pid();</span><br><span class="line"> id | pg_backend_pid</span><br><span class="line">----+----------------</span><br><span class="line">  3 |          21144</span><br></pre></td></tr></table></figure>

<p>此后端已获取了锁 <code>granted(t)</code>。每个后端都有一个操作系统进程标识符（PID）和内部 PostgreSQL 标识符（后端 id）。 PostgreSQL 可以处理许多事务，但锁只能发生在后端之间，并且每个后端执行一个事务。内部簿记只需要一个虚拟事务标识符：一对后端 ID 和后端内部的序列号。</p>
<p>无论锁定的行数有多少，PostgreSQL 在 pg_locks 表中都只有一个相关的锁。查询可能会修改数十亿行，但 PostgreSQL 不会为冗余锁结构浪费内存。</p>
<p>写线程在它的 <code>transactionid</code> 上设置 <code>ExclusiveLock</code>。所有行级锁等待线程都设置了 <code>ShareLock</code>。一旦写线程释放锁，锁管理器就会恢复所有以前锁定的线程。</p>
<p><code>transactionid</code> 的锁释放发生在提交或回滚时。</p>
<h3 id="pg-stat-activity"><a href="#pg-stat-activity" class="headerlink" title="pg_stat_activity"></a>pg_stat_activity</h3><p>获取锁定相关详细信息的另一个好方法是从 pg_stat_activity 表中进行选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT pid,backend_xid,wait_event_type,wait_event,state,query FROM pg_stat_activity WHERE pid IN (31369,21144);</span><br><span class="line">-[ RECORD 1 ]---+---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">pid             | 21144</span><br><span class="line">backend_xid     | 583</span><br><span class="line">wait_event_type | Client</span><br><span class="line">wait_event      | ClientRead</span><br><span class="line">state           | idle in transaction</span><br><span class="line">query           | SELECT id,pg_backend_pid() FROM pg_stat_get_backend_idset() AS t(id) WHERE pg_stat_get_backend_pid(id) = pg_backend_pid();</span><br><span class="line">-[ RECORD 2 ]---+---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">pid             | 31369</span><br><span class="line">backend_xid     | 585</span><br><span class="line">wait_event_type | Lock</span><br><span class="line">wait_event      | transactionid</span><br><span class="line">state           | active</span><br><span class="line">query           | SELECT xmin,xmax,txid_current() FROM locktest WHERE c=1 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h3 id="源代码级调查"><a href="#源代码级调查" class="headerlink" title="源代码级调查"></a>源代码级调查</h3><p>让我们使用 gdb 和 <a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-pmp.html">pt-pmp</a> 工具检查被阻塞进程的堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pt-pmp -p 31369</span><br><span class="line">Sat Jul 28 10:10:25 UTC 2018</span><br><span class="line">30	../sysdeps/unix/sysv/linux/epoll_wait.c: No such file or directory.</span><br><span class="line">      1 epoll_wait,WaitEventSetWaitBlock,WaitEventSetWait,WaitLatchOrSocket,WaitLatch,ProcSleep,WaitOnLock,LockAcquireExtended,LockAcquire,XactLockTableWait,heap_lock_tuple,ExecLockRows,ExecProcNode,ExecutePlan,standard_ExecutorRun,PortalRunSelect,PortalRun,exec_simple_query,PostgresMain,BackendRun,BackendStartup,ServerLoop,PostmasterMain,main</span><br></pre></td></tr></table></figure>

<p><code>WaitOnLock</code> 函数导致等待。该函数位于 lock.c 文件（POSTGRES 主锁机制）中。</p>
<p>锁表是一个共享内存散列表。冲突进程在 <code>storage/lmgr/proc.c</code> 中的进行休眠以等待锁。在大多数情况下，此代码应通过 <code>lmgr.c</code> 或其他锁管理模块调用，而不是直接调用。</p>
<p>接下来，在 pg_stat_activity 中列为 <code>Lock</code> 的锁也称为重量级锁，由锁管理器控制。<code>HWLocks</code> 也用于许多高级操作。</p>
<p>顺便说一句，完整的描述可以在这里找到：<a href="https://www.postgresql.org/docs/current/static/explicit-locking.html">https://www.postgresql.org/docs/current/static/explicit-locking.html</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>避免长时间运行的事务修改频繁更新的行或过多的行。</li>
<li>接下来，不要在 MVCC 数据库中使用热点（由多个应用程序客户端连接并行更新的单行或多行）。这种工作负载更适合内存数据库，通常可以与主要业务逻辑分离。</li>
</ul>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>本文翻译自 <a href="https://www.percona.com/blog/author/nickolay-ihalainen/">Nickolay Ihalainen</a> 在 <a href="https://www.percona.com/blog/">Percona</a> 博客上发布的 <a href="https://www.percona.com/blog/2018/10/16/postgresql-locking-part-1-row-locks/">PostgreSQL locking, Part 1: Row Locks</a> 一文。</p>
<div class="just-for-fun">
笑林广记 - 老父

<p>一市井受封，初见县官，以其齿尊，称之曰：“老先。”<br>其人含怒而归，子问其故，曰：“官欺我太甚，彼该称我老先生才是，乃作歇后语叫甚么老先。明系轻薄，我回称也不曾失了便宜。”<br>子询问何以称呼，答曰：“我本应称他老父母官，今亦缩住后韵，只叫他声老父。”</p>
</div>


]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>Locks</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 15 特性 - MERGE INTO 语法</title>
    <url>/2022/03/postgresql-merge-into-syntax/</url>
    <content><![CDATA[<p><code>MERGE INTO</code> 语法很早之前就在 Oracle 数据库中实现了，最近 PostgreSQL 也实现了相应的语法，该语法符合 SQL2016 标准，与 Oracle 的 <code>MERGE INTO</code> 还是有一定区别的。本文简要介绍一下 PostgreSQL 中的 <code>MERGE INTO</code> 语法。</p>
<span id="more"></span>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>PostgreSQL 提供的 <a href="https://www.postgresql.org/docs/devel/sql-merge.html"><code>MERGER INTO</code> 语法</a>如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ WITH with_query [, ...] ]</span><br><span class="line">MERGE INTO target_table_name [ [ AS ] target_alias ]</span><br><span class="line">USING data_source ON join_condition</span><br><span class="line">when_clause [...]</span><br></pre></td></tr></table></figure>

<p><code>data_source</code> 可以是表、视图或子查询，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; source_table_name | ( source_query ) &#125; [ [ AS ] source_alias ]</span><br></pre></td></tr></table></figure>

<p><code>when_clause</code> 子句用于给出具体的执行动作。当匹配上时，可以执行 <code>UPDATE</code> 和 <code>DELETE</code> 操作；当未匹配上时，则可以执行 <code>INSERT</code> 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; WHEN MATCHED [ AND condition ] THEN &#123; merge_update | merge_delete | DO NOTHING &#125; |</span><br><span class="line">  WHEN NOT MATCHED [ AND condition ] THEN &#123; merge_insert | DO NOTHING &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><code>merge_insert</code>、<code>merge_update</code> 和 <code>merge_delete</code> 的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT [( column_name [, ...] )]</span><br><span class="line">[ OVERRIDING &#123; SYSTEM | USER &#125; VALUE ]</span><br><span class="line">&#123; VALUES ( &#123; expression | DEFAULT &#125; [, ...] ) | DEFAULT VALUES &#125;</span><br><span class="line"></span><br><span class="line">UPDATE SET &#123; column_name = &#123; expression | DEFAULT &#125; |</span><br><span class="line">             ( column_name [, ...] ) = ( &#123; expression | DEFAULT &#125; [, ...] ) &#125; [, ...]</span><br><span class="line"></span><br><span class="line">DELETE</span><br></pre></td></tr></table></figure>

<p>对比 Oracle 的 <a href="https://docs.oracle.com/database/121/SQLRF/statements_9017.htm"><code>MERGE INTO</code></a> 语法，还是可以发现它们存在很大的差异。</p>
<p>Oracle 中的 <code>merge_insert_clause</code>、<code>merge_delete_clause</code> 和 <code>merge_update_clause</code> 中是可以携带 <code>WHERE</code> 子句的，然而在 PostgreSQL 中则是将其放置在 <code>when_clause</code> 子句中了。</p>
<p>PostgreSQL 中的 <code>MERGE INTO</code> 执行步骤如下所示：</p>
<ol>
<li>无论 <code>WHEN</code> 子句匹配与否，为所有的操作执行 <code>BEFORE STATEMENT</code> 触发器。</li>
<li>执行从源表到目标表的连接。生成的查询将正常优化并生成一组候选的更改行。对于每个候选更改行，执行下面的步骤：<br>a. 评估每一行是 <code>MATCHED</code> 还是 <code>NOT MATCHED</code>。<br>b. 按指定的顺序测试每个 <code>WHEN</code> 条件，直到返回 <code>true</code>。<br>c. 当条件返回 true 时，执行以下操作：<ul>
<li>执行操作的事件类型触发的 <code>BEFORE ROW</code> 触发器。</li>
<li>执行指定的操作，对目标表调用任何检查约束。</li>
<li>执行操作的事件类型触发的 <code>AFTER ROW</code> 触发器。</li>
</ul>
</li>
<li>为指定的操作执行 <code>AFTER STATEMENT</code> 触发器，无论它们是否实际发生。这类似于不修改任何行的 <code>UPDATE</code> 语句的行为。</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先，我们创建 <code>target</code> 和 <code>source</code> 表，并向 <code>target</code> 表中插入三条记录，向 <code>source</code> 表插入一条记录，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> target (tid <span class="type">integer</span>, balance <span class="type">integer</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source (sid <span class="type">integer</span>, delta <span class="type">integer</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> target <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> target <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> target <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> source <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>我们先来测试一下 <code>MATCHED ... UPDATE</code> 功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> target t</span><br><span class="line"><span class="keyword">USING</span> source <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> t.tid <span class="operator">=</span> s.sid</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line">        UPDATE <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE 0</span><br></pre></td></tr></table></figure>

<p>可以看到没有任何记录发生变化，符合预期。</p>
<p>接下来，我们测试一下 <code>NOT MATCHED ... INSERT</code> 功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> target t</span><br><span class="line"><span class="keyword">USING</span> source <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> t.tid <span class="operator">=</span> s.sid</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">45</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE 1</span><br></pre></td></tr></table></figure>

<p>查看 <code>target</code> 表，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> target;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> tid | balance</span><br><span class="line">-----+---------</span><br><span class="line">   1 |      10</span><br><span class="line">   2 |      20</span><br><span class="line">   3 |      30</span><br><span class="line">   4 |      45</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>这说明 <code>tid = 4</code> 的记录未匹配上，并正确插入到了 <code>target</code> 表中。</p>
<p>最后，我们来综合测试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO source VALUES (5, 50), (2, 20);</span><br><span class="line">MERGE INTO target t</span><br><span class="line">USING source AS s</span><br><span class="line">ON t.tid = s.sid</span><br><span class="line">WHEN MATCHED AND s.sid &lt; 3 THEN</span><br><span class="line">    UPDATE SET balance = t.balance * 10</span><br><span class="line">WHEN MATCHED THEN</span><br><span class="line">    DELETE</span><br><span class="line">WHEN NOT MATCHED THEN</span><br><span class="line">    INSERT VALUES (s.sid, s.delta);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE 3</span><br></pre></td></tr></table></figure>

<p>可以看到有三条记录发生了变化。我们期望的是当匹配的时候，如果 <code>s.sid &lt; 3</code> 时，那么就将 <code>target</code> 表中的 <code>balance</code> 扩大 10 倍，否则就删除它；当未匹配的时候就插入 <code>source</code> 表中的记录到 <code>target</code> 表中。</p>
<p><code>source</code> 表的内容如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> sid | delta</span><br><span class="line">-----+-------</span><br><span class="line">   4 |    40</span><br><span class="line">   5 |    50</span><br><span class="line">   2 |    20</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>因此，执行上述的 <code>MERGE INTO</code> 语句之后，<code>target</code> 表中 <code>tid = 4</code> 的记录应该被删除，<code>tid = 2</code> 的记录 <code>balance</code> 扩大 10 倍，而未匹配的 <code>5, 50</code> 则会插入到 <code>target</code> 表中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> target;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> tid | balance</span><br><span class="line">-----+---------</span><br><span class="line">   1 |      10</span><br><span class="line">   3 |      30</span><br><span class="line">   2 |     200</span><br><span class="line">   5 |      50</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>结果与预期一致。</p>
<p>需要注意的是，PostgreSQL 中的 <code>MERGE INTO</code> 语法没有提供特殊的权限管理，它依赖于底层 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作的权限控制。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/devel/sql-merge.html">https://www.postgresql.org/docs/devel/sql-merge.html</a><br>[2] <a href="https://docs.oracle.com/database/121/SQLRF/statements_9017.htm">https://docs.oracle.com/database/121/SQLRF/statements_9017.htm</a></p>
<div class="just-for-fun">
笑林广记 - 斋戒库

<p>一监生姓齐，家资甚富，但不识字。<br>一日府尊出票，取鸡二只，兔一只。<br>皂亦不识字，央齐监生看。<br>生曰：“讨鸡二只，免一只。”<br>皂只买一鸡回话。太守怒曰：“票上取鸡二只，兔一只，为何只缴一鸡？”<br>皂以监生事禀。太守遂拘监生来问，时太守适有公干，暂将监生收入斋戒库内候究。<br>生入库，见碑上斋戒二字，认做他父亲齐成姓名，张目惊诧呜咽不止。<br>人问何故，答曰：“先人灵座，何人设建在此，睹物伤情，焉得不哭。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>PG15</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 添加系统表</title>
    <url>/2019/08/postgresql-new-catalog/</url>
    <content><![CDATA[<p>本文将介绍如何在 PostgreSQL 中创建一个新的系统表。PostgreSQL 将系统表都存放在 <code>src/include/catalog</code> 目录下，如下图所示：</p>
<img src="/2019/08/postgresql-new-catalog/catalogs.png" class="" title="PostgresQL 系统表目录">

<p>从目录结构来看，我们大概可以猜测到 PostgreSQL 将系统表的定义和数据分别存放在两个不同的文件中，例如，系统表 <code>pg_class</code>，其表结构定义在 <code>pg_class.h</code> 文件中，而数据则在 <code>pg_class.dat</code> 文件中。此外每个表都在数据库内部都有一个唯一的 OID 来作为标识。PostgreSQL 提供了脚本来检查未使用的 OID 以及是否包含重复的 OID，它们分别为 <code>unused_oids</code> 和 <code>duplicate_oids</code>。所有的系统表都将由 <code>src/backend/catalog/Catalog.pm</code> 进行处理，该文件负责将系统表文件转换为 Perl 数据结构。</p>
<span id="more"></span>
<p>在了解了 PostgreSQL 关于系统表的基本概念之后，我们尝试添加一个自己的系统表 <code>pg_play</code>。</p>
<h2 id="系统表头文件"><a href="#系统表头文件" class="headerlink" title="系统表头文件"></a>系统表头文件</h2><p>正如我们上面看到的，我们需要在 <code>src/include/catalog</code> 目录下新建一个 <code>pg_play.h</code> 的头文件，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * pg_play.h</span></span><br><span class="line"><span class="comment"> *    definition of the &quot;play&quot; system catalog (pg_play)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * src/include/catalog/pg_play.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTES</span></span><br><span class="line"><span class="comment"> *    The Catalog.pm module reads this file and derives schema</span></span><br><span class="line"><span class="comment"> *    information.</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PG_PLAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_PLAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;catalog/genbki.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;catalog/pg_class_d.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------</span></span><br><span class="line"><span class="comment"> *		pg_play definition.  cpp turns this into</span></span><br><span class="line"><span class="comment"> *		typedef struct FormData_pg_play</span></span><br><span class="line"><span class="comment"> * ----------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CATALOG(pg_play,<span class="number">2023</span>,PlayRelationId)</span><br><span class="line">&#123;</span><br><span class="line">	Oid         playid;</span><br><span class="line">	NameData    playname;</span><br><span class="line">&#125; FormData_pg_play;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> FormData_pg_play *Form_pg_play;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PG_PLAY_H */</span></span></span><br></pre></td></tr></table></figure>

<p>每个系统表头文件都应该包含 <code>catalog/genbki.h</code> 头文件，该文件中定义了 <code>CATALOG</code>, <code>BKI_BOOTSTRAP</code> 等相关的宏。其中 <code>CATALOG</code> 宏的作用就是定义一个结构体变量，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CppConcat(x, y)                   x##y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CATALOG(name,oid,oidmacro)  typedef struct CppConcat(FormData_,name)</span></span><br></pre></td></tr></table></figure>

<p>而 <code>catalog/pg_class_d.h</code> 文件则是编译时由 <code>src/backend/catalog/genbki.pl</code> 生成的一个头文件，该文件中包含了系统表属性列的编号定义。例如，<code>pg_play</code> 系统表生成的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pg_play_d.h</span></span><br><span class="line"><span class="comment"> *    Macro definitions for pg_play</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group</span></span><br><span class="line"><span class="comment"> * Portions Copyright (c) 1994, Regents of the University of California</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTES</span></span><br><span class="line"><span class="comment"> *  ******************************</span></span><br><span class="line"><span class="comment"> *  *** DO NOT EDIT THIS FILE! ***</span></span><br><span class="line"><span class="comment"> *  ******************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  It has been GENERATED by src/backend/catalog/genbki.pl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PG_PLAY_D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_PLAY_D_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PlayRelationId 2023</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Anum_pg_play_playid 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Anum_pg_play_playname 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Natts_pg_play 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>							<span class="comment">/* PG_PLAY_D_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="系统表编译配置"><a href="#系统表编译配置" class="headerlink" title="系统表编译配置"></a>系统表编译配置</h2><p>如上所述，我们添加了系统表定义，现在我们要做的就是将其添加到编译环境中，从而使得 PostgreSQL 在编译时可以去处理我们定义的 <code>pg_play</code> 系统表。在 <code>src/backend/catalog/Makefile</code> 文件中有一个 <code>CATALOG_HEADERS</code> 目标，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CATALOG_HEADERS := \</span><br><span class="line">         pg_proc.h pg_type.h pg_attribute.h pg_class.h \</span><br><span class="line">         pg_attrdef.h pg_constraint.h pg_inherits.h pg_index.h pg_operator.h \</span><br><span class="line">         pg_opfamily.h pg_opclass.h pg_am.h pg_amop.h pg_amproc.h \</span><br><span class="line">         pg_language.h pg_largeobject_metadata.h pg_largeobject.h pg_aggregate.h \</span><br><span class="line">         pg_statistic_ext.h \</span><br><span class="line">         pg_statistic.h pg_rewrite.h pg_trigger.h pg_event_trigger.h pg_description.h \</span><br><span class="line">         pg_cast.h pg_enum.h pg_namespace.h pg_conversion.h pg_depend.h \</span><br><span class="line">         pg_database.h pg_db_role_setting.h pg_tablespace.h pg_pltemplate.h \</span><br><span class="line">         pg_authid.h pg_auth_members.h pg_shdepend.h pg_shdescription.h \</span><br><span class="line">         pg_ts_config.h pg_ts_config_map.h pg_ts_dict.h \</span><br><span class="line">         pg_ts_parser.h pg_ts_template.h pg_extension.h \</span><br><span class="line">         pg_foreign_data_wrapper.h pg_foreign_server.h pg_user_mapping.h \</span><br><span class="line">         pg_foreign_table.h pg_policy.h pg_replication_origin.h \</span><br><span class="line">         pg_default_acl.h pg_init_privs.h pg_seclabel.h pg_shseclabel.h \</span><br><span class="line">         pg_collation.h pg_partitioned_table.h pg_range.h pg_transform.h \</span><br><span class="line">         pg_sequence.h pg_publication.h pg_publication_rel.h pg_subscription.h \</span><br><span class="line">         pg_subscription_rel.h pg_play.h</span><br></pre></td></tr></table></figure>

<p>我们在末尾我们新建的 <code>pg_play</code> 系统表头文件。现在，我们在重新编译、安装并初始化数据库即可看到我们新建的 <code>pg_play</code> 系统表。如下图所示：</p>
<img src="/2019/08/postgresql-new-catalog/pg_play_catalog.png" class="" title="pg_play 系统表">

<h2 id="默认元组添加"><a href="#默认元组添加" class="headerlink" title="默认元组添加"></a>默认元组添加</h2><p>如果我们需要想 <code>pg_play</code> 系统表中添加一些默认元组，我们可以创建一个 <code>pg_play.dat</code> 的文件，其内容如下：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># pg_play.dat</span></span><br><span class="line"><span class="comment">#    Initial contents of the pg_play system catalog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># src/include/catalog/pg_play.dat</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">playid =&gt;</span> <span class="string">&#x27;2&#x27;</span>, <span class="string">playname =&gt;</span> <span class="string">&#x27;Play&#x27;</span> &#125;,</span><br><span class="line">&#123; <span class="string">playid =&gt;</span> <span class="string">&#x27;3&#x27;</span>, <span class="string">playname =&gt;</span> <span class="string">&#x27;with&#x27;</span> &#125;,</span><br><span class="line">&#123; <span class="string">playid =&gt;</span> <span class="string">&#x27;4&#x27;</span>, <span class="string">playname =&gt;</span> <span class="string">&#x27;PostgreSQL&#x27;</span> &#125;,</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后需要在 <code>src/backend/catalog/Makefile</code> 文件的 <code>POSTGRES_BKI_DATA</code> 目标中添加 <code>pg_play.dat</code>。最后重新编译、安装并初始化数据库即可。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol>
<li>该方法适合于 PostgreSQL 11 以及后续版本，PostgreSQL 10 及之前的版本可能存在略微差异，但大致相同。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 14 - multirange 类型</title>
    <url>/2021/10/postgresql-multirange-types/</url>
    <content><![CDATA[<p>在最近发布的 PostgreSQL 14 中，我们最兴奋的功能之一是引入了 multirange 类型。简而言之，multirange 类型是一组不重叠的范围（range）。与范围数组不同，它们防止重叠，因此允许你有效地建立有间隙的范围模型。</p>
<p>我们对它们的一个用例是建立时间模型。例如，如果您想记录累积的时间和某人在医院的天数，您可以将其存储为一个 datemultirange 类型。</p>
<p>在 PostgreSQL 14 中，有相当多的运算符和函数可用，但我们需要的一些明显的运算符和函数包括聚合，如联合聚合，目前还不存在。然而，还有一些标准的运算符，如 <code>+</code>（合并两个范围）和 <code>*</code> 表示两个范围相交，<code>-</code> 表示两个范围的差，以及常见的包含布尔运算符。</p>
<span id="more"></span>

<h2 id="定义-multirange-变量"><a href="#定义-multirange-变量" class="headerlink" title="定义 multirange 变量"></a>定义 multirange 变量</h2><p>multirange 类型的典型形式是由一个外层的 <code>&#123;&#125;</code> 和一个以逗号分隔的范围列表组成的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&#123;[2021-05-01, 2021-06-01), [2020-09-01, 2020-10-01)</span></span><br><span class="line"><span class="string">        , [2021-09-01, 2021-09-13)&#125;&#x27;</span>::datemultirange;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;[2020-09-01,2020-10-01),[2021-05-01,2021-06-01),[2021-09-01,2021-09-13)&#125;</span><br></pre></td></tr></table></figure>

<p>观察它是如何将排序改为按时间顺序排列的。</p>
<p>multirange 不能有重叠的范围，但是您可以把一个重叠的范围集写到一个 multirange 中而不会得到错误。让我们看看这里会发生了什么：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&#123;[2021-05-01, 2021-06-01), [2021-09-02, 2021-09-15)</span></span><br><span class="line"><span class="string">        , [2021-09-01, 2021-09-13)&#125;&#x27;</span>::datemultirange;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;[2021-05-01,2021-06-01),[2021-09-01,2021-09-15)&#125;</span><br></pre></td></tr></table></figure>

<p>观察一下它是如何将最后两个日期范围合并成一个包含它们的联合体。</p>
<h2 id="使用-multirange"><a href="#使用-multirange" class="headerlink" title="使用 multirange"></a>使用 multirange</h2><p>假设您有一个普通的表，它只是记录了病人的住院时间（作为一个日期范围），每次住院有一条记录。我们并不关心住院时间是否重叠，因为它们可能代表某天去做某项手术，同一天又去做另一项手术，等等。如果是在同一天，在我们的一些计算中，这两套记录将被视为一天，但您仍然需要保留原因信息，以便计费。</p>
<p>您的表格将看起来像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stays(id <span class="type">bigint</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    id_patient <span class="type">bigint</span>,</span><br><span class="line">    period_stay daterange, reason text,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_stays <span class="keyword">PRIMARY</span> KEY (id) );</span><br></pre></td></tr></table></figure>

<p>您将在其中插入如下数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stays(id_patient, period_stay, reason)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, daterange(<span class="string">&#x27;2021-05-10&#x27;</span>, <span class="string">&#x27;2021-06-01&#x27;</span>), <span class="string">&#x27;Operation and healing&#x27;</span> ),</span><br><span class="line">       (<span class="number">2</span>, daterange(<span class="string">&#x27;2021-05-12&#x27;</span>, <span class="string">&#x27;2021-05-13&#x27;</span>), <span class="string">&#x27;X-Ray&#x27;</span> ),</span><br><span class="line">       (<span class="number">2</span>, daterange(<span class="string">&#x27;2021-05-13&#x27;</span>, <span class="string">&#x27;2021-05-14&#x27;</span>), <span class="string">&#x27;Blood&#x27;</span> ),</span><br><span class="line">       (<span class="number">2</span>, daterange(<span class="string">&#x27;2021-05-13&#x27;</span>, <span class="string">&#x27;2021-05-14&#x27;</span>), <span class="string">&#x27;MRI&#x27;</span> ),</span><br><span class="line">       (<span class="number">2</span>, daterange(<span class="string">&#x27;2021-06-13&#x27;</span>, <span class="string">&#x27;2021-06-14&#x27;</span>), <span class="string">&#x27;Spinal Tap&#x27;</span> );</span><br></pre></td></tr></table></figure>

<p>如果您想创建一个查询，将这些记录汇总到每个病人的单一记录中，并且将住院时间表示为一个多区间，那么很遗憾，我们找不到任何聚合函数来为您做这个。您必须创建你自己的聚合函数，使用一些非常难看的 CTE，或者将您的范围聚合到一个范围数组中，然后以某种方式将其铸造成一个多范围。铸造部分将为您处理重叠问题。</p>
<p>这个例子演示了如何使用 <code>array_agg</code> 将范围聚合到一个数组中，然后使用规范的文本形式将其转换为 datemultirange。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id_patient,</span><br><span class="line">       replace(<span class="built_in">array_agg</span>(period_stay)::text, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)::datemultirange <span class="keyword">AS</span> period_total_stay</span><br><span class="line"><span class="keyword">FROM</span> stays</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id_patient</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id_patient;</span><br></pre></td></tr></table></figure>

<p>上述查询的输出看起来像是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> id_patient <span class="operator">|</span>                 period_total_stay</span><br><span class="line"><span class="comment">------------+---------------------------------------------------</span></span><br><span class="line">          <span class="number">1</span> <span class="operator">|</span> &#123;[<span class="number">2021</span><span class="number">-05</span><span class="number">-10</span>,<span class="number">2021</span><span class="number">-06</span><span class="number">-01</span>)&#125;</span><br><span class="line">          <span class="number">2</span> <span class="operator">|</span> &#123;[<span class="number">2021</span><span class="number">-05</span><span class="number">-12</span>,<span class="number">2021</span><span class="number">-05</span><span class="number">-14</span>),[<span class="number">2021</span><span class="number">-06</span><span class="number">-13</span>,<span class="number">2021</span><span class="number">-06</span><span class="number">-14</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法并不理想，因为它依赖于一个日期范围数组的典型形式，看起来就像下面这样，除了将日期范围用双引号括起来之外，与预期的 datemultirange 完全一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;[2021-05-12,2021-05-13)&quot;,</span><br><span class="line">&quot;[2021-05-13,2021-05-14)&quot;,</span><br><span class="line">&quot;[2021-05-13,2021-05-14)&quot;,&quot;[2021-06-13,2021-06-14)&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>因此，本质上与 datemultirange 的规范形式相同，但每个 daterange 周围有双引号。</p>
<p>我们最喜欢的y一个函数是 <strong><code>unnest</code><strong>，</strong><code>unnest</code></strong> 函数支持 multirange 并返回一组范围。使用 <strong><code>array_agg</code><strong>、</strong><code>multirange</code></strong> 和 <strong><code>unnest</code></strong> 的组合，您可以从一组重叠的范围中创建一组不重叠的范围，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id_patient,</span><br><span class="line">    <span class="built_in">unnest</span>(replace(<span class="built_in">array_agg</span>(period_stay)::text, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)::datemultirange) <span class="keyword">AS</span> period_deduped_stay</span><br><span class="line"><span class="keyword">FROM</span> stays</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id_patient</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id_patient;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> id_patient |   period_deduped_stay</span><br><span class="line">------------+-------------------------</span><br><span class="line">          1 | [2021-05-10,2021-06-01)</span><br><span class="line">          2 | [2021-05-12,2021-05-14)</span><br><span class="line">          2 | [2021-06-13,2021-06-14)</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><ul>
<li>本文翻译自 <a href="https://www.postgresonline.com/">Postgres Online Journal</a> 上的 <a href="https://www.postgresonline.com/article_pfriendly/401.html">Multirange types in PostgreSQL 14</a>。</li>
</ul>
<div class="just-for-fun">
笑林广记 - 属牛

<p>一官遇生辰，吏典闻其属鼠，乃醵黄金铸一鼠为寿。<br>官甚喜，曰：“汝等可知奶奶生辰亦在目下乎？”<br>众吏曰：“不知，请问其属？”<br>官曰：“小我一岁，丑年生的。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 优化 setitimer 系统调用</title>
    <url>/2020/08/postgresql-optimize-setitimer-system-calls/</url>
    <content><![CDATA[<p>当我们在使用 PostgreSQL 数据库并启用 <code>statement_timeout</code> 时，可以看到 <code>setitimer()</code> 函数的调用次数明显偏多。本文分析了 <a href="https://www.postgresql.org/message-id/CA%2BhUKG%2Bo6pbuHBJSGnud%3DTadsuXySWA7CCcPgCt2QE9F6_4iHQ%40mail.gmail.com">Thomas Munro 给出的关于 <code>setitimer()</code> 函数的优化</a>。</p>
<span id="more"></span>

<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>为了方便分析，我们首先需要有一个基本的基准测试。我们使用下面的命令初始化数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ initdb -D pgdata</span><br><span class="line">$ pg_ctl -l log -D pgdata start</span><br><span class="line">$ createdb testdb</span><br><span class="line">$ pgbench -i -s 10 testdb</span><br></pre></td></tr></table></figure>

<p>接着修改配置 <code>statement_timeout</code>，将其设置为 <code>10s</code>，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql postgres -c &quot;ALTER SYSTEM SET statement_timeout TO &#x27;10s&#x27;&quot;</span><br><span class="line">$ pg_ctl -l log -D pgdata start</span><br></pre></td></tr></table></figure>

<p>接着我们使用 <code>pgbench -T60 -Mprepared -S testdb</code> 来进行测试，我们在另一个终端中通过 <code>strace</code> 来分析系统调用，可以得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ strace -c -p 31561</span><br><span class="line">strace: Process 31561 attached</span><br><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 41.11    0.334739           1    424545           sendto</span><br><span class="line"> 26.54    0.216100           1    424449           recvfrom</span><br><span class="line"> 24.33    0.198094           0    424448           setitimer</span><br><span class="line">  8.02    0.065268           1     71339           pread64</span><br><span class="line">  0.00    0.000000           0         1           epoll_ctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.814201               1344782           total</span><br></pre></td></tr></table></figure>

<p>从结果可以看到，整个测试过程中 <code>setitimer()</code> 系统调用调用了 424448 次。</p>
<h2 id="补丁测试"><a href="#补丁测试" class="headerlink" title="补丁测试"></a>补丁测试</h2><p>接下来，我们将 patch 应用到 PostgreSQL 中，重新编译，并进行测试，其结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ strace -c -p 1375</span><br><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 54.16    0.351467           1    520065           sendto</span><br><span class="line"> 35.17    0.228279           0    519963           recvfrom</span><br><span class="line"> 10.67    0.069251           1     88036           pread64</span><br><span class="line">  0.00    0.000001           0         6           rt_sigreturn</span><br><span class="line">  0.00    0.000000           0         5           setitimer</span><br><span class="line">  0.00    0.000000           0         1           epoll_ctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.648998               1128076           total</span><br></pre></td></tr></table></figure>

<p>从结果可以看到，此时的 <code>setitimer()</code> 系统调用仅调用了 5 次，远比之前的次数低。从最终的统计结果来看，应用了补丁程序的 PostgreSQL 整个测试过程中的系统调用比原有的系统调用降低了约 16%。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个补丁程序的思路其实非常简单，实现起来也不复杂，整个 diff 文件不足 100 行。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/utils/misc/timeout.c b/src/backend/utils/misc/timeout.c</span></span><br><span class="line"><span class="comment">index f1c9518b0c..b5027815db 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/timeout.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/timeout.c</span></span><br><span class="line"><span class="meta">@@ -51,6 +51,13 @@</span> static bool all_timeouts_initialized = false;</span><br><span class="line"> static volatile int num_active_timeouts = 0;</span><br><span class="line"> static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];</span><br><span class="line"></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * State used to avoid installing a new timer interrupt when the previous one</span></span><br><span class="line"><span class="addition">+ * hasn&#x27;t fired yet, but isn&#x27;t too late.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+static TimestampTz sigalrm_due_at = PG_INT64_MAX;</span></span><br><span class="line"><span class="addition">+static volatile sig_atomic_t sigalrm_delivered = false;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /*</span><br><span class="line">  * Flag controlling whether the signal handler is allowed to do anything.</span><br><span class="line">  * We leave this &quot;false&quot; when we&#x27;re not expecting interrupts, just in case.</span><br><span class="line"><span class="meta">@@ -195,12 +202,13 @@</span> schedule_alarm(TimestampTz now)</span><br><span class="line"> 		struct itimerval timeval;</span><br><span class="line"> 		long		secs;</span><br><span class="line"> 		int			usecs;</span><br><span class="line"><span class="addition">+		TimestampTz	nearest_timeout;</span></span><br><span class="line"></span><br><span class="line"> 		MemSet(&amp;timeval, 0, sizeof(struct itimerval));</span><br><span class="line"></span><br><span class="line"> 		/* Get the time remaining till the nearest pending timeout */</span><br><span class="line"><span class="deletion">-		TimestampDifference(now, active_timeouts[0]-&gt;fin_time,</span></span><br><span class="line"><span class="deletion">-							&amp;secs, &amp;usecs);</span></span><br><span class="line"><span class="addition">+		nearest_timeout = active_timeouts[0]-&gt;fin_time;</span></span><br><span class="line"><span class="addition">+		TimestampDifference(now, nearest_timeout, &amp;secs, &amp;usecs);</span></span><br><span class="line"></span><br><span class="line"> 		/*</span><br><span class="line"> 		 * It&#x27;s possible that the difference is less than a microsecond;</span><br><span class="line"><span class="meta">@@ -244,9 +252,18 @@</span> schedule_alarm(TimestampTz now)</span><br><span class="line"> 		 */</span><br><span class="line"> 		enable_alarm();</span><br><span class="line"></span><br><span class="line"><span class="addition">+		/*</span></span><br><span class="line"><span class="addition">+		 * Try to avoid having to set the interval timer, if we already know</span></span><br><span class="line"><span class="addition">+		 * that there is an undelivered signal due at the same time or sooner.</span></span><br><span class="line"><span class="addition">+		 */</span></span><br><span class="line"><span class="addition">+		if (nearest_timeout &gt;= sigalrm_due_at &amp;&amp; !sigalrm_delivered)</span></span><br><span class="line"><span class="addition">+			return;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 		/* Set the alarm timer */</span><br><span class="line"> 		if (setitimer(ITIMER_REAL, &amp;timeval, NULL) != 0)</span><br><span class="line"> 			elog(FATAL, &quot;could not enable SIGALRM timer: %m&quot;);</span><br><span class="line"><span class="addition">+		sigalrm_due_at = nearest_timeout;</span></span><br><span class="line"><span class="addition">+		sigalrm_delivered = false;</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -266,6 +283,8 @@</span> handle_sig_alarm(SIGNAL_ARGS)</span><br><span class="line"> &#123;</span><br><span class="line"> 	int			save_errno = errno;</span><br><span class="line"></span><br><span class="line"><span class="addition">+	sigalrm_delivered = true;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Bump the holdoff counter, to make sure nothing we call will process</span><br><span class="line"> 	 * interrupts directly. No timeout handler should do that, but these</span><br><span class="line"><span class="meta">@@ -591,8 +610,9 @@</span> disable_timeouts(const DisableTimeoutParams *timeouts, int count)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"><span class="deletion">- * Disable SIGALRM and remove all timeouts from the active list,</span></span><br><span class="line"><span class="deletion">- * and optionally reset their timeout indicators.</span></span><br><span class="line"><span class="addition">+ * Remove all timeouts from the active list, and optionally reset their timeout</span></span><br><span class="line"><span class="addition">+ * indicators.  Leave any existing itimer installed, because it may allow us to</span></span><br><span class="line"><span class="addition">+ * avoid having to set it again soon.</span></span><br><span class="line">  */</span><br><span class="line"> void</span><br><span class="line"> disable_all_timeouts(bool keep_indicators)</span><br><span class="line"><span class="meta">@@ -601,20 +621,6 @@</span> disable_all_timeouts(bool keep_indicators)</span><br><span class="line"></span><br><span class="line"> 	disable_alarm();</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	/*</span></span><br><span class="line"><span class="deletion">-	 * Only bother to reset the timer if we think it&#x27;s active.  We could just</span></span><br><span class="line"><span class="deletion">-	 * let the interrupt happen anyway, but it&#x27;s probably a bit cheaper to do</span></span><br><span class="line"><span class="deletion">-	 * setitimer() than to let the useless interrupt happen.</span></span><br><span class="line"><span class="deletion">-	 */</span></span><br><span class="line"><span class="deletion">-	if (num_active_timeouts &gt; 0)</span></span><br><span class="line"><span class="deletion">-	&#123;</span></span><br><span class="line"><span class="deletion">-		struct itimerval timeval;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-		MemSet(&amp;timeval, 0, sizeof(struct itimerval));</span></span><br><span class="line"><span class="deletion">-		if (setitimer(ITIMER_REAL, &amp;timeval, NULL) != 0)</span></span><br><span class="line"><span class="deletion">-			elog(FATAL, &quot;could not disable SIGALRM timer: %m&quot;);</span></span><br><span class="line"><span class="deletion">-	&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"> 	num_active_timeouts = 0;</span><br><span class="line"></span><br><span class="line"> 	for (i = 0; i &lt; MAX_TIMEOUTS; i++)</span><br></pre></td></tr></table></figure>

<p>其基本思想是通过 alarm 来取代频繁地调用 <code>setitimer()</code> 函数，而不是针对每个 timeout 都去调用 <code>setitimer()</code> 函数，这真的是将性能挖掘到了极限啊！</p>
<p>变量 <code>sigalrm_due_at</code> 记录了最近一个定时器的到期时间，<code>sigalrm_delivered</code> 则记录是否已经触发了 sigalrm 信号。当最近的定时器的超时时间大于或等于 <code>sigalrm_due_at</code> 并且不存在没有交付的定时器时，它将不会对其调用 <code>setitimer()</code> 来设置定时器。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li><strong>2020-11-21</strong> - 最近该功能在被 Review 的时候发现一个问题，由于我们仅设置了最近的一个 timeout，那么当 <code>handle_sig_alarm()</code> 被中断时，可能出现后续的 timeout 无法正常工作，因此我们需要在故障恢复的时候重新调用 <code>setitimer()</code> 函数设置 timeout，<a href="https://www.postgresql.org/message-id/2B9BB40C-DDEA-4CDB-B37E-C2738E739416%40hotmail.com">详细实现</a>。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL palloc0 函数优化</title>
    <url>/2020/10/postgresql-palloc0/</url>
    <content><![CDATA[<p>最近在查看 PostgreSQL 数据库中内存分配相关的代码时，我发现 <code>palloc()</code> 和 <code>palloc0()</code> 函数存在大量的冗余代码。本着减少冗余代码的想法，我将修改后的代码提交到社区，得到的反馈是这样修改会影响整体效率。本文简要分析一下这是如何影响效率的。</p>
<span id="more"></span>

<h2 id="PATCH-文件"><a href="#PATCH-文件" class="headerlink" title="PATCH 文件"></a>PATCH 文件</h2><p>我提交的 PATCH 文件如下所示，其实非常简单，本质上就是将 <code>palloc0()</code> 函数中的部分代码改由 <code>palloc()</code> 函数来实现。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/utils/mmgr/mcxt.c b/src/backend/utils/mmgr/mcxt.c</span></span><br><span class="line"><span class="comment">index dda70ef9f3..cb07958a1f 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/mmgr/mcxt.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/mmgr/mcxt.c</span></span><br><span class="line"><span class="meta">@@ -982,28 +982,8 @@</span> palloc0(Size size)</span><br><span class="line"> &#123;</span><br><span class="line"> 	/* duplicates MemoryContextAllocZero to avoid increased overhead */</span><br><span class="line"> 	void	   *ret;</span><br><span class="line"><span class="deletion">-	MemoryContext context = CurrentMemoryContext;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	AssertArg(MemoryContextIsValid(context));</span></span><br><span class="line"><span class="deletion">-	AssertNotInCriticalSection(context);</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (!AllocSizeIsValid(size))</span></span><br><span class="line"><span class="deletion">-		elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	context-&gt;isReset = false;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	ret = context-&gt;methods-&gt;alloc(context, size);</span></span><br><span class="line"><span class="deletion">-	if (unlikely(ret == NULL))</span></span><br><span class="line"><span class="deletion">-	&#123;</span></span><br><span class="line"><span class="deletion">-		MemoryContextStats(TopMemoryContext);</span></span><br><span class="line"><span class="deletion">-		ereport(ERROR,</span></span><br><span class="line"><span class="deletion">-				(errcode(ERRCODE_OUT_OF_MEMORY),</span></span><br><span class="line"><span class="deletion">-				 errmsg(&quot;out of memory&quot;),</span></span><br><span class="line"><span class="deletion">-				 errdetail(&quot;Failed on request of size %zu in memory context \&quot;%s\&quot;.&quot;,</span></span><br><span class="line"><span class="deletion">-						   size, context-&gt;name)));</span></span><br><span class="line"><span class="deletion">-	&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-	VALGRIND_MEMPOOL_ALLOC(context, ret, size);</span></span><br><span class="line"><span class="addition">+	ret = palloc(size);</span></span><br><span class="line"></span><br><span class="line"> 	MemSetAligned(ret, 0, size);</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在 Alvaro Herrera 的指导下，我通过分析原始代码和修改后代码的汇编代码进行分析。原版 PostgreSQL 数据库 <code>palloc()</code> 和 <code>palloc0()</code> 的汇编代码如下（使用命令 <code>objdump -S --disassemble postgres</code> 查看）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000005175b0 &lt;palloc&gt;:</span><br><span class="line">  5175b0:	55                   	push   %rbp</span><br><span class="line">  5175b1:	53                   	push   %rbx</span><br><span class="line">  5175b2:	48 89 fd             	mov    %rdi,%rbp</span><br><span class="line">  5175b5:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  5175b9:	48 81 ff ff ff ff 3f 	cmp    $0x3fffffff,%rdi</span><br><span class="line">  5175c0:	48 8b 1d b9 0d 48 00 	mov    0x480db9(%rip),%rbx        # 998380 &lt;CurrentMemoryContext&gt;</span><br><span class="line">  5175c7:	0f 87 85 00 00 00    	ja     517652 &lt;palloc+0xa2&gt;</span><br><span class="line">  5175cd:	48 8b 43 10          	mov    0x10(%rbx),%rax</span><br><span class="line">  5175d1:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  5175d4:	c6 43 04 00          	movb   $0x0,0x4(%rbx)</span><br><span class="line">  5175d8:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">  5175db:	ff 10                	callq  *(%rax)</span><br><span class="line">  5175dd:	48 85 c0             	test   %rax,%rax</span><br><span class="line">  5175e0:	74 0e                	je     5175f0 &lt;palloc+0x40&gt;</span><br><span class="line">  5175e2:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  5175e6:	5b                   	pop    %rbx</span><br><span class="line">  5175e7:	5d                   	pop    %rbp</span><br><span class="line">  5175e8:	c3                   	retq</span><br><span class="line">  5175e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line">  5175f0:	48 8b 3d 81 0d 48 00 	mov    0x480d81(%rip),%rdi        # 998378 &lt;TopMemoryContext&gt;</span><br><span class="line">  5175f7:	be 64 00 00 00       	mov    $0x64,%esi</span><br><span class="line">  5175fc:	e8 4f fa ff ff       	callq  517050 &lt;MemoryContextStatsDetail&gt;</span><br><span class="line">  517601:	31 f6                	xor    %esi,%esi</span><br><span class="line">  517603:	bf 14 00 00 00       	mov    $0x14,%edi</span><br><span class="line">  517608:	e8 83 6e fd ff       	callq  4ee490 &lt;errstart&gt;</span><br><span class="line">  51760d:	bf c5 20 00 00       	mov    $0x20c5,%edi</span><br><span class="line">  517612:	e8 c9 9c fd ff       	callq  4f12e0 &lt;errcode&gt;</span><br><span class="line">  517617:	48 8d 3d 37 55 03 00 	lea    0x35537(%rip),%rdi        # 54cb55 &lt;__func__.7554+0x45&gt;</span><br><span class="line">  51761e:	31 c0                	xor    %eax,%eax</span><br><span class="line">  517620:	e8 db 9e fd ff       	callq  4f1500 &lt;errmsg&gt;</span><br><span class="line">  517625:	48 8b 53 38          	mov    0x38(%rbx),%rdx</span><br><span class="line">  517629:	48 8d 3d b0 12 16 00 	lea    0x1612b0(%rip),%rdi        # 6788e0 &lt;__func__.6248+0x150&gt;</span><br><span class="line">  517630:	48 89 ee             	mov    %rbp,%rsi</span><br><span class="line">  517633:	31 c0                	xor    %eax,%eax</span><br><span class="line">  517635:	e8 86 a3 fd ff       	callq  4f19c0 &lt;errdetail&gt;</span><br><span class="line">  51763a:	48 8d 15 37 13 16 00 	lea    0x161337(%rip),%rdx        # 678978 &lt;__func__.7318&gt;</span><br><span class="line">  517641:	48 8d 3d 50 12 16 00 	lea    0x161250(%rip),%rdi        # 678898 &lt;__func__.6248+0x108&gt;</span><br><span class="line">  517648:	be cc 03 00 00       	mov    $0x3cc,%esi</span><br><span class="line">  51764d:	e8 3e 96 fd ff       	callq  4f0c90 &lt;errfinish&gt;</span><br><span class="line">  517652:	31 f6                	xor    %esi,%esi</span><br><span class="line">  517654:	bf 14 00 00 00       	mov    $0x14,%edi</span><br><span class="line">  517659:	e8 32 6e fd ff       	callq  4ee490 &lt;errstart&gt;</span><br><span class="line">  51765e:	48 8d 3d 0b 12 16 00 	lea    0x16120b(%rip),%rdi        # 678870 &lt;__func__.6248+0xe0&gt;</span><br><span class="line">  517665:	48 89 ee             	mov    %rbp,%rsi</span><br><span class="line">  517668:	31 c0                	xor    %eax,%eax</span><br><span class="line">  51766a:	e8 c1 99 fd ff       	callq  4f1030 &lt;errmsg_internal&gt;</span><br><span class="line">  51766f:	48 8d 15 02 13 16 00 	lea    0x161302(%rip),%rdx        # 678978 &lt;__func__.7318&gt;</span><br><span class="line">  517676:	48 8d 3d 1b 12 16 00 	lea    0x16121b(%rip),%rdi        # 678898 &lt;__func__.6248+0x108&gt;</span><br><span class="line">  51767d:	be c0 03 00 00       	mov    $0x3c0,%esi</span><br><span class="line">  517682:	e8 09 96 fd ff       	callq  4f0c90 &lt;errfinish&gt;</span><br><span class="line">  517687:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)</span><br><span class="line">  51768e:	00 00</span><br><span class="line"></span><br><span class="line">0000000000517690 &lt;palloc0&gt;:</span><br><span class="line">  517690: 55                    push   %rbp</span><br><span class="line">  517691: 53                    push   %rbx</span><br><span class="line">  517692: 48 89 fb              mov    %rdi,%rbx</span><br><span class="line">  517695: 48 83 ec 08           sub    $0x8,%rsp</span><br><span class="line">  517699: 48 81 ff ff ff ff 3f  cmp    $0x3fffffff,%rdi</span><br><span class="line">  5176a0: 48 8b 2d d9 0c 48 00  mov    0x480cd9(%rip),%rbp        # 998380 &lt;CurrentMemoryContext&gt;</span><br><span class="line">  5176a7: 0f 87 d5 00 00 00     ja     517782 &lt;palloc0+0xf2&gt;</span><br><span class="line">  5176ad: 48 8b 45 10           mov    0x10(%rbp),%rax</span><br><span class="line">  5176b1: 48 89 fe              mov    %rdi,%rsi</span><br><span class="line">  5176b4: c6 45 04 00           movb   $0x0,0x4(%rbp)</span><br><span class="line">  5176b8: 48 89 ef              mov    %rbp,%rdi</span><br><span class="line">  5176bb: ff 10                 callq  *(%rax)</span><br><span class="line">  5176bd: 48 85 c0              test   %rax,%rax</span><br><span class="line">  5176c0: 48 89 c1              mov    %rax,%rcx</span><br><span class="line">  5176c3: 74 5b                 je     517720 &lt;palloc0+0x90&gt;</span><br><span class="line">  5176c5: f6 c3 07              test   $0x7,%bl</span><br><span class="line">  5176c8: 75 36                 jne    517700 &lt;palloc0+0x70&gt;</span><br><span class="line">  5176ca: 48 81 fb 00 04 00 00  cmp    $0x400,%rbx</span><br><span class="line">  5176d1: 77 2d                 ja     517700 &lt;palloc0+0x70&gt;</span><br><span class="line">  5176d3: 48 01 c3              add    %rax,%rbx</span><br><span class="line">  5176d6: 48 39 d8              cmp    %rbx,%rax</span><br><span class="line">  5176d9: 73 35                 jae    517710 &lt;palloc0+0x80&gt;</span><br><span class="line">  5176db: 0f 1f 44 00 00        nopl   0x0(%rax,%rax,1)</span><br><span class="line">  5176e0: 48 83 c0 08           add    $0x8,%rax</span><br><span class="line">  5176e4: 48 c7 40 f8 00 00 00  movq   $0x0,-0x8(%rax)</span><br><span class="line">  5176eb: 00</span><br><span class="line">  5176ec: 48 39 c3              cmp    %rax,%rbx</span><br><span class="line">  5176ef: 77 ef                 ja     5176e0 &lt;palloc0+0x50&gt;</span><br><span class="line">  5176f1: 48 83 c4 08           add    $0x8,%rsp</span><br><span class="line">  5176f5: 48 89 c8              mov    %rcx,%rax</span><br><span class="line">  5176f8: 5b                    pop    %rbx</span><br><span class="line">  5176f9: 5d                    pop    %rbp</span><br><span class="line">  5176fa: c3                    retq</span><br><span class="line">  5176fb: 0f 1f 44 00 00        nopl   0x0(%rax,%rax,1)</span><br><span class="line">  517700: 48 89 cf              mov    %rcx,%rdi</span><br><span class="line">  517703: 48 89 da              mov    %rbx,%rdx</span><br><span class="line">  517706: 31 f6                 xor    %esi,%esi</span><br><span class="line">  517708: e8 e3 0e ba ff        callq  b85f0 &lt;memset@plt&gt;</span><br><span class="line">  51770d: 48 89 c1              mov    %rax,%rcx</span><br><span class="line">  517710: 48 83 c4 08           add    $0x8,%rsp</span><br><span class="line">  517714: 48 89 c8              mov    %rcx,%rax</span><br><span class="line">  517717: 5b                    pop    %rbx</span><br><span class="line">  517718: 5d                    pop    %rbp</span><br><span class="line">  517719: c3                    retq</span><br><span class="line">  51771a: 66 0f 1f 44 00 00     nopw   0x0(%rax,%rax,1)</span><br><span class="line">  517720: 48 8b 3d 51 0c 48 00  mov    0x480c51(%rip),%rdi        # 998378 &lt;TopMemoryContext&gt;</span><br><span class="line">  517727: be 64 00 00 00        mov    $0x64,%esi</span><br><span class="line">  51772c: e8 1f f9 ff ff        callq  517050 &lt;MemoryContextStatsDetail&gt;</span><br><span class="line">  517731: 31 f6                 xor    %esi,%esi</span><br><span class="line">  517733: bf 14 00 00 00        mov    $0x14,%edi</span><br><span class="line">  517738: e8 53 6d fd ff        callq  4ee490 &lt;errstart&gt;</span><br><span class="line">  51773d: bf c5 20 00 00        mov    $0x20c5,%edi</span><br><span class="line">  517742: e8 99 9b fd ff        callq  4f12e0 &lt;errcode&gt;</span><br><span class="line">  517747: 48 8d 3d 07 54 03 00  lea    0x35407(%rip),%rdi        # 54cb55 &lt;__func__.7554+0x45&gt;</span><br><span class="line">  51774e: 31 c0                 xor    %eax,%eax</span><br><span class="line">  517750: e8 ab 9d fd ff        callq  4f1500 &lt;errmsg&gt;</span><br><span class="line">  517755: 48 8b 55 38           mov    0x38(%rbp),%rdx</span><br><span class="line">  517759: 48 8d 3d 80 11 16 00  lea    0x161180(%rip),%rdi        # 6788e0 &lt;__func__.6248+0x150&gt;</span><br><span class="line">  517760: 48 89 de              mov    %rbx,%rsi</span><br><span class="line">  517763: 31 c0                 xor    %eax,%eax</span><br><span class="line">  517765: e8 56 a2 fd ff        callq  4f19c0 &lt;errdetail&gt;</span><br><span class="line">  51776a: 48 8d 15 ff 11 16 00  lea    0x1611ff(%rip),%rdx        # 678970 &lt;__func__.7326&gt;</span><br><span class="line">  517771: 48 8d 3d 20 11 16 00  lea    0x161120(%rip),%rdi        # 678898 &lt;__func__.6248+0x108&gt;</span><br><span class="line">  517778: be eb 03 00 00        mov    $0x3eb,%esi</span><br><span class="line">  51777d: e8 0e 95 fd ff        callq  4f0c90 &lt;errfinish&gt;</span><br><span class="line">  517782: 31 f6                 xor    %esi,%esi</span><br><span class="line">  517784: bf 14 00 00 00        mov    $0x14,%edi</span><br><span class="line">  517789: e8 02 6d fd ff        callq  4ee490 &lt;errstart&gt;</span><br><span class="line">  51778e: 48 8d 3d db 10 16 00  lea    0x1610db(%rip),%rdi        # 678870 &lt;__func__.6248+0xe0&gt;</span><br><span class="line">  517795: 48 89 de              mov    %rbx,%rsi</span><br><span class="line">  517798: 31 c0                 xor    %eax,%eax</span><br><span class="line">  51779a: e8 91 98 fd ff        callq  4f1030 &lt;errmsg_internal&gt;</span><br><span class="line">  51779f: 48 8d 15 ca 11 16 00  lea    0x1611ca(%rip),%rdx        # 678970 &lt;__func__.7326&gt;</span><br><span class="line">  5177a6: 48 8d 3d eb 10 16 00  lea    0x1610eb(%rip),%rdi        # 678898 &lt;__func__.6248+0x108&gt;</span><br><span class="line">  5177ad: be df 03 00 00        mov    $0x3df,%esi</span><br><span class="line">  5177b2: e8 d9 94 fd ff        callq  4f0c90 &lt;errfinish&gt;</span><br><span class="line">  5177b7: 66 0f 1f 84 00 00 00  nopw   0x0(%rax,%rax,1)</span><br><span class="line">  5177be: 00 00</span><br></pre></td></tr></table></figure>

<p>修改之后的汇编代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000005175b0 &lt;palloc&gt;:</span><br><span class="line">  5175b0: 55                    push   %rbp</span><br><span class="line">  5175b1: 53                    push   %rbx</span><br><span class="line">  5175b2: 48 89 fd              mov    %rdi,%rbp</span><br><span class="line">  5175b5: 48 83 ec 08           sub    $0x8,%rsp</span><br><span class="line">  5175b9: 48 81 ff ff ff ff 3f  cmp    $0x3fffffff,%rdi</span><br><span class="line">  5175c0: 48 8b 1d b9 0d 48 00  mov    0x480db9(%rip),%rbx        # 998380 &lt;CurrentMemoryContext&gt;</span><br><span class="line">  5175c7: 0f 87 85 00 00 00     ja     517652 &lt;palloc+0xa2&gt;</span><br><span class="line">  5175cd: 48 8b 43 10           mov    0x10(%rbx),%rax</span><br><span class="line">  5175d1: 48 89 fe              mov    %rdi,%rsi</span><br><span class="line">  5175d4: c6 43 04 00           movb   $0x0,0x4(%rbx)</span><br><span class="line">  5175d8: 48 89 df              mov    %rbx,%rdi</span><br><span class="line">  5175db: ff 10                 callq  *(%rax)</span><br><span class="line">  5175dd: 48 85 c0              test   %rax,%rax</span><br><span class="line">  5175e0: 74 0e                 je     5175f0 &lt;palloc+0x40&gt;</span><br><span class="line">  5175e2: 48 83 c4 08           add    $0x8,%rsp</span><br><span class="line">  5175e6: 5b                    pop    %rbx</span><br><span class="line">  5175e7: 5d                    pop    %rbp</span><br><span class="line">  5175e8: c3                    retq</span><br><span class="line">  5175e9: 0f 1f 80 00 00 00 00  nopl   0x0(%rax)</span><br><span class="line">  5175f0: 48 8b 3d 81 0d 48 00  mov    0x480d81(%rip),%rdi        # 998378 &lt;TopMemoryContext&gt;</span><br><span class="line">  5175f7: be 64 00 00 00        mov    $0x64,%esi</span><br><span class="line">  5175fc: e8 4f fa ff ff        callq  517050 &lt;MemoryContextStatsDetail&gt;</span><br><span class="line">  517601: 31 f6                 xor    %esi,%esi</span><br><span class="line">  517603: bf 14 00 00 00        mov    $0x14,%edi</span><br><span class="line">  517608: e8 83 6e fd ff        callq  4ee490 &lt;errstart&gt;</span><br><span class="line">  51760d: bf c5 20 00 00        mov    $0x20c5,%edi</span><br><span class="line">  517612: e8 c9 9c fd ff        callq  4f12e0 &lt;errcode&gt;</span><br><span class="line">  517617: 48 8d 3d 77 54 03 00  lea    0x35477(%rip),%rdi        # 54ca95 &lt;__func__.7554+0x45&gt;</span><br><span class="line">  51761e: 31 c0                 xor    %eax,%eax</span><br><span class="line">  517620: e8 db 9e fd ff        callq  4f1500 &lt;errmsg&gt;</span><br><span class="line">  517625: 48 8b 53 38           mov    0x38(%rbx),%rdx</span><br><span class="line">  517629: 48 8d 3d f0 11 16 00  lea    0x1611f0(%rip),%rdi        # 678820 &lt;__func__.6248+0x150&gt;</span><br><span class="line">  517630: 48 89 ee              mov    %rbp,%rsi</span><br><span class="line">  517633: 31 c0                 xor    %eax,%eax</span><br><span class="line">  517635: e8 86 a3 fd ff        callq  4f19c0 &lt;errdetail&gt;</span><br><span class="line">  51763a: 48 8d 15 6f 12 16 00  lea    0x16126f(%rip),%rdx        # 6788b0 &lt;__func__.7318&gt;</span><br><span class="line">  517641: 48 8d 3d 90 11 16 00  lea    0x161190(%rip),%rdi        # 6787d8 &lt;__func__.6248+0x108&gt;</span><br><span class="line">  517648: be cc 03 00 00        mov    $0x3cc,%esi</span><br><span class="line">  51764d: e8 3e 96 fd ff        callq  4f0c90 &lt;errfinish&gt;</span><br><span class="line">  517652: 31 f6                 xor    %esi,%esi</span><br><span class="line">  517654: bf 14 00 00 00        mov    $0x14,%edi</span><br><span class="line">  517659: e8 32 6e fd ff        callq  4ee490 &lt;errstart&gt;</span><br><span class="line">  51765e: 48 8d 3d 4b 11 16 00  lea    0x16114b(%rip),%rdi        # 6787b0 &lt;__func__.6248+0xe0&gt;</span><br><span class="line">  517665: 48 89 ee              mov    %rbp,%rsi</span><br><span class="line">  517668: 31 c0                 xor    %eax,%eax</span><br><span class="line">  51766a: e8 c1 99 fd ff        callq  4f1030 &lt;errmsg_internal&gt;</span><br><span class="line">  51766f: 48 8d 15 3a 12 16 00  lea    0x16123a(%rip),%rdx        # 6788b0 &lt;__func__.7318&gt;</span><br><span class="line">  517676: 48 8d 3d 5b 11 16 00  lea    0x16115b(%rip),%rdi        # 6787d8 &lt;__func__.6248+0x108&gt;</span><br><span class="line">  51767d: be c0 03 00 00        mov    $0x3c0,%esi</span><br><span class="line">  517682: e8 09 96 fd ff        callq  4f0c90 &lt;errfinish&gt;</span><br><span class="line">  517687: 66 0f 1f 84 00 00 00  nopw   0x0(%rax,%rax,1)</span><br><span class="line">  51768e: 00 00</span><br><span class="line"></span><br><span class="line">0000000000517690 &lt;palloc0&gt;:</span><br><span class="line">  517690: 53                    push   %rbx</span><br><span class="line">  517691: 48 89 fb              mov    %rdi,%rbx</span><br><span class="line">  517694: e8 17 ff ff ff        callq  5175b0 &lt;palloc&gt;</span><br><span class="line">  517699: f6 c3 07              test   $0x7,%bl</span><br><span class="line">  51769c: 48 89 c1              mov    %rax,%rcx</span><br><span class="line">  51769f: 75 2f                 jne    5176d0 &lt;palloc0+0x40&gt;</span><br><span class="line">  5176a1: 48 81 fb 00 04 00 00  cmp    $0x400,%rbx</span><br><span class="line">  5176a8: 77 26                 ja     5176d0 &lt;palloc0+0x40&gt;</span><br><span class="line">  5176aa: 48 01 c3              add    %rax,%rbx</span><br><span class="line">  5176ad: 48 39 d8              cmp    %rbx,%rax</span><br><span class="line">  5176b0: 73 2e                 jae    5176e0 &lt;palloc0+0x50&gt;</span><br><span class="line">  5176b2: 66 0f 1f 44 00 00     nopw   0x0(%rax,%rax,1)</span><br><span class="line">  5176b8: 48 83 c0 08           add    $0x8,%rax</span><br><span class="line">  5176bc: 48 c7 40 f8 00 00 00  movq   $0x0,-0x8(%rax)</span><br><span class="line">  5176c3: 00</span><br><span class="line">  5176c4: 48 39 c3              cmp    %rax,%rbx</span><br><span class="line">  5176c7: 77 ef                 ja     5176b8 &lt;palloc0+0x28&gt;</span><br><span class="line">  5176c9: 48 89 c8              mov    %rcx,%rax</span><br><span class="line">  5176cc: 5b                    pop    %rbx</span><br><span class="line">  5176cd: c3                    retq</span><br><span class="line">  5176ce: 66 90                 xchg   %ax,%ax</span><br><span class="line">  5176d0: 48 89 cf              mov    %rcx,%rdi</span><br><span class="line">  5176d3: 48 89 da              mov    %rbx,%rdx</span><br><span class="line">  5176d6: 31 f6                 xor    %esi,%esi</span><br><span class="line">  5176d8: e8 13 0f ba ff        callq  b85f0 &lt;memset@plt&gt;</span><br><span class="line">  5176dd: 48 89 c1              mov    %rax,%rcx</span><br><span class="line">  5176e0: 48 89 c8              mov    %rcx,%rax</span><br><span class="line">  5176e3: 5b                    pop    %rbx</span><br><span class="line">  5176e4: c3                    retq</span><br><span class="line">  5176e5: 90                    nop</span><br><span class="line">  5176e6: 66 2e 0f 1f 84 00 00  nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  5176ed: 00 00 00</span><br></pre></td></tr></table></figure>

<p>从上面的汇编代码可以看到修改后的 <code>palloc0()</code> 额外引入了更多的汇编指令，从而导致其运行效率有所降低，由于该函数属于底层函数，很多地方都会调用该函数。因此对整体数据库的性能影响较大。当然，这只是从汇编指令级别得到的理论结果，我们还可以通过实际测试来进行对比。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[1] <a href="https://www.postgresql.org/message-id/flat/3A57E434-BB2C-420C-86C8-0A81AE23F679%40hotmail.com">https://www.postgresql.org/message-id/flat/3A57E434-BB2C-420C-86C8-0A81AE23F679%40hotmail.com</a></p>
<div class="just-for-fun">
笑林广记 - 小恭五两

<p>讹诈得财，蜀人谓之敲钉锤。<br>一广文善敲钉锤，见一生员在泮池旁出小恭，上前扭住吓之曰：“尔身列学门，擅在泮池解手，无礼已极。”<br>饬门斗：“押至明伦堂重惩，为大不敬者戒。”<br>生员央之曰：“生员一时错误，情愿认罚。”<br>广文云：“好在是出小恭，若是出大恭，定罚银十两。小恭五两可也。”<br>生员曰：“我这身边带银一块，重十两，愿分一半奉送。”<br>广文云：“何必分，全给了我就是了。”<br>生员说：“老师讲明，小恭五两，因何又要十两？”<br>广文曰：“不妨，你尽管全给了我，以后准你泮池旁再出大恭一次，让你五两。千万不可与外人说，恐坏了我的学规。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 修改用户或数据库参数</title>
    <url>/2022/08/postgresql-parameters-for-database-and-role/</url>
    <content><![CDATA[<p>PostgreSQL 支持不同级别的参数配置，最简单的是全局配置，此外还有针对用户级别和数据库级别的配置，本文就来看看 PostgreSQL 中用户级别和数据库级别的配置的实现。</p>
<p>我们可以实现下面的 SQL 命令来修改用户级别的配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125; [ <span class="keyword">IN</span> DATABASE database_name ] <span class="keyword">SET</span> configuration_parameter &#123; <span class="keyword">TO</span> <span class="operator">|</span> <span class="operator">=</span> &#125; &#123; <span class="keyword">value</span> <span class="operator">|</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125; [ <span class="keyword">IN</span> DATABASE database_name ] <span class="keyword">SET</span> configuration_parameter <span class="keyword">FROM</span> <span class="keyword">CURRENT</span></span><br><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125; [ <span class="keyword">IN</span> DATABASE database_name ] RESET configuration_parameter</span><br><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125; [ <span class="keyword">IN</span> DATABASE database_name ] RESET <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure>

<p>从上面的语法可以看出 PostgreSQL 配置的灵活性，您可以针对某个用户进行配置，也可以针对某个用户连接某个数据库进行配置。</p>
<p>数据库级别的配置相对于用户级别来说就要简单一些了，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE name <span class="keyword">SET</span> configuration_parameter &#123; <span class="keyword">TO</span> <span class="operator">|</span> <span class="operator">=</span> &#125; &#123; <span class="keyword">value</span> <span class="operator">|</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name <span class="keyword">SET</span> configuration_parameter <span class="keyword">FROM</span> <span class="keyword">CURRENT</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name RESET configuration_parameter</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name RESET <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>例如，我们想将当前用户连接数据库的 <code>work_mem</code> 修改为 <code>64M</code>，使用下面的命令即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> ROLE <span class="built_in">current_user</span> <span class="keyword">SET</span> work_mem <span class="keyword">TO</span> <span class="string">&#x27;64MB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当我们重新登录时，可以发现 <code>work_mem</code> 变成了 <code>64MB</code>，如果我们换一个用户登录，可以发现其 <code>work_mem</code> 仍然为默认的 <code>4MB</code>。接下来我们新建一个 <code>testdb</code> 数据库，并修改当前用户登录该数据库的 <code>work_mem</code> 设置为 <code>32MB</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE testdb;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="built_in">current_user</span> <span class="keyword">IN</span> DATABASE testdb <span class="keyword">SET</span> work_mem <span class="keyword">TO</span> <span class="string">&#x27;32MB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们再次使用当前用户登录 <code>testdb</code> 数据库，可以发现此时 <code>work_mem</code> 是 <code>32MB</code>，而不是 <code>64MB</code>。</p>
<p>数据库的参数修改类似，例如，修改 <code>testdb</code> 的 <code>maintenance_work_mem</code> 为 <code>128MB</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE testdb <span class="keyword">SET</span> maintenance_work_mem <span class="keyword">TO</span> <span class="string">&#x27;128MB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接着使用当前用户登录 <code>testdb</code> 数据库时，<code>maintenance_work_mem</code> 被设置为 <code>128MB</code>，当我们切换到其他数据库时，<code>maintenance_work_mem</code> 还是默认的 <code>64MB</code>。</p>
<p>我们知道全局的配置信息是存储在配置文件（<code>postgresql.conf</code> 或 <code>postgresql.auto.conf</code>）中，那上述命令修改的配置存放在哪儿呢？</p>
<p>通过查看系统表，我们可以看到有一个 <code>pg_db_role_setting</code> 的表，大胆猜测一下就是这个表来存储上述的参数信息了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_db_role_setting;</span><br><span class="line"> setdatabase <span class="operator">|</span> setrole <span class="operator">|</span>          setconfig</span><br><span class="line"><span class="comment">-------------+---------+------------------------------</span></span><br><span class="line">           <span class="number">0</span> <span class="operator">|</span>      <span class="number">10</span> <span class="operator">|</span> &#123;work_mem<span class="operator">=</span><span class="number">64</span>MB&#125;</span><br><span class="line">       <span class="number">16388</span> <span class="operator">|</span>      <span class="number">10</span> <span class="operator">|</span> &#123;work_mem<span class="operator">=</span><span class="number">32</span>MB&#125;</span><br><span class="line">           <span class="number">0</span> <span class="operator">|</span>       <span class="number">0</span> <span class="operator">|</span> &#123;work_mem<span class="operator">=</span><span class="number">1</span>MB&#125;</span><br><span class="line">       <span class="number">16388</span> <span class="operator">|</span>       <span class="number">0</span> <span class="operator">|</span> &#123;maintenance_work_mem<span class="operator">=</span><span class="number">128</span>MB&#125;</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>不出所料，果然是该表存储了上述参数信息。如果不熟悉 PostgreSQL 的系统表，我们也可以从源码来分析其存放的位置。</p>
<p>既然可以通过 <code>ALTER ROLE</code> 的方式进行修改，那么我们看看 <code>gram.y</code> 中关于 <code>ALTER ROLE</code> 是如何做语法分析的。通过搜索 <code>AlterRole</code>，我们可以找到如下代码段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AlterRoleSetStmt:</span><br><span class="line">            ALTER ROLE RoleSpec opt_in_database SetResetClause</span><br><span class="line">                &#123;</span><br><span class="line">                    AlterRoleSetStmt *n = makeNode(AlterRoleSetStmt);</span><br><span class="line"></span><br><span class="line">                    n-&gt;role = $<span class="number">3</span>;</span><br><span class="line">                    n-&gt;database = $<span class="number">4</span>;</span><br><span class="line">                    n-&gt;setstmt = $<span class="number">5</span>;</span><br><span class="line">                    $$ = (Node *) n;</span><br><span class="line">                &#125;</span><br><span class="line">            | ALTER ROLE ALL opt_in_database SetResetClause</span><br><span class="line">                &#123;</span><br><span class="line">                    AlterRoleSetStmt *n = makeNode(AlterRoleSetStmt);</span><br><span class="line"></span><br><span class="line">                    n-&gt;role = <span class="literal">NULL</span>;</span><br><span class="line">                    n-&gt;database = $<span class="number">4</span>;</span><br><span class="line">                    n-&gt;setstmt = $<span class="number">5</span>;</span><br><span class="line">                    $$ = (Node *) n;</span><br><span class="line">                &#125;</span><br><span class="line">            | ALTER USER RoleSpec opt_in_database SetResetClause</span><br><span class="line">                &#123;</span><br><span class="line">                    AlterRoleSetStmt *n = makeNode(AlterRoleSetStmt);</span><br><span class="line"></span><br><span class="line">                    n-&gt;role = $<span class="number">3</span>;</span><br><span class="line">                    n-&gt;database = $<span class="number">4</span>;</span><br><span class="line">                    n-&gt;setstmt = $<span class="number">5</span>;</span><br><span class="line">                    $$ = (Node *) n;</span><br><span class="line">                &#125;</span><br><span class="line">            | ALTER USER ALL opt_in_database SetResetClause</span><br><span class="line">                &#123;</span><br><span class="line">                    AlterRoleSetStmt *n = makeNode(AlterRoleSetStmt);</span><br><span class="line"></span><br><span class="line">                    n-&gt;role = <span class="literal">NULL</span>;</span><br><span class="line">                    n-&gt;database = $<span class="number">4</span>;</span><br><span class="line">                    n-&gt;setstmt = $<span class="number">5</span>;</span><br><span class="line">                    $$ = (Node *) n;</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>显然，关于 <code>ALTER ROLE ... SET ...</code> 是通过 <code>AlterRoleSetStmt</code> 来解析的，再次搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep <span class="string">&#x27;AlterRoleSetStmt&#x27;</span> -rn src/ --include <span class="string">&#x27;*.c&#x27;</span></span><br><span class="line">src/backend/commands/user.c:828:AlterRoleSet(AlterRoleSetStmt *stmt)</span><br><span class="line">src/backend/tcop/utility.c:159:         <span class="keyword">case</span> T_AlterRoleSetStmt:</span><br><span class="line">src/backend/tcop/utility.c:919:         <span class="keyword">case</span> T_AlterRoleSetStmt:</span><br><span class="line">src/backend/tcop/utility.c:921:                 AlterRoleSet((AlterRoleSetStmt *) parsetree);</span><br><span class="line">src/backend/tcop/utility.c:2962:                <span class="keyword">case</span> T_AlterRoleSetStmt:</span><br><span class="line">src/backend/tcop/utility.c:3583:                <span class="keyword">case</span> T_AlterRoleSetStmt:</span><br></pre></td></tr></table></figure>

<p>可以发现其在 <code>src/backend/commands/user.c</code> 文件中有一个 <code>AlterRoleSet()</code> 的函数，那么一切就明朗了，查看 <code>AlterRoleSet()</code> 函数，其核心是调用 <code>AlterSetting()</code> 来修改配置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ALTER ROLE ... SET</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Oid</span></span><br><span class="line"><span class="function"><span class="title">AlterRoleSet</span><span class="params">(AlterRoleSetStmt *stmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    AlterSetting(databaseid, roleid, stmt-&gt;setstmt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> roleid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>AlterSetting()</code> 则是读写 <code>pg_db_role_setting</code> 系统表来完成配置的修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">AlterSetting</span><span class="params">(Oid databaseid, Oid roleid, VariableSetStmt *setstmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    rel = table_open(DbRoleSettingRelationId, RowExclusiveLock);</span><br><span class="line">    ScanKeyInit(&amp;scankey[<span class="number">0</span>],</span><br><span class="line">                Anum_pg_db_role_setting_setdatabase,</span><br><span class="line">                BTEqualStrategyNumber, F_OIDEQ,</span><br><span class="line">                ObjectIdGetDatum(databaseid));</span><br><span class="line">    ScanKeyInit(&amp;scankey[<span class="number">1</span>],</span><br><span class="line">                Anum_pg_db_role_setting_setrole,</span><br><span class="line">                BTEqualStrategyNumber, F_OIDEQ,</span><br><span class="line">                ObjectIdGetDatum(roleid));</span><br><span class="line">    scan = systable_beginscan(rel, DbRoleSettingDatidRolidIndexId, <span class="literal">true</span>,</span><br><span class="line">                              <span class="literal">NULL</span>, <span class="number">2</span>, scankey);</span><br><span class="line">    tuple = systable_getnext(scan);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * There are three cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - in RESET ALL, request GUC to reset the settings array and update the</span></span><br><span class="line"><span class="comment">     * catalog if there&#x27;s anything left, delete it otherwise</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - in other commands, if there&#x27;s a tuple in pg_db_role_setting, update</span></span><br><span class="line"><span class="comment">     * it; if it ends up empty, delete it</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - otherwise, insert a new pg_db_role_setting tuple, but only if the</span></span><br><span class="line"><span class="comment">     * command is not RESET</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    InvokeObjectPostAlterHookArg(DbRoleSettingRelationId,</span><br><span class="line">                                 databaseid, <span class="number">0</span>, roleid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    systable_endscan(scan);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Close pg_db_role_setting, but keep lock till commit */</span></span><br><span class="line">    table_close(rel, NoLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，您也可以找到 <code>AlterDatabaseSet()</code> 函数，其本质上也是调用 <code>AlterSetting()</code> 函数来进行修改。</p>
<p>从上面的配置，我们可以看出，这些选项可能在不同的级别上存在冲突。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE testdb <span class="keyword">SET</span> temp_buffers <span class="keyword">TO</span> <span class="string">&#x27;10MB&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> ROLE <span class="built_in">current_user</span> <span class="keyword">SET</span> temp_buffers <span class="keyword">TO</span> <span class="string">&#x27;11MB&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> ROLE <span class="built_in">current_user</span> <span class="keyword">IN</span> DATABASE testdb <span class="keyword">SET</span> temp_buffers <span class="keyword">TO</span> <span class="string">&#x27;12MB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_db_role_setting;</span><br><span class="line"> setdatabase <span class="operator">|</span> setrole <span class="operator">|</span>                   setconfig</span><br><span class="line"><span class="comment">-------------+---------+------------------------------------------------</span></span><br><span class="line">           <span class="number">0</span> <span class="operator">|</span>       <span class="number">0</span> <span class="operator">|</span> &#123;work_mem<span class="operator">=</span><span class="number">1</span>MB&#125;</span><br><span class="line">       <span class="number">16388</span> <span class="operator">|</span>       <span class="number">0</span> <span class="operator">|</span> &#123;maintenance_work_mem<span class="operator">=</span><span class="number">128</span>MB,temp_buffers<span class="operator">=</span><span class="number">10</span>MB&#125;</span><br><span class="line">           <span class="number">0</span> <span class="operator">|</span>      <span class="number">10</span> <span class="operator">|</span> &#123;work_mem<span class="operator">=</span><span class="number">64</span>MB,temp_buffers<span class="operator">=</span><span class="number">11</span>MB&#125;</span><br><span class="line">       <span class="number">16388</span> <span class="operator">|</span>      <span class="number">10</span> <span class="operator">|</span> &#123;work_mem<span class="operator">=</span><span class="number">32</span>MB,temp_buffers<span class="operator">=</span><span class="number">12</span>MB&#125;</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>我们重新登录，查看 <code>temp_buffers</code>，其结构如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">testdb<span class="operator">=</span># <span class="keyword">SHOW</span> temp_buffers;</span><br><span class="line"> temp_buffers</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"> <span class="number">12</span>MB</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>那它是如何加载这些参数的呢？以及它们的优先级设怎样的呢？我们可以在 <code>src/backend/catalog/pg_db_role_setting.c</code> 文件中看到 <code>ApplySetting()</code> 函数，通过查找该函数，我们可以知道它是由 <code>process_settings()</code> 函数调用的，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Load GUC settings from pg_db_role_setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We try specific settings for the database/role combination, as well as</span></span><br><span class="line"><span class="comment"> * general for this database and for this user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">process_settings</span><span class="params">(Oid databaseid, Oid roleid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Relation    relsetting;</span><br><span class="line">    Snapshot    snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsUnderPostmaster)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    relsetting = table_open(DbRoleSettingRelationId, AccessShareLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read all the settings under the same snapshot for efficiency */</span></span><br><span class="line">    snapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Later settings are ignored if set earlier. */</span></span><br><span class="line">    ApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);</span><br><span class="line">    ApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);</span><br><span class="line">    ApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);</span><br><span class="line">    ApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);</span><br><span class="line"></span><br><span class="line">    UnregisterSnapshot(snapshot);</span><br><span class="line">    table_close(relsetting, AccessShareLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>process_settings()</code> 函数则是在 backend 进程起来之后由 <code>PostgresMain()</code> 到 <code>InitPostgres()</code> 调用，在之后便是接收客户端的请求，并执行相应的查询。至此，我们便找到了这些参数的加载过程。根据上面的参数应用规则，我们可以得到如下所示的参数优先级示意图：</p>
<img src="/2022/08/postgresql-parameters-for-database-and-role/parameter-priority.png" class="">

<p>关于参数是如何应用的，不在本文的讨论范畴，感兴趣的朋友可以去看看 <code>ProcessGUCArray()</code> 函数以及 PostgreSQL guc 的相关处理过程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/current/sql-alterdatabase.html">https://www.postgresql.org/docs/current/sql-alterdatabase.html</a><br>[2] <a href="https://www.postgresql.org/docs/current/sql-alterrole.html">https://www.postgresql.org/docs/current/sql-alterrole.html</a><br>[3] <a href="https://www.postgresql.org/docs/current/catalog-pg-db-role-setting.html">https://www.postgresql.org/docs/current/catalog-pg-db-role-setting.html</a></p>
<div class="just-for-fun">
笑林广记 - 江心赋

<p>有富翁同友远出，泊舟江中，偶上岸散步，见壁间题“江心赋”三字，错认“赋”字为“贼”字，惊欲走匿。<br>友问故，指曰：“此处有贼。”<br>友曰：“赋也，非贼也。”<br>其人曰：“赋便赋了，终是有些贼形。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL pg_db_role_setting 参数修改</title>
    <url>/2022/08/postgresql-parameters-in-pg-db-role-setting/</url>
    <content><![CDATA[<p>在<a href="/2022/08/postgresql-parameters-for-database-and-role/" title="上一篇">上一篇</a>文章中介绍了如何修改用户或数据库级别的参数，以及它们的存储位置（<code>pg_db_role_setting</code> 系统表），本文简要说明一下关于这里的参数配置不当，从而导致无法连接数据库的问题。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我尝试通过 <code>ALTER ROLE all SET local_preload_libraries TO fdafd;</code> 修改配置，退出之后，我尝试重新登录时遇到如下问题（这里仅供测试，不要在生成环境这样操作，修改用户或数据库参数时，请确保参数的合法性）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql postgres</span><br><span class="line">psql: error: connection to server on socket &quot;/tmp/.s.PGSQL.5432&quot; failed: FATAL:  could not access file &quot;$libdir/plugins/fdafd&quot;: No such file or directory</span><br></pre></td></tr></table></figure>

<p>嗷了个熬… :( 登录不上了，现在也没有机会修改了。该咋个办呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在<a href="/2022/08/postgresql-parameters-for-database-and-role/" title="前面的文章">前面的文章</a>中我们提到 <code>pg_db_role_setting</code> 里面的参数是通过 <code>process_setting()</code> 函数加载的，我们再看看其实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Load GUC settings from pg_db_role_setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We try specific settings for the database/role combination, as well as</span></span><br><span class="line"><span class="comment"> * general for this database and for this user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">process_settings</span><span class="params">(Oid databaseid, Oid roleid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Relation    relsetting;</span><br><span class="line">    Snapshot    snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsUnderPostmaster)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    relsetting = table_open(DbRoleSettingRelationId, AccessShareLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read all the settings under the same snapshot for efficiency */</span></span><br><span class="line">    snapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Later settings are ignored if set earlier. */</span></span><br><span class="line">    ApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);</span><br><span class="line">    ApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);</span><br><span class="line">    ApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);</span><br><span class="line">    ApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);</span><br><span class="line"></span><br><span class="line">    UnregisterSnapshot(snapshot);</span><br><span class="line">    table_close(relsetting, AccessShareLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码，我们可以得知 <code>pg_db_role_setting</code> 中的参数仅在 <code>IsUnderPostmaster = true</code> 时才会被加载，因此我们可以使用单用户模式运行数据库实例（感谢 Kyotaro Horiguchi 给的建议），从而来修改这个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pg_ctl stop</span><br><span class="line">$ postgres --single postgres</span><br><span class="line"></span><br><span class="line">PostgreSQL stand-alone backend 16devel</span><br><span class="line">backend&gt; SELECT * FROM pg_db_role_setting;</span><br><span class="line">         1: setdatabase (typeid = 26, len = 4, typmod = -1, byval = t)</span><br><span class="line">         2: setrole     (typeid = 26, len = 4, typmod = -1, byval = t)</span><br><span class="line">         3: setconfig   (typeid = 1009, len = -1, typmod = -1, byval = f)</span><br><span class="line">        ----</span><br><span class="line">         1: setdatabase = <span class="string">&quot;0&quot;</span>   (typeid = 26, len = 4, typmod = -1, byval = t)</span><br><span class="line">         2: setrole = <span class="string">&quot;0&quot;</span>       (typeid = 26, len = 4, typmod = -1, byval = t)</span><br><span class="line">         3: setconfig = <span class="string">&quot;&#123;local_preload_libraries=fdafd&#125;&quot;</span>       (typeid = 1009, len = -1, typmod = -1, byval = f)</span><br><span class="line">        ----</span><br></pre></td></tr></table></figure>

<p>接着我们重值该参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backend&gt; ALTER ROLE ALL RESET local_preload_libraries;</span><br><span class="line">backend&gt; SELECT * FROM pg_db_role_setting;</span><br><span class="line">         1: setdatabase (typeid = 26, len = 4, typmod = -1, byval = t)</span><br><span class="line">         2: setrole     (typeid = 26, len = 4, typmod = -1, byval = t)</span><br><span class="line">         3: setconfig   (typeid = 1009, len = -1, typmod = -1, byval = f)</span><br><span class="line">        ----</span><br></pre></td></tr></table></figure>

<p>接着按 <code>Ctrl-D</code> 退出单用户模式，并重启数据库，再次连接数据库，一切就正常了。上述解决方案最大的问题是需要重启数据库服务。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们是否可以提供一种方式，让其在线修改 <code>pg_db_role_setting</code> 参数的加载呢？答案是肯定可以的，但是社区不接受这样的修改。下面是引用 Tom Lane 对此的看法。</p>
<blockquote>
<p>There is not, and never will be, a version of Postgres in which it’s impossible for a superuser to shoot himself in the foot.</p>
<p>Test your settings more carefully before applying them to a production database that you can’t afford to mess up.</p>
</blockquote>
<p>但是谁又能 100% 保证这种事情不会发生呢？这个功能实现起来也不困难，我们只需要在一个参数即可，下面是一个样例。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/utils/init/postinit.c b/src/backend/utils/init/postinit.c</span></span><br><span class="line"><span class="comment">index 29f70accb2..decd828248 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/init/postinit.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/init/postinit.c</span></span><br><span class="line"><span class="meta">@@ -82,6 +82,7 @@</span> static bool ThereIsAtLeastOneRole(void);</span><br><span class="line"> static void process_startup_options(Port *port, bool am_superuser);</span><br><span class="line"> static void process_settings(Oid databaseid, Oid roleid);</span><br><span class="line"></span><br><span class="line"><span class="addition">+bool load_db_role_settings = true;</span></span><br><span class="line"></span><br><span class="line"> /*** InitPostgres support ***/</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -1221,7 +1222,7 @@</span> process_settings(Oid databaseid, Oid roleid)</span><br><span class="line"> 	Relation	relsetting;</span><br><span class="line"> 	Snapshot	snapshot;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (!IsUnderPostmaster)</span></span><br><span class="line"><span class="addition">+	if (!IsUnderPostmaster || !load_db_role_settings)</span></span><br><span class="line"> 		return;</span><br><span class="line"></span><br><span class="line"> 	relsetting = table_open(DbRoleSettingRelationId, AccessShareLock);</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="comment">index af4a1c3068..c0d14a9c6c 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="meta">@@ -151,6 +151,8 @@</span> extern bool trace_syncscan;</span><br><span class="line"> extern bool optimize_bounded_sort;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"><span class="addition">+extern bool load_db_role_settings;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> static int	GUC_check_errcode_value;</span><br><span class="line"></span><br><span class="line"> static List *reserved_class_prefix = NIL;</span><br><span class="line"><span class="meta">@@ -2182,6 +2184,15 @@</span> static struct config_bool ConfigureNamesBool[] =</span><br><span class="line"> 		NULL, NULL, NULL</span><br><span class="line"> 	&#125;,</span><br><span class="line"></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		&#123;&quot;load_db_role_settings&quot;, PGC_SIGHUP, CLIENT_CONN_PRELOAD,</span></span><br><span class="line"><span class="addition">+			gettext_noop(&quot;Whether to load parameters from pg_db_role_setting.&quot;),</span></span><br><span class="line"><span class="addition">+		&#125;,</span></span><br><span class="line"><span class="addition">+		&amp;load_db_role_settings,</span></span><br><span class="line"><span class="addition">+		true,</span></span><br><span class="line"><span class="addition">+		NULL, NULL, NULL</span></span><br><span class="line"><span class="addition">+	&#125;,</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	/* End-of-list marker */</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		&#123;NULL, 0, 0, NULL, NULL&#125;, NULL, false, NULL, NULL, NULL</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/misc/postgresql.conf.sample b/src/backend/utils/misc/postgresql.conf.sample</span></span><br><span class="line"><span class="comment">index b4bc06e5f5..c71b7891d9 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/postgresql.conf.sample</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/postgresql.conf.sample</span></span><br><span class="line"><span class="meta">@@ -745,6 +745,7 @@</span></span><br><span class="line"></span><br><span class="line"> #dynamic_library_path = &#x27;$libdir&#x27;</span><br><span class="line"> #gin_fuzzy_search_limit = 0</span><br><span class="line"><span class="addition">+#load_db_role_settings = on</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>原以为这就完了，Too young, too simple! Daniel Verite 给出了一个更为优雅的解决方案，即通过 <code>PGOPTIONS</code> 选项来覆盖 <code>pg_db_role_setting</code> 中的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ PGOPTIONS=<span class="string">&quot;-c local_preload_libraries=&quot;</span> psql postgres</span><br><span class="line">psql (16devel)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<img src="/2022/08/postgresql-parameters-in-pg-db-role-setting/graceful.png" class="">

<p>下面是关于 <code>PGOPTIONS</code> 和 <code>pg_db_role_setting</code> 的处理流程，可以看得到 <code>PGOPTIONS</code> 的处理先于 <code>pg_db_role_setting</code>，这里后面的配置并不会覆盖前面的配置，因此程序在启动时采用了 <code>PGOPTIONS</code> 中的 <code>local_preload_libraries</code> 配置，我们也可以通过调试，在后续的 <code>process_session_preload_libraries()</code> 函数中看到 <code>local_preload_libraries</code> 的值为空（即 <code>PGOPTIONS</code> 中给出的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">InitPostgres</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_dbname, Oid dboid,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> <span class="keyword">char</span> *username, Oid useroid,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">bool</span> load_session_libraries,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">bool</span> override_allow_connections,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">char</span> *out_dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now process any command-line switches and any additional GUC variable</span></span><br><span class="line"><span class="comment">     * settings passed in the startup packet.   We couldn&#x27;t do this before</span></span><br><span class="line"><span class="comment">     * because we didn&#x27;t know if client is a superuser.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (MyProcPort != <span class="literal">NULL</span>)</span><br><span class="line">        process_startup_options(MyProcPort, am_superuser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process pg_db_role_setting options */</span></span><br><span class="line">    process_settings(MyDatabaseId, GetSessionUserId());</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If this is an interactive session, load any libraries that should be</span></span><br><span class="line"><span class="comment">     * preloaded at backend start.  Since those are determined by GUCs, this</span></span><br><span class="line"><span class="comment">     * can&#x27;t happen until GUC settings are complete, but we want it to happen</span></span><br><span class="line"><span class="comment">     * during the initial transaction in case anything that requires database</span></span><br><span class="line"><span class="comment">     * access needs to be done.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (load_session_libraries)</span><br><span class="line">        process_session_preload_libraries();</span><br><span class="line"></span><br><span class="line">	[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/current/app-postgres.html">https://www.postgresql.org/docs/current/app-postgres.html</a><br>[2] <a href="https://www.postgresql.org/message-id/MEYP282MB166955E4B68992FC86C4DC48B69A9%40MEYP282MB1669.AUSP282.PROD.OUTLOOK.COM">https://www.postgresql.org/message-id/MEYP282MB166955E4B68992FC86C4DC48B69A9%40MEYP282MB1669.AUSP282.PROD.OUTLOOK.COM</a></p>
<div class="just-for-fun">
笑林广记 - 吃乳饼

<p>富翁与人论及童子多肖乳母，为吃其乳，气相感也。<br>其人谓富翁曰：“若是如此，想来足下从幼是吃乳饼长大的。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 15 特性 - 新增 pg_waldump 过滤选项</title>
    <url>/2022/03/postgresql-pg-waldump-new-filters/</url>
    <content><![CDATA[<p>PostgreSQL 主分支中针对 pg_waldump 新增了四类过滤选项，分别为 <code>RelFileNode</code>、<code>BlockNumber</code>、<code>ForkNum</code> 和 <code>FPW</code>。本文将简要介绍一下这四个过滤选项。</p>
<span id="more"></span>

<h2 id="RelFileNode-过滤选项"><a href="#RelFileNode-过滤选项" class="headerlink" title="RelFileNode 过滤选项"></a>RelFileNode 过滤选项</h2><p>该过滤选项可以通过 <code>Tablespace OID/Database OID/relfilenode</code> 的方式来过滤 WAL 日志。例如，我们新建一个表，并插入记录，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(id <span class="type">int</span>, name text);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account <span class="keyword">SELECT</span> id, <span class="string">&#x27;account&#x27;</span> <span class="operator">||</span> id::text <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">1000</span>) id;</span><br></pre></td></tr></table></figure>

<p>接着，我们通过下面的语句查询表 <code>account</code> 的表空间 OID、数据库 OID 以及 <code>relfilenode</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    relname,</span><br><span class="line">    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> reltablespace <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">THEN</span> (<span class="keyword">SELECT</span> oid <span class="keyword">FROM</span> pg_tablespace <span class="keyword">WHERE</span> spcname <span class="operator">=</span> <span class="string">&#x27;pg_default&#x27;</span>)</span><br><span class="line">        <span class="keyword">ELSE</span> reltablespace</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> tablespace,</span><br><span class="line">    (<span class="keyword">SELECT</span> oid <span class="keyword">FROM</span> pg_database <span class="keyword">WHERE</span> datname <span class="operator">=</span> current_database()) <span class="keyword">AS</span> database,</span><br><span class="line">    relfilenode</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    pg_class</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    relname <span class="operator">=</span> <span class="string">&#x27;account&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> relname | tablespace | database | relfilenode</span><br><span class="line">---------+------------+----------+-------------</span><br><span class="line"> account |       1663 |        5 |       16387</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>现在我们便可以通过 <code>RelFileNode</code> 的方式来过滤 WAL 日志，指定 <code>--relation</code> 选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_waldump --relation 1663/5/16387 000000010000000000000001</span></span><br><span class="line">rmgr: Heap        len (rec/tot):     68/    68, tx:        723, lsn: 0/014C17A8, prev 0/014C1360, desc: INSERT+INIT off 1 flags 0x00, blkref #0: rel 1663/5/16387 blk 0</span><br><span class="line">rmgr: Heap        len (rec/tot):     68/    68, tx:        723, lsn: 0/014C17F0, prev 0/014C17A8, desc: INSERT off 2 flags 0x00, blkref #0: rel 1663/5/16387 blk 0</span><br><span class="line">rmgr: Heap        len (rec/tot):     68/    68, tx:        723, lsn: 0/014C1838, prev 0/014C17F0, desc: INSERT off 3 flags 0x00, blkref #0: rel 1663/5/16387 blk 0</span><br><span class="line">rmgr: Heap        len (rec/tot):     68/    68, tx:        723, lsn: 0/014C1880, prev 0/014C1838, desc: INSERT off 4 flags 0x00, blkref #0: rel 1663/5/16387 blk 0</span><br><span class="line">[...]</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4BE0, prev 0/014C4B98, desc: INSERT+INIT off 1 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4C28, prev 0/014C4BE0, desc: INSERT off 2 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4C70, prev 0/014C4C28, desc: INSERT off 3 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4CB8, prev 0/014C4C70, desc: INSERT off 4 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">[...]</span><br><span class="line">pg_waldump: fatal: error in WAL record at 0/14D66A0: invalid record length at 0/14D66D8: wanted 24, got 0</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，<code>tablespace OID</code> 和 <code>relfilenode</code> 必须是非负数，而 <code>Database OID</code> 则可以为 <code>0</code>，例如，<code>pg_database</code> 表是共享的，我们可以通过指定 <code>--relation 1664/0/1262</code> 来查看该表的 WAL 日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ pg_waldump pgdata<span class="operator">/</span>pg_wal<span class="operator">/</span><span class="number">000000010000000000000001</span> <span class="comment">--relation 1664/0/1262 --fork vm --limit 1</span></span><br><span class="line">rmgr: Heap2       len (rec<span class="operator">/</span>tot):     <span class="number">64</span><span class="operator">/</span>  <span class="number">8256</span>, tx:          <span class="number">0</span>, lsn: <span class="number">0</span><span class="operator">/</span><span class="number">01491</span>F20, prev <span class="number">0</span><span class="operator">/</span><span class="number">01491</span>EC0, <span class="keyword">desc</span>: VISIBLE cutoff xid <span class="number">1</span> flags <span class="number">0x03</span>, blkref #<span class="number">0</span> : rel <span class="number">1664</span><span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">1262</span> fork vm blk <span class="number">0</span> FPW, blkref #<span class="number">1</span>: rel <span class="number">1664</span><span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">1262</span> blk <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="BlockNumber-过滤选项"><a href="#BlockNumber-过滤选项" class="headerlink" title="BlockNumber 过滤选项"></a>BlockNumber 过滤选项</h2><p><code>BlockNumber</code> 过滤选项（<code>--block</code> 选项）需要与 <code>RelFileNode</code> 过滤选项一起使用，即指定 <code>--block</code> 选项必须指定 <code>--relation</code> 选项，它可以显示指定的数据块的修改日志，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_waldump --block 1 --relation 1663/5/16387 000000010000000000000001</span></span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4BE0, prev 0/014C4B98, desc: INSERT+INIT off 1 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4C28, prev 0/014C4BE0, desc: INSERT off 2 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4C70, prev 0/014C4C28, desc: INSERT off 3 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4CB8, prev 0/014C4C70, desc: INSERT off 4 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4D00, prev 0/014C4CB8, desc: INSERT off 5 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4D48, prev 0/014C4D00, desc: INSERT off 6 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4D90, prev 0/014C4D48, desc: INSERT off 7 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4DD8, prev 0/014C4D90, desc: INSERT off 8 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4E20, prev 0/014C4DD8, desc: INSERT off 9 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4E68, prev 0/014C4E20, desc: INSERT off 10 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap        len (rec/tot):     70/    70, tx:        723, lsn: 0/014C4EB0, prev 0/014C4E68, desc: INSERT off 11 flags 0x00, blkref #0: rel 1663/5/16387 blk 1</span><br><span class="line">[...]</span><br><span class="line">pg_waldump: fatal: error in WAL record at 0/14D66A0: invalid record length at 0/14D66D8: wanted 24, got 0</span><br></pre></td></tr></table></figure>

<h2 id="ForkNum-过滤选项"><a href="#ForkNum-过滤选项" class="headerlink" title="ForkNum 过滤选项"></a>ForkNum 过滤选项</h2><p>PostgreSQL 在后端存储的时候会将数据表组织为 <code>main</code>, <code>vm</code>, <code>fsm</code> 和 <code>init</code> 四种类型，他们被被称为 <code>ForkNum</code>，<code>ForkNum</code> 过滤选项（<code>--fork</code> 选项）可以过滤指定 <code>Fork</code> 类型的 WAL 日志。首先我们删除一些记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">500</span>;</span><br><span class="line">ANALYZE;</span><br></pre></td></tr></table></figure>

<p>接着我们通过 pg_waldump 来查看 <code>vm</code> 的修改日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_waldump --fork vm --relation 1663/5/16387 000000010000000000000001</span></span><br><span class="line">rmgr: Heap2       len (rec/tot):     64/  8256, tx:          0, lsn: 0/01572228, prev 0/01572080, desc: VISIBLE cutoff xid 0 flags 0x03, blkref #0: rel 1663/5/16387 fork vm blk 0 FPW, blkref #1: rel 1663/5/16387 blk 0</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/01574760, prev 0/015745B8, desc: VISIBLE cutoff xid 0 flags 0x03, blkref #0: rel 1663/5/16387 fork vm blk 0, blkref #1: rel 1663/5/16387 blk 1</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/015754D0, prev 0/01575398, desc: VISIBLE cutoff xid 723 flags 0x01, blkref #0: rel 1663/5/16387 fork vm blk 0, blkref #1: rel 1663/5/16387 blk 2</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/01575510, prev 0/015754D0, desc: VISIBLE cutoff xid 723 flags 0x01, blkref #0: rel 1663/5/16387 fork vm blk 0, blkref #1: rel 1663/5/16387 blk 3</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/01575550, prev 0/01575510, desc: VISIBLE cutoff xid 723 flags 0x01, blkref #0: rel 1663/5/16387 fork vm blk 0, blkref #1: rel 1663/5/16387 blk 4</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/01575590, prev 0/01575550, desc: VISIBLE cutoff xid 723 flags 0x01, blkref #0: rel 1663/5/16387 fork vm blk 0, blkref #1: rel 1663/5/16387 blk 5</span><br><span class="line">pg_waldump: fatal: error in WAL record at 0/15A01E8: invalid record length at 0/15A0220: wanted 24, got 0</span><br></pre></td></tr></table></figure>

<h2 id="FPW-过滤选项"><a href="#FPW-过滤选项" class="headerlink" title="FPW 过滤选项"></a><code>FPW</code> 过滤选项</h2><p><code>FPW</code> 过滤选项（<code>--fullpage</code> 选项），即 <code>full page write</code>，它可以用于过滤 <code>full page write</code> 相关的 WAL 日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHECKPOINT</span><br><span class="line">UPDATE account <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;xxx100&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">600</span>;</span><br></pre></td></tr></table></figure>

<p>如下所示，我们过滤了表 <code>account</code> 相关的 <code>full page write</code> 日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_waldump --fullpage --relation 1663/5/16387 000000010000000000000001</span></span><br><span class="line">rmgr: Heap        len (rec/tot):     59/  8223, tx:        765, lsn: 0/0153B660, prev 0/0153B628, desc: DELETE off 1 flags 0x00 KEYS_UPDATED , blkref #0: rel 1663/5/16387 blk 0 FPW</span><br><span class="line">rmgr: Heap        len (rec/tot):     59/  8223, tx:        765, lsn: 0/0153FEF0, prev 0/0153FEB8, desc: DELETE off 1 flags 0x00 KEYS_UPDATED , blkref #0: rel 1663/5/16387 blk 1 FPW</span><br><span class="line">rmgr: Heap        len (rec/tot):     59/  8223, tx:        765, lsn: 0/01544798, prev 0/01544760, desc: DELETE off 1 flags 0x00 KEYS_UPDATED , blkref #0: rel 1663/5/16387 blk 2 FPW</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/   823, tx:          0, lsn: 0/01571D30, prev 0/01571CF8, desc: PRUNE latestRemovedXid 765 nredirected 0 ndead 185, blkref #0: rel 1663/5/16387 blk 0 FPW</span><br><span class="line">rmgr: Heap2       len (rec/tot):     64/  8256, tx:          0, lsn: 0/01572228, prev 0/01572080, desc: VISIBLE cutoff xid 0 flags 0x03, blkref #0: rel 1663/5/16387 fork vm blk 0 FPW, blkref #1: rel 1663/5/16387 blk 0</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/   823, tx:          0, lsn: 0/01574280, prev 0/01572228, desc: PRUNE latestRemovedXid 765 nredirected 0 ndead 185, blkref #0: rel 1663/5/16387 blk 1 FPW</span><br><span class="line">rmgr: Heap2       len (rec/tot):     59/  3063, tx:          0, lsn: 0/015747A0, prev 0/01574760, desc: PRUNE latestRemovedXid 765 nredirected 0 ndead 129, blkref #0: rel 1663/5/16387 blk 2 FPW</span><br><span class="line">rmgr: Heap        len (rec/tot):     59/  8223, tx:        806, lsn: 0/015A0308, prev 0/015A02D0, desc: LOCK off 45: xid 806: flags 0x00 LOCK_ONLY EXCL_LOCK , blkref #0: rel 1663/5/16387 blk 3 FPW</span><br><span class="line">pg_waldump: fatal: error in WAL record at 0/15A23C0: invalid record length at 0/15A23F8: wanted 24, got 0</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>上述四个过滤选项的实现还是比较简单的，它在 pg_waldump 新增了 <code>XLogRecordMatchesRelationBlock()</code> 和 <code>XLogRecordHasFPW()</code> 来判断 WAL 日志是否满足过滤条件，您可以在<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=127aea2a65cd89c1c28357c6db199683e219491e">这里</a>看到完整的代码，后续<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=52b5568432963b721698a2df1f37a0795b9611dc">这个</a>提交涉及到了 <code>fork</code> 的优化。下面是 <code>XLogRecordMatchesRelationBlock()</code> 和 <code>XLogRecordHasFPW()</code> 函数的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Boolean to return whether the given WAL record matches a specific relation</span></span><br><span class="line"><span class="comment"> * and optionally block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">XLogRecordMatchesRelationBlock</span><span class="params">(XLogReaderState *record,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                          RelFileNode matchRnode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                          BlockNumber matchBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                          ForkNumber matchFork)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>                     block_id;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (block_id = <span class="number">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)</span><br><span class="line">       &#123;</span><br><span class="line">               RelFileNode rnode;</span><br><span class="line">               ForkNumber      forknum;</span><br><span class="line">               BlockNumber blk;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!XLogRecHasBlockRef(record, block_id))</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">               XLogRecGetBlockTag(record, block_id, &amp;rnode, &amp;forknum, &amp;blk);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> ((matchFork == InvalidForkNumber || matchFork == forknum) &amp;&amp;</span><br><span class="line">                       (RelFileNodeEquals(matchRnode, emptyRelFileNode) ||</span><br><span class="line">                        RelFileNodeEquals(matchRnode, rnode)) &amp;&amp;</span><br><span class="line">                       (matchBlock == InvalidBlockNumber || matchBlock == blk))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Boolean to return whether the given WAL record contains a full page write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">XLogRecordHasFPW</span><span class="params">(XLogReaderState *record)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>                     block_id;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (block_id = <span class="number">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)</span><br><span class="line">       &#123;</span><br><span class="line">               <span class="keyword">if</span> (!XLogRecHasBlockRef(record, block_id))</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (XLogRecHasBlockImage(record, block_id))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑还是比较简单的，就是从 WAL 日志里面读取，然后匹配过滤选项。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://postgr.es/m/3a4c2e93-7976-2320-fc0a-32097fe148a7%40enterprisedb.com">https://postgr.es/m/3a4c2e93-7976-2320-fc0a-32097fe148a7%40enterprisedb.com</a><br>[2] <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=127aea2a65cd89c1c28357c6db199683e219491e">https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=127aea2a65cd89c1c28357c6db199683e219491e</a><br>[3] <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=52b5568432963b721698a2df1f37a0795b9611dc">https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=52b5568432963b721698a2df1f37a0795b9611dc</a></p>
<div class="just-for-fun">
笑林广记 - 借药碾

<p>一监生临终，谓妻曰：“我一生挣得这副衣冠，死后必为我殡殓。”<br>妻诺，既死穿衣套靴讫，惟圆帽左右欹侧难戴。<br>妻哭曰：“我的天，一顶帽子也无福戴。”<br>生复还魂张目谓妻曰：“必要戴的。”<br>妻曰：“非不欲带，恨枕不稳耳。”<br>生曰：“对门某医生家药碾槽，借来好做枕。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>PG15</tag>
        <tag>pg_waldump</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 的 repeat 函数</title>
    <url>/2022/07/postgresql-repeat-function/</url>
    <content><![CDATA[<p>PostgreSQL 的 <code>repeat()</code> 函数用于重复生成给定的字符串。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat(&#x27;abc&#x27;, 3) -&gt; &#x27;abcabcabc&#x27;</span><br></pre></td></tr></table></figure>

<p>最近在使用这个方法来生成 1GB 的数据时，遇到了一点问题。如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myrepeat <span class="keyword">AS</span> <span class="keyword">SELECT</span> repeat(<span class="string">&#x27;a&#x27;</span>, <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>);</span><br><span class="line">ERROR:  invalid memory alloc request size <span class="number">1073741828</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过查找 <code>invalid memory alloc request size</code> 字符串，我发现这是和 PostgreSQL 自带的内存管理模块有关。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&#x27;invalid memory alloc request size&#x27;</span> -rn src/</span></span><br><span class="line">src/backend/utils/mmgr/mcxt.c:871:              elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:914:              elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:952:              elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:988:              elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:1078:             elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:1109:             elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:1143:             elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:1194:             elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:1232:             elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br><span class="line">src/backend/utils/mmgr/mcxt.c:1264:             elog(ERROR, &quot;invalid memory alloc request size %zu&quot;, size);</span><br></pre></td></tr></table></figure>

<p>与 <code>invalid memory alloc request size</code> 有关的判断只有两个 <code>AllocHugeSizeIsValid()</code> 和 <code>AllocSizeIsValid()</code>，它们都是宏定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MaxAllocSize, MaxAllocHugeSize</span></span><br><span class="line"><span class="comment"> *      Quasi-arbitrary limits on size of allocations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> *      There is no guarantee that smaller allocations will succeed, but</span></span><br><span class="line"><span class="comment"> *      larger requests will be summarily denied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * palloc() enforces MaxAllocSize, chosen to correspond to the limiting size</span></span><br><span class="line"><span class="comment"> * of varlena objects under TOAST.  See VARSIZE_4B() and related macros in</span></span><br><span class="line"><span class="comment"> * postgres.h.  Many datatypes assume that any allocatable size can be</span></span><br><span class="line"><span class="comment"> * represented in a varlena header.  This limit also permits a caller to use</span></span><br><span class="line"><span class="comment"> * an &quot;int&quot; variable for an index into or length of an allocation.  Callers</span></span><br><span class="line"><span class="comment"> * careful to avoid these hazards can access the higher limit with</span></span><br><span class="line"><span class="comment"> * MemoryContextAllocHuge().  Both limits permit code to assume that it may</span></span><br><span class="line"><span class="comment"> * compute twice an allocation&#x27;s size without overflow.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxAllocSize    ((Size) 0x3fffffff) <span class="comment">/* 1 gigabyte - 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AllocSizeIsValid(size)  ((Size) (size) &lt;= MaxAllocSize)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxAllocHugeSize    (SIZE_MAX / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AllocHugeSizeIsValid(size)  ((Size) (size) &lt;= MaxAllocHugeSize)</span></span><br></pre></td></tr></table></figure>

<p>通过调试我发现 <code>repeat()</code> 函数会调用 <code>palloc()</code> 进行内存分配，这也就意味着它最大可以分配到 <code>1GB - 1</code> 的内存大小。</p>
<p>然而，我们的 <code>repeat(&#39;a&#39;, 1024 * 1024 * 1024)</code> 实际上却需要 <code>1073741828 = 1024 * 1024 * 1024 + 4</code> 的内存大小，这是为什么呢？我们来看一下 <code>repeat()</code> 函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">repeat</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    text       *<span class="built_in">string</span> = PG_GETARG_TEXT_PP(<span class="number">0</span>);</span><br><span class="line">    int32       count = PG_GETARG_INT32(<span class="number">1</span>);</span><br><span class="line">    text       *result;</span><br><span class="line">    <span class="keyword">int</span>         slen,</span><br><span class="line">                tlen;</span><br><span class="line">    <span class="keyword">int</span>         i;</span><br><span class="line">    <span class="keyword">char</span>       *cp,</span><br><span class="line">               *sp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    slen = VARSIZE_ANY_EXHDR(<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(pg_mul_s32_overflow(count, slen, &amp;tlen)) ||</span><br><span class="line">        unlikely(pg_add_s32_overflow(tlen, VARHDRSZ, &amp;tlen)))</span><br><span class="line">        ereport(ERROR,</span><br><span class="line">                (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</span><br><span class="line">                 errmsg(<span class="string">&quot;requested length too large&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    result = (text *) palloc(tlen);</span><br><span class="line"></span><br><span class="line">    SET_VARSIZE(result, tlen);</span><br><span class="line">    cp = VARDATA(result);</span><br><span class="line">    sp = VARDATA_ANY(<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cp, sp, slen);</span><br><span class="line">        cp += slen;</span><br><span class="line">        CHECK_FOR_INTERRUPTS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_TEXT_P(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在调用 <code>palloc()</code> 之前 <code>repeat()</code> 函数通过 <code>pg_mul_s32_overflow()</code> 和 <code>pg_add_s32_overflow()</code> 函数来计算出我们需要分配的内存大小。当执行 <code>pg_mul_s32_overflow()</code> 之后，一切都是正常的，我们需要分配 <code>1GB</code> 的内存，但是由于 PostgreSQL 内部对于 <code>text</code> 类型的处理需要额外的 <code>4</code> 个字节来存储数据的长度，因此它调用 <code>pg_add_s32_overflow()</code> 来计算实际需要分配的内存大小，<code>VARHDRSZ</code> 的定义如下所示，这也正好解释了为什么会多出 4 字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARHDRSZ            ((int32) sizeof(int32))</span></span><br></pre></td></tr></table></figure>

<p>我们尝试使用减小所需的内存大小。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myrepeat <span class="keyword">AS</span> <span class="keyword">SELECT</span> repeat(<span class="string">&#x27;a&#x27;</span>, <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">-</span> <span class="number">5</span>);</span><br><span class="line">ERROR:  invalid memory alloc request size <span class="number">1073741871</span></span><br></pre></td></tr></table></figure>

<p>通过前面的分析，我们知道 <code>repeat(&#39;a&#39;, 1024 * 1024 * 1024 - 5)</code> 的大小为 <code>1073741823</code>，那 <code>1073741871 - 1073741823 = 48</code> 是怎么来的呢？通过调试，其堆栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  palloc0 (size=1073741871) at /mnt/workspace/postgresql/build/../src/backend/utils/mmgr/mcxt.c:1103</span><br><span class="line">#1  0x0000561925199faf in heap_form_tuple (tupleDescriptor=0x561927cb4310, values=0x561927cb4470, isnull=0x561927cb4478)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/access/common/heaptuple.c:1069</span><br><span class="line">#2  0x00005619254879aa in tts_virtual_copy_heap_tuple (slot=0x561927cb4428) at /mnt/workspace/postgresql/build/../src/backend/executor/execTuples.c:280</span><br><span class="line">#3  0x000056192548a40c in ExecFetchSlotHeapTuple (slot=0x561927cb4428, materialize=true, shouldFree=0x7ffc9cc5197f)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/executor/execTuples.c:1660</span><br><span class="line">#4  0x000056192520e0c9 in heapam_tuple_insert (relation=0x7fdacaa9d3e0, slot=0x561927cb4428, cid=5, options=2, bistate=0x561927cb83f0)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/access/heap/heapam_handler.c:245</span><br><span class="line">#5  0x00005619253b2edf in table_tuple_insert (rel=0x7fdacaa9d3e0, slot=0x561927cb4428, cid=5, options=2, bistate=0x561927cb83f0)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/include/access/tableam.h:1376</span><br><span class="line">#6  0x00005619253b3d73 in intorel_receive (slot=0x561927cb4428, self=0x561927c82430) at /mnt/workspace/postgresql/build/../src/backend/commands/createas.c:586</span><br><span class="line">#7  0x0000561925478d86 in ExecutePlan (estate=0x561927cb3ed0, planstate=0x561927cb4108, use_parallel_mode=false, operation=CMD_SELECT, sendTuples=true, numberTuples=0,</span><br><span class="line">    direction=ForwardScanDirection, dest=0x561927c82430, execute_once=true) at /mnt/workspace/postgresql/build/../src/backend/executor/execMain.c:1667</span><br><span class="line">#8  0x0000561925476735 in standard_ExecutorRun (queryDesc=0x561927cab990, direction=ForwardScanDirection, count=0, execute_once=true)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/executor/execMain.c:363</span><br><span class="line">#9  0x000056192547654b in ExecutorRun (queryDesc=0x561927cab990, direction=ForwardScanDirection, count=0, execute_once=true)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/executor/execMain.c:307</span><br><span class="line">#10 0x00005619253b3711 in ExecCreateTableAs (pstate=0x561927c35b00, stmt=0x561927b5aa70, params=0x0, queryEnv=0x0, qc=0x7ffc9cc52370)</span><br></pre></td></tr></table></figure>

<p>关键的核心就在 <code>heap_form_tuple()</code> 函数。其中关于内存分配的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HeapTuple</span></span><br><span class="line"><span class="function"><span class="title">heap_form_tuple</span><span class="params">(TupleDesc tupleDescriptor,</span></span></span><br><span class="line"><span class="params"><span class="function">                Datum *values,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">bool</span> *isnull)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Determine total space needed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    len = offsetof(HeapTupleHeaderData, t_bits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasnull)</span><br><span class="line">        len += BITMAPLEN(numberOfAttributes);</span><br><span class="line"></span><br><span class="line">    hoff = len = MAXALIGN(len); <span class="comment">/* align user data safely */</span></span><br><span class="line"></span><br><span class="line">    data_len = heap_compute_data_size(tupleDescriptor, values, isnull);</span><br><span class="line"></span><br><span class="line">    len += data_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allocate and zero the space needed.  Note that the tuple body and</span></span><br><span class="line"><span class="comment">     * HeapTupleData management structure are allocated in one chunk.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tuple = (HeapTuple) palloc0(HEAPTUPLESIZE + len);</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们需要一个 <code>HeapTupleHeaderData</code> 结构，随后是 <code>NULL</code> 值的 bitmap（如果有的话），接着是数据，最后还需要包含一个 <code>HEAPTUPLESIZE</code> 大小。其中 <code>HeapTupleHeaderData</code> 和 <code>HEAPTUPLESIZE</code> 大小是固定的，均为 <code>24</code>，在这里没有 <code>NULL</code> bitmap，因此其长度为 <code>0</code>，在加上数据长度 <code>1073741823</code>，所以，最终我们需要 <code>1073741823 + 24 + 24 = 1073741871</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myrepeat <span class="keyword">AS</span> <span class="keyword">SELECT</span> repeat(<span class="string">&#x27;a&#x27;</span>, <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">-</span> <span class="number">5</span> <span class="operator">-</span> <span class="number">48</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此外，如果我们直接使用 <code>SELECT</code> 的话，会报如下错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> repeat(<span class="string">&#x27;a&#x27;</span>, <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">-</span> <span class="number">5</span>);</span><br><span class="line">ERROR:  <span class="keyword">out</span> <span class="keyword">of</span> memory</span><br><span class="line">DETAIL:  Cannot enlarge string buffer containing <span class="number">6</span> bytes <span class="keyword">by</span> <span class="number">1073741819</span> more bytes.</span><br></pre></td></tr></table></figure>
<p>通过上面的错误提示，可以推测是 <code>enlargeStringInfo()</code> 函数报的错，查找源码发现确实如此。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep <span class="string">&#x27;Cannot enlarge string buffer containing&#x27;</span> -rn src/ --exclude <span class="string">&quot;*.po&quot;</span></span><br><span class="line">src/common/stringinfo.c:306:                             errdetail(<span class="string">&quot;Cannot enlarge string buffer containing %d bytes by %d more bytes.&quot;</span>,</span><br><span class="line">src/common/stringinfo.c:310:                            _(<span class="string">&quot;out of memory\n\nCannot enlarge string buffer containing %d bytes by %d more bytes.\n&quot;</span>),</span><br></pre></td></tr></table></figure>

<p>通过断点调试可以看到其堆栈信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  enlargeStringInfo (str=0x561927cacf70, needed=1073741819) at /mnt/workspace/postgresql/build/../src/common/stringinfo.c:291</span><br><span class="line">#1  0x000056192591e042 in appendBinaryStringInfoNT (str=0x561927cacf70, data=0x7fda8aa49050 &#x27;a&#x27; &lt;repeats 200 times&gt;..., datalen=1073741819)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/common/stringinfo.c:258</span><br><span class="line">#2  0x00005619254fb323 in pq_sendcountedtext (buf=0x561927cacf70, str=0x7fda8aa49050 &#x27;a&#x27; &lt;repeats 200 times&gt;..., slen=1073741819, countincludesself=false)</span><br><span class="line">    at /mnt/workspace/postgresql/build/../src/backend/libpq/pqformat.c:159</span><br><span class="line">#3  0x000056192519d6af in printtup (slot=0x561927c7b2c8, self=0x561927cacf20) at /mnt/workspace/postgresql/build/../src/backend/access/common/printtup.c:358</span><br></pre></td></tr></table></figure>

<p>从 <code>printtup()</code> 函数可以看到服务器是如何将数据传输到客户端的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">printtup</span><span class="params">(TupleTableSlot *slot, DestReceiver *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Prepare a DataRow message (note buffer is in per-row context)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pq_beginmessage_reuse(buf, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    pq_sendint16(buf, natts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * send the attributes of this tuple</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; natts; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        PrinttupAttrInfo *thisState = myState-&gt;myinfo + i;</span><br><span class="line">        Datum       attr = slot-&gt;tts_values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slot-&gt;tts_isnull[i])</span><br><span class="line">        &#123;</span><br><span class="line">            pq_sendint32(buf, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Here we catch undefined bytes in datums that are returned to the</span></span><br><span class="line"><span class="comment">         * client without hitting disk; see comments at the related check in</span></span><br><span class="line"><span class="comment">         * PageAddItem().  This test is most useful for uncompressed,</span></span><br><span class="line"><span class="comment">         * non-external datums, but we&#x27;re quite likely to see such here when</span></span><br><span class="line"><span class="comment">         * testing new C functions.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (thisState-&gt;typisvarlena)</span><br><span class="line">            VALGRIND_CHECK_MEM_IS_DEFINED(DatumGetPointer(attr),</span><br><span class="line">                                          VARSIZE_ANY(attr));</span><br><span class="line">        <span class="keyword">if</span> (thisState-&gt;format == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Text output */</span></span><br><span class="line">            <span class="keyword">char</span>       *outputstr;</span><br><span class="line"></span><br><span class="line">            outputstr = OutputFunctionCall(&amp;thisState-&gt;finfo, attr);</span><br><span class="line">            pq_sendcountedtext(buf, outputstr, <span class="built_in">strlen</span>(outputstr), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Binary output */</span></span><br><span class="line">            bytea      *outputbytes;</span><br><span class="line"></span><br><span class="line">            outputbytes = SendFunctionCall(&amp;thisState-&gt;finfo, attr);</span><br><span class="line">            pq_sendint32(buf, VARSIZE(outputbytes) - VARHDRSZ);</span><br><span class="line">            pq_sendbytes(buf, VARDATA(outputbytes),</span><br><span class="line">                         VARSIZE(outputbytes) - VARHDRSZ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pq_endmessage_reuse(buf);</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，它包含一个 <code>16</code> 位的属性列数量。然后是每个属性列值的长度和值。属性列数量的长度为 <code>2</code>，属性列值的长度为 <code>32</code> 位整型，长度为 <code>4</code>，因此总长度为 <code>6</code>，最后附加上字符串长度 <code>1073741823</code>。然而，<code>enlargeStringInfo()</code> 最大能分配 <code>1073741823</code> 的内存空间，然而在当前的 <code>StringInfoData</code> 中已经包含了 <code>6</code> 个字节，但是我们还需要 <code>1024 * 1024 * 1024 - 5 = 1073741819</code> 个字节，<code>1073741819 + 6 = 1073741825</code> 超出了 <code>1073741823</code> 的限制。如果我们执行下面的查询，那么便可以获取到数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> repeat(<span class="string">&#x27;a&#x27;</span>, <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">-</span> <span class="number">5</span> <span class="operator">-</span> <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>注意，这里减去 <code>3</code> 是因为 <code>enlargeStringInfo()</code> 函数里面的 <code>needed</code> 不包含末尾的 <code>null</code> 字符。嗷嗷嗷！世界一下子就清静了！</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>当然就是避免使用这么大的字段咯！实际中估计也很少用到吧！:)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/current/functions-string.html">https://www.postgresql.org/docs/current/functions-string.html</a><br>[2] <a href="https://postgr.es/m/ME3P282MB16676ED32167189CB0462173B6D69@ME3P282MB1667.AUSP282.PROD.OUTLOOK.COM">https://postgr.es/m/ME3P282MB16676ED32167189CB0462173B6D69@ME3P282MB1667.AUSP282.PROD.OUTLOOK.COM</a></p>
<div class="just-for-fun">
笑林广记 - 仿制字

<p>一生见有投制生帖者，深叹制字新奇，偶致一远札，遂效之。<br>仆致书回，生问见书有何话说，仆曰：“当面启看，便问老相公无恙，又问老安人好否。予曰：‘俱安。’乃沉吟半晌，带笑而入，才发回书。”<br>生大喜曰：“人不可不学，只一字用着得当，便一家俱问到，添下许多殷勤。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 行级安全策略的使用</title>
    <url>/2019/07/postgresql-row-level-security-policy/</url>
    <content><![CDATA[<p>今天朋友咨询了下面一个问题：</p>
<blockquote>
<p>一个信息系统中包含全省的数据，但是各个市州可以访问自己的数据，而不能访问其他市州的数据。<br>例如，四川省下辖的成都市、绵阳市等有自己的数据，它们可以使用自己的用户登陆并更新自己的数据，<br>而不能修改其他市的数据（不可见）；而四川省级别的用户则对下辖的所有市的数据均可见。</p>
</blockquote>
<p>在我初看这个问题时，PostgreSQL 的行级安全策略 (Row Security Policy) 浮现在我的脑海中。PostgreSQL 的行级安全策略可以基于每个用户限制正常查询可以返回哪些行，或者由数据修改命令插入，更新或删除哪些行。默认情况下，PostgreSQL 中的表是不具备任何策略的。</p>
<span id="more"></span>

<h2 id="启用行级安全策略"><a href="#启用行级安全策略" class="headerlink" title="启用行级安全策略"></a>启用行级安全策略</h2><p>基于上述问题，假设我们有如下的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> city_info (city text, people <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>默认情况下是没有启用行级安全策略，我们可以使用如下命令在该表上启用该特性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> city_info ENABLE <span class="type">ROW</span> LEVEL SECURITY;</span><br></pre></td></tr></table></figure>

<p>为了测试，我们先创建三个用户，它们分别为 <code>admin</code>, <code>chengdu</code> 以及 <code>mianyang</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE ROLE admin WITH LOGIN;</span><br><span class="line">CREATE ROLE chengdu WITH LOGIN;</span><br><span class="line">CREATE ROLE mianyang WITH LOGIN;</span><br><span class="line">ALTER TABLE city_info OWNER TO admin;</span><br></pre></td></tr></table></figure>

<p>接着，我们插入两条测试数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> city_info <span class="keyword">VALUES</span> (<span class="string">&#x27;chengdu&#x27;</span>, <span class="number">100</span>), (<span class="string">&#x27;mianyang&#x27;</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<h2 id="创建策略"><a href="#创建策略" class="headerlink" title="创建策略"></a>创建策略</h2><p>现在，我们为其创建策略使得相应的市只能访问其对应的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> POLICY city_policy <span class="keyword">ON</span> city_info <span class="keyword">USING</span> (city <span class="operator">=</span> <span class="built_in">current_user</span>);</span><br></pre></td></tr></table></figure>

<p>在创建好策略之后，我们使用 <code>chengdu</code> 用户登陆并查询数据时出现如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:  permission denied for relation city_info</span><br></pre></td></tr></table></figure>

<p>这是由于我们还没有对用户授权。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> city_info <span class="keyword">TO</span> chengdu;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> city_info <span class="keyword">TO</span> mianyang;</span><br></pre></td></tr></table></figure>

<h2 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h2><p>在授权完成之后，我们就可以查询数据了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -U chengdu postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=&gt; select * from city_info ;</span><br><span class="line">  city   | people</span><br><span class="line">---------+--------</span><br><span class="line"> chengdu |    100</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>而我们使用 <code>admin</code> 用户登陆则可以查询所有数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -U admin postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=&gt; select * from city_info ;</span><br><span class="line">   city   | people</span><br><span class="line">----------+--------</span><br><span class="line"> chengdu  |    100</span><br><span class="line"> mianyang |     80</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>当我们尝试使用 <code>mianyang</code> 用户去修改数据时只能修改其可见的数据；而原本属于 <code>chengdu</code> 用户的数据是不会被修改的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -U mianyang postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=&gt; select * from city_info ;</span><br><span class="line">   city   | people</span><br><span class="line">----------+--------</span><br><span class="line"> mianyang |     80</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=&gt; update city_info set people = 90;</span><br><span class="line">UPDATE 1</span><br><span class="line">postgres=&gt; select * from city_info ;</span><br><span class="line">   city   | people</span><br><span class="line">----------+--------</span><br><span class="line"> mianyang |     90</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.postgresql.org/docs/10/ddl-rowsecurity.html">https://www.postgresql.org/docs/10/ddl-rowsecurity.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈 PostgreSQL 行级安全策略</title>
    <url>/2020/11/postgresql-row-level-security-v2/</url>
    <content><![CDATA[<p>在 <a href="/2019/07/postgresql-row-level-security-policy/" title="PostgreSQL 行级安全策略的使用">PostgreSQL 行级安全策略的使用</a>一文中，我简要介绍了如何使用行级安全策略，最近因为工作需要对其又有了新的认识，故在此记录一下。本文主要介绍行级安全策略中用户权限和策略表达式（<code>USING</code> 和 <code>CHECK</code>）。</p>
<span id="more"></span>

<h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><p>在之前的文章中我忽略了一点关于行级安全策略的用户权限问题。默认情况下，PostgreSQL 中表的所有者是不受行级安全策略的限制的，也就是说即便表启用了行级安全策略，表的所有者也可以查询所有的数据。</p>
<p>如下所示，我们创建 <code>rls1</code> 和 <code>rls2</code> 两个用户，随后切换到 <code>rls1</code> 用户下并创建 <code>tblrls</code> 表，最后将表上的所有操作授权给 <code>rls2</code> 用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE USER rls1;</span><br><span class="line">CREATE ROLE</span><br><span class="line">postgres=# CREATE USER rls2;</span><br><span class="line">CREATE ROLE</span><br><span class="line">postgres=# \c postgres rls1</span><br><span class="line">You are now connected to database &quot;postgres&quot; as user &quot;rls1&quot;.</span><br><span class="line">postgres=&gt; CREATE TABLE tblrls (id int, value int, username text);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres=&gt; GRANT ALL ON tblrls TO rls2;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure>

<p>接着我们在表中插入数据，并新建一个行级安全策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (1, 10, &#x27;rls1&#x27;), (2, 20, &#x27;rls2&#x27;);</span><br><span class="line">INSERT 0 2</span><br><span class="line">postgres=&gt; ALTER TABLE tblrls ENABLE ROW LEVEL SECURITY ;</span><br><span class="line">ALTER TABLE</span><br><span class="line">postgres=&gt; CREATE POLICY rlsp1 ON tblrls USING ( username = current_user);</span><br><span class="line">CREATE POLICY</span><br></pre></td></tr></table></figure>

<p>此时我们查询数据，您会发现 <code>rls1</code> 用户可以查看所有数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=&gt; SELECT * FROM tblrls; -- rls1 用户</span><br><span class="line"> id | value | username</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 |    10 | rls1</span><br><span class="line">  2 |    20 | rls2</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres=&gt; \c postgres rls2</span><br><span class="line">You are now connected to database &quot;postgres&quot; as user &quot;rls2&quot;.</span><br><span class="line">postgres=&gt; SELECT * FROM tblrls ;</span><br><span class="line"> id | value | username</span><br><span class="line">----+-------+----------</span><br><span class="line">  2 |    20 | rls2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这是由于表属于 <code>rls1</code> 用户，PostgreSQL 提供了 <code>ENFORCE ROW </code> 来控制表所有者的行级安全策略行为。这里为了方便使用，我们通过超级用户登陆，并使用 <code>SET ROLE</code> 来切换用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT * FROM tblrls;</span><br><span class="line"> id | value | username</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 |    10 | rls1</span><br><span class="line">  2 |    20 | rls2</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres=&gt; ALTER TABLE tblrls FORCE ROW LEVEL SECURITY;</span><br><span class="line">ALTER TABLE</span><br><span class="line">postgres=&gt; SELECT * FROM tblrls;</span><br><span class="line"> id | value | username</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 |    10 | rls1</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=&gt; SET ROLE rls2;</span><br><span class="line">SET</span><br><span class="line">postgres=&gt; SELECT * FROM tblrls;</span><br><span class="line"> id | value | username</span><br><span class="line">----+-------+----------</span><br><span class="line">  2 |    20 | rls2</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=&gt; RESET ROLE;</span><br><span class="line">RESET</span><br><span class="line">postgres=# SELECT * FROM tblrls;</span><br><span class="line"> id | value | username</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 |    10 | rls1</span><br><span class="line">  2 |    20 | rls2</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>从上面的结果，我们可以看到，<code>FORCE ROW LEVEL SECURITY</code> 可以控制表所有者的行级安全策略行为，相应的，我们可以通过 <code>NO FORCE ROW LEVEL SECURITY</code> 来禁用表所有者的行级安全策略。在梳理这个功能的时候，我还给 PostgreSQL 提供了一个关于<a href="https://postgr.es/m/15B10F9F-5847-4F5E-BD66-8E25AA473C95@hotmail.com">行级安全策略的 psql 补全功能</a>，代码十分简单，感兴趣的可以去看看。</p>
<h2 id="策略表达式"><a href="#策略表达式" class="headerlink" title="策略表达式"></a>策略表达式</h2><p>在之前的行级安全策略中，我们都只用到了 <code>USING</code> 表达式，PostgreSQL 还支持行级安全策略中使用 <code>CHECK</code> 表达式，它们两者的用途是不一样的。</p>
<p>正如上面看到的，<code>USING</code> 表达式表明了用户可以读取哪些数据，而 <code>CHECK</code> 表达式则指明了哪些数据可以插入/更新到表中。需要注意的是，如果表没有 <code>CHECK</code> 表达式，那么它将使用 <code>USING</code> 表达式。</p>
<p>我们先来看看没有 <code>CHECK</code> 表达式时，插入违反 <code>USING</code> 表达式的示例，接上面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (3, 30, &#x27;rls2&#x27;);  -- rls1 用户</span><br><span class="line">ERROR:  new row violates row-level security policy for table &quot;tblrls&quot;</span><br></pre></td></tr></table></figure>

<p>现在，我们为其创建一个 <code>CHECK</code> 表达式，并测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=&gt; CREATE POLICY rlsp2 ON tblrls WITH CHECK ( value % 10 = 0);</span><br><span class="line">CREATE POLICY</span><br><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (4, 41, &#x27;rls2&#x27;);</span><br><span class="line">ERROR:  new row violates row-level security policy for table &quot;tblrls&quot;</span><br><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (4, 40, &#x27;rls2&#x27;);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看到，在数据插入的时候将检查 <code>CHECK</code> 和 <code>USING</code> 表达式，只要满足其中一个条件即可插入到表中。这种行为在行级安全策略中被称为 PERMISSIVE 模式，多个策略通过 OR 进行连接。</p>
<p>当然，我们也可以指定 RESTRICTIVE 模式，那么多个策略则是通过 AND 的方式进行连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=&gt; DROP POLICY rlsp2 ON tblrls;</span><br><span class="line">DROP POLICY</span><br><span class="line">postgres=&gt; CREATE POLICY rlsp2 ON tblrls AS RESTRICTIVE  WITH CHECK ( value % 10 = 0);</span><br><span class="line">CREATE POLICY</span><br><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (4, 40, &#x27;rls2&#x27;);</span><br><span class="line">ERROR:  new row violates row-level security policy for table &quot;tblrls&quot;</span><br><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (4, 41, &#x27;rls1&#x27;);</span><br><span class="line">ERROR:  new row violates row-level security policy &quot;rlsp2&quot; for table &quot;tblrls&quot;</span><br><span class="line">postgres=&gt; INSERT INTO tblrls VALUES (4, 40, &#x27;rls1&#x27;);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>

<p>注意到这里有的地方每个给出违反的策略名，而有的地方给出了违反的策略名。这是由于在使用 PERMISSIVE 时，PostgreSQL 将会在最外层（多余一个 permissive 策略时）加上一个名为 <code>NULL</code> 的 <code>WithCheckOption</code>（您可以把它理解为一个策略） 对象将多个 permissive 策略组合，其代码在 <code>src/backend/rewrite/rowsecurity.c</code> 文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add a single WithCheckOption for all the permissive policy clauses,</span></span><br><span class="line"><span class="comment">     * combining them together using OR.  This check has no policy name,</span></span><br><span class="line"><span class="comment">     * since if the check fails it means that no policy granted permission</span></span><br><span class="line"><span class="comment">     * to perform the update, rather than any particular policy being</span></span><br><span class="line"><span class="comment">     * violated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WithCheckOption *wco;</span><br><span class="line"></span><br><span class="line">    wco = makeNode(WithCheckOption);</span><br><span class="line">    wco-&gt;kind = kind;</span><br><span class="line">    wco-&gt;relname = pstrdup(RelationGetRelationName(rel));</span><br><span class="line">    wco-&gt;polname = <span class="literal">NULL</span>;</span><br><span class="line">    wco-&gt;cascaded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_length(permissive_quals) == <span class="number">1</span>)</span><br><span class="line">        wco-&gt;qual = (Node *) linitial(permissive_quals);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        wco-&gt;qual = (Node *) makeBoolExpr(OR_EXPR, permissive_quals, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ChangeVarNodes(wco-&gt;qual, <span class="number">1</span>, rt_index, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    *withCheckOptions = list_append_unique(*withCheckOptions, wco);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now add WithCheckOptions for each of the restrictive policy clauses</span></span><br><span class="line"><span class="comment">     * (which will be combined together using AND).  We use a separate</span></span><br><span class="line"><span class="comment">     * WithCheckOption for each restrictive policy to allow the policy</span></span><br><span class="line"><span class="comment">     * name to be included in error reports if the policy is violated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    foreach(item, restrictive_policies)</span><br><span class="line">    &#123;</span><br><span class="line">        RowSecurityPolicy *policy = (RowSecurityPolicy *) lfirst(item);</span><br><span class="line">        Expr       *qual = QUAL_FOR_WCO(policy);</span><br><span class="line">        WithCheckOption *wco;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qual != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qual = copyObject(qual);</span><br><span class="line">            ChangeVarNodes((Node *) qual, <span class="number">1</span>, rt_index, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            wco = makeNode(WithCheckOption);</span><br><span class="line">            wco-&gt;kind = kind;</span><br><span class="line">            wco-&gt;relname = pstrdup(RelationGetRelationName(rel));</span><br><span class="line">            wco-&gt;polname = pstrdup(policy-&gt;policy_name);</span><br><span class="line">            wco-&gt;qual = (Node *) qual;</span><br><span class="line">            wco-&gt;cascaded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            *withCheckOptions = list_append_unique(*withCheckOptions, wco);</span><br><span class="line">            *hasSubLinks |= policy-&gt;hassublinks;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/current/sql-createpolicy.html">https://www.postgresql.org/docs/current/sql-createpolicy.html</a><br>[2] <a href="https://learn.graphile.org/docs/PostgreSQL_Row_Level_Security_Infosheet.pdf">https://learn.graphile.org/docs/PostgreSQL_Row_Level_Security_Infosheet.pdf</a></p>
<div class="just-for-fun">
笑林广记 - 不准纳妾

<p>有悍妻者，颇知书。其夫谋纳妾，乃曰：“于传有之，齐人有一妻一妾。”<br>妻曰：“若尔，则我更纳一夫。”<br>其夫曰：“传有之乎？”<br>妻答曰：“河南程氏两夫。”<br>夫大笑，无以难。<br>又一妻，悍而狡，夫每言及纳妾，辄曰：“尔家贫，安所得金买妾耶？若有金，唯命。”<br>夫乃从人称贷得金，告其妻曰：“金在，请纳妾。”<br>妻遂持其金纳袖中，拜曰：“我今情愿做小罢，这金便可买我。”<br>夫无以难。</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 安全：现实中需要避免的事情</title>
    <url>/2021/08/postgresql-security-things-to-avoid-in-real-life/</url>
    <content><![CDATA[<p>强化 PostgreSQL 变得越来越重要。如今，安全是王道，人们想知道如何确保 PostgreSQL 的安全。我们中的一些人可能还记得近年来发生在 <a href="https://www.zdnet.com/article/hacker-ransoms-23k-mongodb-databases-and-threatens-to-contact-gdpr-authorities/">MongoDB 身上的事情</a>，我们当然希望在 PostgreSQL 世界中避免类似的安全问题。MongoDB 的遭遇实际上是令人震惊的：数以千计的数据库因为糟糕的默认安全设置而被勒索–这绝对是一场噩梦，不仅大大损害了 MongoDB 的声誉，也损害了整个行业的声誉。PostgreSQL 人员尽其所能避免在我们的生态系统中重复出现这种情况。</p>
<p>当有人在谈论您的公司时，标签 <code>#ransomware</code> （勒索软件）并不是您想要看到的。为了避免一些最常见的问题，我们编制了一个 “PostgreSQL 最佳安全问题”，它可以作为改进设置的 12 个步骤的指南。</p>
<span id="more"></span>

<h2 id="1-避免宽松的-listen-addresses-设置"><a href="#1-避免宽松的-listen-addresses-设置" class="headerlink" title="1. 避免宽松的 listen_addresses 设置"></a>1. 避免宽松的 <code>listen_addresses</code> 设置</h2><p>PostgreSQL 是作为一个服务器进程运行的，人们想要连接到该数据库。问题是：这些连接是从哪里来的？在 <code>postgresql.conf</code> 中可以找到 <code>listen_addresses</code> 设置，它控制着这些绑定地址。</p>
<p>换句话说：如果 <code>listen_addresses</code> 被设置为 <code>&#39;*&#39;</code>，PostgreSQL 将监听所有的网络设备，考虑这些连接并进入下一个阶段，即评估 <code>pg_hba.conf</code> 的内容。在所有设备上监听是一个问题，因为一个坏的行为者可以很容易地向您发送身份认证请求的垃圾邮件–那么灾难就只在一个 <code>pg_hba.conf</code> 条目之外。</p>
<p>建议：</p>
<ul>
<li>如果只需要本地连接：<br>设置 <code>listen_addresses = &#39;localhost&#39;</code></li>
<li>如果需要远程连接：<br>设置 <code>listen_addresses = &#39;localhost, &lt;IP of network device&gt;&#39;</code></li>
</ul>
<p>如果您根本不监听，您肯定会更安全。如果您已经限制网络访问，PostgreSQL 甚至不必拒绝您的连接。</p>
<h2 id="2-在-pg-hba-conf-中使用-trust"><a href="#2-在-pg-hba-conf-中使用-trust" class="headerlink" title="2. 在 pg_hba.conf 中使用 trust"></a>2. 在 <code>pg_hba.conf</code> 中使用 <code>trust</code></h2><p>在处理了 <code>listen_addresses (= bind addresses)</code> 之后，PostgreSQL 将处理 <code>pg_hba.conf</code> 以确定是否允许连接。出现的主要问题是：在谈论 <code>pg_hba.conf</code> 的时候，有什么可能出错？好吧，有一些事情是值得一提的。</p>
<p>我们经常看到的是，人们使用 <code>trust</code> 来确保人们无需密码即可连接到 PostgreSQL。如果您正在强化 PostgreSQL，那么使用 <code>trust</code> 基本上是最糟糕的事情。对于本地连接，<code>peer</code> 可能是一个有效的选择—— <code>trust</code> 当然不是。</p>
<p>建议：</p>
<ul>
<li>如果您正在强化 PostgreSQL，请不要使用 <code>trust</code>（尤其不要用于远程连接）。</li>
<li>改用 <code>scram-sha-256</code> 和 <code>SSL</code>。</li>
<li>如果可能的话，尽量避免允许来自任何地方的连接的条目（网络掩码 <code>0.0.0.0/0</code>）。相反，将访问限制在那些真正需要访问的主机和子网中。</li>
<li>不要创建允许连接到所有数据库或所有用户的 <code>pg_hba.conf</code> 条目。要有针对性。</li>
<li>为文件中的每一行添加文档，以便您知道为什么需要该权限，谁要求的，以及在需要时与谁联系。否则，您几乎没有机会清理和删除不再需要的条目。此外，如果需要修改密码，您知道该与谁联系。</li>
</ul>
<h2 id="3-摆脱-PostgreSQL-中的-md5-密码"><a href="#3-摆脱-PostgreSQL-中的-md5-密码" class="headerlink" title="3. 摆脱 PostgreSQL 中的 md5 密码"></a>3. 摆脱 PostgreSQL 中的 <code>md5</code> 密码</h2><p>许多年来，<code>md5</code> 是 PostgreSQL 中进行密码验证的首选方法。然而，<code>md5</code> 的时代早已过去。你甚至可以从网上下载包含最常用的哈希值的现成文件，破解密码的速度更快。</p>
<p>换句话说：忘记 <code>md5</code>，转而使用更强的哈希算法。如果您想知道如何从 <code>md5</code> 迁移到 <code>scram-sha-256</code>，请确保您<a href="https://www.cybertec-postgresql.com/en/from-md5-to-scram-sha-256-in-postgresql/">查看我们的帖子“在 PostgreSQL 中从 MD5 到 scram-sha-256”</a>。</p>
<p>建议：</p>
<ul>
<li>使用 <code>scram-sha-256</code> 替代 <code>md5</code></li>
</ul>
<h2 id="4-处理模式和数据库的-PUBLIC-权限"><a href="#4-处理模式和数据库的-PUBLIC-权限" class="headerlink" title="4. 处理模式和数据库的 PUBLIC 权限"></a>4. 处理模式和数据库的 <code>PUBLIC</code> 权限</h2><p>在 PostgreSQL 中，有一个东西叫做 <code>PUBLIC</code>。它基本上相当于数据库中的 “UNIX世界”。正如您将看到的，它可能会引起一些问题–然而，这些问题是可以避免的。</p>
<p>以下是通常发生的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE USER joe;</span><br><span class="line">CREATE ROLE</span><br><span class="line">postgres=# \c postgres joe</span><br><span class="line">You are now connected to database &quot;postgres&quot; as user &quot;joe&quot;.</span><br><span class="line">postgres=&gt; SELECT current_user;</span><br><span class="line">current_user</span><br><span class="line">--------------</span><br><span class="line">joe</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>我们已经创建了一个用户，并以 <code>joe</code> 的身份登录。我们在这里看到的是，<code>joe</code> 不被允许创建一个新的数据库，这正是我们所期望的。但是：<code>joe</code> 被允许连接到其他一些我们甚至至今都没有听说过的数据库。幸运的是，<code>joe</code> 不被允许读取这个数据库中的任何对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=&gt; CREATE DATABASE joedb;</span><br><span class="line">ERROR: permission denied to create database</span><br><span class="line">postgres=&gt; \c demo</span><br><span class="line">You are now connected to database &quot;demo&quot; as user &quot;joe&quot;.</span><br><span class="line">demo=&gt; SELECT * FROM t_demo;</span><br><span class="line">ERROR: permission denied for table t_demo</span><br></pre></td></tr></table></figure>

<p>但是，默认情况下允许 <code>joe</code> 创建表（<code>public</code> 模式），这当然不是一个好主意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo=&gt; CREATE TABLE bad_idea (id int);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>

<p>因此，我们确定了两个关键问题：</p>
<ul>
<li>允许 <code>joe</code> 连接到其他数据库</li>
<li><code>joe</code> 被允许向 <code>public</code> 模式发送垃圾（译者注：实际上就是创建一些对象，例如表）</li>
</ul>
<p>这比乍看之下更糟糕。经验表明，多年来在 PostgreSQL 中发现的大多数特权升级攻击载体都是通过在数据库中创建恶意对象来实现的。</p>
<p>所以，我们必须修复它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo=# REVOKE ALL ON DATABASE demo FROM public;</span><br><span class="line">REVOKE</span><br><span class="line">demo=# REVOKE ALL ON SCHEMA public FROM public;</span><br><span class="line">REVOKE</span><br></pre></td></tr></table></figure>

<p>现在我们已经做到了，我们可以以 <code>joe</code> 的身份重新连接到演示数据库。在 psql 中，我们可以使用 <code>\c</code> 命令来做这件事。如果你使用的是图形用户界面，只需改变你的数据库连接并以用户 <code>joe</code> 的身份登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo=# \c demo joe</span><br><span class="line">FATAL: permission denied for database &quot;demo&quot;</span><br><span class="line">DETAIL: User does not have CONNECT privilege.</span><br><span class="line">Previous connection kept</span><br></pre></td></tr></table></figure>

<p>首先，我们已经撤销了 <code>PUBLIC</code> 的权限，以确保数据库连接不再可行。然后我们修复 <code>public</code> 模式固定的权限。如您所见，连接不再可能。</p>
<p>建议：</p>
<ul>
<li>从您的数据库权限中删除 <code>PUBLIC</code> 权限</li>
<li>从您的 <code>public</code> 模式中移除 <code>PUBLIC</code> 权限</li>
</ul>
<p>从所有不需要临时权限的用户处撤销数据库上的临时权限也是一个好主意。某些权限提升攻击也适用于临时对象。此外，确保正确测试设置，以确保没有泄漏。</p>
<h2 id="5-避免-ALTER-USER-SET-PASSWORD"><a href="#5-避免-ALTER-USER-SET-PASSWORD" class="headerlink" title="5. 避免 ALTER USER ... SET PASSWORD ..."></a>5. 避免 <code>ALTER USER ... SET PASSWORD ...</code></h2><p>在 PostgreSQL 中更改密码很容易。大多数人使用 <code>ALTER USER ... SET PASSWORD</code> 来做到这一点。但是，有一个问题：这条 SQL 语句最终会以 PLAIN 文本形式出现在您的数据库日志中，这当然是一个主要问题。</p>
<p>建议：</p>
<ul>
<li>使用受信任的 PostgreSQL 客户端设施更改密码，而不是 <code>ALERT ROLE</code>。例如，psql具有 <code>\password</code>，pgAdmin 具有“更改密码”对话框。</li>
</ul>
<p>这项建议似乎很荒谬。然而，这背后有一些道理。要更改密码，可以通过协议支持绕过日志中的纯文本密码问题。通过直观地执行操作，而不是通过简单的 SQL，大多数 GUI 将为您解决问题。</p>
<p><strong>提示：</strong> <a href="https://www.cybertec-postgresql.com/en/products/cybertec-postgresql-enterprise-edition/">CYBERTEC PostgreSQL 企业版 (PGEE)</a> 甚至明确禁止 <code>ALTER USER ... SET PASSWORD</code> 以避免日志流中的风险密码。</p>
<h2 id="6-使用-ALTER-DEFAULT-PRIVILEGES"><a href="#6-使用-ALTER-DEFAULT-PRIVILEGES" class="headerlink" title="6. 使用 ALTER DEFAULT PRIVILEGES"></a>6. 使用 <code>ALTER DEFAULT PRIVILEGES</code></h2><p>假设您正在运行一个应用程序。您的数据库包含 200 个表。权限是为无数用户完美设置的。假设我们想要更新这个应用程序，以便执行 DDL 来进行更改。但是如果有人犯了错误怎么办？如果权限设置不正确怎么办？小问题将开始积累。</p>
<p>此问题的解决方案是 <code>ALTER DEFAULT PRIVILEGES</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo=# \h ALTER DEFAULT</span><br><span class="line">Command: ALTER DEFAULT PRIVILEGES</span><br><span class="line">Description: define default access privileges</span><br><span class="line">Syntax:</span><br><span class="line">ALTER DEFAULT PRIVILEGES</span><br><span class="line">[ FOR &#123; ROLE | USER &#125; target_role [, ...] ]</span><br><span class="line">[ IN SCHEMA schema_name [, ...] ]</span><br><span class="line">abbreviated_grant_or_revoke</span><br><span class="line"></span><br><span class="line">where abbreviated_grant_or_revoke is one of:</span><br><span class="line"></span><br><span class="line">GRANT &#123; &#123; SELECT | INSERT | UPDATE | DELETE |</span><br><span class="line">TRUNCATE | REFERENCES | TRIGGER &#125;</span><br><span class="line">[, ...] | ALL [ PRIVILEGES ] &#125;</span><br><span class="line">ON TABLES</span><br><span class="line">TO &#123; [ GROUP ] role_name | PUBLIC &#125; [, ...]</span><br><span class="line">[ WITH GRANT OPTION ]</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>其思想是在创建对象之后不久就定义默认权限。无论何时创建数据库对象，默认权限都会自动生效并为您解决问题。在这种情况下，PostgreSQL 将通过自动设置新对象的权限，大大简化强化过程。</p>
<p><strong>译者注：</strong> 这里的原文是 <code>The idea is to define default permissions long before objects are created.</code>，可能翻译的不是很准确。</p>
<h2 id="7-使用-SSL"><a href="#7-使用-SSL" class="headerlink" title="7. 使用 SSL"></a>7. 使用 SSL</h2><p>SSL 是 PostgreSQL 安全领域中最重要的主题之一。如果您想强化 PostgreSQL 数据库，则无法绕过 SSL。</p>
<p>PostgreSQL 提供各种级别的 SSL，并允许您加密客户端和服务器之间的连接。通常，我们建议至少使用 <a href="https://www.cybertec-postgresql.com/en/tls-demystifying-communication-encryption-in-postgresql/">TLS</a> 1.2 以确保足够高的安全级别。</p>
<p>如果您想了解有关 SSL 的更多信息，并想知道如何设置它，请<a href="https://www.cybertec-postgresql.com/en/setting-up-ssl-authentication-for-postgresql/">查看我们的页面</a>。</p>
<h2 id="8-安全地编写-SECURITY-DEFINER-函数"><a href="#8-安全地编写-SECURITY-DEFINER-函数" class="headerlink" title="8. 安全地编写 SECURITY DEFINER 函数"></a>8. 安全地编写 <code>SECURITY DEFINER</code> 函数</h2><p>存储过程和服务器端功能通常是一个主要的安全问题。 PostgreSQL 中有两种执行函数的方式：</p>
<ul>
<li>以“你是谁”的身份执行函数</li>
<li>以代码作者身份执行函数</li>
</ul>
<p>默认情况下，函数以当前用户身份执行。换句话说：如果您当前是 <code>joe</code> 用户，该函数将作为 <code>joe</code> 运行。但是，有时以函数的作者身份运行代码，从而使用不同的安全设置会很有用。这样，您可以让具有低权限的用户以受控方式执行某些需要提升权限的操作。这样做的方法是在创建函数时使用 <code>SECURITY DEFINER</code> 选项。</p>
<p>但是强大的工具也很危险，因此您必须仔细定义这些功能。有关详细信息，请阅读我们关于 <a href="https://www.cybertec-postgresql.com/en/abusing-security-definer-functions/">SECURITY DEFINER 函数</a>的文章。</p>
<h2 id="9-避免数据库函数中的-SQL-注入"><a href="#9-避免数据库函数中的-SQL-注入" class="headerlink" title="9. 避免数据库函数中的 SQL 注入"></a>9. 避免数据库函数中的 SQL 注入</h2><p>SQL 注入不仅是应用程序（客户端）端的问题，它还会影响数据库中的过程代码。如果您想避免 SQL 注入，我们建议您继续阅读并了解更多信息。</p>
<p>考虑这个愚蠢的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION tally(table_name text) RETURNS bigint</span><br><span class="line">LANGUAGE plpgsql AS</span><br><span class="line">$$DECLARE</span><br><span class="line">result bigint;</span><br><span class="line">BEGIN</span><br><span class="line">EXECUTE &#x27;SELECT count(*) FROM &#x27; || table_name</span><br><span class="line">INTO result;</span><br><span class="line">RETURN result;</span><br><span class="line">END;$$;</span><br></pre></td></tr></table></figure>

<p>现在，任何可以控制提供给函数的参数的攻击者都可以发起拒绝服务攻击：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tally(<span class="string">&#x27;generate_series(1, 100000000000000000000)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>或者他们可以找出您帐户上的金额：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tally(<span class="string">&#x27;generate_series(1, 1000000)</span></span><br><span class="line"><span class="string">UNION</span></span><br><span class="line"><span class="string">SELECT amount::bigint FROM account WHERE name = &#x27;&#x27;loser&#x27;&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>使用通常的安全预防措施：</p>
<ul>
<li>仅在必要时使用动态 SQL。</li>
<li>仅在必要时将字符串数据类型用于参数。</li>
<li>始终使用 <code>format()</code> 来构造 SQL 查询字符串。</li>
</ul>
<h2 id="10-尽可能限制超级用户访问"><a href="#10-尽可能限制超级用户访问" class="headerlink" title="10. 尽可能限制超级用户访问"></a>10. 尽可能限制超级用户访问</h2><p>如果对安全关键系统具有管理访问权限的人数尽可能少，那总是好的。您想要走多远取决于您的安全需求：</p>
<ul>
<li>加固数据库机器，以便除数据库管理员之外的任何人都无法获得对机器的 shell 访问权限。任何作为 PostgreSQL 操作系统用户具有 shell 访问权限的人都可以完全控制数据库。</li>
<li>为管理员使用个性化的超级用户帐户，以便您可以在需要时快速撤销对管理员的访问权限。</li>
<li>仅在真正需要的地方使用超级用户。例如，复制连接或备份不需要超级用户。</li>
<li>使用 <code>pg_hba.conf</code> 中的超级用户帐户限制访问。理想情况下，只允许本地连接。如果您不想这样做，请限制对管理员个人系统的访问。</li>
<li>对于非常高的安全要求，请确保没有人知道超级用户密码，并将其放在至少只能由两个人打开的保险箱中。每次使用后更改密码。</li>
</ul>
<p>一般来说，使用超级用户是危险的。</p>
<p>建议：</p>
<ul>
<li>永远不要以超级用户身份运行应用程序</li>
<li>尽可能限制超级用户</li>
</ul>
<h2 id="11-定期更新您的-PostgreSQL-数据库"><a href="#11-定期更新您的-PostgreSQL-数据库" class="headerlink" title="11. 定期更新您的 PostgreSQL 数据库"></a>11. 定期更新您的 PostgreSQL 数据库</h2><p>最后，定期更新 PostgreSQL 很重要。请记住，大多数次要版本更新（例如 13.0 -&gt; 13.2 等）都带有与安全相关的更新，这些更新对于减少系统的攻击面至关重要。</p>
<p>PostgreSQL 会定期提供安全更新，我们建议您尽快应用它们。</p>
<h2 id="12-加密整个服务器：PostgreSQL-TDE"><a href="#12-加密整个服务器：PostgreSQL-TDE" class="headerlink" title="12. 加密整个服务器：PostgreSQL TDE"></a>12. 加密整个服务器：PostgreSQL TDE</h2><p>到目前为止，您已经学习了如何加密客户端和服务器之间的连接。但是，有时需要对包括存储在内的整个服务器进行加密。 PostgreSQL TDE 正是这样做的：</p>
<img src="/2021/08/postgresql-security-things-to-avoid-in-real-life/tde-architecture.png" class="">

<p>要了解更多信息，请查看我们关于 <a href="https://www.cybertec-postgresql.com/en/products/postgresql-transparent-data-encryption/">PostgreSQL TDE</a> 的网站。我们提供完全加密的堆栈来帮助您实现最大的 PostgreSQL 安全性。TDE 可免费使用（开源）。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>物化视图是包括 PostgreSQL 在内的大多数数据库的重要特性。它们可以帮助加速大型计算——或者至少可以缓存它们。</p>
<p>如果您想确保<a href="https://www.cybertec-postgresql.com/en/pg_timetable-asynchronous-chain-execution/">您的物化视图是最新的</a>，如果您现在想阅读更多关于 PostgreSQL 的信息，请查看我们关于 <a href="https://www.cybertec-postgresql.com/en/?s=pg_timetable">pg_timetable 的博客</a>，该博客向您展示了如何在 PostgreSQL 中安排作业。为什么 <a href="https://www.cybertec-postgresql.com/en/products/pg_timetable/">pg_timetable</a> 如此有用？我们的调度程序确保相同的作业不能重叠，但如果相同的作业已经在运行，就不再执行。当您运行长作业时，这一点非常重要——特别是如果您想要使用物化视图的话。</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><ul>
<li>本文本文翻译自 Hans-Jürgen Schönig 的 <a href="https://www.cybertec-postgresql.com/en/postgresql-security-things-to-avoid-in-real-life/">POSTGRESQL SECURITY: THINGS TO AVOID IN REAL LIFE</a>。</li>
</ul>
<div class="just-for-fun">
笑林广记 - 糊涂

<p>一青盲人涉讼，自诉眼瞎。<br>官曰：“你明明一双清白眼，如何诈瞎。”<br>答曰：“老爷看小人是清白的，小人看老爷却是糊涂得紧。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 安全性配置概要</title>
    <url>/2021/05/postgresql-security/</url>
    <content><![CDATA[<p>本文从网络、数据库实例、数据库、schema 和表对象几个层面对 PostgreSQL 数据库的安全性配置进行了简要的回顾。</p>
<img src="/2021/05/postgresql-security/pg_security.png" class="">

<span id="more"></span>

<h2 id="网络安全性"><a href="#网络安全性" class="headerlink" title="网络安全性"></a>网络安全性</h2><h3 id="监听地址"><a href="#监听地址" class="headerlink" title="监听地址"></a>监听地址</h3><ul>
<li>unix socket<br>通常 unix socket 方式要比 localhost 的性能要好。</li>
<li>TCP/IP<br><code>listen_addresses</code>和 <code>port</code> 两个参数。<br><code>listen_addresses</code> 可以有多个 IP 地址，使用逗号分割。<ul>
<li>localhost</li>
<li>ip address</li>
</ul>
</li>
</ul>
<h3 id="pg-hba"><a href="#pg-hba" class="headerlink" title="pg_hba"></a>pg_hba</h3><p>pg_hba 用于告知 PostgreSQL 如何认证用户的连接。格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local      DATABASE USER         METHOD [OPTIONS]</span><br><span class="line">host       DATABASE USER ADDRESS METHOD [OPTIONS]</span><br><span class="line">hostssl    DATABASE USER ADDRESS METHOD [OPTIONS]</span><br><span class="line">hostnossl  DATABASE USER ADDRESS METHOD [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>第一条规则匹配后续，后续规则将不予判断。</p>
<ul>
<li><p>rules</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>local</td>
<td>用来配置本地 unix 套接字。</td>
</tr>
<tr>
<td>host</td>
<td>用于配置 SSL 和非 SSL 连接。</td>
</tr>
<tr>
<td>hostssl</td>
<td>仅用于配置 SSL 连接。必须编译有 SSL，并且 <code>ssl = on</code>，此外还需要配置以下参数 <code>ssl_cert_file</code> 和 <code>ssl_key_file</code>。</td>
</tr>
<tr>
<td>hostnossl</td>
<td>配置非 SSL 连接。</td>
</tr>
</tbody></table>
</li>
<li><p>methods</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trust</td>
<td>允许不提供密码的认证，PostgreSQL 数据库中需要有对应的用户。</td>
</tr>
<tr>
<td>reject</td>
<td>拒绝连接。</td>
</tr>
<tr>
<td>md5/password</td>
<td>通过口令进行连接。md5 意味着口令在传输时被加密；password 以明文的形式发送（不建议这种方案）。</td>
</tr>
<tr>
<td>GSS/SSPI</td>
<td>GSSAPI 或 SSPI 认证，针对 TCP/IP 连接。</td>
</tr>
<tr>
<td>ident</td>
<td>通过联系客户端上的 Ident 服务器获得客户端的操作系统用户名，并且检查它是否匹配被请求的数据库用户名。</td>
</tr>
<tr>
<td>peer</td>
<td>只对本地连接有用。</td>
</tr>
<tr>
<td>pam</td>
<td>使用可插拔认证模块（PAM），对于使用非 PostgreSQL 自带的认证方式非常有用。</td>
</tr>
<tr>
<td>ldap</td>
<td>使用轻量级目录访问协议（LDAP）进行认证。</td>
</tr>
<tr>
<td>radius</td>
<td>远程认证拨入用户服务（RADIUS）。</td>
</tr>
<tr>
<td>cert</td>
<td>使用 SSL 客户端证书来执行认证，只用使用 SSL 才能使用它。</td>
</tr>
</tbody></table>
<p><strong>备注：</strong></p>
<ol>
<li>SSPI (Security Support Provider Interface) 是微软 Windows 操作系统中用于执行各种安全相关操作（如身份认证）的一个 Win32 API。</li>
<li>RADIUS 是一种用于在需要认证其链接的网络访问服务器（NAS）和共享认证服务器之间进行认证、授权和记帐信息的文档协议。RADIUS 服务器负责接收用户的连接请求、认证用户，然后返回客户机所有必要的配置信息以将服务发送到用户。</li>
</ol>
</li>
</ul>
<h2 id="实例级安全"><a href="#实例级安全" class="headerlink" title="实例级安全"></a>实例级安全</h2><h3 id="CREATE-USER-ROLE"><a href="#CREATE-USER-ROLE" class="headerlink" title="CREATE USER/ROLE"></a>CREATE USER/ROLE</h3><p><code>CREATE USER</code> 和 <code>CREATE ROLE</code> 的区别仅仅是 <code>CREATE USER</code> 默认具有 <code>LOGIN</code> 权限，而 <code>CREATE ROLE</code> 默认为 <code>NOLOGIN</code> 权限，即通过 <code>CREATE ROLE</code> 创建的用户如果没有指定 <code>LOGIN</code>，那么是无法用于登录数据库的。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SUPERUSER/NOSUPERUSER</td>
<td>是否为超级用户。</td>
</tr>
<tr>
<td>CREATEDB/NOCREATEDB</td>
<td>是否可以创建数据库。</td>
</tr>
<tr>
<td>CREATEROLE/NOCREATEROLE</td>
<td>是否可以创建角色/用户。</td>
</tr>
<tr>
<td>INHERIT/NOINHERIT</td>
<td>是否可以被继承。</td>
</tr>
<tr>
<td>LOGIN/NOLOGIN</td>
<td>是否可以登录数据库。</td>
</tr>
<tr>
<td>REPLICATION/NOREPLICATION</td>
<td>是否用于流复制。</td>
</tr>
<tr>
<td>BYPASSRLS/NOBYPASSRLS</td>
<td>是否可以绕过行级安全策略。</td>
</tr>
<tr>
<td>CONNECTIOIN LIMIT</td>
<td>用户最大连接数量。在设置 CONNECTIONS LIMIT 时，可以指定其值大于 <code>max_connections</code>。</td>
</tr>
<tr>
<td>ENCRYPTED/UNENCRYPTED PASSWORD</td>
<td>是否加密密码。UNENCRYPTED PASSWORD 在测试的时候可能很有用。</td>
</tr>
<tr>
<td>VALID UNTIL</td>
<td>设置用户有效期。</td>
</tr>
</tbody></table>
<h3 id="ALTER-USER-ROLE"><a href="#ALTER-USER-ROLE" class="headerlink" title="ALTER USER/ROLE"></a>ALTER USER/ROLE</h3><ul>
<li>OPTIONS<br>修改 <code>CREATE USER/ROLE</code> 时指定的选项。</li>
<li>PARAMETERS<br>设置参数。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ALTE ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125;</span><br><span class="line">  [ <span class="keyword">IN</span> DATABASE database_name ]</span><br><span class="line">  <span class="keyword">SET</span> configuration_parameter &#123; <span class="keyword">TO</span> <span class="operator">|</span> <span class="operator">=</span> &#125; &#123; <span class="keyword">value</span> <span class="operator">|</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125;</span><br><span class="line">  [ <span class="keyword">IN</span> DATABASE database_name ]</span><br><span class="line">  <span class="keyword">SET</span> configuration_parameter <span class="keyword">FROM</span> <span class="keyword">CURRENT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125;</span><br><span class="line">  [ <span class="keyword">IN</span> DATABASE database_name ]</span><br><span class="line">  RESET configuration_parameter</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> ROLE &#123; role_specification <span class="operator">|</span> <span class="keyword">ALL</span> &#125;</span><br><span class="line">  [ <span class="keyword">IN</span> DATABASE database_name ] RESET <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据库级安全"><a href="#数据库级安全" class="headerlink" title="数据库级安全"></a>数据库级安全</h2><h3 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h3><p>允许用户在数据库中创建 <code>schema</code>，注意，授权了数据库的 <code>CREATE </code>权限仅仅表示用户可以在数据库中创建 <code>schema</code>，而其他对象则不能创建，例如，表、视图、函数等。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>允许某个用户连接到数据库。</p>
<h3 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h3><p>如果没有指定，那么默认的权限来自 <code>public</code>。注意 <code>public</code> 不是一个角色。<br>通常建议在其他数据库创建之前就从 postgres 数据库中收回权限是。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REVOCK <span class="keyword">ALL</span> <span class="keyword">ON</span> DATABASE dbname <span class="keyword">FROM</span> public;</span><br></pre></td></tr></table></figure>

<h2 id="Schema-级安全"><a href="#Schema-级安全" class="headerlink" title="Schema 级安全"></a>Schema 级安全</h2><p>默认情况下，<code>public</code> 被允许使用 <code>public</code> 模式。</p>
<p>当我们在数据库上只有 <code>CONNECT</code> 权限时，我们可以在 <code>public</code> 模式下建表。</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE</td>
<td>用户可以在该模式下创建对象，对对象进行修改。例如，ALTER TABLE。</td>
</tr>
<tr>
<td>USAGE</td>
<td>用户可以进入该模式，但是能否使用该模式下的对象，还有下层的权限进行控制，例如对表的增、删、查、改等。</td>
</tr>
</tbody></table>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123; &#123; <span class="keyword">SELECT</span> <span class="operator">|</span> UPDATE &#125; [, ...] <span class="operator">|</span> <span class="keyword">ALL</span> [ PRIVILEGES ] &#125;</span><br><span class="line">    <span class="keyword">ON</span> <span class="type">LARGE OBJECT</span> loid [, ...]</span><br><span class="line">    <span class="keyword">TO</span> role_specification [, ...] [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION ]</span><br><span class="line">    [ GRANTED <span class="keyword">BY</span> role_specification ]</span><br></pre></td></tr></table></figure>

<h2 id="表级安全"><a href="#表级安全" class="headerlink" title="表级安全"></a>表级安全</h2><h3 id="表权限"><a href="#表权限" class="headerlink" title="表权限"></a>表权限</h3><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>允许用户读取表的内容。</td>
</tr>
<tr>
<td>INSERT</td>
<td>允许用户向表中插入数据，注意如果是带有 RETURNING 子句的还需要 SELECT 权限。</td>
</tr>
<tr>
<td>UPDATE</td>
<td>允许用户对表进行更新。</td>
</tr>
<tr>
<td>DELETE</td>
<td>允许用户删除表中的行记录。</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>允许用户对表执行 TRUNCATE 命令。TRUNCATE 和 DELETE 是两种独立的权限，这是因为 TRUNCATE 会锁表，而 DELETE 语句则不会。</td>
</tr>
<tr>
<td>REFERENCES</td>
<td>允许用户创建外键，必须在引用和被引用列上都有这一特权，否则无法创建。</td>
</tr>
<tr>
<td>TRIGGER</td>
<td>允许用户在该表上创建触发器。</td>
</tr>
</tbody></table>
<h3 id="列级安全"><a href="#列级安全" class="headerlink" title="列级安全"></a>列级安全</h3><p>限制用户对不同列的访问。显示授权：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> (id) <span class="keyword">ON</span> t_useful <span class="keyword">TO</span> paul;</span><br></pre></td></tr></table></figure>

<h2 id="行级安全策略"><a href="#行级安全策略" class="headerlink" title="行级安全策略"></a>行级安全策略</h2><p>限制不同用户对不同数据行的查看权限。</p>
<h3 id="启用-禁用"><a href="#启用-禁用" class="headerlink" title="启用/禁用"></a>启用/禁用</h3><p>默认情况下，表的所有者不受行级安全策略的限制，我们可以通过 <code>FORCE ROW LEVEL SECURITY</code> 来明确表明所有者也需要验证行级安全策略。相关命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE <span class="type">ROW</span> LEVEL SECURITY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE <span class="type">ROW</span> LEVEL SECURITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name FORCE <span class="type">ROW</span> LEVEL SECURITY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">NO</span> FORCE <span class="type">ROW</span> LEVEL SECURITY;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 超级用户始终不受行级安全策略限制。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>多个策略之间使用 <code>OR</code> 进行连接。</p>
<ul>
<li>创建<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> POLICY name <span class="keyword">ON</span> table_name</span><br><span class="line">    [ <span class="keyword">AS</span> &#123; PERMISSIVE <span class="operator">|</span> RESTRICTIVE &#125; ]</span><br><span class="line">    [ <span class="keyword">FOR</span> &#123; <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">|</span> <span class="keyword">INSERT</span> <span class="operator">|</span> UPDATE <span class="operator">|</span> <span class="keyword">DELETE</span> &#125; ]</span><br><span class="line">    [ <span class="keyword">TO</span> &#123; role_name <span class="operator">|</span> PUBLIC <span class="operator">|</span> <span class="built_in">CURRENT_ROLE</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> <span class="operator">|</span> <span class="built_in">SESSION_USER</span> &#125; [, ...] ]</span><br><span class="line">    [ <span class="keyword">USING</span> ( using_expression ) ]</span><br><span class="line">    [ <span class="keyword">WITH</span> <span class="keyword">CHECK</span> ( check_expression ) ]</span><br></pre></td></tr></table></figure>
<ul>
<li>USING<br>过滤已经存在的行记录，与 <code>SELECT</code> 和 <code>UPDATE</code> 子句相关。</li>
<li>CHECK<br>过滤将要被创建的新行，与 <code>INSERT</code> 和 <code>UPDATE</code> 子句相关。</li>
</ul>
</li>
<li>删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> POLICY [ IF <span class="keyword">EXISTS</span> ] name <span class="keyword">ON</span> table_name [ CASCADE <span class="operator">|</span> RESTRICT ]</span><br></pre></td></tr></table></figure></li>
<li>修改<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> POLICY name <span class="keyword">ON</span> table_name RENAME <span class="keyword">TO</span> new_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> POLICY name <span class="keyword">ON</span> table_name</span><br><span class="line">    [ <span class="keyword">TO</span> &#123; role_name <span class="operator">|</span> PUBLIC <span class="operator">|</span> <span class="built_in">CURRENT_ROLE</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> <span class="operator">|</span> <span class="built_in">SESSION_USER</span> &#125; [, ...] ]</span><br><span class="line">    [ <span class="keyword">USING</span> ( using_expression ) ]</span><br><span class="line">    [ <span class="keyword">WITH</span> <span class="keyword">CHECK</span> ( check_expression ) ]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h2><p>主要是针对数据库对象。PostgreSQL 目前还没有提供很好的权限查询功能。</p>
<h3 id="psql"><a href="#psql" class="headerlink" title="psql"></a>psql</h3><p>在 psql 中我们可以通过 <code>\z</code> 命令来查看表、视图和序列的权限，同 <code>\dp </code>命令。</p>
<h3 id="aclexplode"><a href="#aclexplode" class="headerlink" title="aclexplode"></a>aclexplode</h3><p>通过 aclexplode() 函数来查看，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aclexplode(<span class="string">&#x27;&#123;joe=arwdDxt/postgres&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>标识</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>追加，用于 INSERT 子句。</td>
</tr>
<tr>
<td>r</td>
<td>读取，用于 SELECT 子句。</td>
</tr>
<tr>
<td>w</td>
<td>写入，用于 UPDATE 子句。</td>
</tr>
<tr>
<td>d</td>
<td>删除，用于 DELETE 子句。</td>
</tr>
<tr>
<td>D</td>
<td>用于 TRUNCATE 子句。</td>
</tr>
<tr>
<td>x</td>
<td>用于引用。</td>
</tr>
<tr>
<td>t</td>
<td>用于触发器。</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 《由浅入深PostgreSQL》</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 使用存储过程发送邮件</title>
    <url>/2021/11/postgresql-send-email-using-procedure/</url>
    <content><![CDATA[<p>在<a href="/2021/11/postgresql-send-http-using-procedure/" title="上一篇">上一篇</a>中我介绍了如何在 PostgreSQL 数据库中使用存储过程来发送 HTTP 请求，本文则介绍如何使用 PostgreSQL 的存储过程发送邮件。</p>
<p>Oracle 数据库提供了 ult_smtp 来发送邮件，PostgreSQL 同样的不支持该功能，因此只能采取曲线救国的策略，本文将采用 plpython3u 来编写存储过程并发送邮件。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这里的准备工作与上一篇文章类似，唯一不同的是我们不需要装任何 Python 的依赖，因为 Python 默认已经安装好了。这里简要提一下如何在数据库中安装 plpython3u 插件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ psql postgres <span class="operator">-</span>c <span class="string">&#x27;ALTER SYSTEM SET shared_preload_libraries TO plpython3;&#x27;</span></span><br><span class="line">$ pg_ctl restart</span><br><span class="line">$ psql postgres <span class="operator">-</span>c <span class="string">&#x27;CREATE EXTENSION plpython3u;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写存储过程发送邮件"><a href="#编写存储过程发送邮件" class="headerlink" title="编写存储过程发送邮件"></a>编写存储过程发送邮件</h2><p>准备工作已经就绪，接下来就可以编译存储过程了。下面是一个简单的用例。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> send_email(</span><br><span class="line">    sender      <span class="type">varchar</span>,</span><br><span class="line">    receiver    <span class="type">varchar</span>,</span><br><span class="line">    copyto      <span class="type">varchar</span>,</span><br><span class="line">    title       <span class="type">varchar</span>,</span><br><span class="line">    content     <span class="type">varchar</span>,</span><br><span class="line">    filenames   <span class="type">varchar</span>,</span><br><span class="line">    smtp_user   <span class="type">varchar</span> <span class="keyword">default</span> <span class="string">&#x27;japinli@hotmail.com&#x27;</span>,</span><br><span class="line">    smtp_passwd <span class="type">varchar</span> <span class="keyword">default</span> <span class="string">&#x27;your-password&#x27;</span>,</span><br><span class="line">    smtp_server <span class="type">varchar</span> <span class="keyword">default</span> <span class="string">&#x27;outlook.office365.com&#x27;</span>,</span><br><span class="line">    smtp_port   <span class="type">int</span> <span class="keyword">default</span> <span class="number">587</span>)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import ssl</span><br><span class="line">import smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text import MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header import Header</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart import MIMEMultipart</span><br><span class="line"></span><br><span class="line">message <span class="operator">=</span> MIMEMultipart()</span><br><span class="line">message[<span class="string">&#x27;From&#x27;</span>] <span class="operator">=</span> sender</span><br><span class="line">message[<span class="string">&#x27;To&#x27;</span>] <span class="operator">=</span> receiver</span><br><span class="line">message[<span class="string">&#x27;Cc&#x27;</span>] <span class="operator">=</span> copyto</span><br><span class="line">message[<span class="string">&#x27;Subject&#x27;</span>] <span class="operator">=</span> title</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    message.attach(MIMEText(content, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    # <span class="keyword">Add</span> attachement <span class="keyword">to</span> email</span><br><span class="line">    if filenames:</span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> filenames.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">            if <span class="keyword">not</span> fname:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            attach <span class="operator">=</span> MIMEText(<span class="keyword">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>).read(), <span class="string">&#x27;base64&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            attach[<span class="string">&#x27;Content-Type&#x27;</span>] <span class="operator">=</span> <span class="string">&#x27;application/octect-stream&#x27;</span></span><br><span class="line">            attach[<span class="string">&#x27;Content-Disposition&#x27;</span>] <span class="operator">=</span> <span class="string">&#x27;attachement;filename=&quot;&#123;0&#125;&quot;&#x27;</span>.format(os.path.basename(fname))</span><br><span class="line">            message.attach(attach)</span><br><span class="line"></span><br><span class="line">    context <span class="operator">=</span> ssl.create_default_context()</span><br><span class="line">    rcpts <span class="operator">=</span> receiver.split(<span class="string">&#x27;,&#x27;</span>) <span class="operator">+</span> copyto.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    serv <span class="operator">=</span> smtplib.SMTP(smtp_server, smtp_port)</span><br><span class="line">    serv.starttls(context<span class="operator">=</span>context)</span><br><span class="line">    serv.login(smtp_user, smtp_passwd)</span><br><span class="line">    serv.sendmail(sender, rcpts, message.as_string())</span><br><span class="line">    plpy.<span class="built_in">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    plpy.error(<span class="string">&#x27;failed&#x27;</span> <span class="operator">+</span> str(e))</span><br><span class="line"></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpython3u;</span><br></pre></td></tr></table></figure>

<p>您可以将上面的存储过程导入到已经安装了 plpython3u 插件的数据库中（注意，您需要修改邮件服务器和用户信息）。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们可以使用下面的命令进行测试。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> send_email(</span><br><span class="line">    <span class="string">&#x27;japinli@hotmail.com&#x27;</span>,     <span class="comment">-- 发送者</span></span><br><span class="line">    <span class="string">&#x27;jianping.li@xxxxx.cn&#x27;</span>,    <span class="comment">-- 接收者</span></span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,                        <span class="comment">-- 抄送</span></span><br><span class="line">    <span class="string">&#x27;Send Email using PostgreSQL Procedure&#x27;</span>,      <span class="comment">-- 邮件主题</span></span><br><span class="line">    <span class="string">&#x27;This email is sent by PostgreSQL procedure&#x27;</span>, <span class="comment">-- 邮件内容</span></span><br><span class="line">    <span class="string">&#x27;/tmp/scor2272ueR&#x27;</span>                            <span class="comment">-- 附件</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>测试结果如下所示。</p>
<img src="/2021/11/postgresql-send-email-using-procedure/email.jpg" class="">

<div class="just-for-fun">
笑林广记 - 太监观风

<p>镇守太监观风，出“后生可畏焉”为题，众皆掩口而笑，乃问其故，<br>教官禀曰：“诸生以题目太难，求减得一字为好。”<br>乃笑曰：“既如此，除了‘后’字，只做‘生可畏焉’罢。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 使用存储过程发送 HTTP 请求</title>
    <url>/2021/11/postgresql-send-http-using-procedure/</url>
    <content><![CDATA[<p>在 Oracle 中可以通过 utl_http 来发送 HTTP 请求，PostgreSQL 中默认不支持，但是，我们可以通过 plpython3u 插件来实现这个功能。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们需要安装 plpython3u 扩展，在编译 PostgreSQL 的时候加上 <code>--with-python</code> 选项，随后将其添加到 <code>shared_preload_libraries</code> 中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> shared_preload_libraries <span class="keyword">TO</span> plpython3;</span><br></pre></td></tr></table></figure>

<p>注意，我们在编译的时候需要安装 python3-devel 包。</p>
<p>接着重启数据库并以超级用户登录执行下面的命令在数据库中安装扩展（我们需要在使用到该功能的数据库中安装该插件）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION plpython3u;</span><br></pre></td></tr></table></figure>

<p>在使用 Python 编写 PostgreSQL 存储过程发送 HTTP 请求时，我们使用到了 Python 的 requests 模块，因此需要先安装 requests 模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip3 install requests</span></span><br></pre></td></tr></table></figure>

<h2 id="编写存储过程发送-HTTP-请求"><a href="#编写存储过程发送-HTTP-请求" class="headerlink" title="编写存储过程发送 HTTP 请求"></a>编写存储过程发送 HTTP 请求</h2><p>现在一切工作准备就绪，我们可以通过 Python 来编写 PostgreSQL 的存储过程了，下面是一个简单的用例。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> http_post(</span><br><span class="line">    <span class="keyword">in</span>    p_url      <span class="type">varchar</span>,</span><br><span class="line">    <span class="keyword">in</span>    p_token    <span class="type">varchar</span>,</span><br><span class="line">    <span class="keyword">in</span>    p_postdata text,</span><br><span class="line">    <span class="keyword">inout</span> x_status   <span class="type">varchar</span>,</span><br><span class="line">    <span class="keyword">inout</span> x_response text)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">    plpy.<span class="built_in">log</span>(<span class="string">&#x27;start post&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    import requests</span><br><span class="line"></span><br><span class="line">    plpy.<span class="built_in">log</span>(<span class="string">&#x27;set_header&#x27;</span>)</span><br><span class="line">    headers <span class="operator">=</span> &#123;<span class="string">&#x27;charset&#x27;</span>: <span class="string">&#x27;utf8&#x27;</span>&#125;</span><br><span class="line">    headers[<span class="string">&#x27;Content-Type&#x27;</span>] <span class="operator">=</span> <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"></span><br><span class="line">    l_token <span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    if p_token:</span><br><span class="line">        l_token <span class="operator">=</span> <span class="string">&#x27;Bearer &#x27;</span> <span class="operator">+</span> p_token</span><br><span class="line">        headers[<span class="string">&#x27;Authorization&#x27;</span>] <span class="operator">=</span> l_token</span><br><span class="line">    plpy.<span class="built_in">log</span>(l_token)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        r <span class="operator">=</span> requests.post(p_url, p_postdata, headers<span class="operator">=</span>headers, timeout<span class="operator">=</span><span class="number">300</span>)</span><br><span class="line">        if r.status_code <span class="operator">=</span><span class="operator">=</span> <span class="number">200</span>:</span><br><span class="line">            x_status <span class="operator">=</span> <span class="string">&#x27;200&#x27;</span></span><br><span class="line">            x_response <span class="operator">=</span> r.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x_status <span class="operator">=</span> <span class="string">&#x27;400&#x27;</span></span><br><span class="line">            x_response <span class="operator">=</span> <span class="string">&#x27;Access Denied&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        x_status <span class="operator">=</span> <span class="string">&#x27;500&#x27;</span></span><br><span class="line">        x_response <span class="operator">=</span> str(e)</span><br><span class="line">        plpy.<span class="built_in">log</span>(str(e))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x_status, x_response)</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpython3u;</span><br></pre></td></tr></table></figure>

<p>我们可以将存储过程的执行权限赋予特定用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">EXECUTE</span> <span class="keyword">ON</span> <span class="keyword">PROCEDURE</span> http_post <span class="keyword">TO</span> username;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们通过 Python 创建一个简单的 HTTP 服务器，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python2</span></span><br><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span>(<span class="params">SimpleHTTPServer.SimpleHTTPRequestHandler</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span>(<span class="params">self</span>):</span></span><br><span class="line">        content_len = <span class="built_in">int</span>(self.headers.getheader(<span class="string">&#x27;content-length&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">        post_body = self.rfile.read(content_len)</span><br><span class="line">        <span class="built_in">print</span> post_body</span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(<span class="string">&#x27;&#123;&quot;data&quot;: &quot;It works!&quot;&#125;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">Handler = ServerHandler</span><br><span class="line"></span><br><span class="line">httpd = SocketServer.TCPServer((<span class="string">&quot;&quot;</span>, PORT), Handler)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;serving at :&quot;</span>, PORT</span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<p>我们将上面的内容保存到 <code>httpd.py</code> 中，并赋予执行权限，随后在 psql 中执行下面的 SQL 来进行测试。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DO $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    code <span class="type">varchar</span>;</span><br><span class="line">    resp text;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">CALL</span> http_post(<span class="string">&#x27;http://localhost:8000&#x27;</span>, <span class="string">&#x27;xxxxx&#x27;</span>, <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Jim&quot;&#125;&#x27;</span>, code, resp);</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;%: %&#x27;</span>, code, resp;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/13/plpython.html">https://www.postgresql.org/docs/13/plpython.html</a></p>
<div class="just-for-fun">
笑林广记 - 衙官隐语

<p>衙官聚会，各问何职。<br>一官曰：“随常茶饭掇将来，盖义取现成（县丞）也。”<br>一官曰：“滚汤锅里下文书，乃煮（主）簿也。”<br>一官曰：“乡下蛮子租粪窖。”<br>问者不解，答曰：“典屎（史同音）也。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 12 流复制配置</title>
    <url>/2020/02/postgresql-stream-replication/</url>
    <content><![CDATA[<p>PostgreSQL 12 的流复制与之前的版本有所不同，主要有以下几点区别：</p>
<ol>
<li>PG12 将原有的属于 <code>recovery.conf</code> 配置文件中配置项迁移到了 <code>postgresql.conf</code> 文件中，在新系统中如果存在 <code>recovery.conf</code> 文件，数据库将无法启动；</li>
<li>文件 <code>recovery.signal</code> 和 <code>standby.signal</code> 用于切换数据库为非主（non-primary）模式；</li>
<li><code>trigger_file</code> 被修改为 <code>promote_trigger_file</code>，<del>并且只能在 <code>postgresql.conf</code></del> 可在配置文件或服务器命令行进行配置；</li>
<li>最后，<code>standby_mode</code> 参数被移除了。</li>
</ol>
<p>详细说明请<a href="https://www.postgresql.org/docs/12/release-12.html">移步官网</a>。本文将在 Ubuntu 18.04 LTS 下搭建 PG12 的流复制系统。</p>
<span id="more"></span>

<h2 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h2><p>我们在主节点下载 PostgreSQL 12.2 源码，并采用如下命名进行编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=<span class="variable">$HOME</span>/pg12.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j 4 &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p>随后将其拷贝到从节点。为了方便我们可以先配置环境变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HOME</span>/pg12.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;<span class="string">END &gt; pg12.2-env.sh</span></span></span><br><span class="line">export PGHOME=$PWD</span><br><span class="line">export PGDATA=\$PGHOME/pgdata</span><br><span class="line">export PATH=\$PGHOME/bin:\$PATH</span><br><span class="line">export LD_LIBRARY_PATH=\$PGHOME/lib:\$LD_LIBRARY_PATH</span><br><span class="line">END</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string"> source pg12.2-env.sh</span></span></span><br></pre></td></tr></table></figure>

<p>我们接下来将在主节点 192.168.56.3 和从节点 192.168.56.101 上搭建 PostgreSQL 流复制。</p>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>在主节点上初始化并启动数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> initdb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l <span class="built_in">log</span> start</span></span><br></pre></td></tr></table></figure>

<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>接着，我们需要修改监听地址，当修改之后需要重启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psql -c <span class="string">&quot;ALTER SYSTEM SET listen_addresses TO &#x27;*&#x27;&quot;</span> postgres</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l <span class="built_in">log</span> restart</span></span><br></pre></td></tr></table></figure>
<p>我们可以不必在主节点上设置任何其他参数来进行简单的复制设置，因为默认设置已经适用。</p>
<p>现在，我们需要一个用户用于流复制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psql -c <span class="string">&quot;CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD &#x27;P@ssw0rd&#x27;&quot;</span> postgres</span></span><br></pre></td></tr></table></figure>

<p>最后，我们需要配置连接以便从节点可以连接主节点进行复制，我需要修改 <code>pg_hba.conf</code> 配置文件。如果我们允许故障切换，那么可能还需要主节点可以连接从节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;host replication replicator 192.168.56.0/24 md5&quot;</span> &gt;&gt; <span class="variable">$PGDATA</span>/pg_hba.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> psql -c <span class="string">&quot;SELECT pg_reload_conf()&quot;</span> postgres</span></span><br></pre></td></tr></table></figure>

<h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><p>现在，我们可以在从节点使用 <code>pg_basebackup</code> 来做一个主库的基础备份。当我们创建备份时可以指定 <code>-R</code> 选项在数据目录中生成特定于复制的文件和配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> <span class="variable">$HOME</span>/pg12.2/pg12.2-env.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -h 192.168.56.3 -U replicator -D <span class="variable">$PGDATA</span> -R -Fp -Xs -P</span></span><br><span class="line">Password:</span><br><span class="line">23652/23652 kB (100%), 1/1 tablespace</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls <span class="variable">$PGDATA</span></span></span><br><span class="line">PG_VERSION    pg_commit_ts   pg_logical    pg_serial     pg_subtrans  pg_xact</span><br><span class="line">backup_label  pg_dynshmem    pg_multixact  pg_snapshots  pg_tblspc    postgresql.auto.conf</span><br><span class="line">base          pg_hba.conf    pg_notify     pg_stat       pg_twophase  postgresql.conf</span><br><span class="line">global        pg_ident.conf  pg_replslot   pg_stat_tmp   pg_wal       standby.signal</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="variable">$PGDATA</span>/postgresql.auto.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Do not edit this file manually!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It will be overwritten by the ALTER SYSTEM <span class="built_in">command</span>.</span></span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br><span class="line">primary_conninfo = &#x27;user=replicator password=&#x27;&#x27;P@ssw0rd&#x27;&#x27; host=192.168.56.3 port=5432 sslmode=disable sslcompression=0 gssencmode=disable krbsrvname=postgres target_session_attrs=any&#x27;</span><br></pre></td></tr></table></figure>

<p>从下面我们可以看到，备库有一个名为 <code>standby.signal</code> 的文件，该文件没有任何内容，它仅仅是用于 PostgreSQL 确定其状态。如果该文件不存在，我们应该在备库上创建该文件。</p>
<p>此外，我们还需要注意到 <code>postgresql.auto.conf</code> 文件中的 <code>primary_conninfo</code> 参数，该参数在 PG12 之前是存放在 <code>recovery.conf</code> 文件中，并且还有一个参数 <code>standby_mode = on</code>。</p>
<h2 id="启动备库"><a href="#启动备库" class="headerlink" title="启动备库"></a>启动备库</h2><p>现在我们使用下面的命令启动备库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl -l <span class="built_in">log</span> start</span></span><br></pre></td></tr></table></figure>

<p>我们可以在主库上查看流复制相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# \x</span><br><span class="line">Expanded display is on.</span><br><span class="line">postgres=# select * from pg_stat_replication ;</span><br><span class="line">-[ RECORD 1 ]----+------------------------------</span><br><span class="line">pid              | 31970</span><br><span class="line">usesysid         | 16385</span><br><span class="line">usename          | replicator</span><br><span class="line">application_name | walreceiver</span><br><span class="line">client_addr      | 192.168.56.101</span><br><span class="line">client_hostname  |</span><br><span class="line">client_port      | 60384</span><br><span class="line">backend_start    | 2020-02-19 23:07:21.410168+08</span><br><span class="line">backend_xmin     |</span><br><span class="line">state            | streaming</span><br><span class="line">sent_lsn         | 0/3000148</span><br><span class="line">write_lsn        | 0/3000148</span><br><span class="line">flush_lsn        | 0/3000148</span><br><span class="line">replay_lsn       | 0/3000148</span><br><span class="line">write_lag        |</span><br><span class="line">flush_lag        |</span><br><span class="line">replay_lag       |</span><br><span class="line">sync_priority    | 0</span><br><span class="line">sync_state       | async</span><br><span class="line">reply_time       | 2020-02-19 23:07:31.644624+08</span><br></pre></td></tr></table></figure>

<p>我们可以看到，默认情况下 PG 采用异步复制。</p>
<h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>我们接下来可以修改 <code>synchronous_standby_names</code> 从而使从节点由异步节点改变为同步节点。首先我们在主节点上做如下改变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -c &quot;ALTER SYSTEM SET synchronous_standby_names TO &#x27;standby&#x27;&quot; postgres</span><br><span class="line">$ psql -c &quot;SELECT pg_reload_conf()&quot; postgres</span><br></pre></td></tr></table></figure>

<p>接着，在从节点修改 <code>primary_conninfo</code> 参数，并在其中加入 <code>application_name=standby</code>，并重启，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat $PGDATA/postgresql.auto.conf</span><br><span class="line"># Do not edit this file manually!</span><br><span class="line"># It will be overwritten by the ALTER SYSTEM command.</span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br><span class="line">primary_conninfo = &#x27;user=replicator password=&#x27;&#x27;P@ssw0rd&#x27;&#x27; host=192.168.56.3 port=5432 sslmode=disable sslcompression=0 gssencmode=disable krbsrvname=postgres target_session_attrs=any application_name=standby&#x27;</span><br><span class="line"></span><br><span class="line">$ pg_ctl -l log restart</span><br></pre></td></tr></table></figure>

<p>接下来我们可以在主节点进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select * from pg_stat_replication ;</span><br><span class="line">-[ RECORD 1 ]----+------------------------------</span><br><span class="line">pid              | 32052</span><br><span class="line">usesysid         | 16385</span><br><span class="line">usename          | replicator</span><br><span class="line">application_name | standby</span><br><span class="line">client_addr      | 192.168.56.101</span><br><span class="line">client_hostname  |</span><br><span class="line">client_port      | 60386</span><br><span class="line">backend_start    | 2020-02-19 23:18:30.358057+08</span><br><span class="line">backend_xmin     |</span><br><span class="line">state            | streaming</span><br><span class="line">sent_lsn         | 0/3025410</span><br><span class="line">write_lsn        | 0/3025410</span><br><span class="line">flush_lsn        | 0/3025410</span><br><span class="line">replay_lsn       | 0/3025410</span><br><span class="line">write_lag        | 00:00:00.001529</span><br><span class="line">flush_lag        | 00:00:00.001529</span><br><span class="line">replay_lag       | 00:00:00.001529</span><br><span class="line">sync_priority    | 1</span><br><span class="line">sync_state       | sync</span><br><span class="line">reply_time       | 2020-02-19 23:18:30.480227+08</span><br></pre></td></tr></table></figure>

<h2 id="提升从节点"><a href="#提升从节点" class="headerlink" title="提升从节点"></a>提升从节点</h2><p>当主节点掉线时，我们可能希望将从节点提升为主节点，此时，我们需要使用到 <code>promote_trigger_file</code> 参数。</p>
<p>首先，我们在主节点和从节点看看它们各自的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ postgres=# select pg_is_in_recovery();  -- 主节点</span><br><span class="line"> pg_is_in_recovery</span><br><span class="line">-------------------</span><br><span class="line"> f</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select pg_is_in_recovery();    -- 从节点</span><br><span class="line"> pg_is_in_recovery</span><br><span class="line">-------------------</span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>接着，我们在从节点的 <code>postgresql.conf</code> 文件中加入 <code>promote_trigger_file=/tmp/.tfile</code> 配置，这是，当主节点掉线时，我们在从节点创建 <code>/tmp/.tfile</code> 文件，那么从节点将自动提升为主。</p>
<p>如果我们在主节点没有掉线的情况下，创建了 <code>/tmp/.tfile</code> 这个触发文件，那么此时从节点将创建一个新的时间线，从而导致主从不一致。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/12/release-12.html">https://www.postgresql.org/docs/12/release-12.html</a><br>[2] <a href="https://www.postgresql.org/docs/12/runtime-config-replication.html#GUC-PROMOTE-TRIGGER-FILE">https://www.postgresql.org/docs/12/runtime-config-replication.html#GUC-PROMOTE-TRIGGER-FILE</a><br>[3] <a href="https://www.percona.com/blog/2019/10/11/how-to-set-up-streaming-replication-in-postgresql-12/">https://www.percona.com/blog/2019/10/11/how-to-set-up-streaming-replication-in-postgresql-12/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 常用命令集合</title>
    <url>/2018/12/postgresql-skills/</url>
    <content><![CDATA[<p>本文主要收集日常工作中经常使用的 PostgreSQL 相关的命令；其中，主要包含相关的系统函数、使用技巧等。本文将持续更新！！！</p>
<p><strong>备注：</strong> 主要基于 PostgreSQL 10 及其后续版本。</p>
<span id="more"></span>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li><p>查看数据库大小</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_database_size(&#x27;table_name&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据表大小</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_relation_size(&#x27;table_name&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据表大小</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_table_size(&#x27;table_name&#x27;);</span><br></pre></td></tr></table></figure>

<p>  <strong>注意：</strong> <code>pg_relation_size</code> 与 <code>pg_table_size</code> 的区别在于 <code>pg_table_size</code> 将获取数据表的 TOAST 表、空闲空间映射表 (FSM) 和可见性表 (但不包括索引表) 的大小；而 <code>pg_relation_size</code> 可以跟一个 fork 类型的参数 (可取的值为 main, fsm, vm, init) 来获取关系表的部分数据大小，默认为 main 类型，此外 <code>pg_relation_size</code> 也可以用于获取索引表的大小。</p>
</li>
<li><p>获取数据表大小 (包括索引和 TOAST 表)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_total_relation_size(&#x27;table_name&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>将数据转为易于人们阅读的格式</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_size_pretty(pg_relation_size(&#x27;table_name&#x27;));</span><br></pre></td></tr></table></figure></li>
<li><p>查看对应的表空间的路径</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_tablespace_location(oid);</span><br></pre></td></tr></table></figure>

<p>  其中，<code>oid</code> 为表空间的对象 ID。我们可以通过 <code>SELECT oid FROM pg_tablespace;</code> 来查询获得。</p>
</li>
<li><p>查看表对应的文件路径</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_relation_filepath(oid);</span><br></pre></td></tr></table></figure></li>
<li><p>获取当前事务 ID 编号</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT txid_current();</span><br></pre></td></tr></table></figure></li>
<li><p>获取当前 WAL 日志的写入位置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_current_wal_lsn();          -- version 10 or later</span><br><span class="line">SELECT pg_current_xlog_location();    -- before version 10</span><br></pre></td></tr></table></figure></li>
<li><p>获取当前 WAL 日志的插入位置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_current_wal_insert_lsn();          -- version 10 or later</span><br><span class="line">SELECT pg_current_xlog_insert_location();    -- before version 10</span><br></pre></td></tr></table></figure></li>
<li><p>获取日志所在的 WAL 日志文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT pg_walfile_name(lsn);     -- version 10 or later</span><br><span class="line">SELECT pg_xlogfile_name(lsn);    -- before version 10</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li><p><code>max_wal_size (integer)</code></p>
<p>  该参数指定 WAL 日志做 CHECKPOINT 时的最大的 WAL 日志大小。该参数不是强制性的限制，在某些特殊情况下可能会超过该值，例如 <code>archive_command</code> 命令失败或者过高的 <code>wal_keep_segments</code>。若该参数设置过高会影响系统崩溃时的恢复时间。</p>
</li>
<li><p><code>min_wal_size (integer)</code></p>
<p>  主要 WAL 日志的磁盘使用率低于此设置，那么旧的 WAL 日志文件将被回收用于后续的 CHECKPOINT 使用。它可以确保有足够的磁盘空间来存放 WAL 日志记录。</p>
</li>
<li><p><code>checkpoint_completion_target (floating point)</code></p>
<p>  该参数指定 CHECKPOINT 完成的目标，作为 CHECKPOINT 之间的总时间的一部分。该参数可以用于缓解两个 CHECKPOINT 之间的 I/O 负载。</p>
</li>
</ul>
<h3 id="psql-使用"><a href="#psql-使用" class="headerlink" title="psql 使用"></a>psql 使用</h3><ul>
<li><p>查看 <code>\d</code> 以及其他反斜杠命令对应的 SQL 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -E</span><br><span class="line">-----------------------------</span><br><span class="line">postgres=# \set ECHO_HIDDEN on</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul>
<li><p>oid2name</p>
<p>  该工具可以方便的查看数据库对象与 OID 的关系。我们可以通过如下方式查看数据库的 OID。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oid2name</span></span><br><span class="line">All databases:</span><br><span class="line">    Oid  Database Name  Tablespace</span><br><span class="line">----------------------------------</span><br><span class="line">  12405       postgres  pg_default</span><br><span class="line">  12404      template0  pg_default</span><br><span class="line">      1      template1  pg_default</span><br></pre></td></tr></table></figure>

<p>  此外，我们也可以通过该命令查看表的 filenode。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oid2name -d postgres -t foo</span></span><br><span class="line">From database &quot;postgres&quot;:</span><br><span class="line">  Filenode  Table Name</span><br><span class="line">----------------------</span><br><span class="line">     16466         foo</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li><p>查询数据库事务提交率</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> xact_commit::<span class="type">float</span> <span class="operator">/</span> (xact_commit <span class="operator">+</span> xact_rollback) <span class="keyword">AS</span> xact_commit_rate</span><br><span class="line"><span class="keyword">FROM</span> pg_stat_database <span class="keyword">WHERE</span> datname <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查询数据库缓存命中率</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> blks_hit::<span class="type">float</span> <span class="operator">/</span> (blks_hit <span class="operator">+</span> blks_read) <span class="keyword">AS</span> blks_hit_rate</span><br><span class="line"><span class="keyword">FROM</span> pg_stat_database <span class="keyword">WHERE</span> datname <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.postgresql.org/docs/current/functions-admin.html">https://www.postgresql.org/docs/current/functions-admin.html</a><br>[2] <a href="https://www.postgresql.org/docs/current/app-psql.html">https://www.postgresql.org/docs/current/app-psql.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 子事务日志管理器</title>
    <url>/2022/09/postgresql-subtrans/</url>
    <content><![CDATA[<p>本文简要记录一下 PostgreSQL 中有关子事务相关的处理，PostgreSQL 中子事务（<code>pg_subtrans</code>）的管理与事务管理（<code>pg_xact</code>）类似，它存储了每个事务的父事务 ID。它是实现嵌套事务的基本组成部分。主事务（即顶层事务）的父事务 ID 为 <code>InvalidTransactionId</code>，每个子事务都有其直接的父事务 ID。因此，我们可以通过子事务遍历很容易找到父事务 ID，反之则不然。</p>
<p><code>pg_subtrans</code> 只记录当前已打开的事务，因此无需为崩溃或重启持久化数据。在重启时，PostgreSQL 会将当前获取的页面清零。</p>
<span id="more"></span>

<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p>PostgreSQL 将 <code>pg_subtrans</code> 目录下的文件视为一个 hash 表，可以通过事务的 ID 快速获取其直接的父事务 ID，通过这种方式一直往上遍历可以获取到主事务 ID。</p>
<p>PostgreSQL 将子事务信息按页面进行分块，并且 32 个页面组成一个段文件（即磁盘文件）。由于事务 ID 是 32 位无符号数，因此每个页面可以存储 <code>BLKSZ / sizeof(TransactionId)</code> 个事务的信息。如下图所示，我们采用 8K 的页面，则每个页面可以存储 <code>8192 / 4 = 2048</code> 个事务的信息。例如当前事务 ID 为 741，则我们可以通过 <code>741 * 4 = 0x00000b94</code> 得到其父事务 ID 为 <code>0x000002e4 = 740</code>，同样地，我们可以得到 740 的父事务 ID 为 739，而 739 的父事务 ID 为 0，即 739 是一个主事务，其关系为 <code>741 -&gt; 740 -&gt; 739</code>。</p>
<img src="/2022/09/postgresql-subtrans/subtrans-layout.png" class="">

<p>上面的计算中我们忽略了页面编号的计算，<a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/subtrans.c#L51">子事务管理器提供了 <code>TransactionIdToPage</code> 和 <code>TransactionIdToEntry</code> 宏来帮助计算页面号和页面偏移量</a>，其定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We need four bytes per xact. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)</span></span><br></pre></td></tr></table></figure>

<h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><p>PostgreSQL 使用子事务来实现 <a href="https://www.postgresql.org/docs/14/sql-savepoint.html"><code>SAVEPOINT</code></a> 功能，内部则使用<a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L183"><code>TransactionStateData</code></a> 结构来描述事务的状态。下面将结合实际情况分析一下子事务的工作原理。首先，使用下面的命令创建示例表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl(id <span class="type">int</span>, info text);</span><br></pre></td></tr></table></figure>

<p>当我们使用 <a href="https://www.postgresql.org/docs/14/sql-begin.html"><code>BEGIN</code></a> 开启事务时，它将调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L3665"><code>BeginTransactionBlock()</code></a> 函数将 <code>TransactionState-&gt;blockState</code> 设置为 <code>TBLOCK_BEGIN</code> 用以表明我们正式进入一个事务块，当执行完 <a href="https://www.postgresql.org/docs/14/sql-begin.html"><code>BEGIN</code></a> 时，<a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/tcop/postgres.c#L2714"><code>finish_xact_command()</code></a> 函数将调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L2956"><code>CommitTransactionCommand</code></a> 函数切换 <code>TransactionState-&gt;blockState</code> 状态为 <code>TBLOCK_INPROCESS</code> 以表明我们事务块正在运行中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec_simple_query</span><br><span class="line">  +-&gt; PortalRun</span><br><span class="line">  |     +-&gt; PortalRunMulti</span><br><span class="line">  |            +-&gt; PortalRunUtility</span><br><span class="line">  |                  +-&gt; ProcessUtility</span><br><span class="line">  |                        +-&gt; standard_ProcessUtility</span><br><span class="line">  |                              +-&gt; BeginTransactionBlock  (TBLOCK_STARTED =&gt; TBLOCK_BEGIN)</span><br><span class="line">  +-&gt; finish_xact_command</span><br><span class="line">        +-&gt; CommitTransactionCommand  (TBLOCK_START =&gt; TBLOCK_INPROCESS)</span><br></pre></td></tr></table></figure>

<p>现在我们在执行下面的语句插入一条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于这是当前事务中的第一次修改，因此，<a href="https://github.com/postgres/postgres/blob/REL_14_5//src/backend/access/heap/heapam.c#L2069"><code>heap_insert()</code></a> 函数将调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L431"><code>GetCurrentTransactionId()</code></a> 来获取一个事务 ID，如果当前事务已经分配了事务 ID，则直接返回，否则调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L560"><code>AssignTransactionId()</code></a> 分配一个新的事务 ID（需要在 <code>XidGenLock</code> 获得 <code>LW_EXCLUSIVE</code> 锁），并保存到 <code>TransactionState-&gt;fullTransactionId</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec_simple_query</span><br><span class="line">  +-&gt; PortalRun</span><br><span class="line">  |     +-&gt; [...]</span><br><span class="line">  |           +-&gt; ExecModifyTable</span><br><span class="line">  |                 +-&gt; ExecInsert</span><br><span class="line">  |                       +-&gt; table_tuple_insert</span><br><span class="line">  |                             +-&gt; heapam_tuple_insert</span><br><span class="line">  |                                   +-&gt; heap_insert</span><br><span class="line">  |                                         +-&gt; GetCurrentTransactionId</span><br><span class="line">  |                                               +-&gt; AssignTransactionid</span><br><span class="line">  |                                                     +-&gt; GetNewTransactionId  (requires LW_EXCLUSIVE on XidGenLock)</span><br><span class="line">  +-&gt; finish_xact_command</span><br><span class="line">        +-&gt; CommitTransactionCommand</span><br><span class="line">              +-&gt; CommandCounterIncrement</span><br></pre></td></tr></table></figure>

<p>接下来，我们通过 <code>SAVEPOINT s1</code> 创建一个子事务（保存点），函数 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L4114"><code>DefineSavepoint()</code></a> 将t通过 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L5142"><code>PushTransactoin()</code></a> 函数新建一个子事务状态对象，并将当前的事务对象压栈，随后，将新建的子事务对象设置为当前事务对象。当执行完 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L4114"><code>DefineSavepoint()</code></a> 函数之后，其事务状态信息如下图所示：</p>
<img src="/2022/09/postgresql-subtrans/subtrans-savepoint1.png" class="">

<p><strong>注意：</strong> PostgreSQL 一个事务最大支持 <code>2^32 - 1</code> 个子事务。</p>
<p>紧接着，<code>SAVEPOINT s1</code> 语句完成需要调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L2956"><code>CommitTransactionCommand</code></a> 函数提交，由于当前需要开启子事务，因此 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L2956"><code>CommitTransactionCommand</code></a> 函数将调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L4799"><code>StartSubTransaction()</code></a> 函数进入到子事务状态。最后，事务状态信息如下图所示：</p>
<img src="/2022/09/postgresql-subtrans/subtrans-savepoint2.png" class="">

<p><a href="https://www.postgresql.org/docs/14/sql-savepoint.html"><code>SAVEPOINT</code></a> 语句的执行流程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec_simple_query</span><br><span class="line">  +-&gt; PortalRun</span><br><span class="line">  |     +-&gt; PortalRunMulti</span><br><span class="line">  |            +-&gt; PortalRunUtility</span><br><span class="line">  |                  +-&gt; ProcessUtility</span><br><span class="line">  |                        +-&gt; standard_ProcessUtility</span><br><span class="line">  |                              +-&gt; DefineSavepoint</span><br><span class="line">  |                                    +-&gt; PushTransaction</span><br><span class="line">  +-&gt; finish_xact_command</span><br><span class="line">        +-&gt; CommitTransactionCommand</span><br><span class="line">              +-&gt; StartSubtransaction</span><br></pre></td></tr></table></figure>

<p>现在，我们下面的语句在子事务中插入一条记录新的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其整体的执行流程与主事务的大致相同，不同在于获取事务 ID 之后的处理方式。当前事务状态的父事务不为空，因此，该事务为子事务，在调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/varsup.c#L37"><code>GetNewTransactionId()</code></a> 获得事务 ID 之后，它将调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/subtrans.c#L70"><code>SubTransSetParent()</code></a> 函数在 <code>pg_subtrans</code> 中记录父事务的事务 ID。当执行完插入后，事务状态信息如下图所示（更新了子事务状态的 <code>FullTransactionId</code> 字段）：</p>
<img src="/2022/09/postgresql-subtrans/subtrans-savepoint3.png" class="">

<p>其执行流程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec_simple_query</span><br><span class="line">  +-&gt; PortalRun</span><br><span class="line">  |     +-&gt; [...]</span><br><span class="line">  |           +-&gt; ExecModifyTable</span><br><span class="line">  |                 +-&gt; ExecInsert</span><br><span class="line">  |                       +-&gt; table_tuple_insert</span><br><span class="line">  |                             +-&gt; heapam_tuple_insert</span><br><span class="line">  |                                   +-&gt; heap_insert</span><br><span class="line">  |                                         +-&gt; GetCurrentTransactionId</span><br><span class="line">  |                                               +-&gt; AssignTransactionid</span><br><span class="line">  |                                                     +-&gt; GetNewTransactionId  (requires LW_EXCLUSIVE on XidGenLock)</span><br><span class="line">  |                                                     +-&gt; SubTransSetParent  (update pg_subtrans information)</span><br><span class="line">  +-&gt; finish_xact_command</span><br><span class="line">        +-&gt; CommitTransactionCommand</span><br><span class="line">              +-&gt; CommandCounterIncrement</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/subtrans.c#L70"><code>SubTransSetParent()</code></a> 函数为每个子事务记录其直接父事务的事务 ID，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Record the parent of a subtransaction in the subtrans log.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">SubTransSetParent</span><span class="params">(TransactionId xid, TransactionId parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>			pageno = TransactionIdToPage(xid);</span><br><span class="line">	<span class="keyword">int</span>			entryno = TransactionIdToEntry(xid);</span><br><span class="line">	<span class="keyword">int</span>			slotno;</span><br><span class="line">	TransactionId *ptr;</span><br><span class="line"></span><br><span class="line">	Assert(TransactionIdIsValid(parent));</span><br><span class="line">	Assert(TransactionIdFollows(xid, parent));</span><br><span class="line"></span><br><span class="line">	LWLockAcquire(SubtransSLRULock, LW_EXCLUSIVE);</span><br><span class="line"></span><br><span class="line">	slotno = SimpleLruReadPage(SubTransCtl, pageno, <span class="literal">true</span>, xid);</span><br><span class="line">	ptr = (TransactionId *) SubTransCtl-&gt;shared-&gt;page_buffer[slotno];</span><br><span class="line">	ptr += entryno;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It&#x27;s possible we&#x27;ll try to set the parent xid multiple times but we</span></span><br><span class="line"><span class="comment">	 * shouldn&#x27;t ever be changing the xid from one valid xid to another valid</span></span><br><span class="line"><span class="comment">	 * xid, which would corrupt the data structure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*ptr != parent)</span><br><span class="line">	&#123;</span><br><span class="line">		Assert(*ptr == InvalidTransactionId);</span><br><span class="line">		*ptr = parent;</span><br><span class="line">		SubTransCtl-&gt;shared-&gt;page_dirty[slotno] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LWLockRelease(SubtransSLRULock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它根据子事务的 ID 获取到对应的页面编号和页内偏移，随后读取相应的页面并将父事务 ID 写入，此时的信息仅在共享内存中，通过 <a href="https://www.postgresql.org/docs/14/sql-checkpoint.html"><code>CHECKPOINT</code></a> 可以将其刷盘。</p>
<p>最后，我们来看看事务的提交过程，当我们执行 <a href="https://www.postgresql.org/docs/14/sql-commit.html"><code>COMMIT</code></a> 时，其执行流程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec_simple_query</span><br><span class="line">  +-&gt; finish_xact_command</span><br><span class="line">        +-&gt; CommitTransactionCommand</span><br><span class="line">              +-&gt; CommitSubTransaction</span><br><span class="line">                    +-&gt; PopTransaction</span><br><span class="line">              +-&gt; CommitTransaction</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L2956"><code>CommitTransactionCommand</code></a> 函数将循环执行 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L4842"><code>CommitSubTransaction()</code></a> 函数来提交子事务；随后，如果是需要提交主事务，则调用 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L2069"><code>CommitTransaction()</code></a> 函数进行提交（这里面涉及到了 WAL 日志以及 CLOG 相关的更新，感兴趣的朋友可以去看看）主事务。</p>
<p>如果我们执行 <a href="https://github.com/postgres/postgres/blob/REL_14_5/src/backend/access/transam/xact.c#L2069"><code>CHECKPOINT</code></a>，那么我们在 <code>$PGDATA/pg_subtrans</code> 目录下可以看到上述子事务的相关信息。</p>
<!--
$ hexdump -C 0000
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000b80  00 00 00 00 00 00 00 00  d7 02 00 00 00 00 00 00  |................|
00000b90  e3 02 00 00 e4 02 00 00  00 00 00 00 00 00 00 00  |................|
00000ba0  00 00 00 00 00 00 00 00  e9 02 00 00 00 00 00 00  |................|
00000bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000bc0  00 00 00 00 00 00 00 00  ee 02 00 00 00 00 00 00  |................|
00000bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00002000
-->

<img src="/2022/09/postgresql-subtrans/subtrans-page-dump.png" class="">

<p><code>0x00000bc8</code> 对应的事务 ID 为 <code>int(0xbc8) / 4 = 754</code>，而他的父事务 ID 为 <code>0x02ee = 750</code>，750 事务在 0 号页面的 <code>hex(750 * 4) = 0xbb8</code>，全为 0，因此，事务 750 是主事务，这与上面的实际情况一致。</p>
<p>到此，关于 PostgreSQL 的子事务基本上就了解的差不多了，这部分内容其实相对还是比较简单的，<code>pg_xact</code> 的内容就要比 <code>pg_subtrans</code> 稍微复杂一些。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/14/sql-begin.html">https://www.postgresql.org/docs/14/sql-begin.html</a><br>[2] <a href="https://www.postgresql.org/docs/14/sql-checkpoint.html">https://www.postgresql.org/docs/14/sql-checkpoint.html</a><br>[3] <a href="https://www.postgresql.org/docs/14/sql-commit.html">https://www.postgresql.org/docs/14/sql-commit.html</a><br>[4] <a href="https://www.postgresql.org/docs/14/sql-savepoint.html">https://www.postgresql.org/docs/14/sql-savepoint.html</a><br>[5] <a href="https://github.com/postgres/postgres/tree/REL_14_5">https://github.com/postgres/postgres/tree/REL_14_5</a></p>
<div class="just-for-fun">
笑林广记 - 薑字塔

<p>一富翁问“薑”字如何写，对以草字头，次一字，次田字，又一字，又田字，又一字。<br>其人写草壹田壹田壹，写讫玩之，骂曰：“天杀的，如何诳我，分明作耍我造成一座塔了。”</p>
</div>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 系统属性添加</title>
    <url>/2019/08/postgresql-system-attribute/</url>
    <content><![CDATA[<p>PostgreSQL 在插入数据的时候除了维护用户的属性列外，还有几个隐藏的系统属性列，如 <code>ctid</code>、<code>xmin</code> 和 <code>xmax</code> 等。如下图所示：</p>
<img src="/2019/08/postgresql-system-attribute/sysattr.png" class="" title="PostgreSQL 系统属性">

<p>从上图中我们可以看到，系统属性列其编号（即 <code>attnum</code> ）为负数，而用户自定义的属性列其编号则为正数（由 1 开始）。本文将介绍如何在 PostgreSQL 中添加自定义系统属性。</p>
<span id="more"></span>

<h2 id="属性列"><a href="#属性列" class="headerlink" title="属性列"></a>属性列</h2><p>PostgreSQL 为每个属性列都在系统表 <code>pg_attribute</code> 中记录了一个元组，<a href="https://www.postgresql.org/docs/12/catalog-pg-attribute.html">见官网文档</a>。这里我们需要对几个常见的列有所认识，这也是本文后续要使用到的。</p>
<style>
table th:nth-of-type(1) {
    width: 15%;
}
table th:nth-of-type(2) {
    width: 80%;
}
</style>

<table>
<thead>
<tr>
<th>属性列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>attname</strong></td>
<td>属性列的名称。</td>
</tr>
<tr>
<td><strong>atttypid</strong></td>
<td>属性列的数据类型的 OID，引用 <code>pg_type</code> 表的 <code>oid</code> 字段（外键约束）。</td>
</tr>
<tr>
<td><strong>attlen</strong></td>
<td>此属性列的数据类型长度，<code>pg_type</code> 表的 <code>typlen</code> 字段的副本。</td>
</tr>
<tr>
<td><strong>attnum</strong></td>
<td>属性列编号数。用户定义的普通属性列的编号从 1 开始。系统属性列列（例如 <code>ctid</code>）则为负数。</td>
</tr>
<tr>
<td><strong>attcacheoff</strong></td>
<td>存储中始终为 -1，但是当加载到内存中的行描述符时，可能会更新该行描述符以缓存行中属性的偏移量。</td>
</tr>
<tr>
<td><strong>atttypmod</strong></td>
<td>记录在创建表时提供的特定于类型的数据（例如，<code>varchar</code> 类型的最大长度）。它被传递给特定类型的输入函数和长度强制函数。对于不需要 <code>atttypmod</code> 的类型，该值通常为 -1。</td>
</tr>
<tr>
<td><strong>attbyval</strong></td>
<td>数据类型是否按值传递，<code>pg_type</code> 表的 <code>typbyval</code> 字段的副本。</td>
</tr>
<tr>
<td><strong>attstorage</strong></td>
<td>通常是此列类型的 <code>pg_type</code> 表的 <code>typstorage</code> 字段的副本。对于 TOAST-able 数据类型，可以在创建列后更改此值以控制存储策略。</td>
</tr>
<tr>
<td><strong>attalign</strong></td>
<td>数据类型的对其方式，<code>pg_type</code> 表的 <code>typalign</code> 的副本。<br/><code>c</code> 表示按照 <code>char</code> 类型对齐（即不需要对齐）；<code>s</code> 按 <code>short</code> 类型对齐（在大多数机器上是 2 字节对齐）；<code>i</code> 表示按照 <code>int</code> 类型对齐（通常是 4 字节对齐）；<code>d</code> 表示按照 <code>double</code> 类型对齐（通常是 8 字节对齐，但并不全是）。</td>
</tr>
<tr>
<td><strong>attnotnull</strong></td>
<td>该属性列是否具有非空约束。</td>
</tr>
<tr>
<td><strong>attislocal</strong></td>
<td>该属性列在表中是本地定义。请注意，属性列可以是本地定义并同时继承。</td>
</tr>
</tbody></table>
<p>其实整个属性列都是通过 <code>FormData_pg_attribute</code> 结果来记录的，它定义在 <code>src/include/catalog/pg_attribute.h</code> 头文件中。</p>
<h2 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h2><p>PostgreSQL 的系统属性是在 <code>src/backend/catalog/heap.c</code> 源文件中定义的，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a1 = &#123;</span><br><span class="line">    .attname = &#123;<span class="string">&quot;ctid&quot;</span>&#125;,</span><br><span class="line">    .atttypid = TIDOID,</span><br><span class="line">    .attlen = <span class="keyword">sizeof</span>(ItemPointerData),</span><br><span class="line">    .attnum = SelfItemPointerAttributeNumber,</span><br><span class="line">    .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">    .atttypmod = <span class="number">-1</span>,</span><br><span class="line">    .attbyval = <span class="literal">false</span>,</span><br><span class="line">    .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    .attalign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    .attnotnull = <span class="literal">true</span>,</span><br><span class="line">    .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a2 = &#123;</span><br><span class="line">    .attname = &#123;<span class="string">&quot;xmin&quot;</span>&#125;,</span><br><span class="line">    .atttypid = XIDOID,</span><br><span class="line">    .attlen = <span class="keyword">sizeof</span>(TransactionId),</span><br><span class="line">    .attnum = MinTransactionIdAttributeNumber,</span><br><span class="line">    .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">    .atttypmod = <span class="number">-1</span>,</span><br><span class="line">    .attbyval = <span class="literal">true</span>,</span><br><span class="line">    .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    .attalign = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">    .attnotnull = <span class="literal">true</span>,</span><br><span class="line">    .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a6 = &#123;</span><br><span class="line">    .attname = &#123;<span class="string">&quot;tableoid&quot;</span>&#125;,</span><br><span class="line">    .atttypid = OIDOID,</span><br><span class="line">    .attlen = <span class="keyword">sizeof</span>(Oid),</span><br><span class="line">    .attnum = TableOidAttributeNumber,</span><br><span class="line">    .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">    .atttypmod = <span class="number">-1</span>,</span><br><span class="line">    .attbyval = <span class="literal">true</span>,</span><br><span class="line">    .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    .attalign = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">    .attnotnull = <span class="literal">true</span>,</span><br><span class="line">    .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute *SysAtt[] = &#123;&amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5, &amp;a6&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，属性列的编号是通过宏来定义的，例如 <code>TableOidAttributenumber</code>，这些宏的定义在 <code>src/include/access/sysattr.h</code> 头文件中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attribute numbers for the system-defined attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SelfItemPointerAttributeNumber                  (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinTransactionIdAttributeNumber                 (-2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinCommandIdAttributeNumber                     (-3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxTransactionIdAttributeNumber                 (-4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxCommandIdAttributeNumber                     (-5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TableOidAttributeNumber                         (-6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FirstLowInvalidHeapAttributeNumber              (-7)</span></span><br></pre></td></tr></table></figure>

<p><code>atttypid</code> 则是在 <code>src/include/catalog/pg_type.dat</code> 文件中声明，并在编译时由 perl 转换为 <code>pg_type_d.h</code> 文件中的宏定义。</p>
<p>最终这些系统属性列将被保存在 <code>SysAttr</code> 全局数组中。用户在建立表时，PostgreSQL 通过 <code>AddNewAttributeTuples</code> 函数向 <code>pg_attribute</code> 插入属性列信息，随后在加入系统属性信息，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; natts; i++)</span><br><span class="line">&#123;</span><br><span class="line">    attr = TupleDescAttr(tupdesc, i);</span><br><span class="line">    <span class="comment">/* Fill in the correct relation OID */</span></span><br><span class="line">    attr-&gt;attrelid = new_rel_oid;</span><br><span class="line">    <span class="comment">/* Make sure this is OK, too */</span></span><br><span class="line">    attr-&gt;attstattarget = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    InsertPgAttributeTuple(rel, attr, indstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add dependency info */</span></span><br><span class="line">    myself.classId = RelationRelationId;</span><br><span class="line">    myself.objectId = new_rel_oid;</span><br><span class="line">    myself.objectSubId = i + <span class="number">1</span>;</span><br><span class="line">    referenced.classId = TypeRelationId;</span><br><span class="line">    referenced.objectId = attr-&gt;atttypid;</span><br><span class="line">    referenced.objectSubId = <span class="number">0</span>;</span><br><span class="line">    recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The default collation is pinned, so don&#x27;t bother recording it */</span></span><br><span class="line">    <span class="keyword">if</span> (OidIsValid(attr-&gt;attcollation) &amp;&amp;</span><br><span class="line">        attr-&gt;attcollation != DEFAULT_COLLATION_OID)</span><br><span class="line">    &#123;</span><br><span class="line">        referenced.classId = CollationRelationId;</span><br><span class="line">        referenced.objectId = attr-&gt;attcollation;</span><br><span class="line">        referenced.objectSubId = <span class="number">0</span>;</span><br><span class="line">        recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Next we add the system attributes.  Skip OID if rel has no OIDs. Skip</span></span><br><span class="line"><span class="comment"> * all for a view or type relation.  We don&#x27;t bother with making datatype</span></span><br><span class="line"><span class="comment"> * dependencies here, since presumably all these types are pinned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (relkind != RELKIND_VIEW &amp;&amp; relkind != RELKIND_COMPOSITE_TYPE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) lengthof(SysAtt); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FormData_pg_attribute attStruct;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;attStruct, SysAtt[i], <span class="keyword">sizeof</span>(FormData_pg_attribute));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fill in the correct relation OID in the copied tuple */</span></span><br><span class="line">        attStruct.attrelid = new_rel_oid;</span><br><span class="line"></span><br><span class="line">        InsertPgAttributeTuple(rel, &amp;attStruct, indstate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建系统属性列"><a href="#创建系统属性列" class="headerlink" title="创建系统属性列"></a>创建系统属性列</h2><p>现在，我们对系统属性列的工作方式有所了解了，接下来就可以创建自定义系统属性列。首先我们声明一个属性列的编号，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfomaskAttributeNumber                         (-7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FirstLowInvalidHeapAttributeNumber              (-8)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意；</strong> 不要忘记更新 <code>FirstLowInvalidHeapAttributeNumber</code> 的值。</p>
<p>接着，我们需要声明属性列，并将其添加到 <code>SysAtt</code> 数组中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute a7 = &#123;</span><br><span class="line">        .attname = &#123;<span class="string">&quot;infomask&quot;</span>&#125;,</span><br><span class="line">        .atttypid = INT2OID,</span><br><span class="line">        .attlen = <span class="keyword">sizeof</span>(uint16),</span><br><span class="line">        .attnum = InfomaskAttributeNumber,</span><br><span class="line">        .attcacheoff = <span class="number">-1</span>,</span><br><span class="line">        .atttypmod = <span class="number">-1</span>,</span><br><span class="line">        .attbyval = <span class="literal">true</span>,</span><br><span class="line">        .attstorage = <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">        .attalign = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">        .attnotnull = <span class="literal">true</span>,</span><br><span class="line">        .attislocal = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FormData_pg_attribute *SysAtt[] = &#123;&amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5, &amp;a6, &amp;a7&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，我们就基本完成了属性列的添加。当然，为了能够查询，我还需要在两个地方做修改，它们均位于 <code>src/backend/access/common/heaptuple.c</code> 文件中。首先在函数 <code>heap_attisnull</code> 中增加我们的属性列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">heap_attisnull</span><span class="params">(HeapTuple tup, <span class="keyword">int</span> attnum, TupleDesc tupleDesc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We allow a NULL tupledesc for relations not expected to have missing</span></span><br><span class="line"><span class="comment">         * values, such as catalog relations and indexes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assert(!tupleDesc || attnum &lt;= tupleDesc-&gt;natts);</span><br><span class="line">        <span class="keyword">if</span> (attnum &gt; (<span class="keyword">int</span>) HeapTupleHeaderGetNatts(tup-&gt;t_data))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (tupleDesc &amp;&amp; TupleDescAttr(tupleDesc, attnum - <span class="number">1</span>)-&gt;atthasmissing)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (attnum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (HeapTupleNoNulls(tup))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> att_isnull(attnum - <span class="number">1</span>, tup-&gt;t_data-&gt;t_bits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (attnum)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> TableOidAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> SelfItemPointerAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MinTransactionIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MinCommandIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MaxTransactionIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MaxCommandIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> InfomaskAttributeNumber:</span><br><span class="line">                        <span class="comment">/* these are never null */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        elog(ERROR, <span class="string">&quot;invalid attnum: %d&quot;</span>, attnum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，在 <code>heap_getsysattr</code> 函数中添加如何获取 <code>infomask</code> 的值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">heap_getsysattr</span><span class="params">(HeapTuple tup, <span class="keyword">int</span> attnum, TupleDesc tupleDesc, <span class="keyword">bool</span> *isnull)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Datum           result;</span><br><span class="line"></span><br><span class="line">        Assert(tup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently, no sys attribute ever reads as NULL. */</span></span><br><span class="line">        *isnull = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (attnum)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> SelfItemPointerAttributeNumber:</span><br><span class="line">                        <span class="comment">/* pass-by-reference datatype */</span></span><br><span class="line">                        result = PointerGetDatum(&amp;(tup-&gt;t_self));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MinTransactionIdAttributeNumber:</span><br><span class="line">                        result = TransactionIdGetDatum(HeapTupleHeaderGetRawXmin(tup-&gt;t_data));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MaxTransactionIdAttributeNumber:</span><br><span class="line">                        result = TransactionIdGetDatum(HeapTupleHeaderGetRawXmax(tup-&gt;t_data));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MinCommandIdAttributeNumber:</span><br><span class="line">                <span class="keyword">case</span> MaxCommandIdAttributeNumber:</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * cmin and cmax are now both aliases for the same field, which</span></span><br><span class="line"><span class="comment">                         * can in fact also be a combo command id.  XXX perhaps we should</span></span><br><span class="line"><span class="comment">                         * return the &quot;real&quot; cmin or cmax if possible, that is if we are</span></span><br><span class="line"><span class="comment">                         * inside the originating transaction?</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        result = CommandIdGetDatum(HeapTupleHeaderGetRawCommandId(tup-&gt;t_data));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TableOidAttributeNumber:</span><br><span class="line">                        result = ObjectIdGetDatum(tup-&gt;t_tableOid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> InfomaskAttributeNumber:</span><br><span class="line">                        result = UInt16GetDatum(tup-&gt;t_data-&gt;t_infomask);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        elog(ERROR, <span class="string">&quot;invalid attnum: %d&quot;</span>, attnum);</span><br><span class="line">                        result = <span class="number">0</span>;                     <span class="comment">/* keep compiler quiet */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，编译、初始化并启动数据库，效果如下图所示：</p>
<img src="/2019/08/postgresql-system-attribute/result.png" class="" title="效果图">


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/12/catalog-pg-attribute.html">https://www.postgresql.org/docs/12/catalog-pg-attribute.html</a><br>[2] <a href="https://www.postgresql.org/docs/12/catalog-pg-type.html">https://www.postgresql.org/docs/12/catalog-pg-type.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 自定义系统函数</title>
    <url>/2019/11/postgresql-system-function/</url>
    <content><![CDATA[<p>本文主要介绍如何实现一个系统函数，类似于 <code>pg_backend_pid()</code> 的系统函数。PostgreSQL 所有的系统函数都记录在 <code>pg_proc</code> 系统表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select oid,proname from pg_proc where proname = &#x27;pg_backend_pid&#x27;;</span><br><span class="line"> oid  |    proname</span><br><span class="line">------+----------------</span><br><span class="line"> 2026 | pg_backend_pid</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="系统表-pg-proc"><a href="#系统表-pg-proc" class="headerlink" title="系统表 pg_proc"></a>系统表 <code>pg_proc</code></h2><p>关于系统表 <a href="https://www.postgresql.org/docs/11/catalog-pg-proc.html">pg_proc</a> 都详细介绍可以查看官方文档，这里简要介绍一些本文使用到的一些属性列。</p>
<style>
table th:nth-of-type(1) {
    width: 15%;
}
table th:nth-of-type(2) {
    width: 10%;
}
</style>

<table>
<thead>
<tr>
<th>属性列</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>oid</td>
<td>oid</td>
<td>行标识符，用于标识函数</td>
</tr>
<tr>
<td>proname</td>
<td>name</td>
<td>函数名</td>
</tr>
<tr>
<td>pronamespace</td>
<td>oid</td>
<td>包含该函数的命令空间的标识符</td>
</tr>
<tr>
<td>proowner</td>
<td>oid</td>
<td>该函数的拥有者</td>
</tr>
<tr>
<td>prorows</td>
<td>float4</td>
<td>估计的结果行数 (如果 <code>proretset</code> 为 <code>false</code> 则为零)</td>
</tr>
<tr>
<td>proretset</td>
<td>bool</td>
<td>函数返回一个集合（即指定数据类型的多个值）</td>
</tr>
<tr>
<td>provolatile</td>
<td>char</td>
<td>函数的结果是否取决于输入参数，或受外部因素影响<br><code>i</code> - 不变的函数，对于相同的输入始终有相同的输出。<br><code>s</code> - 稳定的函数，其结果（对于固定输入）在扫描中不会改变。<br> <code>v</code> - 易失的函数，其结果可能随时更改，这样做的副作用是无法优化对它们的调用。</td>
</tr>
<tr>
<td>proparallel</td>
<td>char</td>
<td>该函数是否可以在并行模式下安全运行<br><code>s</code> - 可以安全地在并行模式下不受限制地运行功能。<br><code>r</code> - 可以在并行模式下运行的函数，但是它们的执行仅限于并行组领导者，并行工作进程无法调用这些功能。<br><code>u</code> - 在并行模式下不安全的函数，此类函数的存在会强制执行串行执行计划。</td>
</tr>
<tr>
<td>pronargs</td>
<td>int2</td>
<td>输入参数的个数</td>
</tr>
<tr>
<td>pronargdefaults</td>
<td>int2</td>
<td>具有默认值的参数个数</td>
</tr>
<tr>
<td>prorettype</td>
<td>oid</td>
<td>返回值的数据类型</td>
</tr>
<tr>
<td>proargtypes</td>
<td>oidvector</td>
<td>函数参数数据类型数组，这仅包括输入函数</td>
</tr>
<tr>
<td>proallargtypes</td>
<td>oid[]</td>
<td>函数参数数据类型数组，这包含所有参数（输入、输出参数）</td>
</tr>
<tr>
<td>proargmodes</td>
<td>char[]</td>
<td>函数参数的模式数组，<code>i</code> - INPUT 参数，<code>o</code> - OUTPUT 参数，<code>b</code> - INPUT/OUTPUT 参数，<code>v</code> - VARIADIC 参数，<code>t</code> - TABLE 参数。根据实现语言/调用约定，它可能是解释语言功能的实际源代码，链接符号，文件名或几乎所有其他内容。</td>
</tr>
<tr>
<td>prosrc</td>
<td>text</td>
<td>函数处理程序如何调用函数根据实现语言/调用约定，它可能是解释语言功能的实际源代码，链接符号，文件名或几乎所有其他内容</td>
</tr>
</tbody></table>
<p>我们上面提到的 <code>pg_backend_pid</code> 函数的各个属性如下所示：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123; <span class="string">oid =&gt;</span> <span class="string">&#x27;2026&#x27;</span>, <span class="string">descr =&gt;</span> <span class="string">&#x27;statistics: current backend PID&#x27;</span>,</span><br><span class="line">  <span class="string">proname =&gt;</span> <span class="string">&#x27;pg_backend_pid&#x27;</span>, <span class="string">provolatile =&gt;</span> <span class="string">&#x27;s&#x27;</span>, <span class="string">proparallel =&gt;</span> <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">  <span class="string">prorettype =&gt;</span> <span class="string">&#x27;int4&#x27;</span>, <span class="string">proargtypes =&gt;</span> <span class="string">&#x27;&#x27;</span>, <span class="string">prosrc =&gt;</span> <span class="string">&#x27;pg_backend_pid&#x27;</span> &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上述内容来自 <code>src/include/catalog/pg_proc.dat</code> 文件，该文件中定义的系统函数的相关信息，在编译时，PostgreSQL 将会使用 Perl 对其进行转换，并最终插入到 <code>pg_proc</code> 系统表中。</p>
<h2 id="PostgreSQL-函数调用约定"><a href="#PostgreSQL-函数调用约定" class="headerlink" title="PostgreSQL 函数调用约定"></a>PostgreSQL 函数调用约定</h2><p>PostgreSQL 通过函数调用约定来抑制传递参数和返回结果的复杂性。其定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum <span class="title">funcname</span><span class="params">(PG_FUNCTION_ARGS)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如，<code>pg_backend_pid()</code> 函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">pg_backend_pid</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PG_RETURN_INT32(MyProcPid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>PG_GETARG_xxx()</code> 的宏来获取对应类型的参数；在非严格函数中，需要使用 <code>PG_ARGNULL_xxx()</code> 宏来事先检查参数是否为空；同时我们可以使用 <code>PG_RETURN_xxx()</code> 宏来返回结果。<code>PG_GETARG_xxx()</code> 接受一个数字参数，该参数表示我们需要获取那个参数，参数从零开始；<code>PG_RETURN_xxx()</code> 的参数是实际返回的值。这些宏都定义在 <code>src/include/fmgr.h</code> 文件中。</p>
<h2 id="自定义系统函数"><a href="#自定义系统函数" class="headerlink" title="自定义系统函数"></a>自定义系统函数</h2><p>现在，我们可以来实现一个自定义的系统函数。PostgreSQL 提供了一个系统函数 <code>sha256(bytea)</code> 来计算 SHA256 哈希值。在本文中，我们将新 <code>sha256(text)</code> 类型的函数来计算 SHA256 哈希值。其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a SHA256 hash of a text value and return it as hex string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">sha256_text</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>       i, j;</span><br><span class="line">    text     *in_text = PG_GETARG_TEXT_PP(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">size_t</span>    len;</span><br><span class="line">    uint8     hexsum[PG_SHA256_DIGEST_LENGTH];</span><br><span class="line">    <span class="keyword">char</span>      digest[PG_SHA256_DIGEST_STRING_LENGTH];</span><br><span class="line">    pg_sha256_ctx    sha256_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calculate the length of the buffer using varlena metadata */</span></span><br><span class="line">    len = VARSIZE_ANY_EXHDR(in_text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the hash result */</span></span><br><span class="line">    pg_sha256_init(&amp;sha256_ctx);</span><br><span class="line">    pg_sha256_update(&amp;sha256_ctx, (uint8 *) VARDATA_ANY(in_text), len);</span><br><span class="line">    pg_sha256_final(&amp;sha256_ctx, hexsum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; PG_SHA256_DIGEST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *hex = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">        digest[j++] = hex[(hexsum[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>];</span><br><span class="line">        digest[j++] = hex[hexsum[i] &amp; <span class="number">0xF</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    digest[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_TEXT_P(cstring_to_text(digest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其定义在 <code>src/backend/utils/adt/cryptohashes.c</code> 文件中，该文件包含了常用的哈希算法。接着我们需要在 <code>src/include/catalog/pg_proc.dat</code> 文件中添加 <code>sha256_text</code> 的实现，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123; <span class="string">oid =&gt;</span> <span class="string">&#x27;3420&#x27;</span>, <span class="string">descr =&gt;</span> <span class="string">&#x27;SHA-256 hash&#x27;</span>,</span><br><span class="line">  <span class="string">proname =&gt;</span> <span class="string">&#x27;sha256&#x27;</span>, <span class="string">proleakproof =&gt;</span> <span class="string">&#x27;t&#x27;</span>, <span class="string">prorettype =&gt;</span> <span class="string">&#x27;bytea&#x27;</span>,</span><br><span class="line">  <span class="string">proargtypes =&gt;</span> <span class="string">&#x27;bytea&#x27;</span>, <span class="string">prosrc =&gt;</span> <span class="string">&#x27;sha256_bytea&#x27;</span> &#125;,</span><br><span class="line">&#123; <span class="string">oid =&gt;</span> <span class="string">&#x27;3423&#x27;</span>, <span class="string">descr =&gt;</span> <span class="string">&#x27;SHA256 hash&#x27;</span>,</span><br><span class="line">  <span class="string">proname =&gt;</span> <span class="string">&#x27;sha256&#x27;</span>, <span class="string">proleakproof =&gt;</span> <span class="string">&#x27;t&#x27;</span>, <span class="string">prorettype =&gt;</span> <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">  <span class="string">proargtypes =&gt;</span> <span class="string">&#x27;text&#x27;</span>, <span class="string">prosrc =&gt;</span> <span class="string">&#x27;sha256_text&#x27;</span> &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>oid</code> 是不能重复的，我们可以使用 <code>src/include/catalog/unused_oids</code> 来获取一个未使用的 <code>oid</code>。</p>
<p>经过上述步骤，我们就完整的创建了一个 PostgreSQL 系统函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select sha256(&#x27;hello&#x27;);</span><br><span class="line">                              sha256</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"> 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# postgres=# select sha256(&#x27;hello&#x27;::bytea);</span><br><span class="line">                               sha256</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"> \x2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>当然，这个示例只是为了演示而做的。但是，根据这个示例，我们可以轻易的实现我们需要的系统函数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/11/catalog-pg-proc.html">https://www.postgresql.org/docs/11/catalog-pg-proc.html</a><br>[2] <a href="https://www.postgresql.org/docs/11/xfunc-c.html">https://www.postgresql.org/docs/11/xfunc-c.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 数据库系统标识符</title>
    <url>/2020/06/postgresql-system-identifier/</url>
    <content><![CDATA[<p>我们都知道 PostgreSQL 针对每个数据库集群实例，都会有一个唯一的标识符 - <strong>system identifier</strong>。那么这个标识符是如何生成的呢？本文将对其进行简要的分析。</p>
<span id="more"></span>

<p>通过分析 initdb 的源码，我们并不能找到相关的信息，但是我们发现 initdb 是通过 postgres 来进行数据库相关的初始化工作的，在函数 <code>bootstrap_template1()</code> 中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * run the BKI script in bootstrap mode to create template1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bootstrap_template1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Also ensure backend isn&#x27;t confused by this environment var: */</span></span><br><span class="line">    unsetenv(<span class="string">&quot;PGCLIENTENCODING&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(cmd, <span class="keyword">sizeof</span>(cmd),</span><br><span class="line">             <span class="string">&quot;\&quot;%s\&quot; --boot -x1 -X %u %s %s %s&quot;</span>,</span><br><span class="line">             backend_exec,</span><br><span class="line">             wal_segment_size_mb * (<span class="number">1024</span> * <span class="number">1024</span>),</span><br><span class="line">             data_checksums ? <span class="string">&quot;-k&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             boot_options,</span><br><span class="line">             debug ? <span class="string">&quot;-d 5&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PG_CMD_OPEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (line = bki_lines; *line != <span class="literal">NULL</span>; line++)</span><br><span class="line">    &#123;</span><br><span class="line">        PG_CMD_PUTS(*line);</span><br><span class="line">        <span class="built_in">free</span>(*line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PG_CMD_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(bki_lines);</span><br><span class="line"></span><br><span class="line">    check_ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们仅使用 <code>initdb -D pgdata</code> 来初始化数据库实例，那么它实际上会调用 <code>postgres --boot -x1 -X 16777216  -F</code> 来进行初始化。</p>
<p>接下来我们对 postgres 进行分析发现，它将在 <code>BootStrapXLOG()</code> 函数中初始化数据库标识符，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">BootStrapXLOG</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CheckPoint  checkPoint;</span><br><span class="line">    <span class="keyword">char</span>       *buffer;</span><br><span class="line">    XLogPageHeader page;</span><br><span class="line">    XLogLongPageHeader longpage;</span><br><span class="line">    XLogRecord *record;</span><br><span class="line">    <span class="keyword">char</span>       *recptr;</span><br><span class="line">    <span class="keyword">bool</span>        use_existent;</span><br><span class="line">    uint64      sysidentifier;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    pg_crc32c   crc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Select a hopefully-unique system identifier code for this installation.</span></span><br><span class="line"><span class="comment">     * We use the result of gettimeofday(), including the fractional seconds</span></span><br><span class="line"><span class="comment">     * field, as being about as unique as we can easily get.  (Think not to</span></span><br><span class="line"><span class="comment">     * use random(), since it hasn&#x27;t been seeded and there&#x27;s no portable way</span></span><br><span class="line"><span class="comment">     * to seed it other than the system clock value...)  The upper half of the</span></span><br><span class="line"><span class="comment">     * uint64 value is just the tv_sec part, while the lower half contains the</span></span><br><span class="line"><span class="comment">     * tv_usec part (which must fit in 20 bits), plus 12 bits from our current</span></span><br><span class="line"><span class="comment">     * PID for a little extra uniqueness.  A person knowing this encoding can</span></span><br><span class="line"><span class="comment">     * determine the initialization time of the installation, which could</span></span><br><span class="line"><span class="comment">     * perhaps be useful sometimes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    sysidentifier = ((uint64) tv.tv_sec) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    sysidentifier |= ((uint64) tv.tv_usec) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">    sysidentifier |= getpid() &amp; <span class="number">0xFFF</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，PostgreSQL 通过 <code>gettimeofday()</code> 函数来获取当前的时间，随后将 <code>tv.tv_sec</code><br>作为标识符的高 32 位，将 <code>tv.tv_usec</code> 作为标识符的低 32 位中的高 20 位，最后将当前进程的 ID 作为标识符的低 12 位，从而构造一个唯一的数据库实例标识符。这样我们就可以通过下面的方式获取到实例的初始化时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select to_timestamp(system_identifier &gt;&gt; 32) from pg_control_system();</span><br><span class="line">      to_timestamp</span><br><span class="line">------------------------</span><br><span class="line"> 2019-12-12 22:20:59+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 临时表</title>
    <url>/2019/08/postgresql-temporary-table/</url>
    <content><![CDATA[<p>本文主要介绍 PostgreSQL 数据库中的临时表 (Temporary Table)。临时表将在会话结束或者当前事务结束时被删除。PostgreSQL 支持临时表和永久存储表 (Permanent Table) 具有相同的名称，如果出现这种情况，那么只有在临时表被删除之后才能看到永久表或者你可以指定 schema 来明确需要查询的是永久表。此外，在临时表上建立的索引同样也是临时的。</p>
<span id="more"></span>

<h2 id="创建临时表"><a href="#创建临时表" class="headerlink" title="创建临时表"></a>创建临时表</h2><p>在 PostgreSQL 中，我们可以通过下面的语法来创建临时表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE temp_table_name (</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者，我们可以将 <code>TEMPORARY</code> 替换为 <code>TEMP</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMP TABLE temp_table_name (</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>所有的临时表只能在他所在的会话中可见。我们来看一个示列，首先创建一个 <code>test</code> 的数据库，随后在里面创建一个 <code>temp_test</code> 的临时表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# CREATE DATABASE test;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres=# \c test</span><br><span class="line">You are now connected to database &quot;test&quot; as user &quot;japin&quot;.</span><br><span class="line">test=# CREATE TEMP TABLE temp_test (id INT, name VARCHAR(10), age INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">test=# SELECT * FROM temp_test;</span><br><span class="line"> id | name | age</span><br><span class="line">----+------+-----</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<p>接着，我们重新开启一个会话连接到到 <code>test</code> 数据库并查询 <code>temp_test</code> 临时表中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# \c test</span><br><span class="line">You are now connected to database &quot;test&quot; as user &quot;japin&quot;.</span><br><span class="line">test=# SELECT * FROM temp_test;</span><br><span class="line">ERROR:  relation &quot;temp_test&quot; does not exist</span><br><span class="line">LINE 1: SELECT * FROM temp_test;</span><br><span class="line">                      ^</span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>
<p>正如你看到的，第二个会话中没有 <code>temp_test</code> 这个关系表，因此可以说明临时表只在当前会话可见。现在我们尝试断开第一个会话连接并重新连接到 <code>test</code> 数据库查看一下该临时表是否还存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# \q</span><br><span class="line">japin@ww-it:~/Codes/tinydb$ psql -d test</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">test=# SELECT * FROM temp_test;</span><br><span class="line">ERROR:  relation &quot;temp_test&quot; does not exist</span><br><span class="line">LINE 1: SELECT * FROM temp_test;</span><br><span class="line">                      ^</span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<p>从上面可以看到临时表 <code>temp_test</code> 以及不存在了，这说明它在会话结束之后就被数据库回收了。</p>
<h2 id="临时表表名"><a href="#临时表表名" class="headerlink" title="临时表表名"></a>临时表表名</h2><p>PostgreSQL 支持临时表与永久表具有相同的表名，虽然通常不推荐这样做，但是难免出现抽风的情况 :(。如果数据库中包含相同名字的临时表和永久表，那么执行查询时将会在临时表中取数据而不是在永久表中取数据。当然，我们通过指定 schema 来显示的指明从永久表中取数据。考虑如下情况：</p>
<p>首先，我们在 <code>test</code> 数据库中创建一个 <code>customers</code> 的永久表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# CREATE TABLE customers (id INT, name VARCHAR(10), age INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">test=# INSERT INTO customers VALUES (1, &#x27;japin&#x27;, 20), (2, &#x27;tom&#x27;, 20);</span><br><span class="line">INSERT 0 2</span><br><span class="line">test=# SELECT * FROM customers;</span><br><span class="line"> id | name  | age</span><br><span class="line">----+-------+-----</span><br><span class="line">  1 | japin |  20</span><br><span class="line">  2 | tom   |  20</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<p>接着，我们在创建一个相同名字的临时表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# CREATE TEMP TABLE customers (id INT, name VARCHAR(10), age INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line">test=# SELECT * FROM customers;</span><br><span class="line"> id | name | age</span><br><span class="line">----+------+-----</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<p>此时，我们在从 <code>customers</code> 表中查询时便没有数据记录了，这说明临时表 <code>customers</code> 将永久表 <code>customers</code> 覆盖了。我们通过 <code>\d+</code> 命令查看数据库中的关系表，它同样不包含永久表 <code>customers</code> 的信息，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# \d+</span><br><span class="line">                       List of relations</span><br><span class="line">  Schema   |   Name    | Type  | Owner |  Size   | Description</span><br><span class="line">-----------+-----------+-------+-------+---------+-------------</span><br><span class="line"> pg_temp_3 | customers | table | japin | 0 bytes |</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<p>由上述结果可知，临时表是存放在 <code>pg_temp_3</code> 的 sechma 中，而我们创建的永久表则是存放在 <code>public</code> schema 中，因此，我们可以通过指定 schema 来查看永久表 <code>customers</code> 中的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT * FROM public.customers;</span><br><span class="line"> id | name  | age</span><br><span class="line">----+-------+-----</span><br><span class="line">  1 | japin |  20</span><br><span class="line">  2 | tom   |  20</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<h2 id="删除临时表"><a href="#删除临时表" class="headerlink" title="删除临时表"></a>删除临时表</h2><p>临时表的删除与永久表没有区别，它们都是通过 <code>DROP TABLE</code> 语句实现的。例如，我们要删除 <code>customers</code> 临时表可以使用如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE customers;</span><br></pre></td></tr></table></figure>

<p>此时，我们便可以看到永久表 <code>customers</code> 了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# \d+</span><br><span class="line">                       List of relations</span><br><span class="line"> Schema |   Name    | Type  | Owner |    Size    | Description</span><br><span class="line">--------+-----------+-------+-------+------------+-------------</span><br><span class="line"> public | customers | table | japin | 8192 bytes |</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">test=#</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/10/sql-createtable.html">https://www.postgresql.org/docs/10/sql-createtable.html</a><br>[2] <a href="http://www.postgresqltutorial.com/postgresql-temporary-table/">http://www.postgresqltutorial.com/postgresql-temporary-table/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 文本搜索字典导致奔溃</title>
    <url>/2022/08/postgresql-text-search-dictionary-crashed/</url>
    <content><![CDATA[<p>今天朋友在群里发了一个关于文本搜索字典导致崩溃的问题，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEXT <span class="keyword">SEARCH</span> TEMPLATE public.my_ts_template(</span><br><span class="line">  init <span class="operator">=</span> varchar_support,</span><br><span class="line">  lexize <span class="operator">=</span> dispell_lexize</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TEXT <span class="keyword">SEARCH</span> DICTIONARY public.my_ts_dict(</span><br><span class="line">  template <span class="operator">=</span> public.my_ts_template</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在执行第二条语句时将出现如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server closed the connection unexpectedly</span><br><span class="line">        This probably means the server terminated abnormally</span><br><span class="line">        before or while processing the request.</span><br><span class="line">The connection to the server was lost. Attempting reset: Failed.</span><br><span class="line">The connection to the server was lost. Attempting reset: Failed.</span><br></pre></td></tr></table></figure>

<p>从上面的信息可以得知后端进程奔溃了（这个问题就目前的状况来看是不会修正的）。</p>
<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过 GDB 我们可以看到崩溃时的堆栈信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  0x00005605671bce72 in varchar_support (fcinfo=0x7ffd0c87a070)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/utils/adt/varchar.c:565</span><br><span class="line">#1  0x0000560567205842 in FunctionCall1Coll (flinfo=0x7ffd0c87a0d0, collation=0, arg1=0)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/utils/fmgr/fmgr.c:1124</span><br><span class="line">#2  0x000056056720675d in OidFunctionCall1Coll (functionId=3097, collation=0, arg1=0)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/utils/fmgr/fmgr.c:1402</span><br><span class="line">#3  0x0000560566d650ad in verify_dictoptions (tmplId=24576, dictoptions=0x0)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/commands/tsearchcmds.c:381</span><br><span class="line">#4  0x0000560566d652d1 in DefineTSDictionary (names=0x5605678ad4d8, parameters=0x5605678ad720)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/commands/tsearchcmds.c:442</span><br><span class="line">#5  0x0000560567042a96 in ProcessUtilitySlow (pstate=0x5605678cd940, pstmt=0x5605678adae8,</span><br><span class="line">    queryString=0x5605678aca10 &quot;CREATE TEXT SEARCH DICTIONARY public.my_ts_dict (\n  template = public.my_ts_template\n);&quot;, context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x5605678adbd8, qc=0x7ffd0c87aa40)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/tcop/utility.c:1430</span><br><span class="line">#6  0x0000560567041e84 in standard_ProcessUtility (pstmt=0x5605678adae8,</span><br><span class="line">    queryString=0x5605678aca10 &quot;CREATE TEXT SEARCH DICTIONARY public.my_ts_dict (\n  template = public.my_ts_template\n);&quot;, readOnlyTree=false, context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x5605678adbd8,</span><br><span class="line">    qc=0x7ffd0c87aa40) at /home/japin/Codes/postgresql/build/../src/backend/tcop/utility.c:1074</span><br><span class="line">#7  0x0000560567040dfe in ProcessUtility (pstmt=0x5605678adae8,</span><br><span class="line">    queryString=0x5605678aca10 &quot;CREATE TEXT SEARCH DICTIONARY public.my_ts_dict (\n  template = public.my_ts_template\n);&quot;, readOnlyTree=false, context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x5605678adbd8,</span><br><span class="line">    qc=0x7ffd0c87aa40) at /home/japin/Codes/postgresql/build/../src/backend/tcop/utility.c:530</span><br><span class="line">#8  0x000056056703f905 in PortalRunUtility (portal=0x56056791eed0, pstmt=0x5605678adae8, isTopLevel=true,</span><br><span class="line">    setHoldSnapshot=false, dest=0x5605678adbd8, qc=0x7ffd0c87aa40)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/tcop/pquery.c:1158</span><br><span class="line">#9  0x000056056703fb77 in PortalRunMulti (portal=0x56056791eed0, isTopLevel=true, setHoldSnapshot=false,</span><br><span class="line">    dest=0x5605678adbd8, altdest=0x5605678adbd8, qc=0x7ffd0c87aa40)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/tcop/pquery.c:1315</span><br><span class="line">#10 0x000056056703eff5 in PortalRun (portal=0x56056791eed0, count=9223372036854775807, isTopLevel=true,</span><br><span class="line">    run_once=true, dest=0x5605678adbd8, altdest=0x5605678adbd8, qc=0x7ffd0c87aa40)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/tcop/pquery.c:791</span><br><span class="line">#11 0x0000560567038332 in exec_simple_query (</span><br><span class="line">    query_string=0x5605678aca10 &quot;CREATE TEXT SEARCH DICTIONARY public.my_ts_dict (\n  template = public.my_ts_template\n);&quot;) at /home/japin/Codes/postgresql/build/../src/backend/tcop/postgres.c:1243</span><br><span class="line">#12 0x000056056703ce29 in PostgresMain (dbname=0x5605678a7168 &quot;postgres&quot;, username=0x5605678d8d18 &quot;japin&quot;)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/tcop/postgres.c:4505</span><br><span class="line">#13 0x0000560566f64bd0 in BackendRun (port=0x5605678d4c60)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/postmaster/postmaster.c:4491</span><br><span class="line">#14 0x0000560566f644be in BackendStartup (port=0x5605678d4c60)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/postmaster/postmaster.c:4219</span><br><span class="line">#15 0x0000560566f60730 in ServerLoop ()</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/postmaster/postmaster.c:1809</span><br><span class="line">#16 0x0000560566f5fee1 in PostmasterMain (argc=1, argv=0x5605678a5120)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/postmaster/postmaster.c:1481</span><br><span class="line">#17 0x0000560566e234d2 in main (argc=1, argv=0x5605678a5120)</span><br><span class="line">    at /home/japin/Codes/postgresql/build/../src/backend/main/main.c:197</span><br></pre></td></tr></table></figure>

<p>从上面的堆栈中，我们可以得知在 <code>DefineTSDictionary()</code> 函数中 <code>dictoptions</code> 变量为 <code>NIL</code>（即空链表），在传入到 <code>varchar_support()</code> 函数中时并没有检查空值，从而导致崩溃。</p>
<p>问题是找到了，但是这个问题并没有得到认同，Tom Lane 指出 <code>varchar_support()</code> 并不是有效的 <code>init</code> 参数。随后，我又重新查看了<a href="https://www.postgresql.org/docs/devel/sql-createtstemplate.html">文档</a>，发现这个点在文档里面有说明。</p>
<blockquote>
<p>You must be a superuser to use CREATE TEXT SEARCH TEMPLATE. This restriction is made because an erroneous text search template definition could confuse or even crash the server.</p>
</blockquote>
<p>我尝试在 <code>verify_dictoptions()</code> 函数中判断 <code>dictoptions</code> 是否为 <code>NIL</code> 来规避这个问题，这种做法并没有得到认同，诚然，通过检查 <code>dictoptions</code> 是否为 <code>NIL</code> 可以避免崩溃，但是这也就意味者我们必须为 <code>CREATE TEXT SEARCH DICTIONARY</code> 指定选项（这并不是预期的行为）。</p>
<p>目前更倾向的做法是超级用户来确保 <code>CREATE TEXT SEARCH TEMPLATE</code> 语句中 <code>init</code> 参数的合法性。然而在我看来这种解决方案并不十分优雅。这就相当于是给 DBA 埋了一个定时炸弹，您不知道他何时会由何人引爆。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/devel/sql-createtstemplate.html">https://www.postgresql.org/docs/devel/sql-createtstemplate.html</a><br>[2] <a href="https://www.postgresql.org/docs/devel/sql-createtsdictionary.html">https://www.postgresql.org/docs/devel/sql-createtsdictionary.html</a><br>[3] <a href="https://www.postgresql.org/message-id/MEYP282MB16690107AAF04EBB3B9AADD8B6629@MEYP282MB1669.AUSP282.PROD.OUTLOOK.COM">Coredump with text search dictionary</a></p>
<div class="just-for-fun">
笑林广记 - 不愿富

<p>一鬼托生时，冥王判作富人。<br>鬼曰：“不愿富也，但求一生衣食不缺，无是无非，烧清香，吃苦茶，安闲过日足矣。”<br>冥王曰：“要银子便再与你几万，这样安闲清福，却不许你享。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL TOAST 索引读取失败</title>
    <url>/2021/12/postgresql-toast-index-could-not-read-block/</url>
    <content><![CDATA[<p>最近，应用开发报来一个问题，错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:  could not read block 0 in file &quot;base/16385/2294016&quot;: read only 0 of 8192 bytes</span><br><span class="line">CONTEXT:  SQL function &quot;obj_description&quot; during startup</span><br></pre></td></tr></table></figure>

<p>这个错误信息和之前遇到的 <a href="/2020/02/postgresql-hash-index/" title="PostgreSQL HASH 索引拾遗">PostgreSQL HASH 索引拾遗</a>一文的情况很像。但是这里的数据库是 10.4，且是单节点模式，因此排除 HASH 索引的问题。</p>
<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，我们需要确定 <code>2294016</code> 这个文件是对应的数据库对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> oid, relname, relkind <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relfilenode <span class="operator">=</span> <span class="number">2294016</span>;</span><br><span class="line"> oid  <span class="operator">|</span>       relname       <span class="operator">|</span> relkind</span><br><span class="line"><span class="comment">------+---------------------+---------</span></span><br><span class="line"> <span class="number">2841</span> <span class="operator">|</span> pg_toast_2619_index <span class="operator">|</span> i</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>从上面的结果我们可以推测出 <code>2294016</code> 是索引 <code>pg_toast_2619_index</code> 的物理存储文件，而该索引是 TOAST 表的索引，并且这个 TOAST 表对应的基表的 OID 为 2619。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span></span><br><span class="line">postgres<span class="operator">-</span>#     a.oid     <span class="keyword">AS</span> table_oid,</span><br><span class="line">postgres<span class="operator">-</span>#     a.relname <span class="keyword">AS</span> table_name,</span><br><span class="line">postgres<span class="operator">-</span>#     b.relname <span class="keyword">AS</span> toast_name,</span><br><span class="line">postgres<span class="operator">-</span>#     c.relname <span class="keyword">AS</span> index_name</span><br><span class="line">postgres<span class="operator">-</span># <span class="keyword">FROM</span></span><br><span class="line">postgres<span class="operator">-</span>#     pg_class c</span><br><span class="line">postgres<span class="operator">-</span>#         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_index i <span class="keyword">ON</span> c.oid <span class="operator">=</span> i.indexrelid</span><br><span class="line">postgres<span class="operator">-</span>#         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_class b <span class="keyword">ON</span> i.indrelid <span class="operator">=</span> b.oid</span><br><span class="line">postgres<span class="operator">-</span>#         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_class a <span class="keyword">ON</span> b.oid <span class="operator">=</span> a.reltoastrelid</span><br><span class="line">postgres<span class="operator">-</span># <span class="keyword">WHERE</span></span><br><span class="line">postgres<span class="operator">-</span>#     c.relfilenode <span class="operator">=</span> <span class="number">2841</span>;</span><br><span class="line"> table_oid <span class="operator">|</span>  table_name  <span class="operator">|</span>  toast_name   <span class="operator">|</span>     index_name</span><br><span class="line"><span class="comment">-----------+--------------+---------------+---------------------</span></span><br><span class="line">      <span class="number">2619</span> <span class="operator">|</span> pg_statistic <span class="operator">|</span> pg_toast_2619 <span class="operator">|</span> pg_toast_2619_index</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>既然是索引问题，那么是否能通过重建索引来解决这个问题呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># REINDEX INDEX pg_toast_2619_index;</span><br><span class="line">ERROR:  relation &quot;pg_toast_2619_index&quot; does <span class="keyword">not</span> exist</span><br></pre></td></tr></table></figure>

<p>索引不存在？这是我忽略了 schema，事后才想起 TOAST 相关的数据存储在 <code>pg_toast</code> schema 下面。实际中，由于数据库本身数据有可能被损坏了，我选择了对 <code>pg_statistic</code> 整个表重建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># REINDEX <span class="keyword">TABLE</span> pg_statistic;</span><br><span class="line">ERROR:  could <span class="keyword">not</span> <span class="keyword">create</span> <span class="keyword">unique</span> index &quot;pg_statistic_relid_att_inh_index&quot;</span><br><span class="line">DETAIL:  Key (starelid, staattnum, stainherit)<span class="operator">=</span>(<span class="number">16558</span>, <span class="number">9</span>, f) <span class="keyword">is</span> duplicated.</span><br></pre></td></tr></table></figure>

<p>这里在去查询 OID 为 <code>16558</code> 的表时，发现其已经不存在，因此这里将其删除掉。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">DELETE</span> <span class="keyword">FROM</span> pg_catalog.pg_statistic <span class="keyword">WHERE</span> starelid <span class="operator">=</span> <span class="number">16558</span> <span class="keyword">AND</span> staattnum <span class="operator">=</span> <span class="number">9</span> <span class="keyword">AND</span> stainherit <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>至此，已经可以正常访问用户数据了。当然，这里的用户数据也可能存在一些损坏。</p>
<div class="just-for-fun">
笑林广记 - 及第

<p>一举子往京赴试，仆挑行李随后。<br>行到旷野，忽狂风大作，将担上头巾吹下。<br>仆大叫曰：“落地了。”<br>主人心下不悦，嘱曰：“今后莫说落地，只说及第。”<br>仆颔之。<br>将行李拴好，曰：“如今恁你走上天去，再也不会及第了。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 无法更改外键引用的聚集列的数据类型</title>
    <url>/2022/03/postgresql-unable-to-change-data-type-for-column-referenced-by-foreign-key/</url>
    <content><![CDATA[<p>最近在邮件列表中看到一个关于聚集列的数据类型修改导致的异常问题 <a href="https://www.postgresql.org/message-id/17409-52871dda8b5741cb%40postgresql.org">BUG #17409</a>。本文简要记录一下分析过程以及解决方案。目前该问题已经被修复，在 14.1 和 14.2 版本中应该可以重现。</p>
<pre><code>commit 641f3dffcdf1c7378cfb94c98b6642793181d6db
Author: Tom Lane &lt;tgl@sss.pgh.pa.us&gt;
Date:   Fri Mar 11 13:47:26 2022 -0500

    Restore the previous semantics of get_constraint_index().

    Commit 8b069ef5d changed this function to look at pg_constraint.conindid
    rather than searching pg_depend.  That was a good performance improvement,
    but it failed to preserve the exact semantics.  The old code would only
    return an index that was &quot;owned by&quot; (internally dependent on) the
    specified constraint, whereas the new code will also return indexes that
    are just referenced by foreign key constraints.  This confuses ALTER
    TABLE, which was implicitly expecting the previous semantics, into
    failing with errors like
        ERROR:  relation 146621 has multiple clustered indexes
    or
        ERROR:  &quot;pk_attbl&quot; is not an index for table &quot;atref&quot;

    We can fix this without reverting the performance improvement by adding
    a contype check in get_constraint_index().  Another way could be to
    make ALTER TABLE check it, but I&#39;m worried that extension code could
    also have subtle dependencies on the old semantics.

    Tom Lane and Japin Li, per bug #17409 from Holly Roberts.
    Back-patch to v14 where the error crept in.

    Discussion: https://postgr.es/m/17409-52871dda8b5741cb@postgresql.org
</code></pre>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>我们可以通过如下的示例来重现这个问题（源码为 PostgreSQL e94bb1473）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ psql postgres</span><br><span class="line">psql (<span class="number">15</span>devel)</span><br><span class="line">Type &quot;help&quot; <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> attbl (p1 <span class="type">int</span> <span class="keyword">constraint</span> pk_attbl <span class="keyword">primary</span> key);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> atref (c1 <span class="type">int</span> <span class="keyword">references</span> attbl(p1));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres<span class="operator">=</span># CLUSTER attbl <span class="keyword">USING</span> pk_attbl;</span><br><span class="line">CLUSTER</span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> attbl <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> p1 <span class="keyword">SET</span> DATA TYPE <span class="type">bigint</span>;</span><br><span class="line">ERROR:  relation <span class="number">16384</span> has multiple clustered indexes</span><br><span class="line">postgres<span class="operator">=</span>#</span><br></pre></td></tr></table></figure>

<p>然而实际上表 <code>attbl</code> 并不存在多个聚集索引，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT</span><br><span class="line">postgres-#     table_cls.relnamespace::regnamespace::text AS schema,</span><br><span class="line">postgres-#     table_cls.relname AS table,</span><br><span class="line">postgres-#     index_cls.relname AS index,</span><br><span class="line">postgres-#     indisclustered</span><br><span class="line">postgres-# FROM</span><br><span class="line">postgres-#     pg_index pi INNER JOIN pg_class index_cls ON (pi.indexrelid = index_cls.oid)</span><br><span class="line">postgres-#     INNER JOIN pg_class table_cls ON (pi.indrelid = table_cls.oid)</span><br><span class="line">postgres-# WHERE</span><br><span class="line">postgres-#     (table_cls.relnamespace::regnamespace::text, table_cls.relname) = (&#x27;public&#x27;, &#x27;attbl&#x27;);</span><br><span class="line"> schema | table |  index   | indisclustered</span><br><span class="line">--------+-------+----------+----------------</span><br><span class="line"> public | attbl | pk_attbl | t</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>因此可以断定这是一个 BUG。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从邮件来看，这个问题应该是在 13 之后的版本中引入的。通过 <code>git bisect</code> 查找，我发现是在 <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=8b069ef5dca97cd737a5fd64c420df3cd61ec1c9">8b069ef5dc</a> 提交中引入的这个问题。</p>
<pre><code>commit 8b069ef5dca97cd737a5fd64c420df3cd61ec1c9
Author: Peter Eisentraut &lt;peter@eisentraut.org&gt;
Date:   Wed Dec 9 15:12:05 2020 +0100

    Change get_constraint_index() to use pg_constraint.conindid

    It was still using a scan of pg_depend instead of using the conindid
    column that has been added since.

    Since it is now just a catalog lookup wrapper and not related to
    pg_depend, move from pg_depend.c to lsyscache.c.

    Reviewed-by: Matthias van de Meent &lt;boekewurm+postgres@gmail.com&gt;
    Reviewed-by: Tom Lane &lt;tgl@sss.pgh.pa.us&gt;
    Reviewed-by: Michael Paquier &lt;michael@paquier.xyz&gt;
    Discussion: https://www.postgresql.org/message-id/flat/4688d55c-9a2e-9a5a-d166-5f24fe0bf8db%40enterprisedb.com
</code></pre>
<p>该提交主要是修改了 <code>get_constraint_index()</code> 函数，在这之前，它是通过扫描 <code>pg_depend</code> 表来获取约束底层的索引信息（如果存在，返回索引的 oid）；在这之后，它是从 <code>syscache</code> 中获取（系统表 <code>pg_constraint</code>）。</p>
<p>根据错误信息，我发现其是在 <code>RememberClusterOnForRebuilding()</code> 函数中报错，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Subroutine for ATExecAlterColumnType: remember any clustered index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RememberClusterOnForRebuilding</span><span class="params">(Oid indoid, AlteredTableInfo *tab)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!get_index_isclustered(indoid))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tab-&gt;clusterOnIndex)</span><br><span class="line">        elog(ERROR, <span class="string">&quot;relation %u has multiple clustered indexes&quot;</span>, tab-&gt;relid);</span><br><span class="line"></span><br><span class="line">    tab-&gt;clusterOnIndex = get_rel_name(indoid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中，它使用 <code>tab-&gt;clusterOnIndex</code> 来判断是否已经存在聚集索引。这个问题就出在这个聚集索引出现了两次，通过调试发现，这两次的值都是一致的，这里出现两次调用是由于 <code>ALTER TABLE attbl ALTER COLUMN p1 SET DATA TYPE bigint;</code> 这个语句在内部还会生成一条 <code>ALTER TABLE public.tbref ADD CONSTRAINT fk_tbref FOREIGN KEY (c1) REFERENCES attbl(p1);</code> 语句（尚未分析这样做的原因）。由于在 <code>RememberClusterOnForRebuilding()</code> 函数中没有判断 <code>tab-&gt;clusterOnIndex</code> 是否为同一个对象，因此，当同一个对象出现两次时，也会报如上错误，经 Michael Paquier 指出，<code>RememberReplicaIdentityForRebuilding()</code> 存在相似的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>经过上面的分析，我尝试在报错之前判断其是否为同一个对象，v1 版本就此诞生，如下所示。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/commands/tablecmds.c b/src/backend/commands/tablecmds.c</span></span><br><span class="line"><span class="comment">index 3e83f375b5..4c0689d62e 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/commands/tablecmds.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/commands/tablecmds.c</span></span><br><span class="line"><span class="meta">@@ -12853,13 +12853,22 @@</span> ATExecAlterColumnType(AlteredTableInfo *tab, Relation rel,</span><br><span class="line"> static void</span><br><span class="line"> RememberReplicaIdentityForRebuilding(Oid indoid, AlteredTableInfo *tab)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+	char	*indname;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	if (!get_index_isreplident(indoid))</span><br><span class="line"> 		return;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (tab-&gt;replicaIdentityIndex)</span></span><br><span class="line"><span class="addition">+	indname = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+	if (tab-&gt;replicaIdentityIndex == NULL)</span></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		tab-&gt;replicaIdentityIndex = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+		return;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (strcmp(tab-&gt;replicaIdentityIndex, indname) != 0)</span></span><br><span class="line"> 		elog(ERROR, &quot;relation %u has multiple indexes marked as replica identity&quot;, tab-&gt;relid);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	tab-&gt;replicaIdentityIndex = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+	pfree(indname);</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -12868,13 +12877,22 @@</span> RememberReplicaIdentityForRebuilding(Oid indoid, AlteredTableInfo *tab)</span><br><span class="line"> static void</span><br><span class="line"> RememberClusterOnForRebuilding(Oid indoid, AlteredTableInfo *tab)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+	char	*indname;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	if (!get_index_isclustered(indoid))</span><br><span class="line"> 		return;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (tab-&gt;clusterOnIndex)</span></span><br><span class="line"><span class="addition">+	indname = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+	if (tab-&gt;clusterOnIndex == NULL)</span></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		tab-&gt;clusterOnIndex = indname;</span></span><br><span class="line"><span class="addition">+		return;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (strcmp(tab-&gt;clusterOnIndex, indname) != 0)</span></span><br><span class="line"> 		elog(ERROR, &quot;relation %u has multiple clustered indexes&quot;, tab-&gt;relid);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	tab-&gt;clusterOnIndex = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+	pfree(indname);</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>但是，这种方式过于繁琐，因此，Tom Lane 尝试 <code>get_rel_name()</code> 延迟到之后来进行调用，从而避免反复的调用 <code>get_rel_name()</code> 函数，为此诞生了 v2 版本。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/commands/tablecmds.c b/src/backend/commands/tablecmds.c</span></span><br><span class="line"><span class="comment">index dc5872f988..19c924b7df 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/commands/tablecmds.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/commands/tablecmds.c</span></span><br><span class="line"><span class="meta">@@ -189,8 +189,8 @@</span> typedef struct AlteredTableInfo</span><br><span class="line"> 	List	   *changedConstraintDefs;	/* string definitions of same */</span><br><span class="line"> 	List	   *changedIndexOids;	/* OIDs of indexes to rebuild */</span><br><span class="line"> 	List	   *changedIndexDefs;	/* string definitions of same */</span><br><span class="line"><span class="deletion">-	char	   *replicaIdentityIndex;	/* index to reset as REPLICA IDENTITY */</span></span><br><span class="line"><span class="deletion">-	char	   *clusterOnIndex; /* index to use for CLUSTER */</span></span><br><span class="line"><span class="addition">+	Oid			replicaIdentityIndex;	/* index to reset as REPLICA IDENTITY */</span></span><br><span class="line"><span class="addition">+	Oid			clusterOnIndex; /* index to use for CLUSTER */</span></span><br><span class="line"> 	List	   *changedStatisticsOids;	/* OIDs of statistics to rebuild */</span><br><span class="line"> 	List	   *changedStatisticsDefs;	/* string definitions of same */</span><br><span class="line"> &#125; AlteredTableInfo;</span><br><span class="line"><span class="meta">@@ -12856,10 +12856,12 @@</span> RememberReplicaIdentityForRebuilding(Oid indoid, AlteredTableInfo *tab)</span><br><span class="line"> 	if (!get_index_isreplident(indoid))</span><br><span class="line"> 		return;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (tab-&gt;replicaIdentityIndex)</span></span><br><span class="line"><span class="addition">+	/* We must de-duplicate multiple requests */</span></span><br><span class="line"><span class="addition">+	if (OidIsValid(tab-&gt;replicaIdentityIndex) &amp;&amp;</span></span><br><span class="line"><span class="addition">+		tab-&gt;replicaIdentityIndex != indoid)</span></span><br><span class="line"> 		elog(ERROR, &quot;relation %u has multiple indexes marked as replica identity&quot;, tab-&gt;relid);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	tab-&gt;replicaIdentityIndex = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+	tab-&gt;replicaIdentityIndex = indoid;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -12871,10 +12873,12 @@</span> RememberClusterOnForRebuilding(Oid indoid, AlteredTableInfo *tab)</span><br><span class="line"> 	if (!get_index_isclustered(indoid))</span><br><span class="line"> 		return;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	if (tab-&gt;clusterOnIndex)</span></span><br><span class="line"><span class="addition">+	/* We must de-duplicate multiple requests */</span></span><br><span class="line"><span class="addition">+	if (OidIsValid(tab-&gt;clusterOnIndex) &amp;&amp;</span></span><br><span class="line"><span class="addition">+		tab-&gt;clusterOnIndex != indoid)</span></span><br><span class="line"> 		elog(ERROR, &quot;relation %u has multiple clustered indexes&quot;, tab-&gt;relid);</span><br><span class="line"></span><br><span class="line"><span class="deletion">-	tab-&gt;clusterOnIndex = get_rel_name(indoid);</span></span><br><span class="line"><span class="addition">+	tab-&gt;clusterOnIndex = indoid;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"><span class="meta">@@ -13117,13 +13121,15 @@</span> ATPostAlterTypeCleanup(List **wqueue, AlteredTableInfo *tab, LOCKMODE lockmode)</span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Queue up command to restore replica identity index marking</span><br><span class="line"> 	 */</span><br><span class="line"><span class="deletion">-	if (tab-&gt;replicaIdentityIndex)</span></span><br><span class="line"><span class="addition">+	if (OidIsValid(tab-&gt;replicaIdentityIndex))</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		AlterTableCmd *cmd = makeNode(AlterTableCmd);</span><br><span class="line"> 		ReplicaIdentityStmt *subcmd = makeNode(ReplicaIdentityStmt);</span><br><span class="line"></span><br><span class="line"> 		subcmd-&gt;identity_type = REPLICA_IDENTITY_INDEX;</span><br><span class="line"><span class="deletion">-		subcmd-&gt;name = tab-&gt;replicaIdentityIndex;</span></span><br><span class="line"><span class="addition">+		subcmd-&gt;name = get_rel_name(tab-&gt;replicaIdentityIndex);</span></span><br><span class="line"><span class="addition">+		Assert(subcmd-&gt;name);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 		cmd-&gt;subtype = AT_ReplicaIdentity;</span><br><span class="line"> 		cmd-&gt;def = (Node *) subcmd;</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -13135,12 +13141,13 @@</span> ATPostAlterTypeCleanup(List **wqueue, AlteredTableInfo *tab, LOCKMODE lockmode)</span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Queue up command to restore marking of index used for cluster.</span><br><span class="line"> 	 */</span><br><span class="line"><span class="deletion">-	if (tab-&gt;clusterOnIndex)</span></span><br><span class="line"><span class="addition">+	if (OidIsValid(tab-&gt;clusterOnIndex))</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		AlterTableCmd *cmd = makeNode(AlterTableCmd);</span><br><span class="line"></span><br><span class="line"> 		cmd-&gt;subtype = AT_ClusterOn;</span><br><span class="line"><span class="deletion">-		cmd-&gt;name = tab-&gt;clusterOnIndex;</span></span><br><span class="line"><span class="addition">+		cmd-&gt;name = get_rel_name(tab-&gt;clusterOnIndex);</span></span><br><span class="line"><span class="addition">+		Assert(cmd-&gt;name);</span></span><br><span class="line"></span><br><span class="line"> 		/* do it after indexes and constraints */</span><br><span class="line"> 		tab-&gt;subcmds[AT_PASS_OLD_CONSTR] =</span><br></pre></td></tr></table></figure>

<p>上述两个版本都能解决这个问题，但是大神的脚本并没有因此而停下，Tom Lane 又继续分析了 <code>get_constraint_index()</code> 函数，他发现这个函数在前后的语义已经发生了变化。表 <code>attbl</code> 有 <code>pk_attbl</code> 主键约束，同时也有 <code>fk_attbl</code> 外键约束。函数 <code>get_constraint_index()</code> 的新实现返回 <code>pk_attbl</code> 索引作为两个约束的关联索引，而旧代码只为 <code>pk_attbl</code> 约束返回它。v3 版本则是在 <code>get_constraint_index()</code> 加入了对 <code>contype</code> 的判断。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/utils/cache/lsyscache.c b/src/backend/utils/cache/lsyscache.c</span></span><br><span class="line"><span class="comment">index feef999863..1b7e11b93e 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/cache/lsyscache.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/cache/lsyscache.c</span></span><br><span class="line"><span class="meta">@@ -1126,8 +1126,13 @@</span> get_constraint_name(Oid conoid)</span><br><span class="line">  *		Given the OID of a unique, primary-key, or exclusion constraint,</span><br><span class="line">  *		return the OID of the underlying index.</span><br><span class="line">  *</span><br><span class="line"><span class="deletion">- * Return InvalidOid if the index couldn&#x27;t be found; this suggests the</span></span><br><span class="line"><span class="deletion">- * given OID is bogus, but we leave it to caller to decide what to do.</span></span><br><span class="line"><span class="addition">+ * Returns InvalidOid if the constraint could not be found or is of</span></span><br><span class="line"><span class="addition">+ * the wrong type.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * The intent of this function is to return the index &quot;owned&quot; by the</span></span><br><span class="line"><span class="addition">+ * specified constraint.  Therefore we must check contype, since some</span></span><br><span class="line"><span class="addition">+ * pg_constraint entries (e.g. for foreign-key constraints) store the</span></span><br><span class="line"><span class="addition">+ * OID of an index that is referenced but not owned by the constraint.</span></span><br><span class="line">  */</span><br><span class="line"> Oid</span><br><span class="line"> get_constraint_index(Oid conoid)</span><br><span class="line"><span class="meta">@@ -1140,7 +1145,12 @@</span> get_constraint_index(Oid conoid)</span><br><span class="line"> 		Form_pg_constraint contup = (Form_pg_constraint) GETSTRUCT(tp);</span><br><span class="line"> 		Oid			result;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-		result = contup-&gt;conindid;</span></span><br><span class="line"><span class="addition">+		if (contup-&gt;contype == CONSTRAINT_UNIQUE ||</span></span><br><span class="line"><span class="addition">+			contup-&gt;contype == CONSTRAINT_PRIMARY ||</span></span><br><span class="line"><span class="addition">+			contup-&gt;contype == CONSTRAINT_EXCLUSION)</span></span><br><span class="line"><span class="addition">+			result = contup-&gt;conindid;</span></span><br><span class="line"><span class="addition">+		else</span></span><br><span class="line"><span class="addition">+			result = InvalidOid;</span></span><br><span class="line"> 		ReleaseSysCache(tp);</span><br><span class="line"> 		return result;</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/17409-52871dda8b5741cb%40postgresql.org">https://www.postgresql.org/message-id/17409-52871dda8b5741cb%40postgresql.org</a></p>
<div class="just-for-fun">
笑林广记 - 自不识

<p>有监生穿大衣，带圆帽，于着衣镜中自照，得意甚，指谓妻曰：“你看镜中是何人？”<br>妻曰：“臭乌龟，亏你做了监生，连自（字同）都不识。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>BUG</tag>
        <tag>PG14</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 更新 configure 引入无关更改</title>
    <url>/2021/02/postgresql-update-configure-file/</url>
    <content><![CDATA[<p>PostgreSQL 使用 autoconf 工具来自动配置软件源代码包。我在修改了 configure.ac 文件之后执行 autoreconf 发现它将引入其他无关的更改，如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -1187,6 +1189,15 @@</span> do</span><br><span class="line">   | -silent | --silent | --silen | --sile | --sil)</span><br><span class="line">     silent=yes ;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  -runstatedir | --runstatedir | --runstatedi | --runstated \</span></span><br><span class="line"><span class="addition">+  | --runstate | --runstat | --runsta | --runst | --runs \</span></span><br><span class="line"><span class="addition">+  | --run | --ru | --r)</span></span><br><span class="line"><span class="addition">+    ac_prev=runstatedir ;;</span></span><br><span class="line"><span class="addition">+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \</span></span><br><span class="line"><span class="addition">+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \</span></span><br><span class="line"><span class="addition">+  | --run=* | --ru=* | --r=*)</span></span><br><span class="line"><span class="addition">+    runstatedir=$ac_optarg ;;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -14714,7 +14738,7 @@</span> else</span><br><span class="line">     We can&#x27;t simply define LARGE_OFF_T to be 9223372036854775807,</span><br><span class="line">     since some C++ compilers masquerading as C compilers</span><br><span class="line">     incorrectly reject 9223372036854775807.  */</span><br><span class="line"><span class="deletion">-#define LARGE_OFF_T (((off_t) 1 &lt;&lt; 62) - 1 + ((off_t) 1 &lt;&lt; 62))</span></span><br><span class="line"><span class="addition">+#define LARGE_OFF_T ((((off_t) 1 &lt;&lt; 31) &lt;&lt; 31) - 1 + (((off_t) 1 &lt;&lt; 31) &lt;&lt; 31))</span></span><br><span class="line">   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721</span><br><span class="line">               &amp;&amp; LARGE_OFF_T % 2147483647 == 1)</span><br><span class="line">              ? 1 : -1];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是由于供应商的软件包经常包含一些改进导致的，这就导致了我们生成的 configure 文件与其他提交者的有不同的结果。</p>
<span id="more"></span>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们可以从 autoconf 的<a href="https://www.gnu.org/software/autoconf/#downloading">官网下载</a>并重新安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xf autoconf-2.69.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> autoconf-2.69</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>/autoconf-2.69</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure>

<p>最后将 <code>/usr/local/autoconf-2.69/bin</code> 加入到 <code>PATH</code> 环境变量的开始（确保我们安装的 autoconf 先于系统的即可）并重新载入环境变量。随后执行 <code>autoreconf</code> 命令更新 <code>configure</code> 文件，这时就不会引入其他无关的更改。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/message-id/flat/20181229140802.GE2972%40paquier.xyz">https://www.postgresql.org/message-id/flat/20181229140802.GE2972%40paquier.xyz</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 更新组合类型的 domain 类型数组导致崩溃</title>
    <url>/2021/10/postgresql-update-on-domain-array-based-on-a-composite-crashed/</url>
    <content><![CDATA[<p>最近发现 PostgreSQL 在更新组合类型构成的 domain 数组将导致数据库崩溃。在写这篇文章的时候这个 bug 已经被修复了。</p>
<img src="/2021/10/postgresql-update-on-domain-array-based-on-a-composite-crashed/commit.png" class="">

<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>为了复现这个问题，我们使用 <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=998d060f3db79c6918cb4a547695be150833f9a4">998d060f3d</a> 的代码来进行复现。首先，我们通过下面的 SQL 准备一个基本的测试环境。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE comptype <span class="keyword">AS</span> (cf1 <span class="type">int</span>, cf2 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE</span> DOMAIN dcomptype <span class="keyword">AS</span> comptype <span class="keyword">CHECK</span> ((<span class="keyword">value</span>).cf1 <span class="operator">&gt;</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dcomptable (f1 dcomptype[]);</span><br></pre></td></tr></table></figure>

<p>接着，我们向表中插入数据，此时将导致 coredump。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dcomptable (f1[<span class="number">0</span>].cf1) <span class="keyword">VALUES</span> (<span class="number">4</span>);</span><br><span class="line">server closed the connection unexpectedly</span><br><span class="line">        This probably means the server terminated abnormally</span><br><span class="line">        before <span class="keyword">or</span> while processing the request.</span><br><span class="line">The connection <span class="keyword">to</span> the server was lost. Attempting reset: Failed.</span><br><span class="line"><span class="operator">!</span>?<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>日志如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-10-20 11:14:22.313 CST [649100] LOG:  server process (PID 649976) was terminated by signal 11: Segmentation fault</span><br><span class="line">2021-10-20 11:14:22.313 CST [649100] DETAIL:  Failed process was running: insert into dcomptable (f1[0].cf1) values (4);</span><br><span class="line">2021-10-20 11:14:22.313 CST [649100] LOG:  terminating any other active server processes</span><br><span class="line">2021-10-20 11:14:22.319 CST [649100] LOG:  all server processes terminated; reinitializing</span><br><span class="line">2021-10-20 11:14:22.340 CST [649984] LOG:  database system was interrupted; last known up at 2021-10-20 11:11:20 CST</span><br><span class="line">2021-10-20 11:14:22.361 CST [649984] LOG:  database system was not properly shut down; automatic recovery in progress</span><br><span class="line">2021-10-20 11:14:22.369 CST [649984] LOG:  redo starts at 0/149E670</span><br><span class="line">2021-10-20 11:14:22.370 CST [649984] LOG:  invalid record length at 0/149E6A8: wanted 24, got 0</span><br><span class="line">2021-10-20 11:14:22.370 CST [649984] LOG:  redo done at 0/149E670 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</span><br><span class="line">2021-10-20 11:14:22.409 CST [649100] LOG:  database system is ready to accept connections</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当程序崩溃后，堆栈信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x000055c22ce2d24d in pg_detoast_datum (datum=0x0)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/utils/fmgr/fmgr.c:1724</span><br><span class="line">#1  0x000055c22c9f238c in ExecEvalFieldStoreDeForm (state=0x55c22dc94688, op=0x55c22dc94968, econtext=0x55c22dc94388)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/executor/execExprInterp.c:3153</span><br><span class="line">#2  0x000055c22c9ee477 in ExecInterpExpr (state=0x55c22dc94688, econtext=0x55c22dc94388, isnull=0x7ffe292151ef)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/executor/execExprInterp.c:1437</span><br><span class="line">#3  0x000055c22c9ef382 in ExecInterpExprStillValid (state=0x55c22dc94688, econtext=0x55c22dc94388,</span><br><span class="line">    isNull=0x7ffe292151ef) at /home/px/Codes/postgres/Debug/../src/backend/executor/execExprInterp.c:1824</span><br><span class="line">#4  0x000055c22ca4808b in ExecEvalExprSwitchContext (state=0x55c22dc94688, econtext=0x55c22dc94388,</span><br><span class="line">    isNull=0x7ffe292151ef) at /home/px/Codes/postgres/Debug/../src/include/executor/executor.h:339</span><br><span class="line">#5  0x000055c22ca48103 in ExecProject (projInfo=0x55c22dc94680)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/include/executor/executor.h:373</span><br><span class="line">#6  0x000055c22ca48338 in ExecResult (pstate=0x55c22dc94270)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/executor/nodeResult.c:136</span><br><span class="line">#7  0x000055c22ca0505e in ExecProcNodeFirst (node=0x55c22dc94270)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/executor/execProcnode.c:463</span><br><span class="line">#8  0x000055c22ca4030f in ExecProcNode (node=0x55c22dc94270)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/include/executor/executor.h:257</span><br><span class="line">#9  0x000055c22ca4429d in ExecModifyTable (pstate=0x55c22dc93d98)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/executor/nodeModifyTable.c:2425</span><br><span class="line">#10 0x000055c22ca0505e in ExecProcNodeFirst (node=0x55c22dc93d98)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/executor/execProcnode.c:463</span><br><span class="line">#11 0x000055c22c9f903a in ExecProcNode (node=0x55c22dc93d98)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/include/executor/executor.h:257</span><br><span class="line">#12 0x000055c22c9fba73 in ExecutePlan (estate=0x55c22dc93b20, planstate=0x55c22dc93d98, use_parallel_mode=false,</span><br><span class="line">    operation=CMD_INSERT, sendTuples=false, numberTuples=0, direction=ForwardScanDirection, dest=0x55c22dbf5968,</span><br><span class="line">    execute_once=true) at /home/px/Codes/postgres/Debug/../src/backend/executor/execMain.c:1551</span><br><span class="line">#13 0x000055c22c9f9714 in standard_ExecutorRun (queryDesc=0x55c22dbf6a80, direction=ForwardScanDirection, count=0,</span><br><span class="line">    execute_once=true) at /home/px/Codes/postgres/Debug/../src/backend/executor/execMain.c:361</span><br><span class="line">#14 0x000055c22c9f9523 in ExecutorRun (queryDesc=0x55c22dbf6a80, direction=ForwardScanDirection, count=0,</span><br><span class="line">    execute_once=true) at /home/px/Codes/postgres/Debug/../src/backend/executor/execMain.c:305</span><br><span class="line">#15 0x000055c22cc69a81 in ProcessQuery (plan=0x55c22dbf5878,</span><br><span class="line">    sourceText=0x55c22dbce2f0 &quot;insert into dcomptable (f1[0].cf1) values (4);&quot;, params=0x0, queryEnv=0x0,</span><br><span class="line">    dest=0x55c22dbf5968, qc=0x7ffe29215780) at /home/px/Codes/postgres/Debug/../src/backend/tcop/pquery.c:160</span><br><span class="line">#16 0x000055c22cc6b5ba in PortalRunMulti (portal=0x55c22dc358e0, isTopLevel=true, setHoldSnapshot=false,</span><br><span class="line">    dest=0x55c22dbf5968, altdest=0x55c22dbf5968, qc=0x7ffe29215780)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/tcop/pquery.c:1274</span><br><span class="line">#17 0x000055c22cc6aad2 in PortalRun (portal=0x55c22dc358e0, count=9223372036854775807, isTopLevel=true,</span><br><span class="line">    run_once=true, dest=0x55c22dbf5968, altdest=0x55c22dbf5968, qc=0x7ffe29215780)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/tcop/pquery.c:788</span><br><span class="line">#18 0x000055c22cc63cbf in exec_simple_query (</span><br><span class="line">    query_string=0x55c22dbce2f0 &quot;insert into dcomptable (f1[0].cf1) values (4);&quot;)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/tcop/postgres.c:1214</span><br><span class="line">#19 0x000055c22cc688e0 in PostgresMain (dbname=0x55c22dbf9798 &quot;postgres&quot;, username=0x55c22dbc9d98 &quot;px&quot;)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/tcop/postgres.c:4497</span><br><span class="line">#20 0x000055c22cb92c91 in BackendRun (port=0x55c22dbf7560)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4573</span><br><span class="line">#21 0x000055c22cb92576 in BackendStartup (port=0x55c22dbf7560)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4301</span><br><span class="line">#22 0x000055c22cb8e5cb in ServerLoop () at /home/px/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1801</span><br><span class="line">#23 0x000055c22cb8dd64 in PostmasterMain (argc=1, argv=0x55c22dbc7d40)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1473</span><br><span class="line">#24 0x000055c22ca82599 in main (argc=1, argv=0x55c22dbc7d40)</span><br><span class="line">    at /home/px/Codes/postgres/Debug/../src/backend/main/main.c:198</span><br></pre></td></tr></table></figure>

<p>这里 <code>pg_detoast_datum()</code> 函数的值为空导致了崩溃，函数 <code>pg_detoast_datum()</code> 由 <code>DatumGetHeapTupleHeader()</code> 调用，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * heap_deform_tuple needs a HeapTuple not a bare HeapTupleHeader. We</span></span><br><span class="line"><span class="comment"> * set all the fields in the struct just in case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Datum       tupDatum = *op-&gt;resvalue;</span><br><span class="line">HeapTupleHeader tuphdr;</span><br><span class="line">HeapTupleData tmptup;</span><br><span class="line"></span><br><span class="line">tuphdr = DatumGetHeapTupleHeader(tupDatum);</span><br><span class="line">tmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);</span><br><span class="line">ItemPointerSetInvalid(&amp;(tmptup.t_self));</span><br><span class="line">tmptup.t_tableOid = InvalidOid;</span><br><span class="line">tmptup.t_data = tuphdr;</span><br><span class="line"></span><br><span class="line">heap_deform_tuple(&amp;tmptup, tupDesc,</span><br><span class="line">                  op-&gt;d.fieldstore.values,</span><br><span class="line">                  op-&gt;d.fieldstore.nulls);</span><br></pre></td></tr></table></figure>

<p>然而这里 <code>tupDatum</code> 是空的，因此，为了避免出现崩溃，我们可以在这里加上一个判断，如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/executor/execExprInterp.c b/src/backend/executor/execExprInterp.c</span></span><br><span class="line"><span class="comment">index eb49817cee..1ce14097d8 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/executor/execExprInterp.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/executor/execExprInterp.c</span></span><br><span class="line"><span class="meta">@@ -3150,6 +3150,10 @@</span> ExecEvalFieldStoreDeForm(ExprState *state, ExprEvalStep *op, ExprContext *econte</span><br><span class="line">                HeapTupleHeader tuphdr;</span><br><span class="line">                HeapTupleData tmptup;</span><br><span class="line"></span><br><span class="line"><span class="addition">+               if (DatumGetPointer(tupDatum) == NULL)</span></span><br><span class="line"><span class="addition">+                       return;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">                tuphdr = DatumGetHeapTupleHeader(tupDatum);</span><br><span class="line">                tmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);</span><br><span class="line">                ItemPointerSetInvalid(&amp;(tmptup.t_self));</span><br></pre></td></tr></table></figure>

<p>重新编译执行测试 SQL 语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dcomptable (f1[<span class="number">0</span>].cf1) <span class="keyword">VALUES</span> (<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcomptable;</span><br><span class="line">       f1</span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> [<span class="number">0</span>:<span class="number">0</span>]<span class="operator">=</span>&#123;&quot;(4,)&quot;&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>似乎一切都正常了，然而真的是这样么？我们来尝试一下更新语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># UPDATE dcomptable <span class="keyword">SET</span> f1[<span class="number">0</span>].cf2 <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">UPDATE <span class="number">1</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcomptable;</span><br><span class="line">       f1</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"> [<span class="number">0</span>:<span class="number">0</span>]<span class="operator">=</span>&#123;&quot;(,10)&quot;&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>WTF? 为什么 <code>f1[0].cf1</code> 的值丢失了呢？我们尝试同时更新 <code>cf1</code> 和 <code>cf2</code>，看看会发生什么。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># UPDATE dcomptable <span class="keyword">SET</span> f1[<span class="number">0</span>].cf2 <span class="operator">=</span> <span class="number">1</span>, f1[<span class="number">0</span>].cf1 <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">UPDATE <span class="number">1</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcomptable;</span><br><span class="line">       f1</span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> [<span class="number">0</span>:<span class="number">0</span>]<span class="operator">=</span>&#123;&quot;(2,)&quot;&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>这里仅仅保留了最后一个值（<code>f1[0].cf1</code>）。</p>
<p>因此，这就迫使我们重新思考上面的 patch 的正确性了（当时并没有那么仔细的想过这个问题）。为什么当初这里并没有判断 <code>tupDatum</code> 是否为空呢？是否存在某种前提，从而可以断定这里不会存在空的情况呢？</p>
<p>到这里，Tom Lane 大神站出来了。</p>
<blockquote>
<p>This patch seems quite misguided to me.  The proximate cause of<br>the crash is that we’re arriving at ExecEvalFieldStoreDeForm with<br>*op-&gt;resnull and *op-&gt;resvalue both zero, which is a completely<br>invalid situation for a pass-by-reference datatype; so something<br>upstream of this messed up.  Even if there were an argument for<br>acting as though that were a valid NULL value, this patch fails to<br>do so; that’d require setting all the output fieldstore.nulls[]<br>entries to true, which you didn’t.</p>
</blockquote>
<p>大意就是在 <code>ExecEvalFieldStoreDeForm()</code> 函数中不应该出现 <code>*op-&gt;resnull</code> 和 <code>*op-&gt;resvalue</code> 同时为空的情况，换言之，若出现这种情况，那么肯定是上层某个地方出错了。随后，大神也给出了解释。</p>
<blockquote>
<p>After some digging around, I see where the issue actually is:<br>the expression tree we’re dealing with looks like</p>
<pre><code>             &#123;SUBSCRIPTINGREF
             :refexpr
                &#123;VAR
                &#125;
             :refassgnexpr
                &#123;COERCETODOMAIN
                :arg
                   &#123;FIELDSTORE
                   :arg
                      &#123;CASETESTEXPR
                      &#125;
                   &#125;
                &#125;
             &#125;
</code></pre>
<p>The array element we intend to replace has to be passed down to<br>the CaseTestExpr, but that isn’t happening.  That’s because<br>isAssignmentIndirectionExpr fails to recognize a tree like<br>this, so ExecInitSubscriptingRef doesn’t realize it needs to<br>arrange for that.</p>
</blockquote>
<p>这是由于 <code>isAssignmentIndirectionExpr()</code> 在处理间接表达式是遗忘了 <code>domain</code> 数组类型导致的。最终的解决方案如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/executor/execExpr.c b/src/backend/executor/execExpr.c</span></span><br><span class="line"><span class="comment">index 81b9d87bad..33ef39e2d4 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/executor/execExpr.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/executor/execExpr.c</span></span><br><span class="line"><span class="meta">@@ -3092,11 +3092,14 @@</span> ExecInitSubscriptingRef(ExprEvalStep *scratch, SubscriptingRef *sbsref,</span><br><span class="line">  * (We could use this in FieldStore too, but in that case passing the old</span><br><span class="line">  * value is so cheap there&#x27;s no need.)</span><br><span class="line">  *</span><br><span class="line"><span class="deletion">- * Note: it might seem that this needs to recurse, but it does not; the</span></span><br><span class="line"><span class="deletion">- * CaseTestExpr, if any, will be directly the arg or refexpr of the top-level</span></span><br><span class="line"><span class="deletion">- * node.  Nested-assignment situations give rise to expression trees in which</span></span><br><span class="line"><span class="deletion">- * each level of assignment has its own CaseTestExpr, and the recursive</span></span><br><span class="line"><span class="deletion">- * structure appears within the newvals or refassgnexpr field.</span></span><br><span class="line"><span class="addition">+ * Note: it might seem that this needs to recurse, but in most cases it does</span></span><br><span class="line"><span class="addition">+ * not; the CaseTestExpr, if any, will be directly the arg or refexpr of the</span></span><br><span class="line"><span class="addition">+ * top-level node.  Nested-assignment situations give rise to expression</span></span><br><span class="line"><span class="addition">+ * trees in which each level of assignment has its own CaseTestExpr, and the</span></span><br><span class="line"><span class="addition">+ * recursive structure appears within the newvals or refassgnexpr field.</span></span><br><span class="line"><span class="addition">+ * There is an exception, though: if the array is an array-of-domain, we will</span></span><br><span class="line"><span class="addition">+ * have a CoerceToDomain as the refassgnexpr, and we need to be able to look</span></span><br><span class="line"><span class="addition">+ * through that.</span></span><br><span class="line">  */</span><br><span class="line"> static bool</span><br><span class="line"> isAssignmentIndirectionExpr(Expr *expr)</span><br><span class="line"><span class="meta">@@ -3117,6 +3120,12 @@</span> isAssignmentIndirectionExpr(Expr *expr)</span><br><span class="line">                if (sbsRef-&gt;refexpr &amp;&amp; IsA(sbsRef-&gt;refexpr, CaseTestExpr))</span><br><span class="line">                        return true;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+       else if (IsA(expr, CoerceToDomain))</span></span><br><span class="line"><span class="addition">+       &#123;</span></span><br><span class="line"><span class="addition">+               CoerceToDomain *cd = (CoerceToDomain *) expr;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+               return isAssignmentIndirectionExpr(cd-&gt;arg);</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line">        return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，一切正常。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># UPDATE dcomptable <span class="keyword">SET</span> f1[<span class="number">0</span>].cf2 <span class="operator">=</span> <span class="number">1</span>, f1[<span class="number">0</span>].cf1 <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">UPDATE <span class="number">1</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcomptable;</span><br><span class="line">       f1</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"> [<span class="number">0</span>:<span class="number">0</span>]<span class="operator">=</span>&#123;&quot;(2,1)&quot;&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># UPDATE dcomptable <span class="keyword">SET</span> f1[<span class="number">0</span>].cf2 <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">UPDATE <span class="number">1</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcomptable;</span><br><span class="line">        f1</span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"> [<span class="number">0</span>:<span class="number">0</span>]<span class="operator">=</span>&#123;&quot;(2,10)&quot;&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<div class="just-for-fun">
笑林广记 - 家属

<p>官坐堂，众后中有撒一响屁者。<br>官即叫：“拿来！”<br>隶禀曰：“老爷，屁是一阵风，吹散没影踪，叫小的如何拿得？”<br>官怒云：“为何徇情卖放，定要拿到。”<br>皂无奈，只得取干屎回销：“禀老爷，正犯是走了，拿得家属在此。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PyInstaller 打包 PyQt5 失败 - 执行脚本失败</title>
    <url>/2019/07/pyinstaller-package-pyqt5-error-on-Qt5Core/</url>
    <content><![CDATA[<p>最近用 Python 帮人写一个程序，主体工作完成之后，利用 PyQt 写了一个界面，通过命令行运行一切正常，然后，利用 PyInstaller 打包成一个单独的可执行文件时，问题就来了:( 。我使用打包命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -w xxx.py</span><br></pre></td></tr></table></figure>

<p>运行可执行文件时，弹出的对话框显示如下信息，此外就没有别的其它信息了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;failed to execute script xxx&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table>
<thead>
<tr>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Windows 10</td>
</tr>
<tr>
<td>PyQt5</td>
<td>5.13.0</td>
</tr>
<tr>
<td>Python</td>
<td>3.7.4</td>
</tr>
<tr>
<td>PyInstaller</td>
<td>3.5</td>
</tr>
</tbody></table>
<h2 id="问题追溯"><a href="#问题追溯" class="headerlink" title="问题追溯"></a>问题追溯</h2><p>但从上面的错误无法得到更多的信息，因此，我尝试使用 <code>-c</code> 的打包方式，即在程序后端运行一个终端。其打包命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -c xxx.py</span><br></pre></td></tr></table></figure>

<p>这是再次运行，可以后终端中看到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;gui.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    from PyQt5.QtCore import Qt</span><br><span class="line">  File &quot;c:\python37-32\lib\site-packages\PyInstaller\loader\pyimod03_importers.py&quot;, line 627, in exec_module</span><br><span class="line">    exec(bytecode, module.__dict__)</span><br><span class="line">  File &quot;site-packages\PyQt5\__init__.py&quot;, line 41, in &lt;module&gt;</span><br><span class="line">  File &quot;site-packages\PyQt5\__init__.py&quot;, line 33, in find_qt</span><br><span class="line">ImportError: unable to find Qt5Core.dll on PATH</span><br><span class="line">[6852] Failed to execute script gui</span><br></pre></td></tr></table></figure>

<p>此时，问题就比较明显了，程序运行时缺少 <code>Qt5Core.dll</code> 动态库。此时，我尝试把 <code>Qt5Core.dll</code> 文件拷贝到当前目录后，再次运行依然出现上述问题。</p>
<p>搜索时发现这个问题还是个普遍问题，大家都遇到了，具体参考<a href="https://github.com/pyinstaller/pyinstaller/issues/4293">这里</a>。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在 PyQt5.13 中，其 <code>__init__.py</code> 文件内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright (c) 2019 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is part of PyQt5.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file may be used under the terms of the GNU General Public License</span></span><br><span class="line"><span class="comment"># version 3.0 as published by the Free Software Foundation and appearing in</span></span><br><span class="line"><span class="comment"># the file LICENSE included in the packaging of this file.  Please review the</span></span><br><span class="line"><span class="comment"># following information to ensure the GNU General Public License version 3.0</span></span><br><span class="line"><span class="comment"># requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you do not wish to use this file under the terms of the GPL version 3.0</span></span><br><span class="line"><span class="comment"># then you may purchase a commercial license.  For more information contact</span></span><br><span class="line"><span class="comment"># info@riverbankcomputing.com.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span></span><br><span class="line"><span class="comment"># WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_qt</span>():</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">    path = os.environ[<span class="string">&#x27;PATH&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    dll_dir = os.path.dirname(__file__) + <span class="string">&#x27;\\Qt\\bin&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(dll_dir + <span class="string">&#x27;\\Qt5Core.dll&#x27;</span>):</span><br><span class="line">        path = dll_dir + <span class="string">&#x27;;&#x27;</span> + path</span><br><span class="line">        os.environ[<span class="string">&#x27;PATH&#x27;</span>] = path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> dll_dir <span class="keyword">in</span> path.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(dll_dir + <span class="string">&#x27;\\Qt5Core.dll&#x27;</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ImportError(<span class="string">&quot;unable to find Qt5Core.dll on PATH&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.add_dll_directory(dll_dir)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_qt()</span><br><span class="line"><span class="keyword">del</span> find_qt</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，错误是在 <code>raise ImportError(&quot;unable to find Qt5Core.dll on PATH&quot;)</code> 这里报出来。这段代码的大致意思就是在系统的环境变量 PATH 路径下去找 <code>Qt5Core.dll</code> 文件，而实际上这个文件并不在 PATH 路径下。</p>
<p>我们在使用 PyInstaller 打包时，指定 <code>-F</code> 选项理论上是会将 <code>Qt5Core.dll</code> 文件打包进可执行文件的，但是由于 PyQT5.13 默认在系统 PATH 路径下查找，因此出错了。</p>
<p>我们可以将下面的内容注释掉，然后一切运行正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else:</span><br><span class="line">    raise ImportError(&quot;unable to find Qt5Core.dll on PATH&quot;)</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用之前版本的代码替换现有代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os <span class="keyword">as</span> _os</span><br><span class="line"></span><br><span class="line">_path = _os.path.dirname(__file__) + <span class="string">&#x27;\\Qt\\bin;&#x27;</span> + _os.environ[<span class="string">&#x27;PATH&#x27;</span>]</span><br><span class="line">_os.environ[<span class="string">&#x27;PATH&#x27;</span>] = _path</span><br></pre></td></tr></table></figure>

<p>经过修改后，再次打包运行一切正常。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/pyinstaller/pyinstaller/issues/4293#issuecomment-507254991">https://github.com/pyinstaller/pyinstaller/issues/4293#issuecomment-507254991</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt5</tag>
        <tag>PyInstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5 信号槽自定义参数</title>
    <url>/2019/04/pyqt5-signal-slot/</url>
    <content><![CDATA[<p>我们知道 PyQt5 利用信号和槽在对象之间传递数据，当特定的事件发生时，信号将通过 <code>emit</code> 发出，槽则负责响应该信号。QT 中的对象已经包含了非常多信号的定义。本文对信号槽的使用不做具体介绍，感兴趣的朋友可以参考<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/signals_slots.html">这里</a>，我在这里主要记录如何对信号传递用户自定义参数。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面我想给出一个典型的示例程序，在这个程序中我只是简单的添加一个按钮，然后给出按钮被按下的次数，完整的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QLabel</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QPushButton</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QHBoxLayout</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApp</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.clicknum = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        hbox = QHBoxLayout()</span><br><span class="line">        self.label = QLabel(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;click me&#x27;</span>)</span><br><span class="line">        self.button.clicked.connect(self.clickMe)</span><br><span class="line">        hbox.addWidget(self.button)</span><br><span class="line">        hbox.addWidget(self.label)</span><br><span class="line">        widget = QWidget()</span><br><span class="line">        widget.setLayout(hbox)</span><br><span class="line">        self.setCentralWidget(widget)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clickMe</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.clicknum &gt; <span class="number">1</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; times&#x27;</span>.<span class="built_in">format</span>(self.clicknum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; time&#x27;</span>.<span class="built_in">format</span>(self.clicknum)</span><br><span class="line"></span><br><span class="line">        self.label.setText(message)</span><br><span class="line">        self.clicknum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    testapp = TestApp()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的程序非常简单，就是记录从程序开始运行到结束时一共按了多少次按钮。</p>
<img src="/2019/04/pyqt5-signal-slot/simple-test.png" class="">

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>其实此处我主要是为了演示而特意给出这个不太符合常理的做法 (相当的无厘头)。下面请看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QLabel</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QPushButton</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QHBoxLayout</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApp</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.clicknum = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        hbox = QHBoxLayout()</span><br><span class="line">        self.label = QLabel(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;click me&#x27;</span>)</span><br><span class="line">        self.button.clicked.connect(<span class="keyword">lambda</span>: self.clickMe(self.clicknum))</span><br><span class="line">        hbox.addWidget(self.button)</span><br><span class="line">        hbox.addWidget(self.label)</span><br><span class="line">        widget = QWidget()</span><br><span class="line">        widget.setLayout(hbox)</span><br><span class="line">        self.setCentralWidget(widget)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clickMe</span>(<span class="params">self, clicknum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> clicknum &gt; <span class="number">1</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; times&#x27;</span>.<span class="built_in">format</span>(clicknum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            message = <span class="string">&#x27;click: &#123;0&#125; time&#x27;</span>.<span class="built_in">format</span>(clicknum)</span><br><span class="line"></span><br><span class="line">        self.label.setText(message)</span><br><span class="line">        self.clicknum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    testapp = TestApp()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将按钮所关联的槽使用 <code>lambda</code> 方式给出，并为它赋予了一个参数。这样每次在信号被触发时，<code>self.clicknum</code> 的值都将被传递过去。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://eli.thegreenplace.net/2011/04/25/passing-extra-arguments-to-pyqt-slot/">Passing extra arguments to PyQt slots</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 多语言国际化支持</title>
    <url>/2018/11/python-internationalization-support/</url>
    <content><![CDATA[<!--
GNU gettext 是国际化 (i18n) 开发古老而成熟的解决方案。它可以用于本地化任何类型的应用程序，并且在支持不同区域设置和规则方面十分灵活。在本文中，我们将介绍如何使用 Python 标准库中自带的 gettext 模块来实现程序的多语言支持。
-->


<p>Python 的 gettext 模块为应用程序提供了国际化 (Internationalization, I18N) 和本地化 (Localization, L10N) 的服务。该模块提供了两类 APIs：(a) 支持 GNU gettext 的基本 API；(b) 适合 Python 的并且基于类的 API。本文主要针对第二类 API 进行介绍。</p>
<p>为了向 Python 程序提供多语言消息，我们需要按以下步骤进行：</p>
<ol>
<li>使用包装函数对程序中所有可以翻译的字符串进行标记；</li>
<li>使用 xgettext 在标记的文件上生成原始消息目录或 POT 文件；</li>
<li>将 POT 文件复制到特定的区域设置目录并进行翻译（需要使用专用的编辑器）；</li>
<li>导入并使用 gettext 模块，以便正确转换消息字符串。</li>
</ol>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了更好的理解整个过程，我们需要一个想要本地化的示例程序。我们的示例程序目录结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i18n/</span><br><span class="line">+-- locales</span><br><span class="line">|   +-- en_US</span><br><span class="line">|   |   +-- LC_MESSAGES</span><br><span class="line">|   +-- zh_CN</span><br><span class="line">|       +-- LC_MESSAGES</span><br><span class="line">+-- src</span><br><span class="line">    +-- main.py</span><br></pre></td></tr></table></figure>

<p>目录 <code>locales</code> 用于存放多国语言之间的翻译文件，<code>src</code> 则用于存放源码文件。正如上文所述，我们需要标记程序中待翻译的字符串，为了实现这一点，我们将需要翻译的字符串放在 <code>_()</code> 中。文件 main.py 的内容如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Internationalization test.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gettext</span><br><span class="line">_ = gettext.gettext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSomeMessages</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(_(<span class="string">&quot;Hello world!&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(_(<span class="string">&quot;This is a translate message.&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printSomeMessages()</span><br></pre></td></tr></table></figure>

<p>注意，我们引入了 gettext 模块并将 <code>_</code> 赋值为 <code>gettext.gettext</code>。这样可以保证我们的程序可以正常运行。</p>
<h2 id="生成原始翻译消息"><a href="#生成原始翻译消息" class="headerlink" title="生成原始翻译消息"></a>生成原始翻译消息</h2><p>为了自动化在整个应用程序中从包装字符串生成原始可翻译消息的过程，gettext 库的作者提供了一组工具用于解析源文件并提取需要翻译的消息。最初，GNU gettext 仅支持 C/C++ 源码，但是它的扩展程序 xgettext 支持多种语言的源码，包括 Python，Lisp，Java 等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> i18n</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xgettext -o locales/en_US/LC_MESSAGES/base.po_en src/*.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xgettext -o locales/zh_CN/LC_MESSAGES/base.po_zh src/*.py</span></span><br></pre></td></tr></table></figure>

<p>原始信息 (两个文件内容一致) 如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SOME DESCRIPTIVE TITLE.</span><br><span class="line"># Copyright (C) YEAR THE PACKAGE&#x27;S COPYRIGHT HOLDER</span><br><span class="line"># This file is distributed under the same license as the PACKAGE package.</span><br><span class="line"># FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: PACKAGE VERSION\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2018-11-04 10:24+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n&quot;</span><br><span class="line">&quot;Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: LANGUAGE &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text/plain; charset=CHARSET\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: src/main.py:11</span><br><span class="line">msgid &quot;Hello world!&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line"></span><br><span class="line">#: src/main.py:12</span><br><span class="line">msgid &quot;This is a translate message.&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>在得到原始翻译消息之后，我们就可以通过编辑生成的 <code>*.po</code> 文件进行翻译工作了。这里需要注意的是 PO 文件具有自己的格式，因此尽量使用专用的 PO 文件编辑器进行修改。我个人使用的 Emacs + po-mode 进行编辑。</p>
<p>翻译 locales/en_US/LC_MESSAGES/base.po_en 为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># I18N.</span><br><span class="line"># Copyright (C) 2018 Japin Li</span><br><span class="line"># This file is distributed under the same license as the I18N package.</span><br><span class="line"># Japin Li &lt;japinli@hotmail.com&gt;, 2018.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: 0.0.1\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2018-11-04 10:24+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: 2018-11-04 10:26+0800\n&quot;</span><br><span class="line">&quot;Last-Translator: Japin Li &lt;japinli@hotmail.com&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: English &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text/plain; charset=ASCII\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: src/main.py:11</span><br><span class="line">msgid &quot;Hello world!&quot;</span><br><span class="line">msgstr &quot;Hello world!&quot;</span><br><span class="line"></span><br><span class="line">#: src/main.py:12</span><br><span class="line">msgid &quot;This is a translate message.&quot;</span><br><span class="line">msgstr &quot;This is a translate message.&quot;</span><br></pre></td></tr></table></figure>

<p>翻译 locales/zh_CN/LC_MESSAGES/base.po_zh 为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># I18N.</span><br><span class="line"># Copyright (C) 2018 Japin Li</span><br><span class="line"># This file is distributed under the same license as the I18N package.</span><br><span class="line"># Japin Li &lt;japinli@hotmail.com&gt;, 2018.</span><br><span class="line">#</span><br><span class="line">#, fuzzy</span><br><span class="line">msgid &quot;&quot;</span><br><span class="line">msgstr &quot;&quot;</span><br><span class="line">&quot;Project-Id-Version: 0.0.1\n&quot;</span><br><span class="line">&quot;Report-Msgid-Bugs-To: \n&quot;</span><br><span class="line">&quot;POT-Creation-Date: 2018-11-04 10:24+0800\n&quot;</span><br><span class="line">&quot;PO-Revision-Date: 2018-11-04 10:37+0800\n&quot;</span><br><span class="line">&quot;Last-Translator: Japin Li &lt;japinli@hotmail.com&gt;\n&quot;</span><br><span class="line">&quot;Language-Team: Chinese &lt;LL@li.org&gt;\n&quot;</span><br><span class="line">&quot;Language: \n&quot;</span><br><span class="line">&quot;MIME-Version: 1.0\n&quot;</span><br><span class="line">&quot;Content-Type: text/plain; charset=UTF-8\n&quot;</span><br><span class="line">&quot;Content-Transfer-Encoding: 8bit\n&quot;</span><br><span class="line"></span><br><span class="line">#: src/main.py:11</span><br><span class="line">msgid &quot;Hello world!&quot;</span><br><span class="line">msgstr &quot;你好世界！&quot;</span><br><span class="line"></span><br><span class="line">#: src/main.py:12</span><br><span class="line">msgid &quot;This is a translate message.&quot;</span><br><span class="line">msgstr &quot;这是一个翻译消息。&quot;</span><br></pre></td></tr></table></figure>

<p>上述翻译需要注意中文的编码要选择 <code>UTF-8</code>，至于其他的诸如 PACKAGE VERSION，COPYRIGHT 等可以根据自己需要进行填写。当翻译完成之后，我们需要将 <code>*.po</code> 文件通过 msgfmt 最终转换为 <code>*.mo</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> i18n</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> msgfmt -o locales/en_US/LC_MESSAGES/base.mo locales/en_US/LC_MESSAGES/base.po_en</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> msgfmt -o locales/zh_CN/LC_MESSAGES/base.mo locales/zh_CN/LC_MESSAGES/base.po_zh</span></span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>我们修改 src/main.py 文件为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Internationalization test.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gettext</span><br><span class="line">_ = gettext.gettext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSomeMessages</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(_(<span class="string">&quot;Hello world!&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(_(<span class="string">&quot;This is a translate message.&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">localedir=os.path.dirname(os.path.abspath(sys.argv[<span class="number">0</span>])) + <span class="string">&#x27;/../locales&#x27;</span></span><br><span class="line">zh_CN = gettext.translation(<span class="string">&#x27;base&#x27;</span>, localedir, languages=[<span class="string">&#x27;zh_CN&#x27;</span>]);</span><br><span class="line">zh_CN.install()</span><br><span class="line">_ = zh_CN.gettext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printSomeMessages()</span><br></pre></td></tr></table></figure>

<p>其中 <code>getext.translation</code> 函数有三个较为重要的参数。</p>
<ul>
<li>domain - 该参数的名字需要与生成的 <code>*.mo</code> 的文件名匹配。</li>
<li>localedir - 创建的 locales 目录的路径</li>
<li>languages - 需要载入的语言代码</li>
</ul>
<p>最终文件目录结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i18n/</span><br><span class="line">+-- locales</span><br><span class="line">|   +-- en_US</span><br><span class="line">|   |   +-- LC_MESSAGES</span><br><span class="line">|   |       +-- base.mo</span><br><span class="line">|   |       +-- base.po_en</span><br><span class="line">|   +-- zh_CN</span><br><span class="line">|       +-- LC_MESSAGES</span><br><span class="line">|           +-- base.mo</span><br><span class="line">|           +-- base.po_zh</span><br><span class="line">+-- src</span><br><span class="line">    +-- main.py</span><br></pre></td></tr></table></figure>

<p>你可以在 <a href="https://github.com/japinli/i18n">github</a> 上下载整个工程文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://phraseapp.com/blog/posts/translate-python-gnu-gettext/">https://phraseapp.com/blog/posts/translate-python-gnu-gettext/</a><br>[2] <a href="https://docs.python.org/2/library/gettext.html#class-based-api">https://docs.python.org/2/library/gettext.html#class-based-api</a></p>
<hr>

<p><strong>P.S.</strong> Internationalization 简写为 I18N 是因为在单词第一个字母 I 和最后一个字母 N 之间有 18 个字符。Localization 亦是如此。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Seafile 与 OnlyOffice 在线预览 Office 文档</title>
    <url>/2020/05/seafile-with-onlyoffice/</url>
    <content><![CDATA[<p>最近，在公司采用 Seafile 搭建了一个文件服务器，并结合 OnlyOffice 实现在线预览功能。本文简要记录一下这个过程中所遇到的问题。</p>
<span id="more"></span>

<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>我使用了三台机器来构建整个系统，一台 nginx 服务器，用来作为前端代理；一台 Seafile 服务器用于存放文档；一台 OnlyOffice 服务器用来实现在线预览 Office 文档。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先，我们按照 <a href="https://cloud.seafile.com/published/seafile-manual-cn/deploy/using_mysql.md">Seafile 官方给出的部署方式</a>安装 Seafile 服务器，然后采用 <a href="https://cloud.seafile.com/published/seafile-manual-cn/deploy/deploy_with_nginx.md">Nginx 来代理 Seafile 的请求</a>，最后使用 <a href="https://cloud.seafile.com/published/seafile-manual-cn/deploy/only_office.md">OnlyOffice 实现在线预览</a>。</p>
<p><strong>备注：</strong> OnlyOffice 在线预览需要开源版本 6.1.0+ 的 Seafile，本文采用的是 Seafile 7.0.5 版本。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="预览文件下载失败"><a href="#预览文件下载失败" class="headerlink" title="预览文件下载失败"></a>预览文件下载失败</h3><p>在安装好之后，通过 Seafile 域名可以正常访问，并且访问 <code>http://example.seafile.com/onlyoffice/welcome</code> 可以得到 <code>Document Server is running</code> 结果，但是在打开 Word 文档预览时却提示下载失败。这是由于我使用域名来访问 Seafile，但是在 ccnet.conf 配置文件的 SERVICE_URL 配置却是 IP 地址格式导致的。我们可以在 Web 页面进行修改，也可以通过配置文件修改将其修改为域名形式即可，见参考文献 [2]。</p>
<h3 id="预览文件暂时无法访问"><a href="#预览文件暂时无法访问" class="headerlink" title="预览文件暂时无法访问"></a>预览文件暂时无法访问</h3><p>随后，我又遇到文件暂时无法访问的问题，这同样是由于域名导致的，我采用 docker 的方式安装 OnlyOffice，通过查看日志（如下所示）发现它无法解析域名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2020-05-16T01:11:42.235] [ERROR] nodeJS - dnsLookup error: hostname = example.seafile.com</span><br><span class="line">Error: getaddrinfo ENOTFOUND example.seafile.com</span><br><span class="line">    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:56:26)</span><br></pre></td></tr></table></figure>

<p>因此，我们需要在 docker 中添加正确的域名解析即可。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://cloud.seafile.com/published/seafile-manual-cn/home.md">https://cloud.seafile.com/published/seafile-manual-cn/home.md</a><br>[2] <a href="https://bbs.seafile.com/t/topic/4528/2">https://bbs.seafile.com/t/topic/4528/2</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Seafile</tag>
      </tags>
  </entry>
  <entry>
    <title>Greenplum 数据库 semctl 失败之无效参数</title>
    <url>/2019/07/semctl-failed-invalid-argument/</url>
    <content><![CDATA[<p>在编译完成之后对 Greenplum 数据库进行安装测试时遇到如下问题，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psql: FATAL:  semctl(592740353, 7, SETVAL, 0) failed: Invalid argument (pg_sema.c:151)</span><br></pre></td></tr></table></figure>

<p>从而导致数据库启动失败，从错误结果来看应该是与信号量相关。那么具体是怎么回事呢？</p>
<p>文献 <a href="https://wiki.postgresql.org/wiki/Systemd">[1]</a> 中给出了关于这个错误的详细说明，问题是由 System V IPC 对象导致的。</p>
<p>配置文件 <code>logind.conf</code> 中的 <code>RemoveIPC</code> 参数控制着 System V IPC 对象是否在用户完全退出的情况下被清除（系统用户排除在外）。在 <code>systemd 212</code> 版本之后这个选项默认是开启的，即 <code>RemoveIPC=yes</code>。仍在被使用的共享内存段不会被清理，因此 <code>systemd</code> 不会去清理正在使用的共享内存段；但是信号量没有进程附加的概念，因此，当用户退出或进程终止时，即便该信号量正在被使用也会被清理（这里的理解不一定正确，建议直接看原文）。</p>
<span id="more"></span>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在了解了问题的本质之后，我们来看看如何解决这个问题。正如前面所说的，系统用户可以免除这个问题的困扰，那么我们的第一种方法就是建立一个系统用户，然后使用这个用户来运行数据库（<code>useradd -r</code> 命令）。</p>
<p>不过，还是比较推荐第二种方式，即修改 <code>RemoveIPC</code> 为 <code>RemoveIPC=no</code>，随后重启 <code>systemd-logind</code>。Ubuntu 下的做法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;RemoveIPC=no&quot; &gt;&gt; /etc/systemd/logind.conf</span><br><span class="line">$ systemctl restart systemd-logind</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://wiki.postgresql.org/wiki/Systemd">https://wiki.postgresql.org/wiki/Systemd</a><br>[2] <a href="https://www.postgresql.org/message-id/flat/1481075896588-5933635.post%40n3.nabble.com">https://www.postgresql.org/message-id/flat/1481075896588-5933635.post%40n3.nabble.com</a><br>[3] <a href="https://www.postgresql.org/message-id/CAK7tEys9-O4BTERbs3Xuk2BfFNNd55u2sM9j5R2Fi7v6BHjrQw@mail.gmail.com">BUG #13818: PostgreSQL crashes after cronjob runs as “postgres”</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Greenplum</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 查看命令的定义</title>
    <url>/2019/04/show-LaTeX-command-definition/</url>
    <content><![CDATA[<p>最近在使用 LaTeX 撰写文档时需要重定义一个命令的，但是我想要知道该命令的原始定义时怎样的，经过查找发现 LaTeX 在这方面做得还是很不错的。目前，我知道有两种方式可以获取命令的定义：(a) 在文档中使用 <code>\show\command</code>；(b) 在命令行中使用 <code>texdef command</code>。</p>
<span id="more"></span>

<h2 id="show-查看命令定义"><a href="#show-查看命令定义" class="headerlink" title="\show 查看命令定义"></a><code>\show</code> 查看命令定义</h2><p>下面是一个完整的文档示例，在该文档中，我们通过 <code>\show\section</code> 来查看 <code>\section</code> 的定义。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\show</span><span class="keyword">\section</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码非常简单，当我们通过 <code>latex</code> 编译时可以得到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ latex test.tex</span><br><span class="line">This is pdfTeX, Version 3.14159265-2.6-1.40.19 (TeX Live 2018) (preloaded format=latex)</span><br><span class="line"> restricted \write18 enabled.</span><br><span class="line"> entering extended mode</span><br><span class="line"> (./test.tex</span><br><span class="line"> LaTeX2e &lt;2018-04-01&gt; patch level 5</span><br><span class="line"> (/usr/local/texlive/2018/texmf-dist/tex/latex/base/article.cls</span><br><span class="line"> Document Class: article 2014/09/29 v1.4h Standard LaTeX document class</span><br><span class="line"> (/usr/local/texlive/2018/texmf-dist/tex/latex/base/size10.clo)) (./test.aux)</span><br><span class="line"> &gt; \section=\long macro:</span><br><span class="line"> -&gt;\@startsection &#123;section&#125;&#123;1&#125;&#123;\z@ &#125;&#123;-3.5ex \@plus -1ex \@minus -.2ex&#125;&#123;2.3ex \@p</span><br><span class="line"> lus .2ex&#125;&#123;\normalfont \Large \bfseries &#125;.</span><br><span class="line"> l.3 \show\section</span><br><span class="line"></span><br><span class="line"> ?</span><br></pre></td></tr></table></figure>

<p>注意第 10 行的输出，<code>\section=\long macro:</code> 这里就是关于 <code>\section</code> 命令的定义。</p>
<h2 id="texdef-查看命令定义"><a href="#texdef-查看命令定义" class="headerlink" title="texdef 查看命令定义"></a><code>texdef</code> 查看命令定义</h2><p><code>texdef</code> 时一个 shell 命令，我们可以直接在 shell 中执行，例如，我们想看 <code>\section</code> 命令的定义，可以在 shell 中输入 <code>texdef section</code>，其输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ texdef section</span><br><span class="line"></span><br><span class="line">\section:</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<p>为什么 <code>section</code> 命令没有定义？这里的例子其实与上面的稍微有点不一样，上面我们使用的是 <code>latex</code> 来编译的，而 <code>texdef</code> 查看的是原 <code>TeX</code> 命令的定义而非 <code>LaTeX</code> 命令的定义，因此我们需要将其换为 <code>latexdef</code>，其结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ latexdef section</span><br><span class="line"></span><br><span class="line">\section:</span><br><span class="line">\long macro:-&gt;\@startsection &#123;section&#125;&#123;1&#125;&#123;\z@ &#125;&#123;-3.5ex \@plus -1ex \@minus -.2ex&#125;&#123;2.3ex \@plus .2ex&#125;&#123;\normalfont \Large \bfseries &#125;</span><br></pre></td></tr></table></figure>

<p><code>latexdef</code> 命令提供了很多选项给用户选择，关于如何使用 <code>latexdef</code> 请使用 <code>latexdef --help</code> 查看帮助手册。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://tex.stackexchange.com/questions/36955/display-source-for-a-command">https://tex.stackexchange.com/questions/36955/display-source-for-a-command</a></p>
]]></content>
      <categories>
        <category>排版</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 中 ROUND 函数的使用</title>
    <url>/2019/03/sql-rounding/</url>
    <content><![CDATA[<p>在某些情况下我们可能需要对实数进行四舍五入，在 SQL 中我们可以通过 <code>ROUND</code> 函数来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SELECT ROUND(123.456)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line">   123</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"># SELECT ROUND(123.567)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line">   124</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>我们还可以给 <code>ROUND</code> 函数指定第二个参数，它表示四舍五入的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SELECT ROUND(123.456, 1)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line"> 123.5</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"># SELECT ROUND(123.567, -2)</span><br><span class="line"> round</span><br><span class="line">-------</span><br><span class="line">   100</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>申威编译器优化指令操作数越界问题</title>
    <url>/2022/03/sunway-asm-operand-out-of-range/</url>
    <content><![CDATA[<p>申威上面的编译器问题看来还不少，<a href="/2022/02/sunway-float-to-short-compiler-bug/" title="上一篇文章">上一篇文章</a>说到了浮点型优化的问题，今天又遇到指令操作数越界的问题（虽然是个警告，但不排除可能存在其它隐含的问题）。</p>
<span id="more"></span>

<!-- git diff
diff --git a/src/include/storage/s_lock.h b/src/include/storage/s_lock.h
index 16ab2238e7..6c19749194 100644
--- a/src/include/storage/s_lock.h
+++ b/src/include/storage/s_lock.h
@@ -738,6 +738,49 @@ do \
 #endif /* __loongarch__ */


+#if defined(__sw_64) || defined(__sw_64__)    /* Sunway */
+#define HAS_TEST_AND_SET
+
+typedef unsigned long slock_t;
+
+#define TAS(lock) tas(lock)
+
+static __inline__ int
+tas(volatile slock_t *lock)
+{
+    register slock_t _res;
+    unsigned long tmp1;
+    __asm__ __volatile__(
+        "   ldl     $0, %1     \n"
+        "   bne     $0, 2f     \n"
+        "   lldl    %0, %1     \n"
+        "   cmpeq   %0, 0, %2  \n"
+        "   wr_f    %2         \n"
+        "   mov     %2, $0     \n"
+        "   lstl    $0, %1     \n"
+        "   rd_f    $0         \n"
+        "   beq     %2, 2f     \n"
+        "   beq     $0, 2f     \n"
+        "   memb               \n"
+        "   br      3f         \n"
+        "2: mov     1, %0      \n"
+        "3:                    \n"
+:       "=&r"(_res), "+m"(*lock), "=&r"(tmp1)
+:       /* no inputs */
+:       "memory", "0");
+    return (int) _res;
+}
+
+#define S_UNLOCK(lock)    \
+do \
+{ \
+    __asm__ __volatile__ ("memb \n"); \
+    *((volatile slock_t *) (lock)) = 0; \
+} while (0)
+
+#endif /* __sw_64 || __sw_64__ */
+
+
 #if defined(__m32r__) && defined(HAVE_SYS_TAS_H)    /* Renesas' M32R */
 #define HAS_TEST_AND_SET
-->

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>环境与上篇文章提到的一致，在做申威平台的兼容时，采用嵌入式汇编实现 spinlock 时，开启 <code>-O2</code> 优化遇到了 <code>operand out of range</code> 警告。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wcast-function-type -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -O2 -I. -I/mnt/nvme0n1/postgres-14.2/build/../src/backend/replication -I../../../src/include -I/mnt/nvme0n1/postgres-14.2/build/../src/include  -D_GNU_SOURCE   -c -o walreceiverfuncs.s /mnt/nvme0n1/postgres-14.2/build/../src/backend/replication/walreceiverfuncs.c</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wimplicit-fallthrough=3 -Wcast-function-type -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -O2 -I. -I/mnt/nvme0n1/postgres-14.2/build/../src/backend/replication -I../../../src/include -I/mnt/nvme0n1/postgres-14.2/build/../src/include  -D_GNU_SOURCE   -c -o walreceiverfuncs.o walreceiverfuncs.s</span></span><br><span class="line">walreceiverfuncs.s: Assembler messages:</span><br><span class="line">walreceiverfuncs.s:229: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:233: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:303: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:307: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:396: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:400: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:484: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:488: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:575: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:579: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:759: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:763: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:932: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:936: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:1053: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:1057: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:1159: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line">walreceiverfuncs.s:1163: 警告：operand out of range (0x00000000000008c0 is not between 0xfffffffffffff800 and 0x00000000000007ff)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -n 229,233p walreceiverfuncs.s</span></span><br><span class="line">   lldl    $1, 2240($9)</span><br><span class="line">   cmpeq   $1, 0, $2</span><br><span class="line">   wr_f    $2</span><br><span class="line">   mov     $2, $0</span><br><span class="line">   lstl    $0, 2240($9)</span><br><span class="line">   rd_f    $0</span><br></pre></td></tr></table></figure>

<p>从警告信息来看，操作数的取值范围为 <code>[-2048, 2047]</code>，而实际上 <code>lldl $1, 2240($9)</code> 和 <code>lstl $0, 2240($9)</code> 这两个的取值已经超过了这个范围，从而导致警告（我想知道的是为什么是警告，而不是错误）。<br>程序能正常编译出来，回归测试也能顺利通过，但是这个警告总是让人不放心，为此将这个问题同样地转给了申威的人，希望他们能给出回答。</p>
<div class="just-for-fun">
笑林广记 - 王监生

<p>一监生姓王，加纳知县到任。<br>初落学，青衿呈书，得牵牛章，讲诵之际，忽问那“王见之”是何人，答曰：“此王诵之之兄也。”<br>又问那“王曰”然是何人，答曰：“此王曰，叟之弟也。”<br>曰：“妙得紧。且喜我王氏一门，都在书上。”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Sunway</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>申威平台 float 到 short 类型转换的编译器优化问题</title>
    <url>/2022/02/sunway-float-to-short-compiler-bug/</url>
    <content><![CDATA[<p>最近在做申威平台的兼容时发现一个关于编译器优化的 BUG。第一次遇到编译器优化的问题，因此在这里对其进行简要的记录。</p>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>下面是此次主角的基本信息，包括 CPU 硬件、操作系统和 GCC 编译器信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lscpu</span></span><br><span class="line">架构：           sw_64</span><br><span class="line">CPU 运行模式：   64-bit</span><br><span class="line">字节序：         Little Endian</span><br><span class="line">Address sizes:   48 bits physical, 53 bits virtual</span><br><span class="line">CPU:             64</span><br><span class="line">在线 CPU 列表：  0-63</span><br><span class="line">每个核的线程数： 1</span><br><span class="line">每个座的核数：   32</span><br><span class="line">座：             2</span><br><span class="line">NUMA 节点：      2</span><br><span class="line">厂商 ID：        sunway</span><br><span class="line">CPU 系列：       6</span><br><span class="line">型号：           49</span><br><span class="line">型号名称：       SW3231 CPU @ 2.40GHz</span><br><span class="line">CPU MHz：        2400.00</span><br><span class="line">BogoMIPS：       4800.00</span><br><span class="line">L1d 缓存：       2 MiB</span><br><span class="line">L1i 缓存：       2 MiB</span><br><span class="line">L2 缓存：        32 MiB</span><br><span class="line">L3 缓存：        64 MiB</span><br><span class="line">NUMA 节点0 CPU： 0-31</span><br><span class="line">NUMA 节点1 CPU： 32-63</span><br><span class="line">标记：           fpu simd vpn upn cpuid</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uname -a</span></span><br><span class="line">Linux localhost.localdomain 4.19.90-25.0.v2101.ky10.sw_64 #1 SMP Wed Jun 16 18:08:09 CST 2021 sw_64 sw_64 sw_64 GNU/Linux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc --version</span></span><br><span class="line">gcc (GCC) 8.3.0 20190222 (Kylin 8.3.0-4)</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这个问题是在进行数据库产品兼容互认证的时候发现的。我当时采用 <code>-O2</code> 在该平台上编译代码，随后跑回归测试，发现回归测试失败，其中一条信息如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> -- test edge-case coercions to integer</span><br><span class="line"> SELECT &#x27;32767.4&#x27;::float4::int2;</span><br><span class="line"><span class="deletion">- int2</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="deletion">- 32767</span></span><br><span class="line"><span class="deletion">-(1 row)</span></span><br><span class="line"><span class="addition">+ERROR:  smallint out of range</span></span><br></pre></td></tr></table></figure>

<p>这就很奇怪了，为什么超出了范围呢？这个代码在 x86 平台上是可以正常通过的啊！！！于是乎我尝试使用 <code>-O0</code> 来编译想要调试一下，在调试之前，我跑了一下回归测试，发现居然通过了！怎么回事？是我哪儿搞错了吗？我再次尝试 <code>-O2</code> 优化，回归测试依然不过。既然 <code>-O0</code> 编译是正常的那么调试这个版本就没有意义了，为此我使用 <code>-O2 -g</code> 来编译并对其进行调试，发现其在执行 <code>rint()</code> 函数的时候出现了异常，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1317    ftoi2(PG_FUNCTION_ARGS)</span><br><span class="line">1318    &#123;</span><br><span class="line">1319    	float4	num = PG_GETARG_FLOAT4(0);</span><br><span class="line">1320</span><br><span class="line">1321    	/*</span><br><span class="line">1322    	 * Get rid of any fractional part in the input.  This is so we don&#x27;t fail</span><br><span class="line">(gdb) n</span><br><span class="line">1326    	num = rint(num);</span><br><span class="line">(gdb) p num</span><br><span class="line">$15 = 32767.4004</span><br><span class="line">(gdb) n</span><br><span class="line">1329    	if (unlikely(isnan(num) || !FLOAT4_FITS_IN_INT16(num)))</span><br><span class="line">(gdb) p num</span><br><span class="line">$15 = 32768</span><br></pre></td></tr></table></figure>

<p>上面出现了异常，正常情况下调用了 <code>rint()</code> 函数之后应该返回 <code>32767</code>，然而这里却返回了 <code>32768</code>。</p>
<p>为了方便申威那边的人员调试，我将这个用例进行了简化，最开始我是直接调用 <code>rint()</code> 函数（如下所示），发现这样做并不能重现这个问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat test.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;math.h&gt;</span></span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(void)</span><br><span class="line">&#123;</span><br><span class="line">    float num = 32767.4;</span><br><span class="line">    float t = rint(num);</span><br><span class="line">    printf(&quot;rint(%f) = %d\n&quot;, num, (short) t);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -O2 -g -o t2 test.c -lm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./t2</span></span><br><span class="line">rint(32767.400391) = 32767</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -O0 -g -o t0 test.c -lm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./t0</span></span><br><span class="line">rint(32767.400391) = 32767</span><br></pre></td></tr></table></figure>

<p>上面的测试一切都是正常的。为什么在我们的数据库代码中就不行呢？考虑到数据库的代码是通过函数调用的，因此我将其封装成函数调用来进行测试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat test.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;math.h&gt;</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">ftoi2(float num)</span><br><span class="line">&#123;</span><br><span class="line">    float t = rint(num);</span><br><span class="line">    printf(&quot;rint(%f) = %d\n&quot;, num, (short) t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(void)</span><br><span class="line">&#123;</span><br><span class="line">    ftoi2(32767.4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -O2 -g -o t2 test.c -lm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./t2</span></span><br><span class="line">rint(32767.400391) = -32768</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -O0 -g -o t0 test.c -lm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./t0</span></span><br><span class="line">rint(32767.400391) = 32767</span><br></pre></td></tr></table></figure>

<p>是不是很神奇！！！反正我是被惊艳到了。现在，问题得到复现了，从上面的结果来看，可以肯定的是申威平台上的 GCC 编译器优化存在问题，从而导致了计算结果错误。看到这里，我就没办法继续深入下去了，主要还是由于对申威平台不了解、不熟悉他的汇编指令，因此，我将这个问题转给了申威的人继续跟踪，期待这个问题能早日解决。</p>
<p>当前主流的趋势是国产替代，然而我们还是应该要认识到自身与西方国家差距，不能光靠 PPT。只有当潮水退去时，您才知道谁一直在裸泳。希望国产软件不是那个一直裸泳的。</p>
<div class="just-for-fun">
笑林广记 - 监生娘娘

<p>监生至城隍庙，傍有监生案，塑监生娘娘像。<br>归谓妻曰：“原来我们监生恁般尊贵，连你的像，早已都塑在城隍庙里了。”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>Sunway</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>申威平台 PostgreSQL 使用 LLVM 导致崩溃</title>
    <url>/2022/04/sunway-postgresql-llvm-crash/</url>
    <content><![CDATA[<p>继<a href="/2022/02/sunway-float-to-short-compiler-bug/" title="浮点数溢出问题">浮点数溢出问题</a>和<a href="/2022/03/sunway-asm-operand-out-of-range/" title="汇编指令操作数越界问题">汇编指令操作数越界问题</a>之后，我又发现申威平台上一个关于 LLVM 的问题，这个直接导致数据库进程崩溃了，本文简要记录一下这个问题（之前反馈的问题到现在还没有得到回复 :( ，估计是太忙了吧），目前这个问题同样反馈给申威相关的人员了，期待能尽快得到解决。</p>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>既然是与 LLVM 相关，那么我们在编译 PostgreSQL 的时候需要指定 <code>--with-llvm</code> 选项，同时在初始化数据库之后开启 <code>jit</code>，这里就不赘述了。我们来看示例，首先创建两个表 <code>booltbl1</code> 和 <code>booltbl2</code>，并插入数据，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> booltbl1 (f1 bool);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> booltbl1 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> booltbl1 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;True&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> BOOLTBL1 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> booltbl2 (f1 bool);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> booltbl2 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> booltbl2 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;false&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> booltbl2 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;False&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> booltbl2 (f1) <span class="keyword">VALUES</span> (bool <span class="string">&#x27;FALSE&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接着，我们可以使用下面的查询重现 crash 线程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT booltbl1.*, booltbl2.*</span><br><span class="line"><span class="meta">postgres-#</span><span class="bash"> FROM BOOLTBL1, BOOLTBL2</span></span><br><span class="line"><span class="meta">postgres-#</span><span class="bash"> WHERE BOOLTBL2.f1 &lt;&gt; BOOLTBL1.f1;</span></span><br><span class="line">server closed the connection unexpectedly</span><br><span class="line">This probably means the server terminated abnormally</span><br><span class="line">before or while processing the request.</span><br></pre></td></tr></table></figure>

<p>从上面可以看到后端进程崩溃了。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过 gdb 跟踪 crash 时的堆栈情况如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb) bt</span><br><span class="line">#0  0x0000400029b83514 in llvm::RuntimeDyldELF::resolveSW64Relocation(llvm::SectionEntry const&amp;, unsigned long, unsigned long, unsigned int, int) ()</span><br><span class="line">   from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#1  0x0000400029b8832c in llvm::RuntimeDyldELF::resolveRelocation(llvm::SectionEntry const&amp;, unsigned long, unsigned long, unsigned int, long, unsigned long, unsigned int) ()</span><br><span class="line">   from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#2  0x0000400029b880a4 in llvm::RuntimeDyldELF::resolveRelocation(llvm::RelocationEntry const&amp;, unsigned long) () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#3  0x0000400029b48e64 in llvm::RuntimeDyldImpl::resolveRelocationList(llvm::SmallVector&lt;llvm::RelocationEntry, 64u&gt; const&amp;, unsigned long) ()</span><br><span class="line">   from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#4  0x0000400029b495d4 in llvm::RuntimeDyldImpl::applyExternalSymbolRelocations(llvm::StringMap&lt;llvm::JITEvaluatedSymbol, llvm::MallocAllocator&gt;) ()</span><br><span class="line">   from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#5  0x0000400029b49eac in llvm::RuntimeDyldImpl::resolveExternalSymbols() () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#6  0x0000400029b411d8 in llvm::RuntimeDyldImpl::resolveRelocations() () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#7  0x0000400029b4bc6c in llvm::RuntimeDyld::resolveRelocations() () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#8  0x0000400029b4bec0 in llvm::RuntimeDyld::finalizeWithMemoryManagerLocking() () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#9  0x0000400026e43eec in llvm::orc::LegacyRTDyldObjectLinkingLayer::ConcreteLinkedObject&lt;std::shared_ptr&lt;llvm::RuntimeDyld::MemoryManager&gt; &gt;::finalize() ()</span><br><span class="line">   from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#10 0x0000400026e442a0 in llvm::orc::LegacyRTDyldObjectLinkingLayer::ConcreteLinkedObject&lt;std::shared_ptr&lt;llvm::RuntimeDyld::MemoryManager&gt; &gt;::getSymbolMaterializer(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)::&#123;lambda()#1&#125;::operator()() const () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#11 0x0000400026e49328 in llvm::Expected&lt;unsigned long&gt; llvm::detail::UniqueFunctionBase&lt;llvm::Expected&lt;unsigned long&gt;&gt;::CallImpl&lt;llvm::orc::LegacyRTDyldObjectLinkingLayer::ConcreteLinkedObject&lt;std::shared_ptr&lt;llvm::RuntimeDyld::MemoryManager&gt; &gt;::getSymbolMaterializer(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)::&#123;lambda()#1&#125;&gt;(void*) () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#12 0x0000400026de8e3c in llvm::unique_function&lt;llvm::Expected&lt;unsigned long&gt; ()&gt;::operator()() () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#13 0x0000400026ddc5e0 in llvm::JITSymbol::getAddress() () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#14 0x0000400026de6500 in llvm::OrcCBindingsStack::findSymbolAddressIn(unsigned long, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool)</span><br><span class="line">    () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#15 0x0000400026dd8660 in LLVMOrcGetSymbolAddressIn () from /home/postgres/14-stable/build/pg/lib/postgresql/llvmjit.so</span><br><span class="line">#16 0x0000400026dbe0c0 in llvm_get_function (context=0x121ad3bb0, funcname=0x121b73fd8 &quot;evalexpr_0_3&quot;) at /home/postgres/14-stable/build/../src/backend/jit/llvm/llvmjit.c:336</span><br><span class="line">#17 0x0000400026dd6cc8 in ExecRunCompiledExpr (state=0x121b73ca0, econtext=0x121b724c8, isNull=0x11fb2de18)</span><br><span class="line">    at /home/postgres/14-stable/build/../src/backend/jit/llvm/llvmjit_expr.c:2402</span><br><span class="line">#18 0x00000001204a4e44 in ExecEvalExprSwitchContext (state=0x121b73ca0, econtext=0x121b724c8, isNull=0x11fb2de18)</span><br><span class="line">    at /home/postgres/14-stable/build/../src/include/executor/executor.h:339</span><br><span class="line">#19 0x00000001204a4fe0 in ExecQual (state=0x121b73ca0, econtext=0x121b724c8) at /home/postgres/14-stable/build/../src/include/executor/executor.h:408</span><br><span class="line">#20 0x00000001204a53e0 in ExecNestLoop (pstate=0x121b723b8) at /home/postgres/14-stable/build/../src/backend/executor/nodeNestloop.c:214</span><br><span class="line">#21 0x0000000120452d80 in ExecProcNodeFirst (node=0x121b723b8) at /home/postgres/14-stable/build/../src/backend/executor/execProcnode.c:463</span><br><span class="line">#22 0x00000001204433d4 in ExecProcNode (node=0x121b723b8) at /home/postgres/14-stable/build/../src/include/executor/executor.h:257</span><br><span class="line">#23 0x0000000120446c3c in ExecutePlan (estate=0x121b72188, planstate=0x121b723b8, use_parallel_mode=false, operation=CMD_SELECT, sendTuples=true, numberTuples=0,</span><br><span class="line">    direction=ForwardScanDirection, dest=0x121b6f498, execute_once=true) at /home/postgres/14-stable/build/../src/backend/executor/execMain.c:1551</span><br><span class="line">#24 0x0000000120443d78 in standard_ExecutorRun (queryDesc=0x121ac0558, direction=ForwardScanDirection, count=0, execute_once=true)</span><br><span class="line">    at /home/postgres/14-stable/build/../src/backend/executor/execMain.c:361</span><br></pre></td></tr></table></figure>

<p>从堆栈信息可以看到问题出在 llvmjit.so 动态库中的 <code>llvm::RuntimeDyldELF::resolveSW64Relocation()</code> 函数，我尝试在 PostgreSQL 源码中找不到该函数，并且从这个名字来看，很大概率是申威平台针对 LLVM 做兼容提供的函数。</p>
<p>由于对 LLVM 不是很熟悉，还没法从这个错误里面拆出一个最小示例给到申威，不过这个场景是可以重现的，对于他们定位问题应该是足够了，今天已经将整个重现过程给到申威，不过，我总有一种泥牛入海的感觉 :(。</p>
<div class="just-for-fun">
笑林广记 - 附例

<p>一秀才畏考援例。堂试之日，至晚不能成篇，乃大书卷面曰：“惟其如此，所以如此。若要如此，何苦如此。”<br>官见而笑曰：“写得此四句出，毕竟还是个附例。”</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>Sunway</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 查询结果转为 JSON 格式</title>
    <url>/2019/09/turning-query-results-into-json-in-postgresql/</url>
    <content><![CDATA[<img src="/2019/09/turning-query-results-into-json-in-postgresql/postgresql-weekly.png" class="">

<p>您知道 Postgres 提供了一个函数将查询结果集转为 JSON 数据类型吗？这个函数是 <code>row_to_json</code>。</p>
<span id="more"></span>

<p>我们先创建一个表，它包含两个用户记录以以及一个 <code>interests</code> 的属性列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people</span><br><span class="line">	(name text, age <span class="type">int</span>, interests text[]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people (name, age, interests)</span><br><span class="line">	<span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Jon&#x27;</span>, <span class="number">12</span>, <span class="keyword">ARRAY</span> [<span class="string">&#x27;Golf&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>]),</span><br><span class="line">    (<span class="string">&#x27;Jane&#x27;</span>, <span class="number">45</span>, <span class="keyword">ARRAY</span> [<span class="string">&#x27;Art&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p><code>row_to_json</code> 函数最基本的使用方法是使用 <code>ROW</code> 行构造器，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> row_to_json(<span class="type">ROW</span>(name, age, interests)) <span class="keyword">FROM</span> people;</span><br><span class="line">                row_to_json</span><br><span class="line"><span class="comment">-------------------------------------------</span></span><br><span class="line"> &#123;&quot;f1&quot;:&quot;Jon&quot;,&quot;f2&quot;:<span class="number">12</span>,&quot;f3&quot;:[&quot;Golf&quot;,&quot;Food&quot;]&#125;</span><br><span class="line"> &#123;&quot;f1&quot;:&quot;Jane&quot;,&quot;f2&quot;:<span class="number">45</span>,&quot;f3&quot;:[&quot;Art&quot;]&#125;</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>针对表中不同的类型，在最后的输出中都做了相应的转换，但是属性列的名称在输出中并没有体现出来。幸运的是我们可以通过子查询的方式来实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> row_to_json(q1) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people LIMIT <span class="number">1</span>) q1;</span><br><span class="line">                     row_to_json</span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"> &#123;&quot;name&quot;:&quot;Jon&quot;,&quot;age&quot;:<span class="number">12</span>,&quot;interests&quot;:[&quot;Golf&quot;,&quot;Food&quot;]&#125;</span><br><span class="line">(<span class="number">1</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>虽然与我们的示例无关，但我们还是需要提一下，<code>row_to_json</code> 提供了一个可选的参数 <code>prettifies</code> 用于格式化输出，想要启用它，您可以在上面的示例中使用 <code>row_to_json(q1, true)</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> row_to_json(q1, <span class="literal">true</span>) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people LIMIT <span class="number">1</span>) q1;</span><br><span class="line">          row_to_json</span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"> &#123;&quot;name&quot;:&quot;Jon&quot;,               <span class="operator">+</span></span><br><span class="line">  &quot;age&quot;:<span class="number">12</span>,                   <span class="operator">+</span></span><br><span class="line">  &quot;interests&quot;:[&quot;Golf&quot;,&quot;Food&quot;]&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>[1] <a href="https://postgresweekly.com/issues/322">https://postgresweekly.com/issues/322</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 修改 I/O 调度算法</title>
    <url>/2019/03/ubuntu-modify-io-scheduler/</url>
    <content><![CDATA[<p>Linux I/O 调度器控制着内核读写磁盘的工作方式。系统管理员可以通过更改调度器来自定义磁盘调度算法，从而优化系统性能。有三种调度程序可供选择，每种调度程序都有其优点。这些调度器是：</p>
<ul>
<li><p><strong>Noop</strong> - 电梯调度算法，最简单的调度算法，该算法基于先进先出队列 (FIFO) 实现，所有的 I/O 请求都符合先进先出规则，适合于 SSD 设备。</p>
</li>
<li><p><strong>Deadline</strong> - 绝对保障算法，它为读和写分别创建了 FIFO 队列，当内核收到请时，先尝试合并，不能合并则尝试排序或放入队列中，并且尽量保证在请求到达最终期限时进行调度，避免有一些请求长时间不能得到处理。该调度器适合虚拟机所在宿主机器或 I/O 压力比较重的场景，例如数据库服务器。</p>
</li>
<li><p><strong>Completely Fair Queuing, CFQ</strong> - 绝对公平调度算法，它为每个进程和线程单独创建一个队列来管理该进程的 I/O 请求，然后为每个队列分配访问磁盘的时间片。时间片的长度以及允许队列提交的请求数取决于给定进程的 I/O 优先级。该调度器比较适合于通用服务器。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="查询当前调度器"><a href="#查询当前调度器" class="headerlink" title="查询当前调度器"></a>查询当前调度器</h2><p>首先，我们需要知道系统目前使用的是哪种 I/O 调度器。假设我们有一块名为 <code>sda</code> 的磁盘，那么我们可以通过如下命令查看该磁盘使用的调度器类别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/block/sda/queue/scheduler</span></span><br><span class="line">noop [deadline] cfq</span><br></pre></td></tr></table></figure>

<p>从上面可以看到我们的系统在 <code>sda</code> 磁盘上支持 <code>noop</code>，<code>deadline</code> 和 <code>cfq</code> 三种调度器，而默认采用的是 <code>deadline</code> 调度器。</p>
<h2 id="修改调度器"><a href="#修改调度器" class="headerlink" title="修改调度器"></a>修改调度器</h2><p>Ubuntu 系统提供了两种方式来修改调度器：a) 临时修改；b) 永久修改。临时修改的方式在系统重启后将会恢复到默认设置。通常，我们可以通过临时修改的方式来确定哪种调度器能带来更大的性能提升，然后在永久的修改为这种调度器。</p>
<p>我们可以通过下面的命令将系统的调度器临时的修改为 <code>noop</code> 类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> noop &gt; /sys/block/sda/queue/scheduler</span></span><br></pre></td></tr></table></figure>

<p>通过上述方式修改不需要重启机器而是立马生效。如果你需要永久的修改调度器，那么你需要修改 GRUB 的配置文件，即编辑配置文件 <code>/etc/default/grub</code> 修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</span><br></pre></td></tr></table></figure>

<p>为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash elevator=noop&quot;</span><br></pre></td></tr></table></figure>

<p>通过这种方式修改我们需要重启机器以使修改生效，当然我们可以结合临时修改的方式，从而避免重启。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 谭峰，张文升《PostgreSQL 实战》<br>[2] <a href="https://www.techrepublic.com/article/how-to-change-the-linux-io-scheduler-to-fit-your-needs/">How to change the linux io scheduler to fit your needs</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 笔记本盖住不挂机</title>
    <url>/2020/03/ubuntu-lid-switch-action/</url>
    <content><![CDATA[<p>我有一台旧笔记本装有 Ubuntu 18.04 系统，希望把它当作一个服务器，这时我就需要在盖住笔记本时系统不休眠。</p>
<p>Ubuntu 系统中提供了 Login Manager 来管理这些行为，它的配置文件为 /etc/systemd/logind.conf。通过<br><code>man logind.conf</code> 我们可以看到其详细说明。</p>
<p>其中有一项 <code>HandleLidSwitch</code>，它控制了笔记本盖住的行为，默认情况下是 <code>suspend</code>，我们可以将其修改为 <code>ignore</code> 即可以实现我们的目的。例如，我们修改 /etc/system/logind.conf 文件中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#HandleLidSwitch=suspend</span><br></pre></td></tr></table></figure>

<p>行修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandleLidSwitch=ignore</span><br></pre></td></tr></table></figure>

<p>然后重启 systemd-logind 服务即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service systemd-logind restart</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】理解 PostgreSQL 中的 LATERAL 连接</title>
    <url>/2021/07/understanding-lateral-joins-in-postgresql/</url>
    <content><![CDATA[<p><code>LATERAL</code> 连接是 PostgreSQL 和其他关系型数据库（如 Oracle、DB2 和 MS SQL）中鲜为人知的功能之一。然而，<code>LATERAL</code> 连接是一个非常有用的功能，本文将带你看看用它们能完成什么有意义的事情。</p>
<span id="more"></span>

<h2 id="深入理解-FROM"><a href="#深入理解-FROM" class="headerlink" title="深入理解 FROM"></a>深入理解 FROM</h2><p>在我们深入研究 <code>LATERAL</code> 之前，有必要从哲学的家的角度来考虑一下 <code>SELECT</code> 和 <code>FROM</code> 子句。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> whatever <span class="keyword">FROM</span> tab;</span><br></pre></td></tr></table></figure>

<p>本质上，我们可以将这个语句看作是一个循环。用伪代码来编写此 SQL 语句看起来类似下面的代码段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in tab</span><br><span class="line">loop</span><br><span class="line">     “do whatever”</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure>

<p>对于表中的每一条记录，我们做 <code>SELECT</code> 子句所说的事情。通常情况下，数据只是按原样返回。一个 <code>SELECT</code> 语句可以被看作是一个循环。但是，如果我们需要一个“嵌套”的循环呢？这就是 <code>LATERAL</code> 的用处。</p>
<h2 id="LATERAL-连接：创建示例数据"><a href="#LATERAL-连接：创建示例数据" class="headerlink" title="LATERAL 连接：创建示例数据"></a>LATERAL 连接：创建示例数据</h2><p>让我们想象一个简单的例子。想象一下，我们有一系列产品，也有客户的愿望清单。现在的目标是为每个愿望清单找到最好的 3 种产品。下面的 SQL 代码段创建了一些样本数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span>   id <span class="keyword">AS</span> product_id,</span><br><span class="line">             id <span class="operator">*</span> <span class="number">10</span> <span class="operator">*</span> random() <span class="keyword">AS</span> price,</span><br><span class="line">             <span class="string">&#x27;product &#x27;</span> <span class="operator">||</span> id <span class="keyword">AS</span> product</span><br><span class="line">    <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">1000</span>) <span class="keyword">AS</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_wishlist</span><br><span class="line">(</span><br><span class="line">    wishlist_id        <span class="type">int</span>,</span><br><span class="line">    username           text,</span><br><span class="line">    desired_price      <span class="type">numeric</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_wishlist <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;hans&#x27;</span>, <span class="string">&#x27;450&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;joe&#x27;</span>, <span class="string">&#x27;60&#x27;</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;1500&#x27;</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>产品表填充了 1000 种产品。价格是随机的，我们用一个相当有创意的名字来命名产品。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_product LIMIT <span class="number">10</span>;</span><br><span class="line"> product_id <span class="operator">|</span> price              <span class="operator">|</span> product</span><br><span class="line"><span class="comment">------------+--------------------+------------</span></span><br><span class="line">          <span class="number">1</span> <span class="operator">|</span> <span class="number">6.756567642432323</span>  <span class="operator">|</span> product <span class="number">1</span></span><br><span class="line">          <span class="number">2</span> <span class="operator">|</span> <span class="number">5.284467408540081</span>  <span class="operator">|</span> product <span class="number">2</span></span><br><span class="line">          <span class="number">3</span> <span class="operator">|</span> <span class="number">28.284196164210904</span> <span class="operator">|</span> product <span class="number">3</span></span><br><span class="line">          <span class="number">4</span> <span class="operator">|</span> <span class="number">13.543868035690423</span> <span class="operator">|</span> product <span class="number">4</span></span><br><span class="line">          <span class="number">5</span> <span class="operator">|</span> <span class="number">30.576923884383156</span> <span class="operator">|</span> product <span class="number">5</span></span><br><span class="line">          <span class="number">6</span> <span class="operator">|</span> <span class="number">26.572431211361902</span> <span class="operator">|</span> product <span class="number">6</span></span><br><span class="line">          <span class="number">7</span> <span class="operator">|</span> <span class="number">64.84599396020204</span>  <span class="operator">|</span> product <span class="number">7</span></span><br><span class="line">          <span class="number">8</span> <span class="operator">|</span> <span class="number">21.550701384168747</span> <span class="operator">|</span> product <span class="number">8</span></span><br><span class="line">          <span class="number">9</span> <span class="operator">|</span> <span class="number">28.995584553969174</span> <span class="operator">|</span> product <span class="number">9</span></span><br><span class="line">         <span class="number">10</span> <span class="operator">|</span> <span class="number">17.31335004787411</span>  <span class="operator">|</span> product <span class="number">10</span></span><br><span class="line">(<span class="number">10</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，我们有一个愿望清单。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_wishlist;</span><br><span class="line"> wishlist_id <span class="operator">|</span> username <span class="operator">|</span> desired_price</span><br><span class="line"><span class="comment">-------------+----------+---------------</span></span><br><span class="line">           <span class="number">1</span> <span class="operator">|</span> hans     <span class="operator">|</span> <span class="number">450</span></span><br><span class="line">           <span class="number">2</span> <span class="operator">|</span> joe      <span class="operator">|</span> <span class="number">60</span></span><br><span class="line">           <span class="number">3</span> <span class="operator">|</span> jane     <span class="operator">|</span> <span class="number">1500</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，愿望清单属于一个用户，并且有一个我们想要建议的那三种产品的理想价格。</p>
<h2 id="执行-LATERAL-连接"><a href="#执行-LATERAL-连接" class="headerlink" title="执行 LATERAL 连接"></a>执行 LATERAL 连接</h2><p>在提供了一些样本数据并将其加载到我们的 PostgreSQL 数据库后，我们可以接近并尝试提出解决方案。</p>
<p>假设我们想为每个愿望找到前三个产品，可以使用下面的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in wishlist</span><br><span class="line">loop</span><br><span class="line">      for y in products order by price desc</span><br><span class="line">      loop</span><br><span class="line">           found++</span><br><span class="line">           if found &lt;= 3</span><br><span class="line">           then</span><br><span class="line">               return row</span><br><span class="line">           else</span><br><span class="line">               jump to next wish</span><br><span class="line">           end</span><br><span class="line">      end loop</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure>

<p>重要的是，我们需要两个循环。首先，我们需要遍历愿望列表，然后我们看一下排序后的产品列表，挑选 3 个，然后进入下一个愿望列表。</p>
<p>让我们看看如何使用 <code>LATERAL</code> 连接来完成这个任务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>        <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>      t_wishlist <span class="keyword">AS</span> w,</span><br><span class="line">    <span class="keyword">LATERAL</span>  (<span class="keyword">SELECT</span>      <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span>       t_product <span class="keyword">AS</span> p</span><br><span class="line">        <span class="keyword">WHERE</span>       p.price <span class="operator">&lt;</span> w.desired_price</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> p.price <span class="keyword">DESC</span></span><br><span class="line">        LIMIT <span class="number">3</span></span><br><span class="line">       ) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> wishlist_id, price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>我们将一步一步的解释这个查询。你在 <code>FROM</code> 子句中看到的第一件事是 <code>t_wishlist</code> 表。 <code>LATERAL</code> 现在可以做的是使用愿望清单中的记录来施展它的魔法。因此，对于愿望清单中的每条记录，我们都要挑选三个产品。为了弄清我们需要哪些产品，我们可以利用 <code>w.desired_price</code>。换句话说，这就像一个“带参数的连接”。<code>FROM</code> 子句可以看作我们伪代码中的“外循环”，<code>LATERAL</code> 可以被看作是“内循环”。</p>
<p>结果集看起来如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> wishlist_id | username | desired_price | product_id | price              | product</span><br><span class="line">-------------+----------+---------------+------------+--------------------+-------------</span><br><span class="line">           1 | hans     | 450           | 708        | 447.0511375753179  | product 708</span><br><span class="line">           1 | hans     | 450           | 126        | 443.6560873146138  | product 126</span><br><span class="line">           1 | hans     | 450           | 655        | 438.0566432022443  | product 655</span><br><span class="line">           2 | joe      | 60            | 40         | 59.32252841190291  | product 40</span><br><span class="line">           2 | joe      | 60            | 19         | 59.2142714048882   | product 19</span><br><span class="line">           2 | joe      | 60            | 87         | 58.78014573804254  | product 87</span><br><span class="line">           3 | jane     | 1500          | 687        | 1495.8794483743645 | product 687</span><br><span class="line">           3 | jane     | 1500          | 297        | 1494.4586352980593 | product 297</span><br><span class="line">           3 | jane     | 1500          | 520        | 1490.7849437550085 | product 520</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 为每个愿望清单返回三条记录，这正是我们想要的。这里重要的部分是在 <code>SELECT</code> 内部的 <code>LIMIT</code> 子句，而不是 <code>LATERAL</code>。因此，它限制的是每个愿望清单的行数，而不是总的行数。</p>
<p>PostgreSQL 在优化 <code>LATERAL</code> 连接方面做的相当行。在我们的例子中，执行计划看起来很简单。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># explain <span class="keyword">SELECT</span>    <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    t_wishlist <span class="keyword">AS</span> w,</span><br><span class="line">        <span class="keyword">LATERAL</span> (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">               <span class="keyword">FROM</span> t_product <span class="keyword">AS</span> p</span><br><span class="line">               <span class="keyword">WHERE</span> p.price <span class="operator">&lt;</span> w.desired_price</span><br><span class="line">               <span class="keyword">ORDER</span> <span class="keyword">BY</span> p.price <span class="keyword">DESC</span></span><br><span class="line">               LIMIT <span class="number">3</span></span><br><span class="line">               ) <span class="keyword">AS</span> x</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> wishlist_id, price <span class="keyword">DESC</span>;</span><br><span class="line">                                    QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------</span></span><br><span class="line"> Sort (cost<span class="operator">=</span><span class="number">23428.53</span>.<span class="number">.23434</span><span class="number">.90</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2550</span> width<span class="operator">=</span><span class="number">91</span>)</span><br><span class="line">   Sort Key: w.wishlist_id, p.price <span class="keyword">DESC</span></span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span> Nested Loop (cost<span class="operator">=</span><span class="number">27.30</span>.<span class="number">.23284</span><span class="number">.24</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2550</span> width<span class="operator">=</span><span class="number">91</span>)</span><br><span class="line">      <span class="operator">-</span><span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> t_wishlist w (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.18</span><span class="number">.50</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">850</span> width<span class="operator">=</span><span class="number">68</span>)</span><br><span class="line">      <span class="operator">-</span><span class="operator">&gt;</span> Limit (cost<span class="operator">=</span><span class="number">27.30</span>.<span class="number">.27</span><span class="number">.31</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">3</span> width<span class="operator">=</span><span class="number">23</span>)</span><br><span class="line">            <span class="operator">-</span><span class="operator">&gt;</span> Sort (cost<span class="operator">=</span><span class="number">27.30</span>.<span class="number">.28</span><span class="number">.14</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">333</span> width<span class="operator">=</span><span class="number">23</span>)</span><br><span class="line">                  Sort Key: p.price <span class="keyword">DESC</span></span><br><span class="line">                  <span class="operator">-</span><span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> t_product p (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.23</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">333</span> width<span class="operator">=</span><span class="number">23</span>)</span><br><span class="line">                        <span class="keyword">Filter</span>: (price <span class="operator">&lt;</span> (w.desired_price)::<span class="type">double precision</span>)</span><br><span class="line">(<span class="number">9</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p><code>LATERAL</code> 连接是非常有用的，在许多情况下可以利用它来加速操作，或使代码更容易理解。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果你想了解更多关于一般的连接，如如你现在想要阅读更多关于 PostgreSQL 的信息，可以考虑看看 Laurenz Albe 关于 <a href="https://www.cybertec-postgresql.com/en/join-strategies-and-performance-in-postgresql/">PostgreSQL 的连接策略的优秀文章</a>。</p>
<p>如果你想了解更多关于 PostgreSQL 优化器的一般情况，如果你想要了解更多关于优化和其他与 PostgreSQL 查询优化相关的重要主题，请查看我关于<a href="https://www.cybertec-postgresql.com/en/how-the-postgresql-query-optimizer-works/">优化器的博文</a>。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><ul>
<li>本文翻译自 Hans-Jürgen Schönig 的 <a href="https://www.cybertec-postgresql.com/en/understanding-lateral-joins-in-postgresql/">UNDERSTANDING LATERAL JOINS IN POSTGRESQL</a>。</li>
</ul>
<div class="just-for-fun">
笑林广记 - 发利市

<p>一官新到任，祭仪门前毕，有未烬纸钱在地，官即取一锡锭藏好。<br>门子禀曰：“老爷这是纸钱，要他何用？”<br>官曰：“我知道，且等我发个利市者。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 插件编写</title>
    <url>/2018/12/write-postgresql-extension/</url>
    <content><![CDATA[<p>PostgreSQL 标榜自己为最先进 (Most Advance) 的开源关系数据库，它支持大部分 SQL 标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如，通过增加新的数据类型、函数、操作符、聚集函数、索引。PostgreSQL 被设计为易于扩展，因此通过插件我们可以很容易的扩展 PostgreSQL 数据库。本文就从编写一个简单的斐波那契的数据库扩展来介绍 PostgreSQL 插件的编写。</p>
<span id="more"></span>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列 (Fibonacci sequence)，又称黄金分割数列、因数学家列昂纳多·斐波那契 (Leonardoda Fibonacci) 以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…… 在数学上，斐波纳契数列以如下被以递推的方法定义<sup>1</sup>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0, F(1) = 1, F(n) = F(n - 1) + F(n - 2) (n &gt;= 2, n ∈ N)</span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL-扩展插件的框架"><a href="#PostgreSQL-扩展插件的框架" class="headerlink" title="PostgreSQL 扩展插件的框架"></a>PostgreSQL 扩展插件的框架</h2><p>我们为了使 PostgreSQL 可以通过 <code>CREATE EXTENSION</code> 命令加载插件，我们的扩展插件至少需要两个文件：一个名为 <code>extension_name.control</code> 的控制文件和一个名为 <code>extension--version.sql</code> 的扩展 SQL 脚本文件。其中控制文件中包含了扩展插件名、版本等基本信息。现在让我们创建这两个文件。</p>
<p>我们的 fibonacci 扩展插件的控制文件 (fibonacci.control) 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fibonacci extension</span><br><span class="line">comment = &#x27;fibonacci extension&#x27;</span><br><span class="line">default_version = &#x27;0.0.1&#x27;</span><br><span class="line">relocatable = true</span><br></pre></td></tr></table></figure>

<p>我们将使用 PL/pgSQL 来实现这个插件 (fibonacci–0.0.1.sql)，其内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span><br><span class="line">\echo Use &quot;CREATE EXTENSION fibonacci&quot; to load this file. \quit</span><br><span class="line">CREATE FUNCTION fibonacci(n INTEGER)</span><br><span class="line">RETURNS INTEGER</span><br><span class="line">LANGUAGE plpgsql IMMUTABLE STRICT</span><br><span class="line">    AS $$</span><br><span class="line">    DECLARE</span><br><span class="line">        counter INTEGER := 0;</span><br><span class="line">        i INTEGER := 0;</span><br><span class="line">        j INTEGER := 1;</span><br><span class="line">    BEGIN</span><br><span class="line"></span><br><span class="line">        IF n &lt; 1 THEN</span><br><span class="line">            RETURN 0;</span><br><span class="line">        END IF;</span><br><span class="line"></span><br><span class="line">        WHILE counter &lt; n LOOP</span><br><span class="line">            counter := counter + 1;</span><br><span class="line">            SELECT j, i + j INTO i, j;</span><br><span class="line">        END LOOP;</span><br><span class="line"></span><br><span class="line">        RETURN i;</span><br><span class="line">    END;</span><br><span class="line">    $$;</span><br></pre></td></tr></table></figure>

<p>自 PostgreSQL 9.1 之后，PostgreSQL 提供了 PGXS 用于构建其插件，大部分构建插件的环境变量都可以通过 pg_config 得到重用。接下来我们为 fibonacci 插件添加一个 Makefile 文件用于安装插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENSION = fibonacci        # the extensions name</span><br><span class="line">DATA = fibonacci--0.0.1.sql  # script files to install</span><br><span class="line"></span><br><span class="line"># postgres build stuff</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure>

<p>接下来我们便可以通过 <code>make install</code> 来安装插件。最后，我们在数据库中执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@database:~/postgresql-10.4/fib$ psql postgres</span><br><span class="line">psql (10.4)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=# create extension fibonacci ;</span><br><span class="line">CREATE EXTENSION</span><br><span class="line">postgres=# select fibonacci(10);</span><br><span class="line"> fibonacci</span><br><span class="line">-----------</span><br><span class="line">        55</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>现在我们完成了基本的插件功能，但是任何程序都应该包含测试用例以便验证程序的正确性。我们可以很方便的为 PostgreSQL 添加回归测试，在执行完 <code>make install</code> 命令之后利用 <code>make installcheck</code> 运行插件的回归测试。PostgreSQL 将回归测试脚本放在插件目录的 <code>sql/</code> 文件中，每个测试文件都对应一个期望结果的输出文件并放置在插件目录的 <code>expected/</code> 文件中，测试脚本与期望结果具有相同的名字，唯一不同的是期望结果的文件的后缀名为 <code>.out</code>。命令 <code>make installcheck</code> 执行 <code>psql</code> 目录下的所有脚本并且将输出的结果与 <code>expected</code> 目录中的文件进行比较。任何不同的结果都将被写入 <code>regression.diffs</code> 文件。现在，我们为插件添加测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@database:~/postgresql-10.4/fib$ cat sql/fibonacci_test.sql</span><br><span class="line">CREATE EXTENSION fibonacci;</span><br><span class="line">SELECT fibonacci(0);</span><br><span class="line">SELECT fibonacci(1);</span><br><span class="line">SELECT fibonacci(2);</span><br><span class="line">SELECT fibonacci(3);</span><br><span class="line">SELECT fibonacci(4);</span><br><span class="line">SELECT fibonacci(5);</span><br><span class="line">SELECT fibonacci(6);</span><br><span class="line">SELECT fibonacci(7);</span><br><span class="line">SELECT fibonacci(8);</span><br><span class="line">SELECT fibonacci(9);</span><br><span class="line">SELECT fibonacci(10);</span><br><span class="line">SELECT fibonacci(11);</span><br><span class="line">SELECT fibonacci(12);</span><br><span class="line">SELECT fibonacci(13);</span><br><span class="line">SELECT fibonacci(14);</span><br><span class="line">SELECT fibonacci(15);</span><br><span class="line">SELECT fibonacci(16);</span><br><span class="line">SELECT fibonacci(17);</span><br><span class="line">SELECT fibonacci(18);</span><br><span class="line">SELECT fibonacci(19);</span><br><span class="line">SELECT fibonacci(20);</span><br></pre></td></tr></table></figure>

<p>同时，我们需要修改 <code>Makefile</code> 文件，以便其能执行回归测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENSION = fibonacci        # the extensions name</span><br><span class="line">DATA = fibonacci--0.0.1.sql  # script files to install</span><br><span class="line">REGRESS = fibonacci_test     # our test script file (without extension)</span><br><span class="line"></span><br><span class="line"># postgres build stuff</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure>

<p>现在，我们执行 <code>make install &amp;&amp; make installcheck</code> 时，回归测试将会失败，这是由于我们还没有指定期望的输出结果。但是，我们发现目录下多了一个 <code>results</code> 目录，并且该目录下包含 <code>fibonacci_test.out</code> 和 <code>fibonacci_test.out.diff</code> 两个文件。为了简便，我们在这里创建一个 <code>expected</code> 目录，并将 <code>fibonacci_test.out</code> 拷贝到该目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@database:~/postgresql-10.4/fib$ mkdir expected</span><br><span class="line">postgres@database:~/postgresql-10.4/fib$ mv results/fibonacci_test.out expected/</span><br><span class="line">postgres@database:~/postgresql-10.4/fib$ make installcheck</span><br><span class="line">/home/postgres/postgresql-10.4/lib/pgxs/src/makefiles/../../src/test/regress/pg_regress --inputdir=./ --bindir=&#x27;/home/postgres/postgresql-10.4/bin&#x27;    --dbname=contrib_regression fibonacci_test</span><br><span class="line">(using postmaster on Unix socket, default port)</span><br><span class="line">============== dropping database &quot;contrib_regression&quot; ==============</span><br><span class="line">DROP DATABASE</span><br><span class="line">============== creating database &quot;contrib_regression&quot; ==============</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">============== running regression test queries        ==============</span><br><span class="line">test fibonacci_test           ... ok</span><br><span class="line"></span><br><span class="line">=====================</span><br><span class="line"> All 1 tests passed.</span><br><span class="line">=====================</span><br><span class="line"></span><br><span class="line">postgres@database:~/postgresql-10.4/fib$</span><br></pre></td></tr></table></figure>

<p>我们测试求 <code>[1,30]</code> 的斐波那契数列，其运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT i, fibonacci(i) FROM generate_series(1,30) i;</span><br><span class="line"> i  | fibonacci</span><br><span class="line">----+-----------</span><br><span class="line">  1 |         1</span><br><span class="line">  2 |         1</span><br><span class="line">  3 |         2</span><br><span class="line">  4 |         3</span><br><span class="line">  5 |         5</span><br><span class="line">  6 |         8</span><br><span class="line">  7 |        13</span><br><span class="line">  8 |        21</span><br><span class="line">  9 |        34</span><br><span class="line"> 10 |        55</span><br><span class="line"> 11 |        89</span><br><span class="line"> 12 |       144</span><br><span class="line"> 13 |       233</span><br><span class="line"> 14 |       377</span><br><span class="line"> 15 |       610</span><br><span class="line"> 16 |       987</span><br><span class="line"> 17 |      1597</span><br><span class="line"> 18 |      2584</span><br><span class="line"> 19 |      4181</span><br><span class="line"> 20 |      6765</span><br><span class="line"> 21 |     10946</span><br><span class="line"> 22 |     17711</span><br><span class="line"> 23 |     28657</span><br><span class="line"> 24 |     46368</span><br><span class="line"> 25 |     75025</span><br><span class="line"> 26 |    121393</span><br><span class="line"> 27 |    196418</span><br><span class="line"> 28 |    317811</span><br><span class="line"> 29 |    514229</span><br><span class="line"> 30 |    832040</span><br><span class="line">(30 rows)</span><br><span class="line"></span><br><span class="line">Time: 12.432 ms</span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure>

<h2 id="利用-C-语言优化性能"><a href="#利用-C-语言优化性能" class="headerlink" title="利用 C 语言优化性能"></a>利用 C 语言优化性能</h2><p>上面我们使用 PL/pgSQL 为 PostgreSQL 编写了斐波那契插件，从上面的运行时间看基本还算可以。但是，我们还可以通过 C 语言来重写这个插件从而提高其性能。下面给出了 C 语言版的斐波那契插件的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fibonacci.c</span></span><br><span class="line"><span class="comment"> *   Fibonacci extension for PostgreSQL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;postgres.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fmgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="function">Datum <span class="title">fibonacci</span><span class="params">(PG_FUNCTION_ARGS)</span></span>;</span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(fibonacci);</span><br><span class="line"></span><br><span class="line"><span class="function">Datum</span></span><br><span class="line"><span class="function"><span class="title">fibonacci</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 arg = PG_GETARG_INT32(<span class="number">0</span>);</span><br><span class="line">    int32 i = <span class="number">0</span>;</span><br><span class="line">    int32 j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        PG_RETURN_INT32(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (arg--) &#123;</span><br><span class="line">        int32 t = j;</span><br><span class="line">        j = i + j;</span><br><span class="line">        i = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_INT32(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>postgres.h</code> 文件包含了 PostgreSQL 的一些基本的编程接口，该文件需要在每个声明 Postgres 函数的 C 源文件中出现。</li>
<li><code>fmgr.h</code> 包含了 <code>PG_GETARG_XXX</code> 和 <code>PG_RETURN_XXX</code> 的一系列宏定义。</li>
<li><code>PG_MODULE_MAGIC</code> 是一个魔术块，它用于确保将动态加载的目标文件加载到兼容的服务器中。</li>
</ul>
<p>现在，我们利用 C 语言重写了斐波那契插件；接着，我们需要修改安装脚本文件 <code>fibonacci--0.0.1.sql</code> 和 <code>Makefile</code> 文件。为了便于区分，我们将 C 语言实现的版本命名为 <code>0.0.2</code>，因此我们创建一个 <code>fibonacci--0.0.2.sql</code> 的安装脚本，其内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span></span><br><span class="line">\echo Use &quot;CREATE EXTENSION fibonacci&quot; <span class="keyword">to</span> load this file. \quit</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fibonacci(n <span class="type">INTEGER</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span> <span class="keyword">AS</span> <span class="string">&#x27;$libdir/fibonacci&#x27;</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> C IMMUTABLE STRICT;</span><br></pre></td></tr></table></figure>

<p>接下来修改 <code>Makefile</code> 文件使其能正常编译我们的 fibonacci 插件的源文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENSION = fibonacci        # the extensions name</span><br><span class="line">DATA = fibonacci--0.0.2.sql  # script files to install</span><br><span class="line">REGRESS = fibonacci_test     # our test script file (without extension)</span><br><span class="line">MODULES = fibonacci</span><br><span class="line"></span><br><span class="line"># postgres build stuff</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure>

<p>注意，我们还需要修改 <code>fibonacci.control</code> 文件中的 <code>default_version</code> 为 <code>0.0.2</code>。现在我们便可以通过 <code>make install &amp;&amp; make installcheck</code> 来安装插件了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELECT i, fibonacci(i) FROM generate_series(1,30) i;</span><br><span class="line"> i  | fibonacci</span><br><span class="line">----+-----------</span><br><span class="line">  1 |         1</span><br><span class="line">  2 |         1</span><br><span class="line">  3 |         2</span><br><span class="line">  4 |         3</span><br><span class="line">  5 |         5</span><br><span class="line">  6 |         8</span><br><span class="line">  7 |        13</span><br><span class="line">  8 |        21</span><br><span class="line">  9 |        34</span><br><span class="line"> 10 |        55</span><br><span class="line"> 11 |        89</span><br><span class="line"> 12 |       144</span><br><span class="line"> 13 |       233</span><br><span class="line"> 14 |       377</span><br><span class="line"> 15 |       610</span><br><span class="line"> 16 |       987</span><br><span class="line"> 17 |      1597</span><br><span class="line"> 18 |      2584</span><br><span class="line"> 19 |      4181</span><br><span class="line"> 20 |      6765</span><br><span class="line"> 21 |     10946</span><br><span class="line"> 22 |     17711</span><br><span class="line"> 23 |     28657</span><br><span class="line"> 24 |     46368</span><br><span class="line"> 25 |     75025</span><br><span class="line"> 26 |    121393</span><br><span class="line"> 27 |    196418</span><br><span class="line"> 28 |    317811</span><br><span class="line"> 29 |    514229</span><br><span class="line"> 30 |    832040</span><br><span class="line">(30 rows)</span><br><span class="line"></span><br><span class="line">Time: 2.280 ms</span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure>

<p>从运行时间上看，C 语言版的斐波那契要比 PL/pgSQL 的运行速度快大约 80%。</p>
<p><strong>备注：</strong> 由于 C 语言插件在 PostgreSQL 中采用动态库的形式载入的，因此我们需要修改配置文件中的 <code>shared_preload_libraries</code> 参数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何使用 plpgsql 编写 PostgreSQL 的扩展插件，PostgreSQL 有两个基本的文件：</p>
<ul>
<li>extension.control - 插件控制文件</li>
<li>extension–version.sql - 用于创建扩展的脚本文件</li>
</ul>
<p>此外，我们可能还需要 <code>sql</code> 和 <code>expected</code> 目录用于存放回归测试用例及其结果。最后，为了提高插件的运行效率，我们将原来的 PL/pgSQL 版本采用 C 语言来实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin">斐波那契数列</a><br>[2] <a href="http://big-elephants.com/2015-10/writing-postgres-extensions-part-i/">Writing Postgres Extensions - the Basics</a><br>[3] <a href="https://www.postgresql.org/docs/10/xfunc-c.html">PostgreSQL - C-Language Functions</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言数据类型</title>
    <url>/2019/06/C-data-types/</url>
    <content><![CDATA[<p>C 语言的数据类型可以分为七种，它们分别是原始类型（内建类型）、枚举类型、联合类型、结构体、数组、指针以及不完全类型。此外，本文还介绍了类型限定符、存储类型说明符以及类型重命名。</p>
<span id="more"></span>

<h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>C 语言提供的原始数据类型可以分为三类：a. 整数类型；b. 实数类型；c. 复数类型。接下来的部分将详细介绍这三类数据类型。</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数数据类型的大小范围从 8-bit 到 32-bit 之间。在 C99 标准中扩展到了 64-bit。我们应该使用整数数据类型来存储整数值，当然我们也可以用 <code>char</code> 类型来存储字符。下表给出了这些整数类型的最小范围，在不同的平台上这个范围可能还会更大。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>比特位</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>signed char</td>
<td>8</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>8</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>char</td>
<td>8</td>
<td>-128/0</td>
<td>127/255</td>
</tr>
<tr>
<td>short int</td>
<td>16</td>
<td>-32,768</td>
<td>32,767</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>16</td>
<td>0</td>
<td>65,535</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>32</td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
<tr>
<td>long int</td>
<td>32/64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td>32/64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long int</td>
<td>64</td>
<td>-9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>unsigned long long int</td>
<td>64</td>
<td>0</td>
<td>18,446,744,073,709,551,615</td>
</tr>
</tbody></table>
<ul>
<li><strong>char</strong> - 该数据类型被定义为 <code>signed char</code> 或者 <code>unsigned char</code> 类型，这取决于不同的系统平台。</li>
<li><strong>short int</strong> - 该数据类型可以写为 <code>short</code>、<code>signed short int</code> 或 <code>signed short</code>。</li>
<li><strong>unsigned short int</strong> - 该数据类型可以简写为 <code>unsigned short</code>。</li>
<li><strong>int</strong> - 该数据类型可以写为 <code>signed int</code> 或 <code>signed</code>。</li>
<li><strong>unsigned int</strong> - 该数据类型可以简写为 <code>unsigned</code>。</li>
<li><strong>long int</strong> - 该数据类型的长度取决于您的系统，他可以是 32-bit 或 64-bit。它可以写为 <code>signed long int</code>、<code>signed long</code> 或 <code>long</code>。</li>
<li><strong>unsigned long int</strong> - 该数据类型与 <code>long int</code> 数据类型相似。它可以简写为 <code>unsigned long</code>。</li>
<li><strong>long long int</strong> - 该数据类型并非 C89 标准所定义，它是 C99 或 GNU C 标准中的一部分。它可以被写为 <code>signed long long int</code>、<code>signed long long</code> 或 <code>long long</code>。</li>
<li><strong>unsigned long long int</strong> - 该数据类型与 <code>long long int</code> 数据类型相似。它可以简写为 <code>unsigned long long</code>。</li>
</ul>
<h3 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h3><p>C 语言提供了三种类型用于表示小数（浮点数）。尽管目前来树这些类型的大小和范围在大多数计算机上都是一致的，但是历史上它们还是因为系统类型不一而存在差异。这些类型的最大值和最小值在 <code>float.h</code> 文件中通过宏的方式定义。</p>
<ul>
<li><code>float</code> - 三种浮点数类型中取值范围最小的类型（如果它们的大小不一致的情况）。其最小值由 <code>FLT_MIN</code> 给出，并且最小值不能大于 1e-37；最大值则由 <code>FLT_MAX</code> 给出，并且不能小于 1e37。</li>
<li><code>double</code> - 该数据类型至少应与 <code>float</code> 类型一样大，甚至可能超过 <code>float</code> 类型。其最小值和最大值分别由 <code>DBL_MIN</code> 和 <code>DBL_MAX</code> 给出。</li>
<li><code>long double</code> - 该数据类型至少应与 <code>float</code> 类型一样大，甚至可能超过 <code>float</code> 类型。其最小值和最大值分别由 <code>LDBL_MIN</code> 和 <code>LDBL_MAX</code> 给出。</li>
</ul>
<p>所有的浮点类型均为有符号，如果尝试使用无符号浮点类型，如 <code>unsigned float</code> 则会导致编译时错误。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned float a = 0.0;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc test.c</span><br><span class="line">test.c:6:3: error: &#x27;float&#x27; cannot be signed or unsigned</span><br><span class="line">  unsigned float a = 0.0;</span><br><span class="line">  ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>

<p>C 语言提供的实数是具有有限精度，因此，它并不能精确的表示所有实数。大多数采用 GCC 编译的计算机系统都采用二进制来表示实数，这就以为着它不能精确的表示某些数，例如 4.2。为此，在对浮点数进行比较时尽量不要使用 <code>==</code> 操作符，而是检测该数是否在可以容忍的误差范围内。</p>
<h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>GCC 在 C89 的基础上引入了复数类型，同样的，C99 中也增加了复数类型，但是它们之间由许多不同之处。接下来我们将先介绍标准库中的复数类型，随后再介绍 GNU 扩展中的复数类型。</p>
<h4 id="标准复数类型"><a href="#标准复数类型" class="headerlink" title="标准复数类型"></a>标准复数类型</h4><p>复数类型在 C99 标准中引入，它有以下三种类型：</p>
<ul>
<li><code>float _Complex</code></li>
<li><code>double _Complex</code></li>
<li><code>long double _Complex</code></li>
</ul>
<p>该类型以下划线和大写字母开头主要是为了避免与现有程序冲突。在 C99 标准库的 <code>&lt;complex.h&gt;</code> 头文件中定义了一系列宏使得复数的使用更为方便。例如，<code>complex</code> 将被扩展为 <code>_Complex</code>，这使得形如 <code>double complex</code> 的变量声明看起来更自然一些; <code>I</code> 为 <code>const float _Complex</code> 类型的常量，用以表示复数的虚数部分的单位，也可以写作 <code>i</code>。</p>
<p><code>&lt;complex.h&gt;</code> 头文件还包含了许多用于复数计算的函数，如 <code>creal</code> 和 <code>cimag</code> 分别用于获取复数的实数部分和虚数部分。</p>
<h4 id="GNU-扩展的复数类型"><a href="#GNU-扩展的复数类型" class="headerlink" title="GNU 扩展的复数类型"></a>GNU 扩展的复数类型</h4><p>GCC 也为 C89 标准引入了复数类型。它与标准的复数类型拼写不太一样。其形式如下所示：</p>
<ul>
<li><code>__complex__ float</code></li>
<li><code>__complex__ double</code></li>
<li><code>__complex__ long double</code></li>
</ul>
<p>GCC 复数类型的扩展不仅限于复数类型，因此你可以定义复数字符类型和复数整型类型；实际上 <code>__complex__</code> 可以应用于任何原始类型之上。例如：</p>
<ul>
<li><code>__complex__ float</code> - 该数据类型包含两个部分，实数部分和虚数部分；实数部分和虚数部分均为 <code>float</code> 数据类型。</li>
<li><code>__complex__ int</code> - 该数据类型同样包含两个部分，实数部分和虚数部分；实数部分和虚数部分均为 <code>int</code> 数据类型。</li>
</ul>
<p>在 GCC 扩展中，我们可以使用 <code>__real__</code> 和 <code>__imag__</code> 来获取复数的实数部分和虚数部分。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__complex__ <span class="keyword">float</span> a = <span class="number">4</span> + <span class="number">3</span>i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> b = __real__ a;        <span class="comment">/* b 现在为 4 */</span></span><br><span class="line"><span class="keyword">float</span> c = __imag__ a;        <span class="comment">/* c 现在为 3 */</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型是一种自定义类型，它用于存储整型常量值并通过名称来引用。默认情况下，枚举类型值的数据类型为 <code>signed int</code>；你可以使用 GCC 编译器的 <code>-fshort-enums</code> 选项来使用尽可能小的整型类型。这两种行为都符合 C89 标准，但是在同一个程序中混合使用这些选项可能导致不兼容。</p>
<h3 id="定义枚举类型"><a href="#定义枚举类型" class="headerlink" title="定义枚举类型"></a>定义枚举类型</h3><p>枚举类型通过关键字 <code>enum</code> 进行定义，后面紧跟枚举类型的名称（可以省略，此时为匿名的枚举类型），然后是由逗号分割开的枚举值（枚举值放在括号内），最后是代表结束的分号。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">friut</span> &#123;</span> grape, cherry, lemon, kiwi &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例定义了 <code>friut</code> 的枚举类型，它包含 <code>grape</code>，<code>cherry</code>，<code>lemon</code> 和<code>kiwi</code> 四个整型，它们的值分别为 <code>0</code>，<code>1</code>，<code>2</code>，和 <code>3</code>。当然，你也可以指定一个或多个枚举类型的值，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">more_friut</span> &#123;</span> banana = <span class="number">-17</span>, apple, blueberry, mango &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中定义的 <code>banana</code> 的值为 <code>17</code>，其它值依次加 <code>1</code>：即 <code>apple = -16</code>，<code>blueberry = -15</code>，<code>mango = -14</code>。除非特别说明，枚举类型的值为前一个值加 <code>1</code>（第一个值默认为 <code>0</code>）。此外，你还可以引用在该枚举中已经定义了的值，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">yet_more_fruit</span> &#123;</span> kumquat, raspberry, peach, plum = peach + <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中 <code>kumquat = 0</code>，<code>raspberry = 1</code>，<code>peach = 2</code>，<code>plum = 4</code>。</p>
<h3 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h3><p>你可以在定义枚举类型的同时声明枚举类型变量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fruit</span> &#123;</span> banana, apple, blueberry, mango &#125; my_fruit;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将定义和变量声明分离开，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fruit</span> &#123;</span> banana, apple, blueberry, mango &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fruit</span> <span class="title">my_fruit</span>;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是你不能声明匿名的枚举类型。</p>
<p>虽然它们被视为枚举类型的变量，但是你仍然可以为它们赋值任何整型值包括来自其它枚举类型的值。但是当枚举类型的值确定之后，你就不能再更改它，它们将被视为常量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fruit</span> &#123;</span> banana, apple, blueberry, mango &#125;;</span><br><span class="line">banana = <span class="number">15</span>;  <span class="comment">/* 你无法为 banana 赋值新值 */</span></span><br></pre></td></tr></table></figure>

<p>枚举类型与 <code>switch</code> 语句结合起来相当有用，这是因为当在 <code>switch</code> 中只处理了部分枚举类型值时，编译器将会给出警告。</p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型同样属于一种自定义类型，它用于在同一内存空间存储多个变量。你可以随时访问这些变量中的任何一个，其实每次我们应该只读取其中一个变量，由它的定义可以看出，当修改这些变量中的某一个时，其它变量也会发生变化。</p>
<h3 id="定义联合类型"><a href="#定义联合类型" class="headerlink" title="定义联合类型"></a>定义联合类型</h3><p>联合类型通过关键字 <code>union</code> 进行定义，后跟由打括号包围起来的联合类型成员，联合类型的成员定义则与普通变量的定义类似。在 <code>union</code> 和开始大括号之间可以指定联合的名称（可选，如果不指定后续则无法引用，除非使用 <code>typedef</code> 语法）。下面是一个简单的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="声明联合类型"><a href="#声明联合类型" class="headerlink" title="声明联合类型"></a>声明联合类型</h3><p>如果在定义联合类型时给出了名称，那么我们可以在定义的同时或者定义之后声明联合类型变量。</p>
<h4 id="定义时声明变量"><a href="#定义时声明变量" class="headerlink" title="定义时声明变量"></a>定义时声明变量</h4><p>例如，我们可以采用如下形式在定义联合类型的同时声明变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125; first_num, second_num;</span><br></pre></td></tr></table></figure>

<p>上面的示例声明了两个 <code>union numbers</code> 类型的变量：<code>first_num</code> 和 <code>second_num</code>。</p>
<h4 id="定义后声明变量"><a href="#定义后声明变量" class="headerlink" title="定义后声明变量"></a>定义后声明变量</h4><p>当然，我们也可以将定义与变量声明分割开来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span> <span class="title">first_num</span>, <span class="title">second_num</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面的形式与定义时声明变量的效果一致。</p>
<h4 id="初始化联合类型成员"><a href="#初始化联合类型成员" class="headerlink" title="初始化联合类型成员"></a>初始化联合类型成员</h4><p>我们在声明变量的时候也可以对其进行初始化操作。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span> <span class="title">first_num</span> =</span> &#123; <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例将 <code>union numbers</code> 类型的 <code>first_num</code> 变量的第一个成员 <code>i</code> 初始化为 <code>5</code>。除此之外，我们还可以初始化指定的联合类型成员，有两种方式用于初始化联合类型成员。</p>
<ul>
<li><code>member: value</code> - 成员名 + <code>:</code> 的形式，例如：<code>union numbers first_num = &#123; f: 3.14 &#125;;</code>。</li>
<li><code>.member = value</code> - <code>.</code> + 成员名 + <code>=</code> 的形式，例如：<code>union numbers first_num = &#123; .f = 3.14&#125;</code>。</li>
</ul>
<p>当然，我们也可以在定义的同时声明变量并进行初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125; first_num = &#123; <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="访问联合类型"><a href="#访问联合类型" class="headerlink" title="访问联合类型"></a>访问联合类型</h3><p>对联合类型的访问通过访问操作符来完成，即将联合类型的变量放在访问操作符的左边，联合类型的成员名放在访问操作符的右边。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union numbers</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">&#125;;</span><br><span class="line">union numbers first_num;</span><br><span class="line">first_num.i = 3;</span><br><span class="line">first_numb.f = 4.123;</span><br></pre></td></tr></table></figure>

<p>需要注意的时，当需改联合类型的 <code>f</code> 成员时，成员 <code>i</code> 的值相应的也发生了改变。</p>
<h3 id="联合类型大小"><a href="#联合类型大小" class="headerlink" title="联合类型大小"></a>联合类型大小</h3><p>联合类型的大小取决于联合类型成员中占空间最大的成员。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union numbers</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该联合类型的大小为 <code>sizeof(float)</code> 的大小，因为 <code>float</code> 比 <code>int</code> 所占空间大。由于在联合中所有的数据成员共享同一地址空间，因此，只需要该空间能存储联合类型中占空间最大的成员即可。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是由程序员定义数据类型，该数据类型由变量和其它数据类型（可能包含其它结构体）组成。</p>
<h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>结构体的定义与联合类型相似，所不同的是结构体的定义使用 <code>struct</code> 关键字。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的定义中我们定义了一个 <code>struct point</code> 的新类型，该类型包含两个成员：<code>x</code> 和 <code>y</code>，它们均为 <code>double</code> 类型。结构体（或联合类型）都可以包含其它结构体或者联合类型，但是不能包含自身。但是，它们可以包含自身类型的指针（参见不完全类型）。</p>
<h3 id="声明结构体变量"><a href="#声明结构体变量" class="headerlink" title="声明结构体变量"></a>声明结构体变量</h3><p>结构体变量的声明与联合类型一样，可以在定义时或定义之后声明。</p>
<h4 id="定义时声明变量-1"><a href="#定义时声明变量-1" class="headerlink" title="定义时声明变量"></a>定义时声明变量</h4><p>与联合类型类似，我们可以在定义结构体时声明变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; first_point, second_point;</span><br></pre></td></tr></table></figure>

<h4 id="定义后声明变量-1"><a href="#定义后声明变量-1" class="headerlink" title="定义后声明变量"></a>定义后声明变量</h4><p>当然，我们也可以将定义与变量声明分割开来。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span>, <span class="title">second_point</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化结构体变量"><a href="#初始化结构体变量" class="headerlink" title="初始化结构体变量"></a>初始化结构体变量</h4><p>当你在声明结构体变量时可以为结构体成员变量初始化特定的值。如果你没有为结构体提供初始化值，那么它的值取决于是否有静态存储（后续介绍）。如果有，那么整型被初始化为 <code>0</code>，指针类型初始化为 <code>NULL</code>;其它情况下成员变量的值是不确定的。初始化成员变量的一种方式是在大括号中按定义时的顺序给出成员的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span> =</span> &#123; <span class="number">5.0</span>, <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>另一种初始化成员变量的方式是按成员变量名进行初始化。采用这种方式进行初始化可以按任意顺序进行初始化，并且可以保留部分成员不初始化。按成员变量名称初始化也有两种方式：</p>
<ul>
<li><code>.member = value</code> - C99 标准以及 GCC 的 C89 扩展。例如：<code>struct point first_point = &#123; .y = 10.0, .x = 5.0 &#125;;</code>。</li>
<li><code>member: value</code> - GNU C 扩展。例如：<code>struct point first_point = &#123; y: 10.0, x: 5.0 &#125;;</code>。</li>
</ul>
<p>同样地，我们可以在定义结构体时声明变量并进行初始化操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; first_point = &#123; <span class="number">5.0</span>, <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以只初始化部分成员变量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pointy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pointy</span> <span class="title">first_pointy</span> =</span> &#123; <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>x</code> 被初始化为 <code>5</code>，<code>y</code> 被初始化为 <code>0</code>，<code>p</code> 被初始化为 <code>NULL</code>。这里的规则就是 <code>y</code> 和 <code>p</code> 采用静态存储的初始化规则。</p>
<p>当结构体中包含结构体时，我们同样可以对其进行初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">top_left</span>, <span class="title">bottom_right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">my_rectangle</span> =</span> &#123; &#123;<span class="number">1.0</span>, <span class="number">10.0</span>&#125;, &#123;<span class="number">5.0</span>, <span class="number">4.0</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个 <code>struct rectangle</code> 结构体，它包含两个 <code>struct point</code> 类型的成员变量。在初始化的过程中我们使用大括号来区分不同的结构体成员，其实这个大括号是可以省略的（可读性不强）。</p>
<h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>结构体成员的访问与联合类型相似。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span>;</span></span><br><span class="line"></span><br><span class="line">first_point.x = <span class="number">0.0</span>;</span><br><span class="line">first_point.y = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<p>如果结构体中还包含结构体，我们同样可以使用这样方式进行访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">top_left</span>, <span class="title">bottom_right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">my_rectangle</span>;</span></span><br><span class="line"></span><br><span class="line">my_rectangle.top_left.x = <span class="number">0.0</span>;</span><br><span class="line">my_rectangle.top_left.y = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">my_rectangle.bottom_right.x = <span class="number">10.0</span>;</span><br><span class="line">my_rectangle.bottom_right.y = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>在结构体中，我们可以为整型添加一个整数值来告知其不实用标准的字节大小，这种方式被称为位域。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> suit : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> face_value : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例中定义了两个位域字段：<code>suit</code> 和 <code>face_value</code>，它们的位长度分别为 <code>2-bit</code> 和 <code>4-bit</code>，它们的取值范围分别为 <code>0~3</code> 和 <code>0~15</code>（无符号数）。如果它们被定义为有符号数，则其取值范围分别为 <code>-2~1</code> 和 <code>-8~7</code>。</p>
<p>我们可以采用通项来进行表示，<code>N-bit</code> 的位域字段可以表示的范围为：</p>
<ul>
<li>无符号数 - $[0, 2^N-1]$</li>
<li>有符号数 - $[-\frac{2^N}{2}, \frac{2^N}{2}-1]$</li>
</ul>
<p>我们可以使用匿名的位域字段（即没有名称），这样做的目的主要是为了控制那些位可以使用，然而，这种方式可能移植性不是很好且很少使用。此外，我们还可以定义大小为 <code>0</code> 的位域字段，这表示后续的位域字段不与前面的位域字段使用同一个单元，这通常也是没有多大用处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zero_bit_test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>    bit1 : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>         : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>    bit2 : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>上述示例的结构体大小为 8 字节。</li>
<li>你不能对位域字段进行取地址运算 (<code>&amp;</code> 操作符)。</li>
</ol>
<h3 id="结构体大小"><a href="#结构体大小" class="headerlink" title="结构体大小"></a>结构体大小</h3><p>结构体的大小等于结构体中所有成员的大小之和，除此之外，它还可能包含用于特定字节对齐的填充字节。根据不同的计算机类型，某些细节可能不同，但是 4 字节和 8 字节对齐是经常见到的。这样做的目的是为了加快结构体类型的存储访问。</p>
<p>作为 GNU 的扩展，GCC 允许没有成员的结构体，即其大小为 <code>0</code>。如果你想要显示的去掉结构体的填充字节（这可能会降低结构体内存的访问速度），GCC 提供了多种方式。最简单的方式就是通过使用 <code>-fpack-struct</code> 选项。关于更多的填充细节可以参考 GCC 的文档（见扩展阅读 [3]）。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种允许在连续的内存空间中存储一个或多个元素。C 语言的数组以 0 作为开始索引。</p>
<h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>数组的声明由元素的数据类型，数组名以及元素个数组成。例如，<code>int my_array[10];</code>。标准的 C 代码中，数组的元素个数必须为正数。而在 GNU 扩展中，数组的元素个数最小可以为 0。长度为 0 的数组在结构体中作为最后一个成员对于定义变长对象非常有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">this_line</span> =</span> (struct line *)</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct line) + this_length);</span><br><span class="line">    this_line-&gt;length = this_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个 GNU 扩展是支持使用变量定义数组长度，而在标准 C 中仅支持常量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">my_function</span> <span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_array[number];</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>你可以在声明数组变量的时候给它提供一组初始化值进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以只初始化部分值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中 <code>my_array</code> 的前三个值分别初始化为 <code>1</code>，<code>2</code>，<code>3</code>，剩余的两个则被初始化为 <code>0</code>。</p>
<p>在 C99 标准或 C89 的 GNU 扩展中支持乱序初始化，即指定需要初始化的元素下标以及初始值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; [<span class="number">4</span>] <span class="number">1</span>, [<span class="number">2</span>] <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; [<span class="number">4</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述三种声明方式的效果是一样的。在 GNU 中，数组还支持范围的初始化，即将一个范围内的值初始化为同一个值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">100</span>] = &#123; [<span class="number">0</span> ... <span class="number">9</span>] = <span class="number">1</span>, [<span class="number">10</span> ... <span class="number">98</span>] = <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中将 <code>my_array</code> 的 <code>0</code> 到 <code>9</code> 的值初始化为 <code>1</code>；将下标 <code>10</code> 到 <code>98</code> 的值初始化为 <code>2</code>，同时将最后一个元素初始化为 <code>4</code>。这里需要注意的是在下标与 <code>...</code> 之间必须要有空格。</p>
<p>如果你在初始化是对所有元素都进行了初始化，那么你可以不需要指定数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中声明了一个长度为 <code>5</code> 的数组，其值被初始化为 <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>。此外，如果你通过元素下标的方式进行初始化，那么数组的长度将是最大的下标加 <code>1</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">99</span>] = <span class="number">99</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述示例中声明了一个长度为 <code>100</code> 的数组，其前三个值为 <code>0</code>，<code>1</code>，<code>2</code>；最后一个值为 <code>99</code>；其余得知则被初始化为 <code>0</code>。</p>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组元素的访问是通过数组变量名以及数组下标的方式进行访问的。这里再次强调数组下标由 <code>0</code> 开始。例如，对 <code>my_array</code> 数组的第一个值赋值，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>C 语言中多维数组的声明是在数组的基础之上在加数组符号及其长度，即数组的数组。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> two_dimensions[<span class="number">2</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的示例声明了一个二维数组。多维数组的元素访问与一维数组类型，<code>two_dimensions[0][1] = 4</code>。</p>
<p>需要注意的是在 C 语言中，多维数组是按行的方式进行存储的，即 <code>two_dimensions[0][2]</code> 之后紧跟的元素是 <code>two_dimensions[0][3]</code>，而不是 <code>two_dimensions[1][2]</code>。</p>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>你可以使用字符的数组来存储字符串，该数组可以由有符号字符和无符号字符组成。正如前面介绍，当你在声明数组时，你可以指定数组的大小，此时字符串的大小（包括用于表示结束的 <code>null</code> 字符）不能超过数组的大小，如果采用这样方式声明字符串数组，可以不必立即初始化；当然你也可以指定初始化值而不给出数组大小，此时系统将为你分配足够的空间用于存储数组元素。</p>
<p>字符串数组的初始化有两种方式：(a) 使用逗号分割的字符数组；(b) 使用字符串常量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> blue[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">char</span> yellow[<span class="number">26</span>] = &#123;<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> orange[<span class="number">26</span>] = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> gray[] = &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> salmon[] = <span class="string">&quot;salmon&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>无论是上述那种情况，即便是没有显示的给出结束符（<code>\0</code>），字符数组也将会在字符的结尾添加结束符。需要注意的时，如果采用单个字符数组的方式进行初始化字符串，则末尾的结束符号不一定会有，它可能存在，也可能不存在，因此最好不要依赖这个特性。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> bad_str[<span class="number">4</span>] = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>当初始化完成之后，你不能通过赋值操作符为其赋予新的字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> lemon[<span class="number">26</span>] = <span class="string">&quot;custard&quot;</span>;</span><br><span class="line">lemon = <span class="string">&quot;steak sauce&quot;</span>;      <span class="comment">/* 失败 */</span></span><br></pre></td></tr></table></figure>

<p>在使用字符数组时可能存在你给定了数组的大小，但是使用了更大的字符串进行初始化；此时超出的部分并不会重写已经写入数组的内容，而你将在编译时得到警告。由于原始数组大小仍然存在，因此超出原始大小的字符串的任何部分都将写入未分配给它的内存位置。</p>
<h3 id="联合类型数组"><a href="#联合类型数组" class="headerlink" title="联合类型数组"></a>联合类型数组</h3><p>你可以像创建基本类型数组一样创建联合类型的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span> <span class="title">number_array</span>[3];</span></span><br></pre></td></tr></table></figure>

<p>其初始化的方式为 <code>union numbers number_array[3] = &#123; &#123;3&#125;, &#123;4&#125;, &#123;5&#125; &#125;;</code>。其中数组内部的大括号是可以省略的，其访问形式同普通类型一样。</p>
<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>同样地，你也可以为结构体声明数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">point_array</span>[3];</span></span><br></pre></td></tr></table></figure>

<p>上述示例中声明了一个结构体变量 <code>point_array</code>，该变量包含三个 <code>struct point</code> 元素。当然，我们也可以声明变量的时候同时初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">point_array</span>[3] =</span> &#123; &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>其中，结构体元素的初始化可以省略其中的大括号，而结构体数组的元素访问同联合类型一样。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针保存了存储常量和变量的内存地址。对于任何数据类型，包括基本类型和自定义类型，您都可以创建一个指针来保存该类型实例的内存地址。</p>
<h3 id="声明指针变量"><a href="#声明指针变量" class="headerlink" title="声明指针变量"></a>声明指针变量</h3><p>指针的声明与其它变量声明类型包括数据类型和变量名，数据类型代表了指针所指向的内存空间存储的变量类型。指针的声明需要在数据类型和变量名称之间加上间接运算符，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data-type * name;</span><br></pre></td></tr></table></figure>

<p>间接运算符之间的空白字符无关紧要。下面的形式与上面的效果是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data-type *name;</span><br><span class="line">data-type* name;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当在一个语句中声明多个指针变量时需要在每个变量名之前加上间接运算符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *foo, *bar;  <span class="comment">/* 两个指针 */</span></span><br><span class="line"><span class="keyword">int</span> *baz, quux;   <span class="comment">/* 一个指针以及一个整型变量 */</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化指针变量"><a href="#初始化指针变量" class="headerlink" title="初始化指针变量"></a>初始化指针变量</h3><p>指针变量的初始化需要用到取地址运算符。我们可以在变量声明的时候对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;i;</span><br></pre></td></tr></table></figure>

<p>存储在指针变量的内容是一个整型值，它表示计算机内存的地址。在声明变量之后如果需要对指针变量进行赋值，此时就不再需要间接运算符了。如果在后续过程中使用了间接运算符，那么改变的将是指针所指向的变量的值而不是指针变量本身。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;i;  <span class="comment">/* 变量 ip 现在存储的是变量 i 的地址 */</span></span><br><span class="line">ip = &amp;j;       <span class="comment">/* 变量 ip 现在存储的是变量 j 的地址 */</span></span><br><span class="line">*ip = &amp;i;      <span class="comment">/* 变量 j 现在存储的是变量 i 的地址 */</span></span><br></pre></td></tr></table></figure>

<p>最要的是如果你没有使用一个对象的地址对指针变量进行初始化，那么它所指向的地方是不确定的，这时使用该指针变量可能导致程序崩溃（通常来说，这种情况被称为__未定义行为 - undefined behavior__）。</p>
<h3 id="联合类型指针"><a href="#联合类型指针" class="headerlink" title="联合类型指针"></a>联合类型指针</h3><p>联合类型的指针变量同原始类型一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span> <span class="title">foo</span> =</span> &#123;<span class="number">4</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">numbers</span> *<span class="title">number_ptr</span> =</span> &amp;foo;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以通过指针变量实现对联合类型的成员访问，但是我们不能使用常规的成员访问符而需要使用间接成员访问符。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">number_ptr-&gt;i = <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<h3 id="结构体类型指针"><a href="#结构体类型指针" class="headerlink" title="结构体类型指针"></a>结构体类型指针</h3><p>结构体类型的指针变量与联合类型一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> length, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">salmon</span> =</span> &#123;<span class="number">4.3</span>, <span class="number">5.8</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> *<span class="title">fish_ptr</span> =</span> &amp;salmon;</span><br><span class="line"></span><br><span class="line">fish_ptr-&gt;length = <span class="number">5.1</span>;</span><br><span class="line">fish_ptr-&gt;weight = <span class="number">6.3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="不完全类型"><a href="#不完全类型" class="headerlink" title="不完全类型"></a>不完全类型</h2><p>当在定义结构体、联合类型以及枚举类型时不指定其成员（对于枚举类型来说即枚举值），这种类型被称为不完全类型 (incomplete type)。你不可以定义不完全类型的变量，但是可以定义不完全类型的指针。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面定义了一个不完全类型，在给出该类型的完全定义之前，我们不能使用它定义变量，你需要在后续给出该类型的完整定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种不完全类型通常用于链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singly_linked_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">singly_linked_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="comment">/* 其它元素 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singly_linked_list</span> *<span class="title">list_head</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>[1] What Every Computer Scientist Should Know About Floating-Point Arithmetic<br>[2] section 4.2.2 of Donald Knuth’s The Art of Computer Programming.<br>[3] <a href="https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Code-Gen-Options.html#Code-Gen-Options">https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Code-Gen-Options.html#Code-Gen-Options</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言语句</title>
    <url>/2019/10/C-statements/</url>
    <content><![CDATA[<p>C 语言提供了语句用以控制程序的执行流程。您可以编写不执行任何操作的语句，当然也可以编写执行毫不相关的语句（没有任何意义）。本文主要介绍 C 语言所提供的一些语句类型，它们分别是：</p>
<ol start="0">
<li>空语句 - 即形如 <code>;</code> 这样的语句；</li>
<li>块语句 - 用括号括起来的一组零个或多个语句；</li>
<li>条件语句 - <strong>if</strong>；</li>
<li>返回语句 - <strong>return</strong>；</li>
<li>循环语句 - <strong>do</strong>、<strong>while</strong>、<strong>for</strong>；</li>
<li>开关语句 - <strong>switch</strong>，与 <strong>case</strong> 结合使用；</li>
<li>标签语句 - <strong>labels:</strong>，通常与 <strong>goto</strong> 结合使用；</li>
<li>跳转语句 - <strong>goto</strong>、<strong>break</strong>、<strong>continue</strong>，后两者用于循环语句中；</li>
<li>表达式语句 - 例如 <code>a += 10</code>；</li>
<li>类型定义语句 - <strong>typedef</strong>；</li>
</ol>
<span id="more"></span>

<h2 id="标签语句-（Labels）"><a href="#标签语句-（Labels）" class="headerlink" title="标签语句 （Labels）"></a>标签语句 （Labels）</h2><p>我们可以使用标签来标示一部分源代码，以便后续通过 <strong>goto</strong> 语句来使用。标签由标识符以及紧随其后的冒号组成。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">treet:</span><br></pre></td></tr></table></figure>

<p>标签名不会影响其它标识符名称，例如，我们可以按如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> treet = <span class="number">5</span>;    <span class="comment">/* 名为 treet 的变量 */</span></span><br><span class="line">treet:            <span class="comment">/* 名为 treet 的标签 */</span></span><br></pre></td></tr></table></figure>

<p>在 ISO C 的标准中，标签后面必须跟至少一个语句，可以是空语句。GCC 则支持标签后不带任何语句。在编写可移植性的代码时需要注意这一点。</p>
<h2 id="表达式语句（Expression-Statements）"><a href="#表达式语句（Expression-Statements）" class="headerlink" title="表达式语句（Expression Statements）"></a>表达式语句（Expression Statements）</h2><p>表达式语句通过在表达式末尾附加一个分号构成。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>;</span><br><span class="line"><span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="number">10</span> &gt;= <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，所有的表达式在执行时都将被求值，但是这些求值结果由于没有保存，因此会被丢弃。编译器可能会忽略这些语句。</p>
<p>仅当表达式语句具有某种副作用（例如存储值，调用函数）或导致程序错误时，它才有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++;</span><br><span class="line">y = x + <span class="number">25</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello, user!&quot;</span>);</span><br><span class="line">*cucumber;</span><br></pre></td></tr></table></figure>

<p>如果 <code>cucumber</code> 即不是有效的指针并且被声明为 <code>volatile</code>，那么最后一个语句 <code>*cucumber*</code> 可能会导致潜在的程序错误。</p>
<h2 id="条件语句（if）"><a href="#条件语句（if）" class="headerlink" title="条件语句（if）"></a>条件语句（if）</h2><p>我们可以使用条件语句来根据表达式的真假情况有选择的执行程序的一部分。其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">    then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure>

<p>若 <code>test</code> 求值结果为 <code>true</code>，那么程序将执行 <code>then-statment</code> 语句；反之，程序将执行 <code>else-statement</code> 语句。<code>else</code> 部分是可选的。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果表达式 <code>x == 10</code> 为 <code>true</code>，那么将执行 <code>puts(&quot;x is 10&quot;);</code> 语句。如果表达式 <code>x == 10</code> 为 <code>false</code>，那么 <code>puts(&quot;x is 10&quot;);</code> 将不会被执行。</p>
<p>下面的例子展示了 <code>else</code> 字句的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is 10&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is not 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们还可以使用一系列 <code>if</code> 语句来测试多个条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is 1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is 2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is 3&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is something else&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下面的函数用于计算给你年份 <code>y</code> 的复活节日期：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">easterDate</span> <span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g = (y % <span class="number">19</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = (y / <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = ((<span class="number">3</span> * c) / <span class="number">4</span>) - <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> z = (((<span class="number">8</span> * c) + <span class="number">5</span>) / <span class="number">25</span>) - <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> d = ((<span class="number">5</span> * y) / <span class="number">4</span>) - x - <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> e = ((<span class="number">11</span> * g) + <span class="number">20</span> + z - x) % <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((e == <span class="number">25</span>) &amp;&amp; (g &gt; <span class="number">11</span>)) || (e == <span class="number">24</span>))</span><br><span class="line">        e++;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">44</span> - e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">21</span>)</span><br><span class="line">        n += <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    n = n + <span class="number">7</span> - ((d + n) % <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">31</span>)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Easter: %d April %d&quot;</span>, n - <span class="number">31</span>, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Easter: %d March %d&quot;</span>, n, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开关语句（switch）"><a href="#开关语句（switch）" class="headerlink" title="开关语句（switch）"></a>开关语句（switch）</h2><p>我们可以使用 <code>switch</code> 语句将一个表达式与其他表达式进行比较，然后根据比较结果执行一系列子语句。其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> compare<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">if</span>-equal-statement<span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> compare<span class="number">-2</span>:</span><br><span class="line">        <span class="keyword">if</span>-equal-statement<span class="number">-2</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">default</span>-statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 语句将 <code>test</code> 表达式的结果与每一个 <code>compare</code> 表达式进行比较，直到它找到与 <code>test</code> 表达式结果相等的 <code>compare</code>。接着，程序将执行这个 <code>compare</code> 表达式之后的语句。所有的 <code>compare</code> 表达式都必须是整型并且为常量整型（即，文字整数或由文字整数构建的表达式）。</p>
<p>我们可以在 <code>switch</code> 语句中给出一个可选的 <code>default</code> 字句。如果 <code>test</code> 表达式与 <code>default</code> 前的 <code>compare</code> 表达式均不匹配时，<code>default</code> 字句后的语句将被执行。通常，<code>default</code> 放在 <code>switch</code> 语句的末尾，但这不是必须的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 0&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is something else&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每个 <code>case</code> 语句后的 <code>break</code> 语句，这是因为，一旦找到匹配的 <code>case</code> 语句，不仅会执行其后语句，还会执行该 <code>case</code>语句后其它 <code>case</code> 语句下的所有语句。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 0&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is 1&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;x is something else&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例代码将输出下面的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x is <span class="number">0</span></span><br><span class="line">x is <span class="number">1</span></span><br><span class="line">x is something <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p>这通常不是我们所期望的。在每个 <code>case</code> 语句的末尾包含一个 <code>break</code> 语句可以将程序流重定向到 <code>switch</code> 语句之后。</p>
<p>GNU C 支持在单个的 <code>case</code> 语句中指定一个连续的整数范围，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> low ... high:</span><br></pre></td></tr></table></figure>

<p>这与包含相同个数的 <code>case</code> 语句具有相同的含义。即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> low:</span><br><span class="line"><span class="keyword">case</span> low + <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> ...:</span><br><span class="line"><span class="keyword">case</span> high - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> high:</span><br></pre></td></tr></table></figure>

<p>这个特性同样可以应用于 ASCII 字符集：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> ... <span class="string">&#x27;Z&#x27;</span>:</span><br></pre></td></tr></table></figure>

<p>请注意在 <code>...</code> 周围包含空格，否则可能在与整数一起使用时会出现解析错误。即，我们需要写成<code>case 1 ... 5:</code> 而不是 <code>case 1...5:</code>。</p>
<p>通常我们使用 <code>switch</code> 语句来处理 <code>errno</code> 的各种可能值。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句可以用于重复的执行某段代码，C 语句提供了三种基本的循环语句，<code>while</code>、<code>do</code> 和 <code>for</code>。接下来我们将分别介绍这三种循环语句。</p>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p><code>while</code> 循环语句在循环开始时进行退出测试，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (test)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p><code>while</code> 语句首先对 <code>test</code> 表达式求值。若结果为 <code>true</code>，那么将执行 <code>statement</code> 语句，随后再一次对 <code>test</code> 表达式求值；只要 <code>test</code> 表达式为 <code>true</code>，那么将一直执行 <code>statement</code> 语句。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (counter &lt; <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, counter++);</span><br></pre></td></tr></table></figure>

<p>此外，<code>break</code> 语句也可以用于退出当前循环。</p>
<h3 id="do-语句"><a href="#do-语句" class="headerlink" title="do 语句"></a>do 语句</h3><p><code>do</code> 循环语句是在循环末尾进行退出测试，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(test)</span></span></span><br></pre></td></tr></table></figure>

<p><code>do</code> 语句首先执行 <code>statement</code> 语句，随后对 <code>test</code> 表达式求值。若结果为 <code>true</code>，那么继续执行 <code>statement</code> 语句。<code>statement</code> 仅在 <code>test</code> 表达式结果为 <code>false</code> 的时候退出。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    <span class="title">printf</span> <span class="params">(<span class="string">&quot;%d &quot;</span>, x++)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>同样地，我们可以使用 <code>break</code> 语句来提前终止循环。</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p><code>for</code> 循环语句其结构允许简单的变量初始化，表达式测试和变量修改，它可以很方便地进行计数器的循环控制，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialize; test; step)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p><code>for</code> 语句首先执行 <code>initialize</code> 表达式，接着执行 <code>test</code> 表达式，如 <code>test</code> 表达式结果为 <code>false</code>，那么程序将退出 <code>for</code> 循环。否则，如果 <code>test</code> 表达式结果为 <code>true</code>，则执行 <code>statement</code> 语句。最后对 <code>step</code> 进行求值，循环的下一个迭代再次从 <code>test</code> 表达式开始。</p>
<p>大多数情况下，<code>initialize</code> 将对一个或多个变量赋值，它们通常用作计数器，<code>test</code> 表达式将这些变量与一个预定义的表达式进行比较，而 <code>step</code> 则负责更新这些变量的值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>首先，它执行 <code>initialize</code> 表达式，将变量 <code>x</code> 初始化为 <code>0</code>，接着，只要 <code>x</code> 的值小于 <code>10</code>，<code>x</code> 的值将在循环体中输出，再接着，<code>x</code> 的值在 <code>step</code> 表达式中自增，并重新计算 <code>test</code> 表达式。</p>
<p><code>for</code> 循环语句中的三个表达式都是可选的，并且它们的任意组合都是有效的。由于第一个 <code>initialize</code> 表达式仅执行一次，因此它是最常被省略的表达式。例如，我们可以将上面的 <code>for</code> 循环改写为如下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>如果我们省略 <code>test</code> 表达式，那么这将是一个无限循环，即死循环（没有在循环体使用 <code>break</code> 或 <code>goto</code> 语句）。这与将 <code>test</code> 设置为 <code>1</code> 或 <code>true</code> 具有相同的效果，它们从不会变成 <code>false</code>。</p>
<p>下面的示例中，<code>for</code> 从 <code>1</code> 开始输出数字随后自增，并且一直进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; ; x++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>如果省略 <code>step</code> 表达式，那么将没有更新计算的方法（循环体内没有更新）- 这通常不是我们所期望的。例如，下面的示例将一直输出数字 <code>1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>;)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>需要注意的时，我们不能在 <code>test</code> 表达式中使用逗号运算符来同时检查多个变量，因为逗号运算符通常会将做操作数的结果给丢弃，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>, y = <span class="number">10</span>; x &lt;= <span class="number">10</span>, y &gt;= <span class="number">1</span>; x+=<span class="number">2</span>, y--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>其输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">6</span></span><br><span class="line"><span class="number">11</span> <span class="number">5</span></span><br><span class="line"><span class="number">13</span> <span class="number">4</span></span><br><span class="line"><span class="number">15</span> <span class="number">3</span></span><br><span class="line"><span class="number">17</span> <span class="number">2</span></span><br><span class="line"><span class="number">19</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>&amp;&amp;</code> 运算符来测试多个变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>, y = <span class="number">10</span>; x &lt;= <span class="number">10</span> <span class="keyword">and</span> y &gt;= <span class="number">1</span>; x+=<span class="number">2</span>, y--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>同样，我们也可以使用 <code>break</code> 语句来终止 <code>for</code> 循环。</p>
<p>这是用于计算平方和的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sum_of_squares</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++)</span><br><span class="line">        sum += i * i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="块语句（Blocks）"><a href="#块语句（Blocks）" class="headerlink" title="块语句（Blocks）"></a>块语句（Blocks）</h2><p>块语句是用括号括起来的一组零个或多个语句。块语句又被称为__复合语句__。通常，块语句用于 <code>if</code> 语句或循环语句的主体，以将语句进行分组。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((x % <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is even\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is odd\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以在块语句中嵌套块语句，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x % <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is even\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is %d\n&quot;</span>, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is odd\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在块语句内声明变量；这样的变量是该块语句的局部变量。在 C89 中，声明必须出现在其他语句之前，因此有时为此目的引入一个块语句十分有用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);   <span class="comment">/* 编译错误！变量 x 仅存在于前一个块语句中 */</span></span><br></pre></td></tr></table></figure>

<h2 id="空语句（Null-Statement）"><a href="#空语句（Null-Statement）" class="headerlink" title="空语句（Null Statement）"></a>空语句（Null Statement）</h2><p>空语句仅包含一个分号（<code>;</code>）。空语句不会执行任何操作、它也不会在任何地方存储值，同时它也不会在程序执行时产生额外的开销。</p>
<p>通常，空语句用作循环语句的主体，或用作 <code>for</code> 语句中的一个或多个表达式。例如下面的示例使用空语句作为循环的主体（并且它还计算了 <code>n</code> 的整数平方根，仅是示例而已，没多大作用）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i * i &lt; n; i++)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>下面的例子同样使用空语句作为循环的主体，但同时输出了变量 <code>x</code> 的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">5</span>; <span class="built_in">printf</span>(<span class="string">&quot;x is now %d\n&quot;</span>, x), x++)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>有时，我们需要在标签（该标签之后没有任何其它语句）之后加上一个空语句，从而解决移植性问题。</p>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>C 语言提供了三种跳转方式，它们分别是 <code>goto</code>、<code>break</code> 和 <code>continue</code>。接下来我们将分别介绍这三种跳转语句。</p>
<h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h3><p>我们可以使用 <code>goto</code> 语句来实现无条件的跳转到程序的某个地方，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>

<p>我们需要指定一个跳转的标签；当执行 <code>goto</code> 语句时，程序流将跳转到标签所在位置。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> end_of_program;</span><br><span class="line">...</span><br><span class="line">end_of_program:</span><br></pre></td></tr></table></figure>

<p>标签可以是位于 <code>goto</code> 语句所在函数的任意位置，<code>goto</code> 语句不支持跨函数跳转，因此，我们不能使用 <code>goto</code> 语句来跳转到另一函数的标签位置。</p>
<p>我们也可以使用 <code>goto</code> 语句来模拟循环，但是通常不建议那样做，原因有两点：</p>
<ol>
<li>这使得代码难以阅读；</li>
<li>可能导致编译器无法进行优化（GCC 是无法对其进行优化的）。</li>
</ol>
<p>如果可能，我们应尽量使用 <code>for</code>，<code>while</code> 和 <code>do</code> 语句而不是 <code>goto</code> 语句。</p>
<p>GCC 支持 <code>goto</code> 语句跳转到一个由 <code>void *</code> 变量指定的地址处。要想使得其工作，我们需要使用 <code>&amp;&amp;</code> 而不是 <code>&amp;</code> 来获取标签的地址，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Play</span> &#123;</span> ROCK=<span class="number">0</span>, PAPER=<span class="number">1</span>, SCISSORS=<span class="number">2</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> &#123;</span> WIN, LOSE, DRAW &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> Result <span class="title">turn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> jumptable[] = &#123;&amp;&amp;rock, &amp;&amp;paper, &amp;&amp;scissors&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Play</span> <span class="title">opp</span>;</span>                <span class="comment">/* opponent’s play */</span></span><br><span class="line">    <span class="keyword">goto</span> *jumptable[select_option (&amp;opp)];</span><br><span class="line">rock:</span><br><span class="line">    <span class="keyword">return</span> opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);</span><br><span class="line">paper:</span><br><span class="line">    <span class="keyword">return</span> opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);</span><br><span class="line">scissors:</span><br><span class="line">    <span class="keyword">return</span> opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>我们可以使用 <code>break</code> 语句来终止 <code>while</code>、<code>do</code>、<code>for</code> 或者 <code>switch</code> 语句。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= <span class="number">10</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出 <code>1</code> 到 <code>7</code> 的数字，当 <code>x</code> 自增到 <code>8</code> 时，表达式 <code>x == 8</code> 为 <code>true</code>，那么将执行 <code>break</code> 语句，从而跳转到 <code>for</code> 语句之后。</p>
<p>如果我们将 <code>break</code> 语句放在本身位于循环或 <code>switch</code> 语句内的循环或 <code>switch</code> 语句内时，<code>break</code> 仅终止最里面的循环或 <code>switch</code> 语句。</p>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>我们可以在循环中使用 <code>continue</code> 语句来终止循环的当前迭代并开始下一次迭代，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum_of_odd_numbers += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，如果我们将 <code>continue</code> 放在循环内的循环中，<code>continue</code> 只会影响最里层的循环。</p>
<h2 id="返回语句（return）"><a href="#返回语句（return）" class="headerlink" title="返回语句（return）"></a>返回语句（return）</h2><p>我们可以使用 <code>return</code> 语句来结束函数的执行，并将程序控制权返回给调用它的函数，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">return</span>-value;</span><br></pre></td></tr></table></figure>

<p><code>return-value</code> 是一个可选的返回表达式。如果函数的返回类型为 <code>void</code>，那么返回一个表达式是无效的，然而，我们可以使用 <code>return</code> 语句不返回任何值。</p>
<p>如果函数的返回类型与返回值不匹配，并且不能执行自动转换，那么返回的返回值同样是无效的。</p>
<p>如果函数的返回类型不为 <code>void</code> 并且没有指定返回值，那么这个返回语句是有效的，除非调用该函数的上下文环境需要一个返回值，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = cosine(y);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，函数 <code>cosine</code> 是在需要返回值的上下文中调用的，因此可以将该返回值分配给 <code>x</code>。</p>
<p>即使在不需要返回值的情况下，忽略非 <code>void</code> 返回类型函数的返回值并不是一个好主意。当使用 GCC 时，我们可以使用命令行参数 <code>-Wreturn-type</code> 来警告此类忽略了返回值的函数。</p>
<p>以下是具有 <code>void</code> 和非 <code>void</code> 返回类型函数中使用 <code>return</code> 语句的一些示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">print_plus_five</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, x + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">square_value</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型定义语句-typedef"><a href="#类型定义语句-typedef" class="headerlink" title="类型定义语句 (typedef)"></a>类型定义语句 (typedef)</h2><p>我们可以使用 <code>typedef</code> 语句为数据类型创建新的名称，其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> old-type-name <span class="keyword">new</span>-type-name</span><br></pre></td></tr></table></figure>

<p><code>old-type-name</code> 是以及存在的类型名，它可能包含多个 <code>token</code> （如，<code>unsigned long int</code>）；<code>new-type-name</code> 则是新定义的类型的名称，它必须是单个的标识符。为类型创建此新名称不会导致旧名称不再存在。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> real_number_type;</span><br></pre></td></tr></table></figure>

<p>对于自定义数据类型，可以在定义类型时使用 <code>typedef</code> 为该类型创建新名称。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">float</span> length;</span><br><span class="line">    <span class="keyword">float</span> probability_of_being_caught;</span><br><span class="line">&#125; fish_type;</span><br></pre></td></tr></table></figure>

<p>我们也可以对数组进行类型定义，首先要提供元素的类型，然后在类型定义的末尾确定元素数量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> array_of_bytes[<span class="number">5</span>];</span><br><span class="line">array_of_bytes five_bytes = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>为类型选择名称时，应避免以 <code>_t</code> 后缀结束类型名称。编译器允许我们这样做，但是 POSIX 标准保留对标准库类型名称使用 <code>_t</code> 后缀。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Statements">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Statements</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL TDE 读取文件参数无效分析</title>
    <url>/2022/09/cybertec-postgresql-tde-invalid-argument/</url>
    <content><![CDATA[<p>本文记录 Cybertec PostgreSQL 数据库在 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"><code>maintenance_work_mem</code></a> 较大时导致的读取文件参数无效或崩溃的情况。</p>
<span id="more"></span>

<h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><p>我们可以使用下面的命令来重现这个问题。首先，我们下载 <a href="https://github.com/cybertec-postgresql/postgres">Cybertec 的 PostgreSQL 数据库</a>，并进行编译安装，这里需要使用到 OpenSSL，同时为了便于调试，编译优化采用 <code>-O0</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/cybertec-postgresql/postgres.git pgtde</span><br><span class="line">$ <span class="built_in">cd</span> pgtde  <span class="comment"># commit (038a08243)</span></span><br><span class="line">$ git checkout -b PG_14_TDE_1_1 origin/PG_14_TDE_1_1</span><br><span class="line">$ mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ ../configure --prefix=<span class="variable">$PWD</span>/tde --with-openssl --enable-debug CFLAGS=<span class="string">&#x27;-O0&#x27;</span></span><br><span class="line">$ make -j $(nproc) &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>紧接着，配置环境变量，方便操作，这里我们用到了 <code>keycmd.sh</code> 来为数据库提供一个加解密密钥（确保其具有可执行权限）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt;<span class="string">END &gt; env.sh</span></span><br><span class="line"><span class="string">export PGHOME=$pwd/tde</span></span><br><span class="line"><span class="string">export PGPORT=8743</span></span><br><span class="line"><span class="string">export PGDATA=\$PGHOME/pgdata</span></span><br><span class="line"><span class="string">export PATH=\$PGHOME/bin:\$PATH</span></span><br><span class="line"><span class="string">export LD_LIBRARY_PATH=\$PGHOME/lib:\$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="string">export PGENCRKEYCMD=$pwd/keycmd.sh</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line">$ cat &lt;&lt;<span class="string">END &gt; keycmd.sh</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">echo &quot;882fb7c12e80280fd664c69d2d636913&quot;</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line">$ chmod +x keycmd.sh</span><br><span class="line">$ <span class="built_in">source</span> env.sh</span><br></pre></td></tr></table></figure>

<p>随后，初始化数据库，修改配置参数并启动服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ initdb</span><br><span class="line">$ cat &lt;&lt;END &gt;&gt; $PGDATA/postgresql.auto.conf</span><br><span class="line">maintenance_work_mem = &#x27;128MB&#x27;</span><br><span class="line">END</span><br><span class="line">$ pg_ctl -l log start</span><br></pre></td></tr></table></figure>

<p>最后，使用 <code>pgbench</code> 初始化数据，复现错误场景。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pgbench -i -s 100 postgres</span><br><span class="line">NOTICE:  table <span class="string">&quot;pgbench_accounts&quot;</span> does not exist, skipping</span><br><span class="line">NOTICE:  table <span class="string">&quot;pgbench_branches&quot;</span> does not exist, skipping</span><br><span class="line">NOTICE:  table <span class="string">&quot;pgbench_history&quot;</span> does not exist, skipping</span><br><span class="line">NOTICE:  table <span class="string">&quot;pgbench_tellers&quot;</span> does not exist, skipping</span><br><span class="line">creating tables...</span><br><span class="line">generating data (client-side)...</span><br><span class="line">10000000 of 10000000 tuples (100%) <span class="keyword">done</span> (elapsed 43.01 s, remaining 0.00 s)</span><br><span class="line">vacuuming...</span><br><span class="line">creating primary keys...</span><br><span class="line">pgbench: fatal: query failed: ERROR:  could not <span class="built_in">read</span> file <span class="string">&quot;(null)&quot;</span>: Invalid argument</span><br><span class="line">pgbench: query was: alter table pgbench_accounts add primary key (aid)</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最初，我们在默认的配置上测试，并没有任何问题，当在修改了默认参数之后，遇到了这个问题，经过反复修改参数并测试，最终定位到 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"><code>maintenance_work_mem</code></a> 上，当采用默认的 <code>64MB</code> 一切正常，如果过是修改为 <code>128MB</code> 或更大，那么这个问题就可以得到稳定的重现（有时是上面看到的错误，有时是直接崩溃）。</p>
<p>经过反复的调试，我们最终定位到了 <a href="https://github.com/cybertec-postgresql/postgres/blob/038a08243ff7765d9d11052e91f43ed97fe199fb/src/include/storage/buffile.h#L89"><code>BufFileLogicalToPhysicalPos()</code></a> 函数，该函数是用于将逻辑位置转换为物理位置的，它在计算时出现了溢出的情况。我们可以通过 GDB 附加到进程并新增下面的断点来观察。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b tuplesort.c:3137 if srcTape == 2 &amp;&amp; state-&gt;maxTapes == 4</span><br></pre></td></tr></table></figure>


<p>上述步骤完成之后，我们在 psql 中执行下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> pgbench_accounts <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (aid);</span><br></pre></td></tr></table></figure>

<p>断点触发之后，我们可以再新增一个断点 <code>b BufFileLogicalToPhysicalPos</code>，随后在 GDB 中执行 <code>continue</code>，此时的堆栈信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  BufFileLogicalToPhysicalPos (pos=2142765056) at /home/japin/Codes/pgtde/build/../src/include/storage/buffile.h:100</span><br><span class="line">#1  0x00005606b8dfa46e in BufFileSeek (file=0x5606ba03e808, fileno=2, offset=0, whence=0)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/storage/file/buffile.c:961</span><br><span class="line">#2  0x00005606b8dfaacf in BufFileSeekBlock (file=0x5606ba03e808, blknum=261568)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/storage/file/buffile.c:1176</span><br><span class="line">#3  0x00005606b9017eca in ltsReadBlock (lts=0x5606ba0449c0, blocknum=261568, buffer=0x7fe2b0418048)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/logtape.c:288</span><br><span class="line">#4  0x00005606b901800b in ltsReadFillBuffer (lts=0x5606ba0449c0, lt=0x5606ba044c00)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/logtape.c:324</span><br><span class="line">#5  0x00005606b9018993 in ltsInitReadBuffer (lts=0x5606ba0449c0, lt=0x5606ba044c00)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/logtape.c:661</span><br><span class="line">#6  0x00005606b9019157 in LogicalTapeRead (lts=0x5606ba0449c0, tapenum=2, ptr=0x7fff52ff05b4, size=4)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/logtape.c:989</span><br><span class="line">#7  0x00005606b9021ebc in getlen (state=0x5606ba0286b8, tapenum=2, eofOK=true)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/tuplesort.c:3706</span><br><span class="line">#8  0x00005606b9020fe9 in mergereadnext (state=0x5606ba0286b8, srcTape=2, stup=0x7fff52ff0630)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/tuplesort.c:3159</span><br><span class="line">#9  0x00005606b9020f58 in beginmerge (state=0x5606ba0286b8)</span><br><span class="line">    at /home/japin/Codes/pgtde/build/../src/backend/utils/sort/tuplesort.c:3137</span><br></pre></td></tr></table></figure>

<p>从堆栈信息我们可以看到调用 <a href="https://github.com/cybertec-postgresql/postgres/blob/038a08243ff7765d9d11052e91f43ed97fe199fb/src/include/storage/buffile.h#L89"><code>BufFileLogicalToPhysicalPos()</code></a> 函数的参数 <code>pos=2142765056</code>，结合下面该函数的定义，我们代入计算一下就可以知道发生溢出了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">off_t</span></span></span><br><span class="line"><span class="function"><span class="title">BufFileLogicalToPhysicalPos</span><span class="params">(<span class="keyword">off_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">off_t</span>   last_seg_bytes, result;</span><br><span class="line">    <span class="keyword">int</span> full_segs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data_encrypted)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * BYTES_PER_SEGMENT_LOGICAL -&gt; buffile_seg_blocks_logical * BLCKSZ</span></span><br><span class="line"><span class="comment">     *                                  i.e. 130784 * 8192 = 1071382528</span></span><br><span class="line"><span class="comment">     * BYTES_PER_SEGMENT         -&gt;         buffile_seg_blocks * BLCKSZ</span></span><br><span class="line"><span class="comment">     *                                  i.e. 131072 * 8192 = 1073741824</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      full_seg = 2142765056 / 1071382528 = 2</span></span><br><span class="line"><span class="comment">     *      result = 2 * 1073741824 = 2147483648</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里特别要注意 full_segs * BYTES_PER_SEGMENT 的运算，由于 full_segs 和</span></span><br><span class="line"><span class="comment">     * buffile_seg_blocks 均为 int 类型，因此它们更加 int 类型的规则进行运算，</span></span><br><span class="line"><span class="comment">     * 然而 int 类型最大能存储 2^31 - 1 = 2147483647，因此上述结果发生溢出。</span></span><br><span class="line"><span class="comment">     * 2147483648 = 0x80000000 在赋值给 off_t（8 字节有符号整数）时，由于类型</span></span><br><span class="line"><span class="comment">     * 转换时的高字节填充原则，从而变成 `0xffffffff80000000`，即 -2147483648。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    full_segs = pos / BYTES_PER_SEGMENT_LOGICAL;</span><br><span class="line">    result = full_segs * BYTES_PER_SEGMENT;</span><br><span class="line"></span><br><span class="line">    last_seg_bytes = pos % BYTES_PER_SEGMENT_LOGICAL;</span><br><span class="line">    <span class="keyword">if</span> (last_seg_bytes &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">off_t</span>   full_blocks;</span><br><span class="line">        <span class="keyword">int</span>     last_block_usage;</span><br><span class="line">        <span class="keyword">int</span>     useful_per_block = BLCKSZ - SizeOfBufFilePageHeader;</span><br><span class="line"></span><br><span class="line">        full_blocks = last_seg_bytes / useful_per_block;</span><br><span class="line">        result += full_blocks * BLCKSZ;</span><br><span class="line"></span><br><span class="line">        last_block_usage = last_seg_bytes % useful_per_block;</span><br><span class="line">        <span class="keyword">if</span> (last_block_usage &gt; <span class="number">0</span>)</span><br><span class="line">            result += last_block_usage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Even if we&#x27;re at block boundary, add the header size so that we end</span></span><br><span class="line"><span class="comment">     * up at usable position.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 再加上 18 字节的头部长度，结果为 -2147483630</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    result += SizeOfBufFilePageHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数返回之后将进行下面的计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fileno = pos_phys / BYTES_PER_SEGMENT;  /* -2147483630 / 1073741824 = -1 */</span><br><span class="line">offset = pos_phys % BYTES_PER_SEGMENT;  /* -2147483630 % 1073741824 = -1073741806 */</span><br></pre></td></tr></table></figure>

<p>随后在 <a href="https://github.com/cybertec-postgresql/postgres/blob/038a08243ff7765d9d11052e91f43ed97fe199fb/src/backend/storage/file/buffile.c#L916"><code>BufFileSeek()</code></a> 函数中将 <code>fileno</code> 保存到 <code>file-&gt;common.curFile</code> 并通过 <a href="https://github.com/cybertec-postgresql/postgres/blob/038a08243ff7765d9d11052e91f43ed97fe199fb/src/backend/storage/file/buffile.c#L1543"><code>BufFileLoadBuffer()</code></a> 函数加载数据。<a href="https://github.com/cybertec-postgresql/postgres/blob/038a08243ff7765d9d11052e91f43ed97fe199fb/src/backend/storage/file/buffile.c#L1543"><code>BufFileLoadBuffer()</code></a> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">BufFileLoadBuffer</span><span class="params">(BufFile *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufFileCommon   *f = &amp;file-&gt;common;</span><br><span class="line">    BufFileSegment      *thisfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Only whole multiple of BLCKSZ can be encrypted / decrypted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Assert(f-&gt;curOffset % BLCKSZ == <span class="number">0</span> || !data_encrypted);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Advance to next component file if necessary and possible.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;curOffset &gt;= buffile_max_filesize &amp;&amp;</span><br><span class="line">        f-&gt;curFile + <span class="number">1</span> &lt; file-&gt;numFiles)</span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;curFile++;</span><br><span class="line">        f-&gt;curOffset = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Read whatever we can get, up to a full bufferload.</span></span><br><span class="line"><span class="comment">     * 这里由于 f-&gt;curFile 为 -1，因此取出来的 thisfile 是无效的（数组越界了），</span></span><br><span class="line"><span class="comment">     * 出现非法的数据，导致 FileRead() 函数执行出错，这里的出错是随机的，取决于</span></span><br><span class="line"><span class="comment">     * 内存中的数据（这就是为什么有时候崩溃，有时候是报读取文件错误（参数无效）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thisfile = &amp;file-&gt;files[f-&gt;curFile];</span><br><span class="line">    f-&gt;nbytes = FileRead(thisfile-&gt;vfd,</span><br><span class="line">                         f-&gt;buffer.data,</span><br><span class="line">                         <span class="keyword">sizeof</span>(f-&gt;buffer),</span><br><span class="line">                         f-&gt;curOffset,</span><br><span class="line">                         WAIT_EVENT_BUFFILE_READ);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;nbytes = <span class="number">0</span>;</span><br><span class="line">        ereport(ERROR,</span><br><span class="line">                (errcode_for_file_access(),</span><br><span class="line">                 errmsg(<span class="string">&quot;could not read file \&quot;%s\&quot;: %m&quot;</span>,</span><br><span class="line">                        FilePathName(thisfile-&gt;vfd))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we choose not to advance curOffset here */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data_encrypted)</span><br><span class="line">        BufFileAdjustUsefulBytes(f, file-&gt;files, ERROR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nbytes &gt; <span class="number">0</span>)</span><br><span class="line">        pgBufferUsage.temp_blks_read++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题是溢出导致，那么我们可以在计算的时候强制转换为 <code>off_t</code> 类型或者将 <code>full_segs</code> 定义为 <code>off_t</code> 类型，从而保证结果的正确性。修复方法如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/include/storage/buffile.h b/src/include/storage/buffile.h</span></span><br><span class="line"><span class="comment">index 00723f45fd..e5964f5948 100644</span></span><br><span class="line"><span class="comment">--- a/src/include/storage/buffile.h</span></span><br><span class="line"><span class="comment">+++ b/src/include/storage/buffile.h</span></span><br><span class="line"><span class="meta">@@ -95,7 +95,7 @@</span> static inline off_t</span><br><span class="line"> BufFileLogicalToPhysicalPos(off_t pos)</span><br><span class="line"> &#123;</span><br><span class="line">        off_t   last_seg_bytes, result;</span><br><span class="line"><span class="deletion">-       int     full_segs;</span></span><br><span class="line"><span class="addition">+       off_t   full_segs;</span></span><br><span class="line"></span><br><span class="line">        if (!data_encrypted)</span><br><span class="line">                return pos;</span><br><span class="line"><span class="meta">@@ -130,7 +130,7 @@</span> BufFileLogicalToPhysicalPos(off_t pos)</span><br><span class="line"> static inline off_t</span><br><span class="line"> BufFilePhysicalToLogicalPos(off_t pos)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-       int             full_segs;</span></span><br><span class="line"><span class="addition">+       off_t   full_segs;</span></span><br><span class="line">        off_t   last_seg_bytes, result;</span><br><span class="line"></span><br><span class="line">        if (!data_encrypted)</span><br></pre></td></tr></table></figure>

<p>经测试，上述代码可以有效地解决了该问题，代码里面还有其他地方可能存在类似的问题，在给 Cybertec 发送了定位分析之后，他们着手<a href="https://github.com/cybertec-postgresql/postgres/commit/20880085986344177f32ffb36c513381d650b361">修复了这个问题</a>。</p>
<p>然而，还有一个问题，为什么 <code>64MB</code> 的 <code>maintenance_work_mem</code> 不会出现这个问题呢？在进行上述问题定位的时候，我们发现它是在执行并行的索引创建过程，为此，我们测试了当不采用并行时，程序的运行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SHOW max_parallel_maintenance_workers;</span><br><span class="line"> max_parallel_maintenance_workers</span><br><span class="line">----------------------------------</span><br><span class="line"> 2</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# ALTER TABLE pgbench_accounts ADD PRIMARY KEY (aid);</span><br><span class="line">2022-09-23 15:51:46.657 CST [25168] ERROR:  could not read file &quot;(null)&quot;: Invalid argument</span><br><span class="line">2022-09-23 15:51:46.657 CST [25168] STATEMENT:  alter table pgbench_accounts add primary key (aid);</span><br><span class="line">ERROR:  could not read file &quot;(null)&quot;: Invalid argument</span><br><span class="line">postgres=# SET max_parallel_maintenance_workers TO 0;</span><br><span class="line">SET</span><br><span class="line">postgres=# ALTER TABLE pgbench_accounts ADD PRIMARY KEY (aid);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>

<p>从上面的输出可以看到，当并行被禁用之后，一切都是正常的。那么 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"><code>maintenance_work_mem</code></a> 是如何影响并行的呢？答案就在 <a href="https://github.com/cybertec-postgresql/postgres/blob/a8de814ba12c1454089be2cd0a3f71ec52513690/src/backend/optimizer/plan/planner.c#L5835"><code>plan_create_index_workers()</code></a> 函数中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">plan_create_index_workers</span><span class="params">(Oid tableOid, Oid indexOid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If parallel_workers storage parameter is set for the table, accept that</span></span><br><span class="line"><span class="comment">     * as the number of parallel worker processes to launch (though still cap</span></span><br><span class="line"><span class="comment">     * at max_parallel_maintenance_workers).  Note that we deliberately do not</span></span><br><span class="line"><span class="comment">     * consider any other factor when parallel_workers is set. (e.g., memory</span></span><br><span class="line"><span class="comment">     * use by workers.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (rel-&gt;rel_parallel_workers != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parallel_workers = Min(rel-&gt;rel_parallel_workers,</span><br><span class="line">                               max_parallel_maintenance_workers);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	[...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Estimate heap relation size ourselves, since rel-&gt;pages cannot be</span></span><br><span class="line"><span class="comment">     * trusted (heap RTE was marked as inheritance parent)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    estimate_rel_size(heap, <span class="literal">NULL</span>, &amp;heap_blocks, &amp;reltuples, &amp;allvisfrac);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Determine number of workers to scan the heap relation using generic</span></span><br><span class="line"><span class="comment">     * model</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    parallel_workers = compute_parallel_worker(rel, heap_blocks, <span class="number">-1</span>,</span><br><span class="line">                                               max_parallel_maintenance_workers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cap workers based on available maintenance_work_mem as needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that each tuplesort participant receives an even share of the</span></span><br><span class="line"><span class="comment">     * total maintenance_work_mem budget.  Aim to leave participants</span></span><br><span class="line"><span class="comment">     * (including the leader as a participant) with no less than 32MB of</span></span><br><span class="line"><span class="comment">     * memory.  This leaves cases where maintenance_work_mem is set to 64MB</span></span><br><span class="line"><span class="comment">     * immediately past the threshold of being capable of launching a single</span></span><br><span class="line"><span class="comment">     * parallel worker to sort.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (parallel_workers &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           maintenance_work_mem / (parallel_workers + <span class="number">1</span>) &lt; <span class="number">32768L</span>)</span><br><span class="line">        parallel_workers--;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parallel_workers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用于计算并行工作的进程数。其流程大致如下：</p>
<ol>
<li>如果用户为表指定了 <a href="https://www.postgresql.org/docs/14/sql-createtable.html#RELOPTION-PARALLEL-WORKERS"><code>parallel_workers</code></a>，那么并行的工作进程数为该参数和 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS"><code>max_parallel_maintenance_workers</code></a> 中较小的，此时不会考虑工作进程使用的内存。</li>
<li>如果用户没有指定，则分三个步骤来计算并行工作的进程数：<br>2.1. 先通过 <a href="https://github.com/cybertec-postgresql/postgres/blob/a8de814ba12c1454089be2cd0a3f71ec52513690/src/backend/optimizer/util/plancat.c#L948"><code>estimate_rel_size()</code></a> 评估表的大小（主要是计算出实际的页面数），实际是调用 <a href="https://github.com/cybertec-postgresql/postgres/blob/a8de814ba12c1454089be2cd0a3f71ec52513690/src/backend/access/table/tableam.c#L647"><code>table_block_relation_estimate_size()</code></a> 函数进行计算；<br>2.2. 随后通过 <a href="https://github.com/cybertec-postgresql/postgres/blob/a8de814ba12c1454089be2cd0a3f71ec52513690/src/backend/optimizer/path/allpaths.c#L3734"><code>compute_parallel_worker()</code></a> 函数计算并行的工作进程数；该函数会根据表和索引的页面数量来计算并行工作进程的数量（涉及到 <a href="https://www.postgresql.org/docs/14/runtime-config-query.html#GUC-MIN-PARALLEL-TABLE-SCAN-SIZE"><code>min_parallel_table_scan_size</code></a> 和 <a href="https://www.postgresql.org/docs/14/runtime-config-query.html#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE"><code>min_parallel_index_scan_size</code></a> 两个参数）。默认情况下，一个工作线进程处理约 <code>24MB</code> 的表数据 (<code>min_parallel_table_sacn_size * BLCKSZ * 3</code>)，或 <code>1536KB</code> 的索引数据 (<code>min_parallel_index_scan_size * BLCKSZ * 3</code>)；然后取处理表数据和索引数据中较小的工作进程数；最后还需要保证不超过最大的并行维护工作进程数 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS"><code>max_parallel_maintenance_workers</code></a>。<br>2.3. 根据步骤 2 计算的并行工作进程数和 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"><code>maintenance_work_mem</code></a> 调整并行工作的进程数。确保每个并行工作的进程都能从 <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"><code>maintenance_work_mem</code></a> 中分配到至少 <code>32MB</code> 的内存。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/cybertec-postgresql/postgres">https://github.com/cybertec-postgresql/postgres</a><br>[2] <a href="https://www.postgresql.org/docs/14/runtime-config-resource.html">https://www.postgresql.org/docs/14/runtime-config-resource.html</a><br>[3] <a href="https://www.postgresql.org/docs/14/sql-createtable.html">https://www.postgresql.org/docs/14/sql-createtable.html</a><br>[4] <a href="https://www.postgresql.org/docs/14/runtime-config-query.html">https://www.postgresql.org/docs/14/runtime-config-query.html</a></p>
<div class="just-for-fun">
笑林广记 - 胡瘌杀

<p>或看审囚回，人问之，答曰：“今年重囚五人，俱有认色：一痴子、一颠子、一瞎子、一胡子、一瘌痢。”<br>问如何审了，答曰：“只胡子与瘌痢吃亏，其余免死。”<br>又问何故，曰：“只听见问官说痴弗杀，颠弗杀，一眼弗杀，胡子搭瘌杀。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言表达式和运算符</title>
    <url>/2019/06/expressions-and-operators/</url>
    <content><![CDATA[<p>表达式和运算符是组成 C 语言的基本组成部分，本文主要针对表达式和运算符进行讲解，涉及到赋值运算符、算术运算符、比较运算符和逻辑运算符等运算符以及条件表达式、成员访问表达式和函数调用表达式等一系列表达式。</p>
<span id="more"></span>

<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>C 语言中定义一个表达式由一个操作符和零个或多个运算符组成。操作数是诸如常量、变量以及函数调用返回值的类型对象。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span></span><br><span class="line">cosine(<span class="number">3.14159</span>)    <span class="comment">/* 我们假设其返回一个浮点类型值 */</span></span><br></pre></td></tr></table></figure>

<p>括号可以用于构造子表达式，如 <code>( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )</code>。在由括号组成的表达式中，首先对最内层的表达式进行求值，即 <code>3 + 10</code> 和 <code>2 * 6</code> 分别求值为 <code>13</code> 和 <code>12</code>；随后进行 <code>13 - 12</code> 的表达式求值，其结果为 <code>1</code>；最后执行 <code>2 * 1</code> 的表达式求值，得出最后结果为 <code>2</code>。从这里可以看出，C 语言的表达式求值顺序是由内到外进行的，而最外层的括号是可以省略的。</p>
<h3 id="函数调用表达式"><a href="#函数调用表达式" class="headerlink" title="函数调用表达式"></a>函数调用表达式</h3><p>对任何具有返回值的函数的调用是一个表达式。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">a = <span class="number">10</span> + function();</span><br></pre></td></tr></table></figure>

<h3 id="成员访问表达式"><a href="#成员访问表达式" class="headerlink" title="成员访问表达式"></a>成员访问表达式</h3><p>您可以使用成员访问运算符 <code>.</code> 来访问联合或结构体的成员。您需要将结构体或联合的变量放在运算符的左边，成员名放在运算符的右边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">first_point</span>;</span></span><br><span class="line"></span><br><span class="line">first_point.x = <span class="number">0</span>;</span><br><span class="line">first_point.y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>当然，您也可以通过指针进行访问（使用间接运算符 <code>-&gt;</code>）。<code>x-&gt;y</code> 等同于 <code>(*x)-&gt;y</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">salmon</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> *<span class="title">fish_pointer</span> =</span> &amp;salmon;</span><br><span class="line"></span><br><span class="line">fish_pointer-&gt;length = <span class="number">3</span>;</span><br><span class="line">fish_pointer-&gt;weight = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>您可以通过条件运算符来形成一个条件表达式，它将根据第一个操作数的真假来决定是计算第二操作数还是第三个操作数。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a ? b : c;</span><br></pre></td></tr></table></figure>

<p>如果表达式 <code>a</code> 为 <code>true</code>，那么表达式 <code>b</code> 的结果将作为整个表达式的最终结果。否则表达式 <code>c</code> 的结果将作为整个表达式的最终结果。</p>
<p>表达式 <code>b</code> 和 <code>c</code> 必须兼容，即，它们必须是：</p>
<ol>
<li>算术类型；</li>
<li>兼容的结构体或联合类型；</li>
<li>兼容的指针类型（其中一个可能为 <code>NULL</code>）。</li>
</ol>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = (x == <span class="number">5</span>) ? y : z;</span><br></pre></td></tr></table></figure>

<p>如果 <code>x</code> 等于 <code>5</code>，那么 <code>a</code> 将等于 <code>y</code> 的值；否则，<code>a</code> 将等于 <code>z</code> 的值。它可以被视为是一个简短的 <code>if ... else ...</code> 的写法。例如，下面的写法等同于上述写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">5</span>) &#123;</span><br><span class="line">    a = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第一个操作数为 <code>true</code>，那么第三个操作数将不会被执行；同样地，如果第一个操作数为 <code>false</code>，那么第二个操作数将不会被执行。第一个操作数总是会被执行的。</p>
<h3 id="表达式中的语句与声明"><a href="#表达式中的语句与声明" class="headerlink" title="表达式中的语句与声明"></a>表达式中的语句与声明</h3><p>作为 GNU C 的扩展，它允许您在括号中构建复杂的语句。它让您可以在表达式中引入循环、<code>switch</code> 语句以及局部变量。</p>
<p>回想一下，复合语句（也称为块）是由大括号包围的语句序列。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(&#123; <span class="keyword">int</span> y = function (); <span class="keyword">int</span> z;</span><br><span class="line">       <span class="keyword">if</span> (y &gt; <span class="number">0</span>) z = y;</span><br><span class="line">       <span class="keyword">else</span> z = - y;</span><br><span class="line">   z; &#125;)</span><br></pre></td></tr></table></figure>

<p>这是一个求函数 <code>function()</code> 返回值的绝对值的有效表达式（虽然复杂了一点）。</p>
<p>复合语句中的最后一件事应该是一个后跟分号的表达式; 此子表达式的值用作整个构造的值。（如果你在大括号中最后使用了一些其他类型的语句，那么构造的类型为void，因此实际上没有值。）</p>
<p>此功能在使宏定义“安全”时非常有用（因此它们只能评估每个操作数一次）。例如，我们经常在 C 语言中看到如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p>但是上述定义中 <code>a</code> 或者 <code>b</code> 将被执行两次，这就可能导致副作用。在 GNU C 中，如果您知道操作数的类型，您可以定义更为安全的版本（以整型为例）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxint(a,b) \</span></span><br><span class="line"><span class="meta">    (&#123;int _a = (a), _b = (b); _a &gt; _b ? _a : _b; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>如果您不知道操作数的类型，您仍然可以这样做，但是您需要使用 <code>typeof</code> 表达式或者类型命名。</p>
<p>常量表达式中不允许嵌入语句，例如枚举常量的值，位字段的宽度或静态变量的初始值。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符指定了操作数上需要执行的操作，运算符可以有一个、两个或者三个操作数，这取决于运算符的类型。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符（Assignment Operator）将值存储在变量中。C 语言提供了多种赋值运算符的变体。</p>
<p>标准的赋值运算符（<code>=</code>）仅仅是将右操作数的值存放到左操作数指定的变量中。与所有赋值运算符一样，左操作数（通常称为__左值 lvalue__）不能是字面值（literal）或常量值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> y = <span class="number">45.12</span> + <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">int</span> z = (<span class="number">2</span> * (<span class="number">3</span> + function ()));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line">    <span class="keyword">int</span> baz;</span><br><span class="line">&#125; quux = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不同于下面将要介绍的其它赋值运算符，普通的赋值运算符可以为结构体类型赋值。</p>
<p>复合赋值运算符执行的操作涉及到左操作数和右操作数，并将计算的结果存储到左操作数中。下表给出了复合赋值运算符以及其作用：</p>
<table>
<thead>
<tr>
<th>复合赋值运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>+=</code></td>
<td>将两个操作数进行加法运算，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>使用左左操作数减去右操作数，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>将两个操作数进行乘法运算，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>将左操作数除以右操作数，并将结果赋给左操作数</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>对两个操作数执行取余除法，并将除法结果赋给左操作数</td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>对左操作数执行左移操作，移位右操作数指定的位数，并将移位结果赋给左操作数</td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>对左操作数执行右移操作，移位右操作数指定的位数，并将移位结果赋给左操作数</td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>对两个操作数执行按位与操作，并将操作结果分配给左操作数</td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>对两个操作数执行按位或操作，并将操作结果赋给左操作数</td>
</tr>
<tr>
<td><code>^=</code></td>
<td>对两个操作数执行按位异或操作，并将操作结果赋给左操作数</td>
</tr>
</tbody></table>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>自增运算符 (<code>++</code>) 是将操作数自加 <code>1</code> 的运算符。操作数必须是原始类型、指针或枚举类型变量之一。你可以在操作数之前或之后使用自增运算符。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> w = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> y = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">float</span> z = <span class="number">5.2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"></span><br><span class="line">++w;   <span class="comment">/* w 现在是字符 ‘2’ (而不是值 2) */</span></span><br><span class="line">x++;   <span class="comment">/* x 现在是 6 */</span></span><br><span class="line">++y;   <span class="comment">/* y 现在是 ‘C’ (在 ASCII 系统上) */</span></span><br><span class="line">z++;   <span class="comment">/* z 现在是 6.2 */</span></span><br><span class="line">++p;   <span class="comment">/* p 现在是 &amp;x + sizeof(int) */</span></span><br></pre></td></tr></table></figure>

<p>指针自增操作自有在指针所指向的值是有效的内存空间时才有意义。</p>
<p>前缀自增运算符在计算操作数之前加 1，后缀自增运算符在计算操作数之后加 1。在前面的示例中更换自增运算符的位置没有任何影响。但是，在下面的情况下就有所不同了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d \n&quot;</span>, x++);    <span class="comment">/* 输出 x 的值，随后将 x 自增 1 */</span></span><br><span class="line"><span class="comment">/* x 现在等于 6 */</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d \n&quot;</span>, ++x);    <span class="comment">/* 先自增 1，随后输出 x 的值 */</span></span><br></pre></td></tr></table></figure>

<p>上面的示例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>同样，您也可以使用自减运算符减去 1，其用法与自增运算符相同。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>C 语言提供了标准的算术运算符，它包括加法、减法、乘法、除法、取模以及负号。这些算术运算符的使用相当简单，与我们平时接触到的算法大部分相同。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加法 */</span></span><br><span class="line">x = <span class="number">5</span> + <span class="number">3</span>;</span><br><span class="line">y = <span class="number">10.23</span> + <span class="number">37.332</span>;</span><br><span class="line">quux_pointer = foo_pointer + bar_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 减法 */</span></span><br><span class="line">x = <span class="number">5</span> - <span class="number">3</span>;</span><br><span class="line">y = <span class="number">57.223</span> - <span class="number">10.903</span>;</span><br><span class="line">quux_pointer = foo_pointer - bar_pointer;</span><br></pre></td></tr></table></figure>

<p>您可以在指针类型上使用加法和减法，但是不能使用乘法和除法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 乘法 */</span></span><br><span class="line">x = <span class="number">5</span> * <span class="number">3</span>;</span><br><span class="line">y = <span class="number">47.4</span> * <span class="number">1.001</span>;</span><br><span class="line"><span class="comment">/* 除法 */</span></span><br><span class="line">x = <span class="number">5</span> / <span class="number">3</span>;</span><br><span class="line">y = <span class="number">940.0</span> / <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure>

<p>正数的正数除法向零取整，例如 <code>5/3</code> 的值为 1。但是，如果操作数包含负数，那么取整的方向有实现决定。</p>
<p>您可以使用取模运算符 <code>％</code> 来获得两个操作数产生的余数。您通过将两个操作数分别放置在运算符的两端来进行取模运算。<code>3 % 5</code> 与 <code>5 % 3</code> 有不同的结果。取模运算符的操作数必须是原始数据类型。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 取模运算 */</span></span><br><span class="line">x = <span class="number">5</span> % <span class="number">3</span>;</span><br><span class="line">y = <span class="number">74</span> % <span class="number">47</span>;</span><br></pre></td></tr></table></figure>

<p>负号运算符的使用如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 负号 */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">float</span> y = <span class="number">-3.14159</span>;</span><br></pre></td></tr></table></figure>

<p>如果您在无符号数上使用负号运算符，其结果并不是其相反数，而是这个无符号数数据类型的最大值减去这个无符号数。</p>
<p>目前，大多数系统都使用二进制补码算法，因此在这类系统上，负数所能表示的范围总是比正数多。例如，在某些系统上，下面的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = INT_MAX;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX  = %d\n&quot;</span>, x);</span><br><span class="line">    x = INT_MIN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN  = %d\n&quot;</span>, x);</span><br><span class="line">    x = -x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-INT_MIN = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INT_MAX  = 2147483647</span><br><span class="line">INT_MIN  = -2147483648</span><br><span class="line">-INT_MIN = -2147483648</span><br></pre></td></tr></table></figure>

<p>当然，您还可以将正号应用于数值表达式，例如，<code>int x = +42;</code>。除非显式为负数，否则假定数值为正，因此该运算符对程序操作没有影响。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>您可以使用比较运算符来确定两个操作数彼此之间的关系：它们是否相等、一个比另一个大或一个比另一个小等。当您使用任何比较运算符时，其结果不是 1 就是 0，分别代表 true 和 false。</p>
<p>在下面的代码示例中，变量 x 和 y 代表算术类型或指针的任何两个表达式。</p>
<p>相等运算符 (<code>==</code>) 用于测试两个操作数是否相等。如果它们相等，则返回 1；如果不想等，则返回 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is equal to y&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is not equal to y&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不等号运算符 (<code>!=</code>) 用于测试两个操作数是否不相等。如果它们相等，则返回 0；如果不想等，则返回 1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is not equal to y&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;x is equal to y&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浮点数的相等或不想等比较运算符可能产生意想不到的结果。我们在之前介绍数据类型的时候已经有所提及。</p>
<p>您可以比较函数指针是否相等或不等；测试的结果表示两个函数指针是否指向同一个函数。</p>
<p>除了相等和不想等之外，您还可以比较两个操作数之间的小于 (<code>&lt;</code>)、小于等于 (<code>&lt;=</code>)、大于 (<code>&gt;</code>) 和大于等于 (<code>&gt;=</code>) 关系。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is less than y&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (x &lt;= y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is less than or equal to y&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is greater than y&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;x is greater than or equal to y&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于测试一组操作数的真假性。在 C 语言中，任何非零表达式都被视为真；而计算结果为零的表达式视为假。</p>
<p>逻辑与运算符 (<code>&amp;&amp;</code>) 用于测试两个操作数是否均为真 (true)。如果第一个表达式计算结果为假 (false)，则不会计算第二个表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x == <span class="number">5</span>) &amp;&amp; (y == <span class="number">10</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x is 5 and y is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>逻辑或运算符 (<code>||</code>) 用于测试两个操作数中是否有为真的。如果第一个表达式计算结果为真，则不会计算第二个表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x == <span class="number">5</span>) || (y == <span class="number">10</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x is 5 or y is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>逻辑非运算符 (<code>!</code>) 用于反转操作数的真假性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(x == <span class="number">5</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x is not 5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于逻辑运算符中的第二个表达式并不是必须被计算的，因此您可以用非常不直观的形式编写代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo &amp;&amp; x++)</span><br><span class="line">    bar();</span><br></pre></td></tr></table></figure>

<p>如果 <code>foo</code> 的值为 0，那么不仅函数 <code>bar()</code> 不会被调用，<code>x</code> 的值也不会增加。如果您想要无论在什么情况下都增加 <code>x</code> 的值，您应该将其写在逻辑运算符之外来做这件事。</p>
<h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p>您可以使用左移运算符 (<code>&lt;&lt;</code>) 来将第一个操作数向左移动指定的比特位。第二个操作数表示要移位的位数。从值左侧移除的位被丢弃，而右侧移入的位则填充为 0。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">47</span>;    <span class="comment">/* 47 的二进制为 00101111 */</span></span><br><span class="line">x &lt;&lt; <span class="number">1</span>;    <span class="comment">/* 00101111 &lt;&lt; 1 为 01011110 */</span></span><br></pre></td></tr></table></figure>

<p>类似地，您可以使用右移运算符 (<code>&gt;&gt;</code>) 来将第一个操作数向右移动指定的比特位。从值右侧移除的位被丢弃，而左侧移入的位通常也由 0 来填充，但如果第一个操作数是带符号的负值，则添加的位将为 0 或先前位于最左位位置的任何值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">47</span>;   <span class="comment">/* 47 的二进制为 00101111 */</span></span><br><span class="line">x &gt;&gt; <span class="number">1</span>;   <span class="comment">/* 00101111 &gt;&gt; 1 为 00010111 */</span></span><br></pre></td></tr></table></figure>

<p>无论是左移还是右移运算符，如果第二个操作数大于第一个操作数的比特位时，或者第二个操作数是负数时，这都属于未定义的情况。</p>
<h3 id="按位逻辑运算符"><a href="#按位逻辑运算符" class="headerlink" title="按位逻辑运算符"></a>按位逻辑运算符</h3><p>C 语言提供了按位与 (<code>&amp;</code>)，按位或 (<code>|</code>)，按位取反 (<code>~</code>) 以及按位异或 (<code>^</code>) 运算符。(本节中的操作数均为二进制形式。)</p>
<p>按位与运算符将会检测两个操作数的每个位，仅当它们都为 1 时结果中的相应位才为 1，其它情况下均为 0。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11001001</span> &amp; <span class="number">10011011</span> = <span class="number">10001001</span></span><br></pre></td></tr></table></figure>

<p>按位或则是在两个操作数中，相应位全为 0 时，其结果中对应的位才为 0，否则则为 1。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11001001</span> ^ <span class="number">10011011</span> = <span class="number">01010010</span></span><br></pre></td></tr></table></figure>

<p>按位取反则是将操作数中的每个比特位进行反转，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">~<span class="number">11001001</span> = <span class="number">00110110</span></span><br></pre></td></tr></table></figure>

<p>在 C 语言中，您只能将这些运算符与整数（或字符）类型的操作数一起使用，并且为了最大程度的可移植性，您应该只使用带有无符号整数类型的按位取反运算符。</p>
<h3 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h3><p>您可以用取地址符 (<code>&amp;</code>) 来获取对象的内存地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer_to_x = &amp;x;</span><br></pre></td></tr></table></figure>

<p>函数指针和数据指针是不兼容的，因此，您不能指望将函数的地址存储到数据指针中，然后将其复制到函数指针中并成功调用它。它可能适用于某些系统，但它并不具有可移植性。</p>
<p>作为 C89 的 GNU 扩展，您还可以使用标签地址运算符 (<code>&amp;&amp;</code>) 获取标签的地址。结果是一个 <code>void *</code> 类型的指针，它可以与 <code>goto</code> 一起使用。</p>
<p>给定存储在指针中的内存地址，您可以使用间接运算符 <code>*</code> 来获取存储在地址中的值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = &amp;x;    <span class="comment">/* ptr 现在存储着 x 的地址 */</span></span><br><span class="line"></span><br><span class="line">y = *ptr;    <span class="comment">/* y 获取了存储在地址 ptr 中的值 */</span></span><br></pre></td></tr></table></figure>

<p>您需要避免在未初始化未确定的内存地址上使用解地址运算符。</p>
<h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a><code>sizeof</code> 运算符</h3><p>您可以使用 <code>sizeof</code> 运算符来获取数据类型的字节大小，其操作数可以是真实得到数据类型限定符（例如，int 和 float），也可以是有效的表达式。当操作数是数据类型时，它必须使用括号包裹起来。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> a = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">size_t</span> b = <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"><span class="keyword">size_t</span> c = <span class="keyword">sizeof</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">size_t</span> d = <span class="keyword">sizeof</span>(<span class="number">5.143</span>);</span><br><span class="line"><span class="keyword">size_t</span> e = <span class="keyword">sizeof</span> a;</span><br></pre></td></tr></table></figure>

<p><code>sizeof</code> 运算符的返回值类型为 <code>size_t</code>，它定义在 <code>&lt;stddef.h&gt;</code> 头文件中。<code>size_t</code> 是无符号正数类型，可能为 <code>unsigned int</code> 或 <code>unsigned long int</code>；在不同的系统上可能有所不同。</p>
<p><code>size_t</code> 类型通常是循环索引的一种方便类型，因为它保证能够保存任何数组中的元素数量; 然而，<code>int</code> 则可能不满足这种情况。</p>
<p><code>sizeof</code> 运算符可以用来自动的计算数组的元素个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> values[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">48</span>, <span class="number">681</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYSIZE(x) (sizeof x/sizeof x[0])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAYSIZE(values); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种情况下可能不适用。第一种情况是在数组长度为 0 （GCC 的 GNU 扩展支持长度为 0 的数组）；第二种情况则是在数组作为函数的参数（此时数组将退化为指针）。</p>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>你可以使用逗号表达式来分割两个表达式。例如，第二个表达式可能会使用第一个表达式生成的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++, y = x * x;</span><br></pre></td></tr></table></figure>

<p>通常，逗号表达式经常用于 <code>for</code> 语句中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>, y = <span class="number">10</span>;  x &lt;=<span class="number">10</span> &amp;&amp; y &gt;=<span class="number">1</span>;  x++, y--)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做可是很方便的在 <code>for</code> 语句中设置、监控以及修改表达式的值。</p>
<p>注意，逗号也用于分割函数参数，但这时它并不属于逗号运算符。</p>
<p>如果您想再函数中使用逗号运算符，您需要使用括号将其包裹起来。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(x,  y=<span class="number">47</span>,  x,  z);</span><br></pre></td></tr></table></figure>

<p>上述示例将被解释为带有四个参数的函数调用。而下面的示例则表示三个参数的函数调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(x,  (y=<span class="number">47</span>,  x),  z);</span><br></pre></td></tr></table></figure>

<p>其中，第二参数为 <code>(y=47, x)</code>。</p>
<h3 id="数组下标运算符"><a href="#数组下标运算符" class="headerlink" title="数组下标运算符"></a>数组下标运算符</h3><p>您可以使用下标运算符来获取数组元素。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>数组的下标运算符等于指针操作，例如 <code>A[i]</code> 等同于 <code>(*((A) + (i)))</code>。这就意味着大多数情况下使用数组名都等同于指针操作。这同样意味着您不能对使用 <code>register</code> 定义的数组使用下标运算符。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>您可以使用类型转换来将表达式转换为特定数据类型。类型转换由包裹在括号内的类型限定符以及后续的表达式组成。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">3</span>;</span><br><span class="line">x = (<span class="keyword">float</span>) (y / z);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>x</code> 和 <code>y</code> 均为整数类型，随后执行除法操作，最后将其结果转换为 <code>float</code> 类型，其结果为 <code>2</code>。我们显示地将除法的结果转换为 <code>float</code> 其实并没有任何作用，因为 <code>y/z</code> 的结果已经为 <code>2</code>。</p>
<p>要解决此问题，您需要在除法运算发生之前将其中一个操作数转换为浮点类型。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">3</span>;</span><br><span class="line">x = (y / (<span class="keyword">float</span>) z);</span><br></pre></td></tr></table></figure>

<p>类型转换仅适用于标量类型（例如，整型、浮点类型以及指针类型）。因此，下面的转换将失败：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fooTag</span> &#123;</span> <span class="comment">/* members ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fooTag</span> <span class="title">foo</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> byteArray[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">foo = (struct fooType) byteArray; <span class="comment">/* 失败 */</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>当表达式包含多个运算符（例如 <code>a + b * f()</code>）时，将根据优先级规则对运算符进行分组。例如，该表达式的含义是调用不带参数的函数 <code>f</code>，将结果乘以 <code>b</code>，然后将结果添加到 <code>a</code>。这就是运算符优先级的 <code>C</code> 规则为此表达式确定的内容。</p>
<p>以下是表达式类型的列表，首先按最高优先级顺序显示。有时两个或多个运营商具有相同的优先权;除非另有说明，否则所有这些操作员都是从左到右应用的。</p>
<ol>
<li>函数调用、数组下标、成员访问运算符表达式。</li>
<li>一元运算符，包括逻辑非、按位取反、自增、自减、正负号、间接运算符、取地址运算符、类型转换、<code>sizeof</code> 表达式。当连续包含多个一元运算符时，后面的运算符嵌套在前面的运算符中：例如 <code>!-x</code> 表示 <code>!(-x)</code>。</li>
<li>乘法、除法以及取模表达式。</li>
<li>加法与减法表达式。</li>
<li>移位表达式。</li>
<li>大于、小于、大于等于、小于等于表达式。</li>
<li>等于、不等于表达式。</li>
<li>按位与表达式。</li>
<li>按位异或表达式。</li>
<li>按位或表达式。</li>
<li>逻辑与表达式。</li>
<li>逻辑或表达式。</li>
<li>条件表达式（使用<code>? :</code>）。当用作子表达式时，它们从右到左依次执行。</li>
<li>所有赋值表达式，包括复合赋值。当多个赋值语句在单个较大表达式中显示为子表达式时，它们将从右到左进行求值。</li>
<li>逗号运算符表达式。</li>
</ol>
<p>上面的列表看起来比较枯燥，但它其实非常简单之间，不过它也隐藏这一些陷阱。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo = *p++;</span><br></pre></td></tr></table></figure>

<p>这里 <code>p</code> 作为表达式的副作用递增，但是 <code>foo</code> 的取值为 <code>*(p++)</code> 而不是 <code>(*p)++</code>，因为一元运算符从右到左绑定。还有其他潜在的意外隐藏在 <code>C</code> 优先级表背后的例子。因此，如果读者误解了程序的含义，那么您应该使用括号来明确您的意思。</p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>在 C 语言中，您不能假设多个子表达式按照看似自然的顺序进行求值。例如，考虑表达式 <code>++a * f()</code> ，请问 <code>a</code> 的自增发生在函数 <code>f</code> 调用之前还是之后呢？编译器可以按任意顺序执行，因此您无法进行假设。</p>
<p>实际的编译器在将源代码转换为实际计算机中的特定动作时，为了提高效率可以重新排序这些操作。您编写的程序与计算机实际执行的操作之间的对应关系是根据副作用和序列点来指定的。</p>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>副作用（_side effects_）包含一下几点：</p>
<ol>
<li>访问 <code>volatile</code> 对象；</li>
<li>修改一个对象；</li>
<li>修改文件；</li>
<li>调用一个执行了上述动作的函数。</li>
</ol>
<p>这些本质上是运行程序的外部可见效果。它们被称为副作用，因为它们是表达式评估的影响，超出了表达式的实际结果值。</p>
<p>编译器允许以与程序源码所暗示不同的顺序执行程序的操作，前提是最终实际发生了所有必要的副作用。 编译器也允许完全省略一些操作; 例如，如果可以确定该值未被使用并且求值表达式的该部分不会产生任何所需的副作用，则允许跳过求值表达式的一部分。</p>
<h3 id="序列点"><a href="#序列点" class="headerlink" title="序列点"></a>序列点</h3><p>编译器的另一个要求是副作用应该以正确的顺序发生。为了在不过度约束编译器的情况下提供此功能，C89 和 C90 标准指定了序列点列表。序列点（_sequence points_）是以下的其中之一：</p>
<ol>
<li>函数的调用（在对函数参数求值完成之后）；</li>
<li>与运算符 <code>&amp;&amp;</code> 的左侧操作数的结尾；</li>
<li>或运算符 <code>||</code> 的左侧操作数的结尾；</li>
<li>逗号运算符 <code>,</code> 的左侧操作数的结尾；</li>
<li>三元运算符的第一个操作数结尾 <code>a ? b : c</code>；</li>
<li>完整的声明结尾；</li>
<li>初始化表达式的结尾；</li>
<li>表达式语句的结尾（即，表达式后的 <code>;</code>）；</li>
<li><code>if</code> 或 <code>switch</code> 控制表达式的结尾；</li>
<li><code>while</code> 或 <code>do</code> 控制表达式的结尾；</li>
<li><code>for</code> 语句的三个控制表达式中的任何一个的结尾；</li>
<li><code>return</code> 语句的表达式结尾；</li>
<li>库函数返回之前；</li>
<li>在与格式化 <code>I/O</code> 项相关联的操作之后（例如，使用 <code>strftime</code> 或 <code>printf</code>和 <code>scanf</code> 函数）；</li>
<li>紧接在调用比较函数之前和之后（例如调用 <code>qsort</code> 函数）。</li>
</ol>
<p>在序列点，先前表达求值的所有副作用必须完整，并且可能没有发生后续求值的副作用。</p>
<p>这可能看起来有点难以理解，但还有另一种方法可以考虑这一点。想象一下，您编写了一个库（其中一些函数是外部的，也许不是其他函数）并编译它，允许其他人从他们的代码中调用您的一个函数。上面的定义确保在它们调用函数时，它们传入的数据具有与抽象机器指定的行为一致的值，并且函数返回的任何数据都具有与抽象一致的状态机。这包括通过指针访问的数据（即不仅仅是函数参数和带有外部链接的标识符）。</p>
<p>以上略微简化，因为存在在链接时执行整个程序优化的编译器。但重要的是，虽然它们可能会执行优化，但程序的可见副作用必须与抽象机器生成的副作用相同。</p>
<h3 id="序列点约束表达式"><a href="#序列点约束表达式" class="headerlink" title="序列点约束表达式"></a>序列点约束表达式</h3><p>下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>非常正常，且毫无疑问会在许多程序中出现。但是接下来的代码就有点难懂了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = ++i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>i</code> 最终的值为多少呢？C 语言标准（C89 和 C99）都禁止在符合规划的程序中使用该结构。</p>
<p>在两个序列点之间，您只允许做以下两件事：</p>
<ol>
<li>通过表达式的求值，对象可以将其存储值最多修改一次；</li>
<li>只读对象的先前值以确定要存储的值。</li>
</ol>
<p>这两个条件中的第一个禁止表达式如 <code>foo(x=2, ++x)</code>；第二个条件禁止像 <code>a[i++] = i</code> 这样的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=0; bar(++x,++x)</span><br></pre></td></tr></table></figure>

<p>不符合规定的程序；在参数求值完成之前两次修改 <code>x</code> 的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>; bar((++x,++x))</span><br></pre></td></tr></table></figure>

<p>允许；函数仅有一个参数（传入的值为 <code>2</code>），逗号运算符有一个序列点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*p++ || *p++</span><br></pre></td></tr></table></figure>

<p>允许；在 <code>||</code> 处有一个序列点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p)), *q = p; *p = foo(); bar((*p)++, (*q)++);</span><br></pre></td></tr></table></figure>

<p>不允许；在对 <code>bar</code> 的参数的求值完成之前，<code>p</code> 对象被修改两次。事实上，这是通过 <code>p</code> 和 <code>q</code> 来完成的，这是无关紧要的，因为它们都指向同一个对象。</p>
<p>让我们回到我们用来介绍评估顺序问题的例子，<code>++a * f()</code>。假设代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是否复合标准呢？尽管 <code>foo</code> 中的表达式两次修改 <code>a</code> 的值，但这不是问题。我们看看两种可能的情况：</p>
<ul>
<li>右操作数 <code>f()</code> 先执行 - 由于 <code>f()</code> 返回一个而不是 <code>void</code>，因此它必须包含一个 <code>return</code> 语句。因此，在 <code>return</code> 的末尾势必会有一个序列点，它介于 <code>f()</code> 修改 <code>a</code> 的值和左操作数修改 <code>a</code> 值之间。</li>
<li>左操作数 <code>++a</code> 先执行 - 首先，<code>a</code> 自增，然后对 <code>f()</code> 的参数（它们中有零）求值。在实际调用 <code>f()</code> 之前势必有一个序列点。</li>
</ul>
<p>因此，我们看到我们的程序复合标准。注意上述的讨论并不依赖于函数 <code>f()</code> 主体的具体细节，它仅取决于函数包含一个序列点，在我们的示例中它是一个 <code>return</code> 语句，但是表达式语句或完整的声明符也是可以的。</p>
<p>但是，上述代码的结果取决于运算符 <code>**</code> 的操作数的求值顺序（MacOS clang-1001.0.46.4 结果为 <code>6</code>，即属于第二种情况）。如果首先计算左操作数，则 <code>foo()</code> 返回 <code>6</code>，否则，返回 <code>303</code>。C 标准没有规定操作数的求值顺序，也不需要实现给出文档说明或者按照某一特定顺序实现。这段代码是不确定的（<em>unspecified</em>)，这就意味着它们可能是几种特定情况的一种，但是 C 标准并没有给出具体应该是那一种。</p>
<h3 id="序列点和信号传递"><a href="#序列点和信号传递" class="headerlink" title="序列点和信号传递"></a>序列点和信号传递</h3><p>当接收到信号时，这将在序列点之间发生。<code>volatile</code> 对象的副作用将先于序列点发生，而其它对象的更新可能不会发生（其实这个地方理解的不太清楚）。这甚至会出现在类似 <code>x = 0;</code> 这样的赋值语句中，因为代码生成器可能在为这条语句生成多个指令，这意味着它可以信号到来时被中途中断。</p>
<p>C 标准对信号处理程序中可能发生的数据访问非常严格。它们当然可以使用自动变量，但在读取或写入其他对象方面，它们必须是 <code>volatile sig_atomic_t</code> 类型。<code>volatile</code> 类型限定符确保对程序其他部分中的变量的访问不会跨越序列点，并且使用 <code>sig_atomic_t</code> 类型可确保变量的变化对于信号传递是原子的。</p>
<p>POSIX 标准还允许在信号处理程序调用少量库函数。这些功能称为异步信号安全(<em>async-signal-safe</em>)函数集。如果您的程序要在 POSIX 系统上运行而不在其他系统上运行，您也可以安全地在信号处理程序中调用它们。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Expressions-and-Operators">https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Expressions-and-Operators</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 迁移 PostgreSQL - 自定义聚合函数</title>
    <url>/2021/09/migrate-oracle-user-defined-aggregate-functions-to-postgresql/</url>
    <content><![CDATA[<p>数据库通常都提供了一系列预定义的聚合函数（Aggregate Functions），例如 MAX，MIN，SUM 等，它们对一组数据进行操作。这些预定义的聚合函数通常只能处理标量类型，不能处理诸如对象类型等复杂的数据类型，当前大部分数据库都提供了为复杂数据类型自定义聚合函数（User-Defined Aggregate Functions）的功能。本文简要介绍 Oracle 中的自定义聚合函数以及如何迁移到 PostgreSQL 数据库中。</p>
<span id="more"></span>

<h2 id="Oracle-自定义聚合函数"><a href="#Oracle-自定义聚合函数" class="headerlink" title="Oracle 自定义聚合函数"></a>Oracle 自定义聚合函数</h2><p>在 Oracle 数据库中要实现自定义聚合函数，我们需要实现下面的 <code>ODCIAggregate</code> 接口。</p>
<ul>
<li><code>ODCIAggregateInitialize</code> - 初始化用户自定义聚合函数的状态，并返回该状态。</li>
<li><code>ODCIAggregateIterate</code> - 反复调用该函数来更新聚合函数状态。在每次调用时，一个新的值和聚合状态被传递进来。该函数处理新值并返回更新后的聚合状态。该函数对于数据库组中的每一个非 NULL 值都会被调用。NULL 值在聚合过程中被忽略，并且不被传递给该函数。</li>
<li><code>ODCIAggregateMerge</code> - 这是一个可选的函数，它用于并行执行聚合函数，当并行执行的聚合函数完成之后，我们需要通过该函数将两个聚合状态进行合并，并返回一个新的聚合状态。</li>
<li><code>ODCIAggregateTerminate</code> - 聚合函数的最后一步，该例函数将聚合状态作为输入，并返回聚合值。</li>
</ul>
<p>例如，我们要执行下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(t.sales) <span class="keyword">FROM</span> AnnualSales t <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.state;</span><br></pre></td></tr></table></figure>

<p>聚合函数 <code>AVG()</code> 的执行过程如下所示：</p>
<ol>
<li><strong>初始化</strong>。该聚合函数可能包含两个状态：<code>runningSum</code> 和 <code>runningCount</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runningSum = 0;</span><br><span class="line">runningCount = 0;</span><br></pre></td></tr></table></figure></li>
<li><strong>循环迭代</strong>。对每个连续的输入值进行处理，并更新状态：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runningSum += val;</span><br><span class="line">runningCount++;</span><br></pre></td></tr></table></figure></li>
<li><strong>终止</strong>。计算结果。更加聚合状态返回聚合值： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (runningCount &gt; 0) &#123;</span><br><span class="line">    return runningSum / runningCount;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在上面的情况我们并有<strong>合并</strong>的过程。如果有合并的需求，其形式如下：</p>
<ul>
<li><strong>合并</strong>。合并两个聚合状态并返回新的聚合状态。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runningSum = runningSum1 + runningSum2;</span><br><span class="line">runningCount = runningCount1 + runningCount2;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建聚合函数"><a href="#创建聚合函数" class="headerlink" title="创建聚合函数"></a>创建聚合函数</h3><p>Oracle 中的聚合函数创建分为两步：实现聚合函数接口和创建用户自定义聚合函数。</p>
<h4 id="实现聚合函数接口"><a href="#实现聚合函数接口" class="headerlink" title="实现聚合函数接口"></a>实现聚合函数接口</h4><p>正如上面所说，我们需要实现上述 4 个接口。Oracle 将其分为两部分 <code>TYPE</code> 和 <code>TYPE BODY</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TYPE SpatialUnionRoutines(</span><br><span class="line">    STATIC FUNCTION ODCIAggregateInitialize( ... ) ...,</span><br><span class="line">    MEMBER FUNCTION ODCIAggregateIterate(...) ... ,</span><br><span class="line">    MEMBER FUNCTION ODCIAggregateMerge(...) ...,</span><br><span class="line">    MEMBER FUNCTION ODCIAggregateTerminate(...)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TYPE BODY SpatialUnionRoutines IS</span><br><span class="line">    ...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h4 id="创建聚合函数-1"><a href="#创建聚合函数-1" class="headerlink" title="创建聚合函数"></a>创建聚合函数</h4><p>此步骤通过指定其签名和实现 <code>ODCIAggregate</code> 接口的对象类型来创建 <code>SpatialUnion()</code> 聚合函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION SpatialUnion(x Geometry) RETURN Geometry</span><br><span class="line">AGGREGATE USING SpatialUnionRoutines;</span><br></pre></td></tr></table></figure>

<p>如果我们想要聚合函数执行并行，那么我们需要加上 <code>PARALLEL_ENABLE</code> 选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION SpatialUnion(x Geometry) RETURN Geometry</span><br><span class="line">PARALLEL_ENABLE AGGREGATE USING SpatialUnionRoutines;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这个例子说明了如何创建一个简单的用户定义的聚合函数 <code>SecondMax()</code>，以返回一组数字中的第二大值。</p>
<p>首先，我们需要给出 <code>SecondMaxImpl</code> 类型的声明，它包含 <code>ODCIAggregate</code> 接口声明以及可能会用到的状态信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE SecondMaxImpl <span class="keyword">AS</span> OBJECT</span><br><span class="line">(</span><br><span class="line">    max    number, <span class="comment">-- highest value seen so far</span></span><br><span class="line">    secmax number, <span class="comment">-- second highest value seen so far</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">STATIC</span> <span class="keyword">FUNCTION</span> ODCIAggregateInitialize(sctx <span class="keyword">IN</span> <span class="keyword">OUT</span> SecondMaxImpl)</span><br><span class="line">        <span class="keyword">RETURN</span> number,</span><br><span class="line">    <span class="keyword">MEMBER</span> <span class="keyword">FUNCTION</span> ODCIAggregateIterate(self <span class="keyword">IN</span> <span class="keyword">OUT</span> SecondMaxImpl, <span class="keyword">value</span> <span class="keyword">IN</span> number)</span><br><span class="line">	    <span class="keyword">RETURN</span> number,</span><br><span class="line">    <span class="keyword">MEMBER</span> <span class="keyword">FUNCTION</span> ODCIAggregateMerge(self <span class="keyword">IN</span> <span class="keyword">OUT</span> SecondMaxImpl, ctx2 <span class="keyword">IN</span> SecondMaxImpl)</span><br><span class="line">	    <span class="keyword">RETURN</span> number,</span><br><span class="line">    <span class="keyword">MEMBER</span> <span class="keyword">FUNCTION</span> ODCIAggregateTerminate(self <span class="keyword">IN</span> SecondMaxImpl, returnValue <span class="keyword">OUT</span> number, flags <span class="keyword">IN</span> number)</span><br><span class="line">	    <span class="keyword">RETURN</span> number</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>接着，我们需要给出 <code>SecondMaxImpl</code> 类型的实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE BODY SecondMaxImpl <span class="keyword">IS</span></span><br><span class="line">    <span class="keyword">STATIC</span> <span class="keyword">FUNCTION</span> ODCIAggregateInitialize(sctx <span class="keyword">IN</span> <span class="keyword">OUT</span> SecondMaxImpl)</span><br><span class="line">    <span class="keyword">RETURN</span> number <span class="keyword">IS</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">      sctx :<span class="operator">=</span> SecondMaxImpl(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> ODCIConst.Success;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">MEMBER</span> <span class="keyword">FUNCTION</span> ODCIAggregateIterate(self <span class="keyword">IN</span> <span class="keyword">OUT</span> SecondMaxImpl, <span class="keyword">value</span> <span class="keyword">IN</span> number)</span><br><span class="line">    <span class="keyword">RETURN</span> number <span class="keyword">IS</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        IF <span class="keyword">value</span> <span class="operator">&gt;</span> self.max <span class="keyword">THEN</span></span><br><span class="line">            self.secmax :<span class="operator">=</span> self.max;</span><br><span class="line">            self.max :<span class="operator">=</span> <span class="keyword">value</span>;</span><br><span class="line">        ELSIF <span class="keyword">value</span> <span class="operator">&gt;</span> self.secmax <span class="keyword">THEN</span></span><br><span class="line">            self.secmax :<span class="operator">=</span> <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">        <span class="keyword">return</span> ODCIConst.Success;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">MEMBER</span> <span class="keyword">FUNCTION</span> ODCIAggregateMerge(self <span class="keyword">IN</span> <span class="keyword">OUT</span> SecondMaxImpl, ctx2 <span class="keyword">IN</span> SecondMaxImpl)</span><br><span class="line">	<span class="keyword">RETURN</span> number <span class="keyword">IS</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        IF ctx2.max <span class="operator">&gt;</span> self.max <span class="keyword">THEN</span></span><br><span class="line">            IF ctx2.secmax <span class="operator">&gt;</span> self.secmax <span class="keyword">THEN</span></span><br><span class="line">                self.secmax :<span class="operator">=</span> ctx2.secmax;</span><br><span class="line">            <span class="keyword">ELSE</span></span><br><span class="line">			    self.secmax :<span class="operator">=</span> self.max;</span><br><span class="line">            <span class="keyword">END</span> IF;</span><br><span class="line">            self.max :<span class="operator">=</span> ctx2.max;</span><br><span class="line">        ELSIF ctx2.max <span class="operator">&gt;</span> self.secmax <span class="keyword">THEN</span></span><br><span class="line">            self.secmax :<span class="operator">=</span> ctx2.max;</span><br><span class="line">      <span class="keyword">END</span> IF;</span><br><span class="line">      <span class="keyword">return</span> ODCIConst.Success;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">member</span> <span class="keyword">function</span> ODCIAggregateTerminate(self <span class="keyword">IN</span> SecondMaxImpl, returnValue <span class="keyword">OUT</span> number, flags <span class="keyword">IN</span> number)</span><br><span class="line">	<span class="keyword">RETURN</span> number <span class="keyword">IS</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        returnValue :<span class="operator">=</span> self.secmax;</span><br><span class="line">        <span class="keyword">return</span> ODCIConst.Success;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>最后，创建用户自定义聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> SecondMax(input number) <span class="keyword">RETURN</span> number</span><br><span class="line">PARALLEL_ENABLE AGGREGATE <span class="keyword">USING</span> SecondMaxImpl;</span><br></pre></td></tr></table></figure>
<p>接着我们就可以使用 <code>SecondMax()</code> 聚合函数了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SecondMax(salary), department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> SecondMax(salary) <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line">SECONDMAX(SALARY) DEPARTMENT_ID</span><br><span class="line"><span class="comment">----------------- -------------</span></span><br><span class="line">            <span class="number">13500</span>            <span class="number">80</span></span><br><span class="line">            <span class="number">17000</span>            <span class="number">90</span></span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL-自定义聚合函数"><a href="#PostgreSQL-自定义聚合函数" class="headerlink" title="PostgreSQL 自定义聚合函数"></a>PostgreSQL 自定义聚合函数</h2><p>在 PostgreSQL 中，我们可以通过 <a href="https://www.postgresql.org/docs/13/sql-createaggregate.html"><code>CREATE AGGREGATE</code></a> 命令来创建自定义聚合函数，PostgreSQL 中对于聚合函数的自定义提供了多个接口，例如 <code>sfunc</code>，<code>finalfunc</code>, <code>combinefunc</code> 等。PostgreSQL 中的聚合函数必须要提供两个值：<code>sfunc</code> 和 <code>stype</code>。</p>
<ul>
<li><strong><code>sfunc</code></strong> - 这是一个函数接口，它将根据当前的状态值以及新到来的数据得到下一步的装置，类似与 Oracle 中的 <code>ODCIAggregateIterate()</code> 函数。</li>
<li><strong><code>stype</code></strong> - 聚合函数状态值的类型，类似于与 Oracle 中 <code>type</code> 的非函数部分。</li>
</ul>
<p>此外，我们还可能会用到以下参数：</p>
<ul>
<li><strong><code>initcond</code></strong> - 用于给出聚合函数状态的初始值，作用相当于 Oracle 中的 <code>ODCIAggregateInitialize()</code> 函数。</li>
<li><strong><code>combinefunc</code></strong> - 合并两个聚合状态，相当于 Oracle 中的 <code>ODCIAggregateMerge()</code> 函数。</li>
<li><strong><code>finalfunc</code></strong> - 根据聚合状态计算聚合值，相当于 Oracle 中的 <code>ODCIAggregateTerminate()</code> 函数。</li>
</ul>
<h3 id="迁移-SecondMax"><a href="#迁移-SecondMax" class="headerlink" title="迁移 SecondMax"></a>迁移 SecondMax</h3><p>对 PostgreSQL 的自定义聚合函数有了基本的了解，我们来看看如何将上面的 Oracle <code>SecondMax</code> 迁移到 PostgreSQL 中。</p>
<p>首先，我们需要两个状态值，<code>max</code> 和 <code>secmax</code>。我可以通过新建一个类型来实现这个目的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE second_max_state <span class="keyword">AS</span> (max <span class="type">numeric</span>, secmax <span class="type">numeric</span>);</span><br></pre></td></tr></table></figure>

<p>理论上，这里我们可以不必新建一个类型，而是直接使用 <code>numeric</code> 的数组也是可以的。为了使其更具一般性，这里采用了新类型的方式。</p>
<p>接着我们需要创建 3 个函数，<code>sfunc</code>，<code>combinefunc</code> 和 <code>finalfunc</code>。我们先看 <code>sfunc</code> 函数。</p>
<p><code>sfunc</code> 接收当前状态和当前数据值作为参数，并计算新的状态值。其实现如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> second_max_transition(state second_max_state, <span class="keyword">value</span> <span class="type">numeric</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> second_max_state</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF <span class="keyword">value</span> <span class="operator">&gt;</span> state.max <span class="keyword">THEN</span></span><br><span class="line">	    state.secmax :<span class="operator">=</span> state.max;</span><br><span class="line">		state.max :<span class="operator">=</span> <span class="keyword">value</span>;</span><br><span class="line">	ELSIF <span class="keyword">value</span> <span class="operator">&gt;</span> state.secmax <span class="keyword">THEN</span></span><br><span class="line">	    state.secmax :<span class="operator">=</span> <span class="keyword">value</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line">	<span class="keyword">RETURN</span> state;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>接着是 <code>combinefunc</code> 函数，它合并两个状态并产生新的状态。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> second_max_combine(state1 second_max_state, state2 second_max_state)</span><br><span class="line"><span class="keyword">RETURNS</span> second_max_state</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF state2.max <span class="operator">&gt;</span> state1.max <span class="keyword">THEN</span></span><br><span class="line">	    IF state2.secmax <span class="operator">&gt;</span> state1.secmax <span class="keyword">THEN</span></span><br><span class="line">		    state1.secmax :<span class="operator">=</span> state2.secmax;</span><br><span class="line">		<span class="keyword">ELSE</span></span><br><span class="line">		    state1.secmax :<span class="operator">=</span> state1.max;</span><br><span class="line">		<span class="keyword">END</span> IF;</span><br><span class="line">		state1.max :<span class="operator">=</span> state2.max;</span><br><span class="line">	ELSIF state2.max <span class="operator">&gt;</span> state1.secmax <span class="keyword">THEN</span></span><br><span class="line">	    state1.secmax :<span class="operator">=</span> state2.max;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line">	<span class="keyword">RETURN</span> state1;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>接下来是 <code>finalfunc</code> 函数，它接收一个状态作为参数并返回最后的聚合值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> second_max_final(state second_max_state)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">numeric</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> state.secmax;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>最后，我们通过 <code>CREATE AGGREGATE</code> 命令创建自定义聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> AGGREGATE second_max(<span class="keyword">value</span> <span class="type">numeric</span>) (</span><br><span class="line">    stype <span class="operator">=</span> second_max_state,</span><br><span class="line">    sfunc <span class="operator">=</span> second_max_transition,</span><br><span class="line">    combinefunc <span class="operator">=</span> second_max_combine,</span><br><span class="line">    finalfunc <span class="operator">=</span> second_max_final,</span><br><span class="line">    initcond <span class="operator">=</span> <span class="string">&#x27;(0, 0)&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>完成上面的步骤之后，执行下面的查询，可以得到和 Oracle 相同的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> second_max(salary), department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">ROUP <span class="keyword">BY</span> department_id</span><br><span class="line">AVING second_max(salary) <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br><span class="line"> second_max <span class="operator">|</span> department_id</span><br><span class="line"><span class="comment">------------+---------------</span></span><br><span class="line">   <span class="number">13500.00</span> <span class="operator">|</span>            <span class="number">80</span></span><br><span class="line">   <span class="number">17000.00</span> <span class="operator">|</span>            <span class="number">90</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>该测试数据来自 Oracle 数据库中的 <code>HR.EMPLOYEES</code> 表。</p>
<p>PostgreSQL 数据库中表结构如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id <span class="type">numeric</span>(<span class="number">6</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    last_name <span class="type">varchar</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    hire_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    job_id <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    commission_pct <span class="type">numeric</span>(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">    manager_id <span class="type">numeric</span>(<span class="number">6</span>,<span class="number">0</span>),</span><br><span class="line">    department_id <span class="type">numeric</span>(<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Oracle 数据库中表结构如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id number(<span class="number">6</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name varchar2(<span class="number">20</span> byte),</span><br><span class="line">    last_name varchar2(<span class="number">25</span> byte) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email varchar2(<span class="number">25</span> byte) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number varchar2(<span class="number">20</span> byte),</span><br><span class="line">    hire_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    job_id varchar2(<span class="number">10</span> byte) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    salary number(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    commission_pct number(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">    manager_id number(<span class="number">6</span>,<span class="number">0</span>),</span><br><span class="line">    department_id number(<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>数据如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>, <span class="string">&#x27;King&#x27;</span>, <span class="string">&#x27;SKING&#x27;</span>, <span class="string">&#x27;515.123.4567&#x27;</span>, TO_DATE(<span class="string">&#x27;1987-06-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;AD_PRES&#x27;</span>, <span class="string">&#x27;24000&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;90&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;Neena&#x27;</span>, <span class="string">&#x27;Kochhar&#x27;</span>, <span class="string">&#x27;NKOCHHAR&#x27;</span>, <span class="string">&#x27;515.123.4568&#x27;</span>, TO_DATE(<span class="string">&#x27;1989-09-21 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;AD_VP&#x27;</span>, <span class="string">&#x27;17000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;90&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;102&#x27;</span>, <span class="string">&#x27;Lex&#x27;</span>, <span class="string">&#x27;De Haan&#x27;</span>, <span class="string">&#x27;LDEHAAN&#x27;</span>, <span class="string">&#x27;515.123.4569&#x27;</span>, TO_DATE(<span class="string">&#x27;1993-01-13 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;AD_VP&#x27;</span>, <span class="string">&#x27;17000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;90&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;Alexander&#x27;</span>, <span class="string">&#x27;Hunold&#x27;</span>, <span class="string">&#x27;AHUNOLD&#x27;</span>, <span class="string">&#x27;590.423.4567&#x27;</span>, TO_DATE(<span class="string">&#x27;1990-01-03 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;9000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;102&#x27;</span>, <span class="string">&#x27;60&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;104&#x27;</span>, <span class="string">&#x27;Bruce&#x27;</span>, <span class="string">&#x27;Ernst&#x27;</span>, <span class="string">&#x27;BERNST&#x27;</span>, <span class="string">&#x27;590.423.4568&#x27;</span>, TO_DATE(<span class="string">&#x27;1991-05-21 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;6000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;60&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;105&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Austin&#x27;</span>, <span class="string">&#x27;DAUSTIN&#x27;</span>, <span class="string">&#x27;590.423.4569&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-06-25 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;4800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;60&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;106&#x27;</span>, <span class="string">&#x27;Valli&#x27;</span>, <span class="string">&#x27;Pataballa&#x27;</span>, <span class="string">&#x27;VPATABAL&#x27;</span>, <span class="string">&#x27;590.423.4560&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-02-05 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;4800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;60&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;107&#x27;</span>, <span class="string">&#x27;Diana&#x27;</span>, <span class="string">&#x27;Lorentz&#x27;</span>, <span class="string">&#x27;DLORENTZ&#x27;</span>, <span class="string">&#x27;590.423.5567&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-02-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;4200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;103&#x27;</span>, <span class="string">&#x27;60&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;Nancy&#x27;</span>, <span class="string">&#x27;Greenberg&#x27;</span>, <span class="string">&#x27;NGREENBE&#x27;</span>, <span class="string">&#x27;515.124.4569&#x27;</span>, TO_DATE(<span class="string">&#x27;1994-08-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;FI_MGR&#x27;</span>, <span class="string">&#x27;12000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;109&#x27;</span>, <span class="string">&#x27;Daniel&#x27;</span>, <span class="string">&#x27;Faviet&#x27;</span>, <span class="string">&#x27;DFAVIET&#x27;</span>, <span class="string">&#x27;515.124.4169&#x27;</span>, TO_DATE(<span class="string">&#x27;1994-08-16 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;FI_ACCOUNT&#x27;</span>, <span class="string">&#x27;9000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Chen&#x27;</span>, <span class="string">&#x27;JCHEN&#x27;</span>, <span class="string">&#x27;515.124.4269&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-09-28 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;FI_ACCOUNT&#x27;</span>, <span class="string">&#x27;8200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;Ismael&#x27;</span>, <span class="string">&#x27;Sciarra&#x27;</span>, <span class="string">&#x27;ISCIARRA&#x27;</span>, <span class="string">&#x27;515.124.4369&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-09-30 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;FI_ACCOUNT&#x27;</span>, <span class="string">&#x27;7700&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;112&#x27;</span>, <span class="string">&#x27;Jose Manuel&#x27;</span>, <span class="string">&#x27;Urman&#x27;</span>, <span class="string">&#x27;JMURMAN&#x27;</span>, <span class="string">&#x27;515.124.4469&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-03-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;FI_ACCOUNT&#x27;</span>, <span class="string">&#x27;7800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;113&#x27;</span>, <span class="string">&#x27;Luis&#x27;</span>, <span class="string">&#x27;Popp&#x27;</span>, <span class="string">&#x27;LPOPP&#x27;</span>, <span class="string">&#x27;515.124.4567&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-12-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;FI_ACCOUNT&#x27;</span>, <span class="string">&#x27;6900&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;Den&#x27;</span>, <span class="string">&#x27;Raphaely&#x27;</span>, <span class="string">&#x27;DRAPHEAL&#x27;</span>, <span class="string">&#x27;515.127.4561&#x27;</span>, TO_DATE(<span class="string">&#x27;1994-12-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PU_MAN&#x27;</span>, <span class="string">&#x27;11000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;115&#x27;</span>, <span class="string">&#x27;Alexander&#x27;</span>, <span class="string">&#x27;Khoo&#x27;</span>, <span class="string">&#x27;AKHOO&#x27;</span>, <span class="string">&#x27;515.127.4562&#x27;</span>, TO_DATE(<span class="string">&#x27;1995-05-18 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PU_CLERK&#x27;</span>, <span class="string">&#x27;3100&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;116&#x27;</span>, <span class="string">&#x27;Shelli&#x27;</span>, <span class="string">&#x27;Baida&#x27;</span>, <span class="string">&#x27;SBAIDA&#x27;</span>, <span class="string">&#x27;515.127.4563&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-12-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PU_CLERK&#x27;</span>, <span class="string">&#x27;2900&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;117&#x27;</span>, <span class="string">&#x27;Sigal&#x27;</span>, <span class="string">&#x27;Tobias&#x27;</span>, <span class="string">&#x27;STOBIAS&#x27;</span>, <span class="string">&#x27;515.127.4564&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-07-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PU_CLERK&#x27;</span>, <span class="string">&#x27;2800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;118&#x27;</span>, <span class="string">&#x27;Guy&#x27;</span>, <span class="string">&#x27;Himuro&#x27;</span>, <span class="string">&#x27;GHIMURO&#x27;</span>, <span class="string">&#x27;515.127.4565&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-11-15 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PU_CLERK&#x27;</span>, <span class="string">&#x27;2600&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;119&#x27;</span>, <span class="string">&#x27;Karen&#x27;</span>, <span class="string">&#x27;Colmenares&#x27;</span>, <span class="string">&#x27;KCOLMENA&#x27;</span>, <span class="string">&#x27;515.127.4566&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-08-10 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PU_CLERK&#x27;</span>, <span class="string">&#x27;2500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;114&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;Matthew&#x27;</span>, <span class="string">&#x27;Weiss&#x27;</span>, <span class="string">&#x27;MWEISS&#x27;</span>, <span class="string">&#x27;650.123.1234&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-07-18 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_MAN&#x27;</span>, <span class="string">&#x27;8000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Fripp&#x27;</span>, <span class="string">&#x27;AFRIPP&#x27;</span>, <span class="string">&#x27;650.123.2234&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-04-10 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_MAN&#x27;</span>, <span class="string">&#x27;8200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;Payam&#x27;</span>, <span class="string">&#x27;Kaufling&#x27;</span>, <span class="string">&#x27;PKAUFLIN&#x27;</span>, <span class="string">&#x27;650.123.3234&#x27;</span>, TO_DATE(<span class="string">&#x27;1995-05-01 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_MAN&#x27;</span>, <span class="string">&#x27;7900&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;Shanta&#x27;</span>, <span class="string">&#x27;Vollman&#x27;</span>, <span class="string">&#x27;SVOLLMAN&#x27;</span>, <span class="string">&#x27;650.123.4234&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-10-10 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_MAN&#x27;</span>, <span class="string">&#x27;6500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;Mourgos&#x27;</span>, <span class="string">&#x27;KMOURGOS&#x27;</span>, <span class="string">&#x27;650.123.5234&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-11-16 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_MAN&#x27;</span>, <span class="string">&#x27;5800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;125&#x27;</span>, <span class="string">&#x27;Julia&#x27;</span>, <span class="string">&#x27;Nayer&#x27;</span>, <span class="string">&#x27;JNAYER&#x27;</span>, <span class="string">&#x27;650.124.1214&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-07-16 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;126&#x27;</span>, <span class="string">&#x27;Irene&#x27;</span>, <span class="string">&#x27;Mikkilineni&#x27;</span>, <span class="string">&#x27;IMIKKILI&#x27;</span>, <span class="string">&#x27;650.124.1224&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-09-28 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2700&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;127&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Landry&#x27;</span>, <span class="string">&#x27;JLANDRY&#x27;</span>, <span class="string">&#x27;650.124.1334&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-01-14 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2400&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;128&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>, <span class="string">&#x27;Markle&#x27;</span>, <span class="string">&#x27;SMARKLE&#x27;</span>, <span class="string">&#x27;650.124.1434&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-03-08 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;129&#x27;</span>, <span class="string">&#x27;Laura&#x27;</span>, <span class="string">&#x27;Bissot&#x27;</span>, <span class="string">&#x27;LBISSOT&#x27;</span>, <span class="string">&#x27;650.124.5234&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-08-20 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3300&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;130&#x27;</span>, <span class="string">&#x27;Mozhe&#x27;</span>, <span class="string">&#x27;Atkinson&#x27;</span>, <span class="string">&#x27;MATKINSO&#x27;</span>, <span class="string">&#x27;650.124.6234&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-10-30 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;131&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Marlow&#x27;</span>, <span class="string">&#x27;JAMRLOW&#x27;</span>, <span class="string">&#x27;650.124.7234&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-02-16 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;132&#x27;</span>, <span class="string">&#x27;TJ&#x27;</span>, <span class="string">&#x27;Olson&#x27;</span>, <span class="string">&#x27;TJOLSON&#x27;</span>, <span class="string">&#x27;650.124.8234&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-04-10 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2100&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;133&#x27;</span>, <span class="string">&#x27;Jason&#x27;</span>, <span class="string">&#x27;Mallin&#x27;</span>, <span class="string">&#x27;JMALLIN&#x27;</span>, <span class="string">&#x27;650.127.1934&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-06-14 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3300&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;134&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Rogers&#x27;</span>, <span class="string">&#x27;MROGERS&#x27;</span>, <span class="string">&#x27;650.127.1834&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-08-26 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2900&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;135&#x27;</span>, <span class="string">&#x27;Ki&#x27;</span>, <span class="string">&#x27;Gee&#x27;</span>, <span class="string">&#x27;KGEE&#x27;</span>, <span class="string">&#x27;650.127.1734&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-12-12 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2400&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;136&#x27;</span>, <span class="string">&#x27;Hazel&#x27;</span>, <span class="string">&#x27;Philtanker&#x27;</span>, <span class="string">&#x27;HPHILTAN&#x27;</span>, <span class="string">&#x27;650.127.1634&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-02-06 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;137&#x27;</span>, <span class="string">&#x27;Renske&#x27;</span>, <span class="string">&#x27;Ladwig&#x27;</span>, <span class="string">&#x27;RLADWIG&#x27;</span>, <span class="string">&#x27;650.121.1234&#x27;</span>, TO_DATE(<span class="string">&#x27;1995-07-14 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3600&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;138&#x27;</span>, <span class="string">&#x27;Stephen&#x27;</span>, <span class="string">&#x27;Stiles&#x27;</span>, <span class="string">&#x27;SSTILES&#x27;</span>, <span class="string">&#x27;650.121.2034&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-10-26 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;139&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Seo&#x27;</span>, <span class="string">&#x27;JSEO&#x27;</span>, <span class="string">&#x27;650.121.2019&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-02-12 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2700&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;140&#x27;</span>, <span class="string">&#x27;Joshua&#x27;</span>, <span class="string">&#x27;Patel&#x27;</span>, <span class="string">&#x27;JPATEL&#x27;</span>, <span class="string">&#x27;650.121.1834&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-04-06 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;141&#x27;</span>, <span class="string">&#x27;Trenna&#x27;</span>, <span class="string">&#x27;Rajs&#x27;</span>, <span class="string">&#x27;TRAJS&#x27;</span>, <span class="string">&#x27;650.121.8009&#x27;</span>, TO_DATE(<span class="string">&#x27;1995-10-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;142&#x27;</span>, <span class="string">&#x27;Curtis&#x27;</span>, <span class="string">&#x27;Davies&#x27;</span>, <span class="string">&#x27;CDAVIES&#x27;</span>, <span class="string">&#x27;650.121.2994&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-01-29 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;3100&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;143&#x27;</span>, <span class="string">&#x27;Randall&#x27;</span>, <span class="string">&#x27;Matos&#x27;</span>, <span class="string">&#x27;RMATOS&#x27;</span>, <span class="string">&#x27;650.121.2874&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-03-15 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2600&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;144&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Vargas&#x27;</span>, <span class="string">&#x27;PVARGAS&#x27;</span>, <span class="string">&#x27;650.121.2004&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-07-09 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;2500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Russell&#x27;</span>, <span class="string">&#x27;JRUSSEL&#x27;</span>, <span class="string">&#x27;011.44.1344.429268&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-10-01 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_MAN&#x27;</span>, <span class="string">&#x27;14000&#x27;</span>, <span class="string">&#x27;0.4&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;Karen&#x27;</span>, <span class="string">&#x27;Partners&#x27;</span>, <span class="string">&#x27;KPARTNER&#x27;</span>, <span class="string">&#x27;011.44.1344.467268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-01-05 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_MAN&#x27;</span>, <span class="string">&#x27;13500&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;Alberto&#x27;</span>, <span class="string">&#x27;Errazuriz&#x27;</span>, <span class="string">&#x27;AERRAZUR&#x27;</span>, <span class="string">&#x27;011.44.1344.429278&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-03-10 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_MAN&#x27;</span>, <span class="string">&#x27;12000&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;Gerald&#x27;</span>, <span class="string">&#x27;Cambrault&#x27;</span>, <span class="string">&#x27;GCAMBRAU&#x27;</span>, <span class="string">&#x27;011.44.1344.619268&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-10-15 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_MAN&#x27;</span>, <span class="string">&#x27;11000&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;149&#x27;</span>, <span class="string">&#x27;Eleni&#x27;</span>, <span class="string">&#x27;Zlotkey&#x27;</span>, <span class="string">&#x27;EZLOTKEY&#x27;</span>, <span class="string">&#x27;011.44.1344.429018&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-01-29 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_MAN&#x27;</span>, <span class="string">&#x27;10500&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;150&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Tucker&#x27;</span>, <span class="string">&#x27;PTUCKER&#x27;</span>, <span class="string">&#x27;011.44.1344.129268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-01-30 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;151&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Bernstein&#x27;</span>, <span class="string">&#x27;DBERNSTE&#x27;</span>, <span class="string">&#x27;011.44.1344.345268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-03-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;9500&#x27;</span>, <span class="string">&#x27;0.25&#x27;</span>, <span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;152&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Hall&#x27;</span>, <span class="string">&#x27;PHALL&#x27;</span>, <span class="string">&#x27;011.44.1344.478968&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-08-20 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;9000&#x27;</span>, <span class="string">&#x27;0.25&#x27;</span>, <span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;153&#x27;</span>, <span class="string">&#x27;Christopher&#x27;</span>, <span class="string">&#x27;Olsen&#x27;</span>, <span class="string">&#x27;COLSEN&#x27;</span>, <span class="string">&#x27;011.44.1344.498718&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-03-30 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;8000&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;154&#x27;</span>, <span class="string">&#x27;Nanette&#x27;</span>, <span class="string">&#x27;Cambrault&#x27;</span>, <span class="string">&#x27;NCAMBRAU&#x27;</span>, <span class="string">&#x27;011.44.1344.987668&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-12-09 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7500&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;155&#x27;</span>, <span class="string">&#x27;Oliver&#x27;</span>, <span class="string">&#x27;Tuvault&#x27;</span>, <span class="string">&#x27;OTUVAULT&#x27;</span>, <span class="string">&#x27;011.44.1344.486508&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-11-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7000&#x27;</span>, <span class="string">&#x27;0.15&#x27;</span>, <span class="string">&#x27;145&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;156&#x27;</span>, <span class="string">&#x27;Janette&#x27;</span>, <span class="string">&#x27;King&#x27;</span>, <span class="string">&#x27;JKING&#x27;</span>, <span class="string">&#x27;011.44.1345.429268&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-01-30 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27;0.35&#x27;</span>, <span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;157&#x27;</span>, <span class="string">&#x27;Patrick&#x27;</span>, <span class="string">&#x27;Sully&#x27;</span>, <span class="string">&#x27;PSULLY&#x27;</span>, <span class="string">&#x27;011.44.1345.929268&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-03-04 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;9500&#x27;</span>, <span class="string">&#x27;0.35&#x27;</span>, <span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;158&#x27;</span>, <span class="string">&#x27;Allan&#x27;</span>, <span class="string">&#x27;McEwen&#x27;</span>, <span class="string">&#x27;AMCEWEN&#x27;</span>, <span class="string">&#x27;011.44.1345.829268&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-08-01 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;9000&#x27;</span>, <span class="string">&#x27;0.35&#x27;</span>, <span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;159&#x27;</span>, <span class="string">&#x27;Lindsey&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;LSMITH&#x27;</span>, <span class="string">&#x27;011.44.1345.729268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-03-10 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;8000&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;160&#x27;</span>, <span class="string">&#x27;Louise&#x27;</span>, <span class="string">&#x27;Doran&#x27;</span>, <span class="string">&#x27;LDORAN&#x27;</span>, <span class="string">&#x27;011.44.1345.629268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-12-15 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7500&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;161&#x27;</span>, <span class="string">&#x27;Sarath&#x27;</span>, <span class="string">&#x27;Sewall&#x27;</span>, <span class="string">&#x27;SSEWALL&#x27;</span>, <span class="string">&#x27;011.44.1345.529268&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-11-03 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7000&#x27;</span>, <span class="string">&#x27;0.25&#x27;</span>, <span class="string">&#x27;146&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;162&#x27;</span>, <span class="string">&#x27;Clara&#x27;</span>, <span class="string">&#x27;Vishney&#x27;</span>, <span class="string">&#x27;CVISHNEY&#x27;</span>, <span class="string">&#x27;011.44.1346.129268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-11-11 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;10500&#x27;</span>, <span class="string">&#x27;0.25&#x27;</span>, <span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;163&#x27;</span>, <span class="string">&#x27;Danielle&#x27;</span>, <span class="string">&#x27;Greene&#x27;</span>, <span class="string">&#x27;DGREENE&#x27;</span>, <span class="string">&#x27;011.44.1346.229268&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-03-19 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;9500&#x27;</span>, <span class="string">&#x27;0.15&#x27;</span>, <span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;164&#x27;</span>, <span class="string">&#x27;Mattea&#x27;</span>, <span class="string">&#x27;Marvins&#x27;</span>, <span class="string">&#x27;MMARVINS&#x27;</span>, <span class="string">&#x27;011.44.1346.329268&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-01-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7200&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;165&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Lee&#x27;</span>, <span class="string">&#x27;DLEE&#x27;</span>, <span class="string">&#x27;011.44.1346.529268&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-02-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;6800&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;166&#x27;</span>, <span class="string">&#x27;Sundar&#x27;</span>, <span class="string">&#x27;Ande&#x27;</span>, <span class="string">&#x27;SANDE&#x27;</span>, <span class="string">&#x27;011.44.1346.629268&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-03-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;6400&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;167&#x27;</span>, <span class="string">&#x27;Amit&#x27;</span>, <span class="string">&#x27;Banda&#x27;</span>, <span class="string">&#x27;ABANDA&#x27;</span>, <span class="string">&#x27;011.44.1346.729268&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-04-21 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;6200&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;147&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;168&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Ozer&#x27;</span>, <span class="string">&#x27;LOZER&#x27;</span>, <span class="string">&#x27;011.44.1343.929268&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-03-11 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;11500&#x27;</span>, <span class="string">&#x27;0.25&#x27;</span>, <span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;169&#x27;</span>, <span class="string">&#x27;Harrison&#x27;</span>, <span class="string">&#x27;Bloom&#x27;</span>, <span class="string">&#x27;HBLOOM&#x27;</span>, <span class="string">&#x27;011.44.1343.829268&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-03-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;170&#x27;</span>, <span class="string">&#x27;Tayler&#x27;</span>, <span class="string">&#x27;Fox&#x27;</span>, <span class="string">&#x27;TFOX&#x27;</span>, <span class="string">&#x27;011.44.1343.729268&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-01-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;9600&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;171&#x27;</span>, <span class="string">&#x27;William&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;WSMITH&#x27;</span>, <span class="string">&#x27;011.44.1343.629268&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-02-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7400&#x27;</span>, <span class="string">&#x27;0.15&#x27;</span>, <span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;172&#x27;</span>, <span class="string">&#x27;Elizabeth&#x27;</span>, <span class="string">&#x27;Bates&#x27;</span>, <span class="string">&#x27;EBATES&#x27;</span>, <span class="string">&#x27;011.44.1343.529268&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-03-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7300&#x27;</span>, <span class="string">&#x27;0.15&#x27;</span>, <span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;173&#x27;</span>, <span class="string">&#x27;Sundita&#x27;</span>, <span class="string">&#x27;Kumar&#x27;</span>, <span class="string">&#x27;SKUMAR&#x27;</span>, <span class="string">&#x27;011.44.1343.329268&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-04-21 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;6100&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;148&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;174&#x27;</span>, <span class="string">&#x27;Ellen&#x27;</span>, <span class="string">&#x27;Abel&#x27;</span>, <span class="string">&#x27;EABEL&#x27;</span>, <span class="string">&#x27;011.44.1644.429267&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-05-11 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;11000&#x27;</span>, <span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;149&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;175&#x27;</span>, <span class="string">&#x27;Alyssa&#x27;</span>, <span class="string">&#x27;Hutton&#x27;</span>, <span class="string">&#x27;AHUTTON&#x27;</span>, <span class="string">&#x27;011.44.1644.429266&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-03-19 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;8800&#x27;</span>, <span class="string">&#x27;0.25&#x27;</span>, <span class="string">&#x27;149&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;176&#x27;</span>, <span class="string">&#x27;Jonathon&#x27;</span>, <span class="string">&#x27;Taylor&#x27;</span>, <span class="string">&#x27;JTAYLOR&#x27;</span>, <span class="string">&#x27;011.44.1644.429265&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-03-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;8600&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;149&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;177&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Livingston&#x27;</span>, <span class="string">&#x27;JLIVINGS&#x27;</span>, <span class="string">&#x27;011.44.1644.429264&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-04-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;8400&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;149&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;178&#x27;</span>, <span class="string">&#x27;Kimberely&#x27;</span>, <span class="string">&#x27;Grant&#x27;</span>, <span class="string">&#x27;KGRANT&#x27;</span>, <span class="string">&#x27;011.44.1644.429263&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-05-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;7000&#x27;</span>, <span class="string">&#x27;0.15&#x27;</span>, <span class="string">&#x27;149&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;179&#x27;</span>, <span class="string">&#x27;Charles&#x27;</span>, <span class="string">&#x27;Johnson&#x27;</span>, <span class="string">&#x27;CJOHNSON&#x27;</span>, <span class="string">&#x27;011.44.1644.429262&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-01-04 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SA_REP&#x27;</span>, <span class="string">&#x27;6200&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;149&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;180&#x27;</span>, <span class="string">&#x27;Winston&#x27;</span>, <span class="string">&#x27;Taylor&#x27;</span>, <span class="string">&#x27;WTAYLOR&#x27;</span>, <span class="string">&#x27;650.507.9876&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-01-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;181&#x27;</span>, <span class="string">&#x27;Jean&#x27;</span>, <span class="string">&#x27;Fleaur&#x27;</span>, <span class="string">&#x27;JFLEAUR&#x27;</span>, <span class="string">&#x27;650.507.9877&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-02-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3100&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;182&#x27;</span>, <span class="string">&#x27;Martha&#x27;</span>, <span class="string">&#x27;Sullivan&#x27;</span>, <span class="string">&#x27;MSULLIVA&#x27;</span>, <span class="string">&#x27;650.507.9878&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-06-21 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;183&#x27;</span>, <span class="string">&#x27;Girard&#x27;</span>, <span class="string">&#x27;Geoni&#x27;</span>, <span class="string">&#x27;GGEONI&#x27;</span>, <span class="string">&#x27;650.507.9879&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-02-03 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;120&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;184&#x27;</span>, <span class="string">&#x27;Nandita&#x27;</span>, <span class="string">&#x27;Sarchand&#x27;</span>, <span class="string">&#x27;NSARCHAN&#x27;</span>, <span class="string">&#x27;650.509.1876&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-01-27 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;4200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;185&#x27;</span>, <span class="string">&#x27;Alexis&#x27;</span>, <span class="string">&#x27;Bull&#x27;</span>, <span class="string">&#x27;ABULL&#x27;</span>, <span class="string">&#x27;650.509.2876&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-02-20 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;4100&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;186&#x27;</span>, <span class="string">&#x27;Julia&#x27;</span>, <span class="string">&#x27;Dellinger&#x27;</span>, <span class="string">&#x27;JDELLING&#x27;</span>, <span class="string">&#x27;650.509.3876&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-06-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3400&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;187&#x27;</span>, <span class="string">&#x27;Anthony&#x27;</span>, <span class="string">&#x27;Cabrio&#x27;</span>, <span class="string">&#x27;ACABRIO&#x27;</span>, <span class="string">&#x27;650.509.4876&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-02-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;188&#x27;</span>, <span class="string">&#x27;Kelly&#x27;</span>, <span class="string">&#x27;Chung&#x27;</span>, <span class="string">&#x27;KCHUNG&#x27;</span>, <span class="string">&#x27;650.505.1876&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-06-14 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;189&#x27;</span>, <span class="string">&#x27;Jennifer&#x27;</span>, <span class="string">&#x27;Dilly&#x27;</span>, <span class="string">&#x27;JDILLY&#x27;</span>, <span class="string">&#x27;650.505.2876&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-08-13 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3600&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;190&#x27;</span>, <span class="string">&#x27;Timothy&#x27;</span>, <span class="string">&#x27;Gates&#x27;</span>, <span class="string">&#x27;TGATES&#x27;</span>, <span class="string">&#x27;650.505.3876&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-07-11 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2900&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;191&#x27;</span>, <span class="string">&#x27;Randall&#x27;</span>, <span class="string">&#x27;Perkins&#x27;</span>, <span class="string">&#x27;RPERKINS&#x27;</span>, <span class="string">&#x27;650.505.4876&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-12-19 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;122&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;192&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Bell&#x27;</span>, <span class="string">&#x27;SBELL&#x27;</span>, <span class="string">&#x27;650.501.1876&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-02-04 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;4000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;193&#x27;</span>, <span class="string">&#x27;Britney&#x27;</span>, <span class="string">&#x27;Everett&#x27;</span>, <span class="string">&#x27;BEVERETT&#x27;</span>, <span class="string">&#x27;650.501.2876&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-03-03 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3900&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;194&#x27;</span>, <span class="string">&#x27;Samuel&#x27;</span>, <span class="string">&#x27;McCain&#x27;</span>, <span class="string">&#x27;SMCCAIN&#x27;</span>, <span class="string">&#x27;650.501.3876&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-07-01 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3200&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;195&#x27;</span>, <span class="string">&#x27;Vance&#x27;</span>, <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;VJONES&#x27;</span>, <span class="string">&#x27;650.501.4876&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-03-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2800&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;196&#x27;</span>, <span class="string">&#x27;Alana&#x27;</span>, <span class="string">&#x27;Walsh&#x27;</span>, <span class="string">&#x27;AWALSH&#x27;</span>, <span class="string">&#x27;650.507.9811&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-04-24 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3100&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;197&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;Feeney&#x27;</span>, <span class="string">&#x27;KFEENEY&#x27;</span>, <span class="string">&#x27;650.507.9822&#x27;</span>, TO_DATE(<span class="string">&#x27;1998-05-23 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;3000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;198&#x27;</span>, <span class="string">&#x27;Donald&#x27;</span>, <span class="string">&#x27;OConnell&#x27;</span>, <span class="string">&#x27;DOCONNEL&#x27;</span>, <span class="string">&#x27;650.507.9833&#x27;</span>, TO_DATE(<span class="string">&#x27;1999-06-21 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2600&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;199&#x27;</span>, <span class="string">&#x27;Douglas&#x27;</span>, <span class="string">&#x27;Grant&#x27;</span>, <span class="string">&#x27;DGRANT&#x27;</span>, <span class="string">&#x27;650.507.9844&#x27;</span>, TO_DATE(<span class="string">&#x27;2000-01-13 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;SH_CLERK&#x27;</span>, <span class="string">&#x27;2600&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;124&#x27;</span>, <span class="string">&#x27;50&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;200&#x27;</span>, <span class="string">&#x27;Jennifer&#x27;</span>, <span class="string">&#x27;Whalen&#x27;</span>, <span class="string">&#x27;JWHALEN&#x27;</span>, <span class="string">&#x27;515.123.4444&#x27;</span>, TO_DATE(<span class="string">&#x27;1987-09-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;AD_ASST&#x27;</span>, <span class="string">&#x27;4400&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;201&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Hartstein&#x27;</span>, <span class="string">&#x27;MHARTSTE&#x27;</span>, <span class="string">&#x27;515.123.5555&#x27;</span>, TO_DATE(<span class="string">&#x27;1996-02-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;MK_MAN&#x27;</span>, <span class="string">&#x27;13000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;202&#x27;</span>, <span class="string">&#x27;Pat&#x27;</span>, <span class="string">&#x27;Fay&#x27;</span>, <span class="string">&#x27;PFAY&#x27;</span>, <span class="string">&#x27;603.123.6666&#x27;</span>, TO_DATE(<span class="string">&#x27;1997-08-17 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;MK_REP&#x27;</span>, <span class="string">&#x27;6000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;201&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;203&#x27;</span>, <span class="string">&#x27;Susan&#x27;</span>, <span class="string">&#x27;Mavris&#x27;</span>, <span class="string">&#x27;SMAVRIS&#x27;</span>, <span class="string">&#x27;515.123.7777&#x27;</span>, TO_DATE(<span class="string">&#x27;1994-06-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;HR_REP&#x27;</span>, <span class="string">&#x27;6500&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;40&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;204&#x27;</span>, <span class="string">&#x27;Hermann&#x27;</span>, <span class="string">&#x27;Baer&#x27;</span>, <span class="string">&#x27;HBAER&#x27;</span>, <span class="string">&#x27;515.123.8888&#x27;</span>, TO_DATE(<span class="string">&#x27;1994-06-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;PR_REP&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;70&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;205&#x27;</span>, <span class="string">&#x27;Shelley&#x27;</span>, <span class="string">&#x27;Higgins&#x27;</span>, <span class="string">&#x27;SHIGGINS&#x27;</span>, <span class="string">&#x27;515.123.8080&#x27;</span>, TO_DATE(<span class="string">&#x27;1994-06-07 00:00:00&#x27;</span>, <span class="string">&#x27;SYYYY-MM-DD HH24:MI:SS&#x27;</span>), <span class="string">&#x27;AC_MGR&#x27;</span>, <span class="string">&#x27;12000&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;110&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="string">&#x27;206&#x27;</span>, <span class="string">&#x27;William&#x27;</span>, <span class="string">&#x27;Gietz&#x27;</span>, <span class="string">&#x27;WGIETZ&#x27;</span>, <span class="string">&#x27;51</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Oracle 中自定义聚合函数采用的是面向对象的思想，将函数和变量都封装在 <code>type</code> 类型中。PostgreSQL 则需要我们定义一个类型并给出相应的函数来实现具体的功能，这些函数由于是全局的可能会导致函数名冲突，当然，我们可以通过 sechma 来避免这类问题的出现。PostgreSQL 中对于自定义函数还提供了许多其他的接口供用户使用，灵活性方面强于 Oracle。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96595/dci11agg.htm">https://docs.oracle.com/cd/B10501_01/appdev.920/a96595/dci11agg.htm</a><br>[2] <a href="https://www.postgresql.org/docs/13/sql-createaggregate.html">https://www.postgresql.org/docs/13/sql-createaggregate.html</a><br>[3] <a href="https://www.postgresql.org/docs/13/xaggr.html#XAGGR-SUPPORT-FUNCTIONS">https://www.postgresql.org/docs/13/xaggr.html#XAGGR-SUPPORT-FUNCTIONS</a></p>
<div class="just-for-fun">
笑林广记 - 偷牛

<p>有失牛而讼于官者，官问曰：“几时偷去的？”<br>答曰：“老爷，明日没有的。”<br>吏在旁不觉失笑。官怒曰：“想就是你偷了。”<br>吏洒两袖曰：“任凭老爷搜。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>PostgreSQL</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 空闲会话超时</title>
    <url>/2021/01/postgresql-idle-session-timeout/</url>
    <content><![CDATA[<p>经过约八个月的努力，终于完成了 PostgreSQL 空闲会话超时断开的功能，该功能将在版本 14 中发布。这是我第一次向 PostgreSQL 提供功能，虽然之前也有向社区提供过补丁，但是这次整个功能（相对比较简单）被接受还是比较高兴的，感谢社区各位大佬的帮助和反馈。</p>
<img src="/2021/01/postgresql-idle-session-timeout/idle_session_timeout-commit-message.png" class="">

<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>正如提交日志所描述的，我们可以通过设置 <code>idle_session_timeout</code> 参数来指定空闲会话断开的时机。首先，我们看看该参数的说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select * from pg_settings where name = &#x27;idle_session_timeout&#x27; \gx</span><br><span class="line">-[ RECORD 1 ]---+-------------------------------------------------------------------------------</span><br><span class="line">name            | idle_session_timeout</span><br><span class="line">setting         | 0</span><br><span class="line">unit            | ms</span><br><span class="line">category        | Client Connection Defaults / Statement Behavior</span><br><span class="line">short_desc      | Sets the maximum allowed idle time between queries, when not in a transaction.</span><br><span class="line">extra_desc      | A value of 0 turns off the timeout.</span><br><span class="line">context         | user</span><br><span class="line">vartype         | integer</span><br><span class="line">source          | default</span><br><span class="line">min_val         | 0</span><br><span class="line">max_val         | 2147483647</span><br><span class="line">enumvals        |</span><br><span class="line">boot_val        | 0</span><br><span class="line">reset_val       | 0</span><br><span class="line">sourcefile      |</span><br><span class="line">sourceline      |</span><br><span class="line">pending_restart | f</span><br></pre></td></tr></table></figure>

<p>接着，我们修改配置并重新载入，随后查看该功能是否有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# alter system set idle_session_timeout to 10000;</span><br><span class="line">ALTER SYSTEM</span><br><span class="line">postgres=# select pg_reload_conf();</span><br><span class="line"> pg_reload_conf</span><br><span class="line">----------------</span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# SELECT 1;</span><br><span class="line"> ?column?</span><br><span class="line">----------</span><br><span class="line">        1</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres=# select * from pg_settings where name = &#x27;idle_session_timeout&#x27; \gx</span><br><span class="line">-[ RECORD 1 ]---+-------------------------------------------------------------------------------</span><br><span class="line">name            | idle_session_timeout</span><br><span class="line">setting         | 10000</span><br><span class="line">unit            | ms</span><br><span class="line">category        | Client Connection Defaults / Statement Behavior</span><br><span class="line">short_desc      | Sets the maximum allowed idle time between queries, when not in a transaction.</span><br><span class="line">extra_desc      | A value of 0 turns off the timeout.</span><br><span class="line">context         | user</span><br><span class="line">vartype         | integer</span><br><span class="line">source          | configuration file</span><br><span class="line">min_val         | 0</span><br><span class="line">max_val         | 2147483647</span><br><span class="line">enumvals        |</span><br><span class="line">boot_val        | 0</span><br><span class="line">reset_val       | 10000</span><br><span class="line">sourcefile      | /Users/japinli/Codes/postgresql/Debug/pg/pgdata/postgresql.auto.conf</span><br><span class="line">sourceline      | 3</span><br><span class="line">pending_restart | f</span><br></pre></td></tr></table></figure>

<p>随后，等待 10s，我们可以从日志中看到如下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-23 23:26:38.350 CST [20695] FATAL:  terminating connection due to idle-session timeout</span><br></pre></td></tr></table></figure>

<p>我们再返回之前的 session，确认连接是否已经断开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# SELEC 1;</span><br><span class="line">FATAL:  terminating connection due to idle-session timeout</span><br><span class="line">server closed the connection unexpectedly</span><br><span class="line">	This probably means the server terminated abnormally</span><br><span class="line">	before or while processing the request.</span><br><span class="line">The connection to the server was lost. Attempting reset: Succeeded.</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，之前的 session 已经断开连接，我们可以通过 ps 来查看对应的进程。</p>
<p>PostgreSQL 数据库是采用的进程模型，因此每个连接都会对应一个后端进程，该后端进程将分配系统资源（例如内存，work_mem），大量的空闲会话将导致内存无法得到有效的使用，有了空闲会话超时功能我们可以设置超时时间来避免空闲会话占用系统资源。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>该功能的实现与 <code>idle_in_transaction_session_timeout</code> 相似。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/doc/src/sgml/config.sgml b/doc/src/sgml/config.sgml</span></span><br><span class="line"><span class="comment">index 425f57901d..15b94c96c0 100644</span></span><br><span class="line"><span class="comment">--- a/doc/src/sgml/config.sgml</span></span><br><span class="line"><span class="comment">+++ b/doc/src/sgml/config.sgml</span></span><br><span class="line"><span class="meta">@@ -8310,15 +8310,52 @@</span> COPY postgres_log FROM &#x27;/full/path/to/logfile.csv&#x27; WITH csv;</span><br><span class="line">       &lt;/term&gt;</span><br><span class="line">       &lt;listitem&gt;</span><br><span class="line">        &lt;para&gt;</span><br><span class="line"><span class="deletion">-       Terminate any session with an open transaction that has been idle for</span></span><br><span class="line"><span class="deletion">-       longer than the specified amount of time. This allows any</span></span><br><span class="line"><span class="deletion">-       locks held by that session to be released and the connection slot to be reused;</span></span><br><span class="line"><span class="deletion">-       it also allows tuples visible only to this transaction to be vacuumed.  See</span></span><br><span class="line"><span class="deletion">-       &lt;xref linkend=&quot;routine-vacuuming&quot;/&gt; for more details about this.</span></span><br><span class="line"><span class="addition">+        Terminate any session that has been idle (that is, waiting for a</span></span><br><span class="line"><span class="addition">+        client query) within an open transaction for longer than the</span></span><br><span class="line"><span class="addition">+        specified amount of time.</span></span><br><span class="line"><span class="addition">+        If this value is specified without units, it is taken as milliseconds.</span></span><br><span class="line"><span class="addition">+        A value of zero (the default) disables the timeout.</span></span><br><span class="line"><span class="addition">+       &lt;/para&gt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       &lt;para&gt;</span></span><br><span class="line"><span class="addition">+        This option can be used to ensure that idle sessions do not hold</span></span><br><span class="line"><span class="addition">+        locks for an unreasonable amount of time.  Even when no significant</span></span><br><span class="line"><span class="addition">+        locks are held, an open transaction prevents vacuuming away</span></span><br><span class="line"><span class="addition">+        recently-dead tuples that may be visible only to this transaction;</span></span><br><span class="line"><span class="addition">+        so remaining idle for a long time can contribute to table bloat.</span></span><br><span class="line"><span class="addition">+        See &lt;xref linkend=&quot;routine-vacuuming&quot;/&gt; for more details.</span></span><br><span class="line"><span class="addition">+       &lt;/para&gt;</span></span><br><span class="line"><span class="addition">+      &lt;/listitem&gt;</span></span><br><span class="line"><span class="addition">+     &lt;/varlistentry&gt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+     &lt;varlistentry id=&quot;guc-idle-session-timeout&quot; xreflabel=&quot;idle_session_timeout&quot;&gt;</span></span><br><span class="line"><span class="addition">+      &lt;term&gt;&lt;varname&gt;idle_session_timeout&lt;/varname&gt; (&lt;type&gt;integer&lt;/type&gt;)</span></span><br><span class="line"><span class="addition">+      &lt;indexterm&gt;</span></span><br><span class="line"><span class="addition">+       &lt;primary&gt;&lt;varname&gt;idle_session_timeout&lt;/varname&gt; configuration parameter&lt;/primary&gt;</span></span><br><span class="line"><span class="addition">+      &lt;/indexterm&gt;</span></span><br><span class="line"><span class="addition">+      &lt;/term&gt;</span></span><br><span class="line"><span class="addition">+      &lt;listitem&gt;</span></span><br><span class="line"><span class="addition">+       &lt;para&gt;</span></span><br><span class="line"><span class="addition">+        Terminate any session that has been idle (that is, waiting for a</span></span><br><span class="line"><span class="addition">+        client query), but not within an open transaction, for longer than</span></span><br><span class="line"><span class="addition">+        the specified amount of time.</span></span><br><span class="line"><span class="addition">+        If this value is specified without units, it is taken as milliseconds.</span></span><br><span class="line"><span class="addition">+        A value of zero (the default) disables the timeout.</span></span><br><span class="line">        &lt;/para&gt;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       &lt;para&gt;</span></span><br><span class="line"><span class="addition">+        Unlike the case with an open transaction, an idle session without a</span></span><br><span class="line"><span class="addition">+        transaction imposes no large costs on the server, so there is less</span></span><br><span class="line"><span class="addition">+        need to enable this timeout</span></span><br><span class="line"><span class="addition">+        than &lt;varname&gt;idle_in_transaction_session_timeout&lt;/varname&gt;.</span></span><br><span class="line"><span class="addition">+       &lt;/para&gt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">        &lt;para&gt;</span><br><span class="line"><span class="deletion">-       If this value is specified without units, it is taken as milliseconds.</span></span><br><span class="line"><span class="deletion">-       A value of zero (the default) disables the timeout.</span></span><br><span class="line"><span class="addition">+        Be wary of enforcing this timeout on connections made through</span></span><br><span class="line"><span class="addition">+        connection-pooling software or other middleware, as such a layer</span></span><br><span class="line"><span class="addition">+        may not react well to unexpected connection closure.  It may be</span></span><br><span class="line"><span class="addition">+        helpful to enable this timeout only for interactive sessions,</span></span><br><span class="line"><span class="addition">+        perhaps by applying it only to particular users.</span></span><br><span class="line">        &lt;/para&gt;</span><br><span class="line">       &lt;/listitem&gt;</span><br><span class="line">      &lt;/varlistentry&gt;</span><br><span class="line"><span class="comment">diff --git a/src/backend/storage/lmgr/proc.c b/src/backend/storage/lmgr/proc.c</span></span><br><span class="line"><span class="comment">index 9b6aa2fe0d..0366a7cc00 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/storage/lmgr/proc.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/storage/lmgr/proc.c</span></span><br><span class="line"><span class="meta">@@ -61,6 +61,7 @@</span> int			DeadlockTimeout = 1000;</span><br><span class="line"> int			StatementTimeout = 0;</span><br><span class="line"> int			LockTimeout = 0;</span><br><span class="line"> int			IdleInTransactionSessionTimeout = 0;</span><br><span class="line"><span class="addition">+int			IdleSessionTimeout = 0;</span></span><br><span class="line"> bool		log_lock_waits = false;</span><br><span class="line"></span><br><span class="line"> /* Pointer to this process&#x27;s PGPROC struct, if any */</span><br><span class="line"><span class="comment">diff --git a/src/backend/tcop/postgres.c b/src/backend/tcop/postgres.c</span></span><br><span class="line"><span class="comment">index 9d98c028a2..2b53ebf97d 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/tcop/postgres.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/tcop/postgres.c</span></span><br><span class="line"><span class="meta">@@ -3242,14 +3242,28 @@</span> ProcessInterrupts(void)</span><br><span class="line"></span><br><span class="line"> 	if (IdleInTransactionSessionTimeoutPending)</span><br><span class="line"> 	&#123;</span><br><span class="line"><span class="deletion">-		/* Has the timeout setting changed since last we looked? */</span></span><br><span class="line"><span class="addition">+		/*</span></span><br><span class="line"><span class="addition">+		 * If the GUC has been reset to zero, ignore the signal.  This is</span></span><br><span class="line"><span class="addition">+		 * important because the GUC update itself won&#x27;t disable any pending</span></span><br><span class="line"><span class="addition">+		 * interrupt.</span></span><br><span class="line"><span class="addition">+		 */</span></span><br><span class="line"> 		if (IdleInTransactionSessionTimeout &gt; 0)</span><br><span class="line"> 			ereport(FATAL,</span><br><span class="line"> 					(errcode(ERRCODE_IDLE_IN_TRANSACTION_SESSION_TIMEOUT),</span><br><span class="line"> 					 errmsg(&quot;terminating connection due to idle-in-transaction timeout&quot;)));</span><br><span class="line"> 		else</span><br><span class="line"> 			IdleInTransactionSessionTimeoutPending = false;</span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+	if (IdleSessionTimeoutPending)</span></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		/* As above, ignore the signal if the GUC has been reset to zero. */</span></span><br><span class="line"><span class="addition">+		if (IdleSessionTimeout &gt; 0)</span></span><br><span class="line"><span class="addition">+			ereport(FATAL,</span></span><br><span class="line"><span class="addition">+					(errcode(ERRCODE_IDLE_SESSION_TIMEOUT),</span></span><br><span class="line"><span class="addition">+					 errmsg(&quot;terminating connection due to idle-session timeout&quot;)));</span></span><br><span class="line"><span class="addition">+		else</span></span><br><span class="line"><span class="addition">+			IdleSessionTimeoutPending = false;</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	if (ProcSignalBarrierPending)</span><br><span class="line"><span class="meta">@@ -3826,7 +3840,8 @@</span> PostgresMain(int argc, char *argv[],</span><br><span class="line"> 	StringInfoData input_message;</span><br><span class="line"> 	sigjmp_buf	local_sigjmp_buf;</span><br><span class="line"> 	volatile bool send_ready_for_query = true;</span><br><span class="line"><span class="deletion">-	bool		disable_idle_in_transaction_timeout = false;</span></span><br><span class="line"><span class="addition">+	bool		idle_in_transaction_timeout_enabled = false;</span></span><br><span class="line"><span class="addition">+	bool		idle_session_timeout_enabled = false;</span></span><br><span class="line"></span><br><span class="line"> 	/* Initialize startup process environment if necessary. */</span><br><span class="line"> 	if (!IsUnderPostmaster)</span><br><span class="line"><span class="meta">@@ -4228,6 +4243,8 @@</span> PostgresMain(int argc, char *argv[],</span><br><span class="line"> 		 * processing of batched messages, and because we don&#x27;t want to report</span><br><span class="line"> 		 * uncommitted updates (that confuses autovacuum).  The notification</span><br><span class="line"> 		 * processor wants a call too, if we are not in a transaction block.</span><br><span class="line"><span class="addition">+		 *</span></span><br><span class="line"><span class="addition">+		 * Also, if an idle timeout is enabled, start the timer for that.</span></span><br><span class="line"> 		 */</span><br><span class="line"> 		if (send_ready_for_query)</span><br><span class="line"> 		&#123;</span><br><span class="line"><span class="meta">@@ -4239,7 +4256,7 @@</span> PostgresMain(int argc, char *argv[],</span><br><span class="line"> 				/* Start the idle-in-transaction timer */</span><br><span class="line"> 				if (IdleInTransactionSessionTimeout &gt; 0)</span><br><span class="line"> 				&#123;</span><br><span class="line"><span class="deletion">-					disable_idle_in_transaction_timeout = true;</span></span><br><span class="line"><span class="addition">+					idle_in_transaction_timeout_enabled = true;</span></span><br><span class="line"> 					enable_timeout_after(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span><br><span class="line"> 										 IdleInTransactionSessionTimeout);</span><br><span class="line"> 				&#125;</span><br><span class="line"><span class="meta">@@ -4252,7 +4269,7 @@</span> PostgresMain(int argc, char *argv[],</span><br><span class="line"> 				/* Start the idle-in-transaction timer */</span><br><span class="line"> 				if (IdleInTransactionSessionTimeout &gt; 0)</span><br><span class="line"> 				&#123;</span><br><span class="line"><span class="deletion">-					disable_idle_in_transaction_timeout = true;</span></span><br><span class="line"><span class="addition">+					idle_in_transaction_timeout_enabled = true;</span></span><br><span class="line"> 					enable_timeout_after(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span><br><span class="line"> 										 IdleInTransactionSessionTimeout);</span><br><span class="line"> 				&#125;</span><br><span class="line"><span class="meta">@@ -4275,6 +4292,14 @@</span> PostgresMain(int argc, char *argv[],</span><br><span class="line"></span><br><span class="line"> 				set_ps_display(&quot;idle&quot;);</span><br><span class="line"> 				pgstat_report_activity(STATE_IDLE, NULL);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+				/* Start the idle-session timer */</span></span><br><span class="line"><span class="addition">+				if (IdleSessionTimeout &gt; 0)</span></span><br><span class="line"><span class="addition">+				&#123;</span></span><br><span class="line"><span class="addition">+					idle_session_timeout_enabled = true;</span></span><br><span class="line"><span class="addition">+					enable_timeout_after(IDLE_SESSION_TIMEOUT,</span></span><br><span class="line"><span class="addition">+										 IdleSessionTimeout);</span></span><br><span class="line"><span class="addition">+				&#125;</span></span><br><span class="line"> 			&#125;</span><br><span class="line"></span><br><span class="line"> 			/* Report any recently-changed GUC options */</span><br><span class="line"><span class="meta">@@ -4310,12 +4335,21 @@</span> PostgresMain(int argc, char *argv[],</span><br><span class="line"> 		DoingCommandRead = false;</span><br><span class="line"></span><br><span class="line"> 		/*</span><br><span class="line"><span class="deletion">-		 * (5) turn off the idle-in-transaction timeout</span></span><br><span class="line"><span class="addition">+		 * (5) turn off the idle-in-transaction and idle-session timeouts, if</span></span><br><span class="line"><span class="addition">+		 * active.</span></span><br><span class="line"><span class="addition">+		 *</span></span><br><span class="line"><span class="addition">+		 * At most one of these two will be active, so there&#x27;s no need to</span></span><br><span class="line"><span class="addition">+		 * worry about combining the timeout.c calls into one.</span></span><br><span class="line"> 		 */</span><br><span class="line"><span class="deletion">-		if (disable_idle_in_transaction_timeout)</span></span><br><span class="line"><span class="addition">+		if (idle_in_transaction_timeout_enabled)</span></span><br><span class="line"> 		&#123;</span><br><span class="line"> 			disable_timeout(IDLE_IN_TRANSACTION_SESSION_TIMEOUT, false);</span><br><span class="line"><span class="deletion">-			disable_idle_in_transaction_timeout = false;</span></span><br><span class="line"><span class="addition">+			idle_in_transaction_timeout_enabled = false;</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+		if (idle_session_timeout_enabled)</span></span><br><span class="line"><span class="addition">+		&#123;</span></span><br><span class="line"><span class="addition">+			disable_timeout(IDLE_SESSION_TIMEOUT, false);</span></span><br><span class="line"><span class="addition">+			idle_session_timeout_enabled = false;</span></span><br><span class="line"> 		&#125;</span><br><span class="line"></span><br><span class="line"> 		/*</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/errcodes.txt b/src/backend/utils/errcodes.txt</span></span><br><span class="line"><span class="comment">index 64ca2deec9..1d5a78e73d 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/errcodes.txt</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/errcodes.txt</span></span><br><span class="line"><span class="meta">@@ -109,6 +109,7 @@</span> Section: Class 08 - Connection Exception</span><br><span class="line"> 08004    E    ERRCODE_SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION      sqlserver_rejected_establishment_of_sqlconnection</span><br><span class="line"> 08007    E    ERRCODE_TRANSACTION_RESOLUTION_UNKNOWN                         transaction_resolution_unknown</span><br><span class="line"> 08P01    E    ERRCODE_PROTOCOL_VIOLATION                                     protocol_violation</span><br><span class="line"><span class="addition">+08P02    E    ERRCODE_IDLE_SESSION_TIMEOUT                                   idle_session_timeout</span></span><br><span class="line"></span><br><span class="line"> Section: Class 09 - Triggered Action Exception</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/init/globals.c b/src/backend/utils/init/globals.c</span></span><br><span class="line"><span class="comment">index 3d5d6cc033..ea28769d6a 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/init/globals.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/init/globals.c</span></span><br><span class="line"><span class="meta">@@ -32,6 +32,7 @@</span> volatile sig_atomic_t QueryCancelPending = false;</span><br><span class="line"> volatile sig_atomic_t ProcDiePending = false;</span><br><span class="line"> volatile sig_atomic_t ClientConnectionLost = false;</span><br><span class="line"> volatile sig_atomic_t IdleInTransactionSessionTimeoutPending = false;</span><br><span class="line"><span class="addition">+volatile sig_atomic_t IdleSessionTimeoutPending = false;</span></span><br><span class="line"> volatile sig_atomic_t ProcSignalBarrierPending = false;</span><br><span class="line"> volatile uint32 InterruptHoldoffCount = 0;</span><br><span class="line"> volatile uint32 QueryCancelHoldoffCount = 0;</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/init/postinit.c b/src/backend/utils/init/postinit.c</span></span><br><span class="line"><span class="comment">index 59b3f4b135..e5965bc517 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/init/postinit.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/init/postinit.c</span></span><br><span class="line"><span class="meta">@@ -72,6 +72,7 @@</span> static void ShutdownPostgres(int code, Datum arg);</span><br><span class="line"> static void StatementTimeoutHandler(void);</span><br><span class="line"> static void LockTimeoutHandler(void);</span><br><span class="line"> static void IdleInTransactionSessionTimeoutHandler(void);</span><br><span class="line"><span class="addition">+static void IdleSessionTimeoutHandler(void);</span></span><br><span class="line"> static bool ThereIsAtLeastOneRole(void);</span><br><span class="line"> static void process_startup_options(Port *port, bool am_superuser);</span><br><span class="line"> static void process_settings(Oid databaseid, Oid roleid);</span><br><span class="line"><span class="meta">@@ -619,6 +620,7 @@</span> InitPostgres(const char *in_dbname, Oid dboid, const char *username,</span><br><span class="line"> 		RegisterTimeout(LOCK_TIMEOUT, LockTimeoutHandler);</span><br><span class="line"> 		RegisterTimeout(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span><br><span class="line"> 						IdleInTransactionSessionTimeoutHandler);</span><br><span class="line"><span class="addition">+		RegisterTimeout(IDLE_SESSION_TIMEOUT, IdleSessionTimeoutHandler);</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	/*</span><br><span class="line"><span class="meta">@@ -1233,6 +1235,14 @@</span> IdleInTransactionSessionTimeoutHandler(void)</span><br><span class="line"> 	SetLatch(MyLatch);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+static void</span></span><br><span class="line"><span class="addition">+IdleSessionTimeoutHandler(void)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	IdleSessionTimeoutPending = true;</span></span><br><span class="line"><span class="addition">+	InterruptPending = true;</span></span><br><span class="line"><span class="addition">+	SetLatch(MyLatch);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> /*</span><br><span class="line">  * Returns true if at least one role is defined in this database cluster.</span><br><span class="line">  */</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="comment">index 1ccf7593ee..daf9c127cd 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/guc.c</span></span><br><span class="line"><span class="meta">@@ -2509,7 +2509,7 @@</span> static struct config_int ConfigureNamesInt[] =</span><br><span class="line"></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		&#123;&quot;idle_in_transaction_session_timeout&quot;, PGC_USERSET, CLIENT_CONN_STATEMENT,</span><br><span class="line"><span class="deletion">-			gettext_noop(&quot;Sets the maximum allowed duration of any idling transaction.&quot;),</span></span><br><span class="line"><span class="addition">+			gettext_noop(&quot;Sets the maximum allowed idle time between queries, when in a transaction.&quot;),</span></span><br><span class="line"> 			gettext_noop(&quot;A value of 0 turns off the timeout.&quot;),</span><br><span class="line"> 			GUC_UNIT_MS</span><br><span class="line"> 		&#125;,</span><br><span class="line"><span class="meta">@@ -2518,6 +2518,17 @@</span> static struct config_int ConfigureNamesInt[] =</span><br><span class="line"> 		NULL, NULL, NULL</span><br><span class="line"> 	&#125;,</span><br><span class="line"></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		&#123;&quot;idle_session_timeout&quot;, PGC_USERSET, CLIENT_CONN_STATEMENT,</span></span><br><span class="line"><span class="addition">+			gettext_noop(&quot;Sets the maximum allowed idle time between queries, when not in a transaction.&quot;),</span></span><br><span class="line"><span class="addition">+			gettext_noop(&quot;A value of 0 turns off the timeout.&quot;),</span></span><br><span class="line"><span class="addition">+			GUC_UNIT_MS</span></span><br><span class="line"><span class="addition">+		&#125;,</span></span><br><span class="line"><span class="addition">+		&amp;IdleSessionTimeout,</span></span><br><span class="line"><span class="addition">+		0, 0, INT_MAX,</span></span><br><span class="line"><span class="addition">+		NULL, NULL, NULL</span></span><br><span class="line"><span class="addition">+	&#125;,</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		&#123;&quot;vacuum_freeze_min_age&quot;, PGC_USERSET, CLIENT_CONN_STATEMENT,</span><br><span class="line"> 			gettext_noop(&quot;Minimum age at which VACUUM should freeze a table row.&quot;),</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/misc/postgresql.conf.sample b/src/backend/utils/misc/postgresql.conf.sample</span></span><br><span class="line"><span class="comment">index 5298e18ecd..033aa335a0 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/misc/postgresql.conf.sample</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/misc/postgresql.conf.sample</span></span><br><span class="line"><span class="meta">@@ -663,6 +663,7 @@</span></span><br><span class="line"> #statement_timeout = 0			# in milliseconds, 0 is disabled</span><br><span class="line"> #lock_timeout = 0			# in milliseconds, 0 is disabled</span><br><span class="line"> #idle_in_transaction_session_timeout = 0	# in milliseconds, 0 is disabled</span><br><span class="line"><span class="addition">+#idle_session_timeout = 0		# in milliseconds, 0 is disabled</span></span><br><span class="line"> #vacuum_freeze_min_age = 50000000</span><br><span class="line"> #vacuum_freeze_table_age = 150000000</span><br><span class="line"> #vacuum_multixact_freeze_min_age = 5000000</span><br><span class="line"><span class="comment">diff --git a/src/include/miscadmin.h b/src/include/miscadmin.h</span></span><br><span class="line"><span class="comment">index 2c71db79c0..1bdc97e308 100644</span></span><br><span class="line"><span class="comment">--- a/src/include/miscadmin.h</span></span><br><span class="line"><span class="comment">+++ b/src/include/miscadmin.h</span></span><br><span class="line"><span class="meta">@@ -82,6 +82,7 @@</span> extern PGDLLIMPORT volatile sig_atomic_t InterruptPending;</span><br><span class="line"> extern PGDLLIMPORT volatile sig_atomic_t QueryCancelPending;</span><br><span class="line"> extern PGDLLIMPORT volatile sig_atomic_t ProcDiePending;</span><br><span class="line"> extern PGDLLIMPORT volatile sig_atomic_t IdleInTransactionSessionTimeoutPending;</span><br><span class="line"><span class="addition">+extern PGDLLIMPORT volatile sig_atomic_t IdleSessionTimeoutPending;</span></span><br><span class="line"> extern PGDLLIMPORT volatile sig_atomic_t ProcSignalBarrierPending;</span><br><span class="line"></span><br><span class="line"> extern PGDLLIMPORT volatile sig_atomic_t ClientConnectionLost;</span><br><span class="line"><span class="comment">diff --git a/src/include/storage/proc.h b/src/include/storage/proc.h</span></span><br><span class="line"><span class="comment">index 989c5849d4..0786fcf103 100644</span></span><br><span class="line"><span class="comment">--- a/src/include/storage/proc.h</span></span><br><span class="line"><span class="comment">+++ b/src/include/storage/proc.h</span></span><br><span class="line"><span class="meta">@@ -378,6 +378,7 @@</span> extern PGDLLIMPORT int DeadlockTimeout;</span><br><span class="line"> extern PGDLLIMPORT int StatementTimeout;</span><br><span class="line"> extern PGDLLIMPORT int LockTimeout;</span><br><span class="line"> extern PGDLLIMPORT int IdleInTransactionSessionTimeout;</span><br><span class="line"><span class="addition">+extern PGDLLIMPORT int IdleSessionTimeout;</span></span><br><span class="line"> extern bool log_lock_waits;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/include/utils/timeout.h b/src/include/utils/timeout.h</span></span><br><span class="line"><span class="comment">index 8adb4e14ca..ecb2a366a5 100644</span></span><br><span class="line"><span class="comment">--- a/src/include/utils/timeout.h</span></span><br><span class="line"><span class="comment">+++ b/src/include/utils/timeout.h</span></span><br><span class="line"><span class="meta">@@ -31,10 +31,11 @@</span> typedef enum TimeoutId</span><br><span class="line"> 	STANDBY_TIMEOUT,</span><br><span class="line"> 	STANDBY_LOCK_TIMEOUT,</span><br><span class="line"> 	IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span><br><span class="line"><span class="addition">+	IDLE_SESSION_TIMEOUT,</span></span><br><span class="line"> 	/* First user-definable timeout reason */</span><br><span class="line"> 	USER_TIMEOUT,</span><br><span class="line"> 	/* Maximum number of timeout reasons */</span><br><span class="line"><span class="deletion">-	MAX_TIMEOUTS = 16</span></span><br><span class="line"><span class="addition">+	MAX_TIMEOUTS = USER_TIMEOUT + 10</span></span><br><span class="line"> &#125; TimeoutId;</span><br><span class="line"></span><br><span class="line"> /* callback function signature */</span><br></pre></td></tr></table></figure>

<p>这个功能虽然比较小众，但是用来练手是比较好的一个实践过程，通过这个功能我更加熟悉了 PostgreSQL 社区的工作流程。社区中的人都比较包容，对于一些比较基础的问题也能耐心的解释，对待事物很严谨，即使是文档也是如此。最后附上整个功能的讨论过程。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[1] <a href="https://postgr.es/m/763A0689-F189-459E-946F-F0EC4458980B@hotmail.com">https://postgr.es/m/763A0689-F189-459E-946F-F0EC4458980B@hotmail.com</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 逻辑复制</title>
    <url>/2020/12/postgresql-logical-replication/</url>
    <content><![CDATA[<p>PostgreSQL 数据库在 9.0 中引入了物理复制，之前的文章中也有介绍。物理复制将主库中所有的更改都通过 WAL 日志流式地传输到备库中，备库通过重放 WAL 日志来实现同步。但是，物理复制也有其自身的局限性。</p>
<ul>
<li>不能执行有选择性的复制，或者说不支持复制部分数据库对象；</li>
<li>不能在不同的数据大版本之间进行复制，例如，pg10 -&gt; pg12 是无法通过物理复制来实现同步的；</li>
<li>不能在不同平台之间进行复制，例如，Linux 和 Windows 之间不能使用物理复制来实现同步；</li>
<li>备库无法提供写入操作。</li>
</ul>
<p>PostgreSQL 在版本 10 中引入了逻辑复制，它用于解决上述物理复制的局限性，同时业务复制开辟了一个新的方向。逻辑复制使用发布和订阅模式，一个或多个订阅者可以订阅一个发布者上的一个或多个发布。订阅者最初会从发布者那里收到复制的数据库对象的副本，并在同一对象上实时进行后续更改。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>正如上面所说，PostgreSQL 的逻辑复制采用的是发布-订阅模型，因此，在发布者（publisher）节点上，它将创建一个发布（publication），它是一个表或一组表的更改集合；在订阅者（subscriber）节点上，它将创建一个订阅（subscription），它可以订阅来自同一个发布者的一个或多个发布。</p>
<p>逻辑复制通常从获取发布者数据库上的数据快照并将其复制到订阅者开始，这被称为表同步阶段（table synchronization phase）。在表同步阶段，如果存在多个表需要同步，那么 PostgreSQL 将创建多个进程来进行同步，但是每个表只能有一个同步进程。一旦复制完成后，发布者节点中的后续更改将实时发送给订阅者节点。订阅者以与发布者相同的顺序应用数据，从而确保单个订阅中的发布具有事务一致性。这种数据复制方法有时称为事务复制。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>在使用逻辑复制之前，我们需要在发布者将 <code>wal_level</code> 参数修改为 <code>logical</code>。这将指示服务器在 WAL 中存储其他信息，以将二进制更改转换为逻辑更改。接下来，我们就可以使用命令创建 <code>CREATE PUBLICATION</code> 创建发布了，其语法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PUBLICATION name</span><br><span class="line">    [ FOR TABLE [ ONLY ] table_name [ * ] [, ...]</span><br><span class="line">      | FOR ALL TABLES ]</span><br><span class="line">    [ WITH ( publication_parameter [= value] [, ... ] ) ]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>name</strong> - 表示发布的名称，该名称在当前数据库中必须唯一。</li>
<li><strong>FOR TABLE</strong> - 指定需要添加到该发布中的表。如果指定了 __ONLY__，那么仅该表纳入发布中，反之，其后代表也被纳入到发布中。您也可以在表名后加上 <code>*</code> 来显示地将后代表纳入发布中。分区表总是纳入到发布中的，因此我们不需要显示地将分区表的子表加入到发布中。<br>只有持久话的基表和分区表可以做个发布的内容。临时表、无日志表、外表、物化视图和常规视图都不能作为发布的内容。分区表被加入到发布中后，其后续的字表将自动加入到发布中。</li>
<li><strong>FOR ALL TABLES</strong> - 将发布标记为可复制数据库中所有的表，包括将来创建的表。</li>
<li><strong>WITH</strong> - 指定发布可选的参数，目前支持两个参数。<ul>
<li><strong>publish (string)</strong> - 此参数确定新发布将向订阅者发布哪些 DML 操作。这些操作包括 <code>insert</code>、<code>update</code>、<code>delete</code> 和 <code>truncate</code>。默认是所有操作。</li>
<li><strong>publish_via_partition_root (boolean)</strong> - 此参数决定是否使用分区表（或其分区上）的身份和模式，而不是实际更改的各个分区的身份和模式来发布发布发布中包含的分区表（或其分区上）的更改；后者是默认值。启用此功能可以将更改复制到非分区表或由不同分区集组成的分区表中。<br>如果启用此功能，直接在分区上执行的TRUNCATE操作将不会被复制。</li>
</ul>
</li>
</ul>
<p>这里有几点我们需要注意：</p>
<ol>
<li>逻辑复制不支持 DDL 操作。</li>
<li><code>COPY ... FROM</code> 命令是由 <code>INSERT</code> 操作来发布的。</li>
<li><code>INSERT ... ON CONFLICT</code> 命令是根据其最终结果来决定发布的命令。如果其不是 <code>INSERT</code> 或 <code>UPDATE</code>，它甚至可能不会发布。</li>
<li>添加到发布中以发布 <code>UPDATE </code> 和/或 <code>DELETE</code> 操作的表必须定义 <code>REPLICA IDENTITY</code>。</li>
<li>用户需要有足够的权限才可以将表加入到发布中。对于 <code>FOR ALL TABLES</code> 必须是超级用户。</li>
<li>用户必须具有 <code>CREATE</code> 权限才可以创建发布（超级用户除外）。</li>
<li>发布创建完成之后并没有开始复制流程，它仅仅是为订阅者定义了分组和过滤逻辑。</li>
<li>如果没有指定 <code>FOR TABLE</code> 和 <code>FOR ALL TABLES</code>，则发表一组空表，这对于后续添加表非常有用。</li>
</ol>
<p>有了发布者之后，我们就需要创建订阅者了，其语法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE SUBSCRIPTION subscription_name</span><br><span class="line">    CONNECTION &#x27;conninfo&#x27;</span><br><span class="line">    PUBLICATION publication_name [, ...]</span><br><span class="line">    [ WITH ( subscription_parameter [= value] [, ... ] ) ]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>subscription_name</strong> - 订阅者名称，当前数据库必须唯一。</li>
<li><strong>conninfo</strong> - 连接到发布者的连接字符串。</li>
<li><strong>publication_name</strong> - 发布者上的发布名。</li>
<li><strong>WITH</strong> - 指定订阅的可选参数。目前支持以下参数。<ul>
<li><strong>copy_data (boolean)</strong> - 指定复制开始后是否应复制正在订阅的发布中的现有数据，默认 <code>true</code>。</li>
<li><strong>create_slot (boolean)</strong> - 指定命令是否应在发布者上创建复制槽，默认 <code>true</code>。</li>
<li><strong>enabled (boolean)</strong> - 指定订阅是应该主动复制，还是应该仅设置但尚未启动，默认值为 <code>true</code>。</li>
<li><strong>slot_name (string)</strong> - 指定复制槽的名称。如果指定为 <code>NONE</code>，那么这个复制上将不会使用复制槽，这种情况下需要 <code>enabled</code> 和 <code>create_slot</code> 设置为 <code>false</code>。</li>
<li><strong>syncronous_commit (enum)</strong> - 该参数将重写订阅重放进程的 <code>syncronous_commit</code> 参数。默认值为 <code>off</code>。<br>对于逻辑复制来说，该参数设置为 <code>off</code> 是安全的，如果订阅者由于缺少同步而丢失了事务，那么数据将再次从发布者发送。</li>
<li><strong>binary (boolean)</strong> - 指定订阅是否将请求发布者以二进制格式（而不是文本）发送数据，默认值为 <code>false</code>。<br>当跨版本复制时，发布者可能对某种数据类型具有二进制发送功能，而订阅者却缺乏该类型的二进制接收功能。在这种情况下，数据传输将失败，因此不能使用 <code>binary</code> 选项。</li>
<li><strong>connect (boolean)</strong> - 指定 <code>CREATE SUBSCRIPTION</code> 是否连接到发布者。若将该参数设置为 <code>false</code>,那么 <code>enabled</code>、<code>create_slot</code> 和 <code>copy_data</code> 的默认值将被设置为 <code>false</code>。</li>
<li><strong>streaming (boolean)</strong> - 指定是否将正在进行的事务进行发布。默认情况下，所有的事务将在发布者进行完全编码，然后作为一个整体发送给订阅者。</li>
</ul>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>接下来，我们将展示如何使用逻辑复制。首先我创建一个简单的表，并插入一条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# CREATE TABLE t1 (a integer PRIMARY KEY, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# INSERT INTO t1 VALUES (1, 1);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>

<p>接下来，我们为这个表创建一个发布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# CREATE PUBLICATION my_pub FOR TABLE t1;</span><br><span class="line">CREATE PUBLICATION</span><br></pre></td></tr></table></figure>

<p>现在，发布已经创建完了，现在我们需要创建订阅。注意，我们在同一机器上的不通端口运行两个 PostgreSQL 数据库实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[8765]=# CREATE TABLE t1(a integer PRIMARY KEY, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE SUBSCRIPTION my_sub CONNECTION &#x27;host=localhost port=5432 dbname=postgres&#x27; PUBLICATION my_pub;</span><br><span class="line">NOTICE:  created replication slot &quot;my_sub&quot; on publisher</span><br><span class="line">CREATE SUBSCRIPTION</span><br></pre></td></tr></table></figure>

<p>现在，我们可以验证数据是否被复制过来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[8765]=# TABLE t1;</span><br><span class="line"> a | b</span><br><span class="line">---+---</span><br><span class="line"> 1 | 1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>接下来，我在验证数据更改之后是否被复制。首先，我们在发布者上插入一条记录，随后在订阅者上查看该记录是否被复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# INSERT INTO t1 VALUES (2, 2);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">postgres[8765]=# TABLE t1;</span><br><span class="line"> a | b</span><br><span class="line">---+---</span><br><span class="line"> 1 | 1</span><br><span class="line"> 2 | 2</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，数据被正确复制到订阅者。</p>
<h2 id="分区表的流复制"><a href="#分区表的流复制" class="headerlink" title="分区表的流复制"></a>分区表的流复制</h2><p>这里对分区表的流复制特别说明一下，在 PostgreSQL 13 中，对于分区表流复制引入了一个新的参数 <code>publish_via_partition_root</code>，默认为 <code>false</code>。文档说明如下。</p>
<blockquote>
<p>This parameter determines whether changes in a partitioned table (or on its partitions)<br>contained in the publication will be published using the identity and schema of the<br>partitioned table rather than that of the individual partitions that are actually changed;<br>the latter is the default. Enabling this allows the changes to be replicated into a<br>non-partitioned table or a partitioned table consisting of a different set of partitions.</p>
<p>If this is enabled, TRUNCATE operations performed directly on partitions are not replicated.</p>
</blockquote>
<h3 id="publish-via-partition-root-false"><a href="#publish-via-partition-root-false" class="headerlink" title="publish_via_partition_root (false)"></a>publish_via_partition_root (false)</h3><p>我们先来看看默认情况下，逻辑复制的分区表表现形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# CREATE TABLE parted_parent (a integer, b integer) PARTITION BY RANGE(a);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# CREATE TABLE parted_child01 PARTITION OF parted_parent FOR VALUES FROM (1) TO (10);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# CREATE TABLE parted_child02 PARTITION OF parted_parent FOR VALUES FROM (10) TO (20);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (1, 1), (11, 11);</span><br><span class="line">INSERT 0 2</span><br><span class="line">postgres[5432]=# CREATE PUBLICATION my_parted_pub FOR TABLE parted_parent;</span><br><span class="line">CREATE PUBLICATION</span><br><span class="line"></span><br><span class="line">postgres[8765]=# CREATE TABLE parted_parent (a integer, b integer) PARTITION BY RANGE(a);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child01 PARTITION OF parted_parent FOR VALUES FROM (1) TO (10);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child02 PARTITION OF parted_parent FOR VALUES FROM (10) TO (20);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE SUBSCRIPTION my_parted_sub CONNECTION &#x27;host=localhost port=5432 dbname=postgres&#x27; PUBLICATION my_parted_pub;</span><br><span class="line">NOTICE:  created replication slot &quot;my_parted_sub&quot; on publisher</span><br><span class="line">CREATE SUBSCRIPTION</span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line"> 11 | 11</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，数据从发布者复制到了订阅者上。我们在插入数据看后续的更改是否可以复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (2, 2);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line"> 11 | 11</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>一切正常，如果此时我们在发布者上新加一个分区表会如何呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# CREATE TABLE parted_child03 PARTITION OF parted_parent FOR VALUES FROM (20) TO (30);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (25, 25);</span><br><span class="line">INSERT 0 1</span><br><span class="line">postgres[5432]=# TABLE parted_parent ;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child03 PARTITION OF parted_parent FOR VALUES FROM (20) TO (30);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# TABLE parted_parent ;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line"> 11 | 11</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到新加入的分区子表没能将数据复制到订阅者上。我们在 <code>parted_child01</code> 上执行 <code>TRUNCATE</code> 看会发生什么情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# TRUNCATE parted_child01;</span><br><span class="line">TRUNCATE TABLE</span><br><span class="line">postgres[5432]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 11 | 11</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>可以看到在分区子表上执行 <code>TRUNCATE</code>，其将复制到订阅者上进行相应的操作。那我们可以在订阅者上面不定义分区表，而是采用普通表来存储上游分区表的数据吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[8765]=# DROP SUBSCRIPTION my_parted_sub;</span><br><span class="line">NOTICE:  dropped replication slot &quot;my_parted_sub&quot; on publisher</span><br><span class="line">DROP SUBSCRIPTION</span><br><span class="line">postgres[8765]=# DROP TABLE parted_parent;</span><br><span class="line">DROP TABLE</span><br><span class="line">postgres[8765]=# \d</span><br><span class="line">Did not find any relations.</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_parent (a integer, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE SUBSCRIPTION my_parted_sub CONNECTION &#x27;host=localhost port=5432 dbname=postgres&#x27; PUBLICATION my_parted_pub;</span><br><span class="line">ERROR:  relation &quot;public.parted_child03&quot; does not exist</span><br></pre></td></tr></table></figure>

<p>在这种情况下，分区表不能通过逻辑复制汇总到一个普通表中，但我们仍然可以对其进行复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[8765]=# CREATE TABLE parted_child01 (a integer, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child02 (a integer, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child03 (a integer, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE SUBSCRIPTION my_parted_sub CONNECTION &#x27;host=localhost port=5432 dbname=postgres&#x27; PUBLICATION my_parted_pub01;</span><br><span class="line">NOTICE:  created replication slot &quot;my_parted_sub&quot; on publisher</span><br><span class="line">CREATE SUBSCRIPTION</span><br><span class="line">postgres[8765]=# table parted_parent ;</span><br><span class="line"> a | b</span><br><span class="line">---+---</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">postgres[8765]=# table parted_child01 ;</span><br><span class="line"> a | b</span><br><span class="line">---+---</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">postgres[8765]=# table parted_child02 ;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 11 | 11</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres[8765]=# table parted_child03 ;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 25 | 25</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>我们通过建立与分区表对于的表来进行复制，这样是可以到达复制的效果的，但是就丢失了分区表的关系。</p>
<p>我们可以通过对订阅进行刷新来获取新加入的发布表的信息，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER SUBSCRIPTION my_parted_sub REFRESH PUBLICATION;</span><br></pre></td></tr></table></figure>

<h3 id="publish-via-partition-root-true"><a href="#publish-via-partition-root-true" class="headerlink" title="publish_via_partition_root (true)"></a>publish_via_partition_root (true)</h3><p>现在，我们来看看当设置了 <code>publish_via_partition_root</code>，逻辑复制时分区表是怎样表现的。首先，我们清理一下环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[8765]=# drop subscription my_parted_sub;</span><br><span class="line">NOTICE:  dropped replication slot &quot;my_parted_sub&quot; on publisher</span><br><span class="line">DROP SUBSCRIPTION</span><br><span class="line">postgres[8765]=# drop table parted_parent, parted_child01, parted_child02, parted_child03;</span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line">postgres[5432]=# DROP PUBLICATION my_parted_pub;</span><br><span class="line">DROP PUBLICATION</span><br><span class="line">postgres[5432]=# drop table parted_parent;</span><br><span class="line">DROP TABLE</span><br></pre></td></tr></table></figure>

<p>接着，我们重复上面的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# CREATE TABLE parted_parent (a integer, b integer) PARTITION BY RANGE(a);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# CREATE TABLE parted_child01 PARTITION OF parted_parent FOR VALUES FROM (1) TO (10);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# CREATE TABLE parted_child02 PARTITION OF parted_parent FOR VALUES FROM (10) TO (20);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (1, 1), (11, 11);</span><br><span class="line">INSERT 0 2</span><br><span class="line">postgres[5432]=# CREATE PUBLICATION my_parted_pub FOR TABLE parted_parent WITH (publish_via_partition_root);</span><br><span class="line">CREATE PUBLICATION</span><br><span class="line"></span><br><span class="line">postgres[8765]=# CREATE TABLE parted_parent (a integer, b integer) PARTITION BY RANGE(a);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child01 PARTITION OF parted_parent FOR VALUES FROM (1) TO (10);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child02 PARTITION OF parted_parent FOR VALUES FROM (10) TO (20);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE SUBSCRIPTION my_parted_sub CONNECTION &#x27;host=localhost port=5432 dbname=postgres&#x27; PUBLICATION my_parted_pub;</span><br><span class="line">NOTICE:  created replication slot &quot;my_parted_sub&quot; on publisher</span><br><span class="line">CREATE SUBSCRIPTION</span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line"> 11 | 11</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>接着测试后续更改是否可以复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (2, 2);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line"> 11 | 11</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>好像没有什么不同嘛！那新建的分区子表呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# CREATE TABLE parted_child03 PARTITION OF parted_parent FOR VALUES FROM (20) TO (30);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (25, 25);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">postgres[8765]=# CREATE TABLE parted_child03 PARTITION OF parted_parent FOR VALUES FROM (20) TO (30);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>可以看到，这里与上面表现不一致了，新加的分区子表的数据被复制过去了。这只是其中的一个不同，接着我们看看在分区子表上执行 <code>TRUNCATE</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# TRUNCATE parted_child01;</span><br><span class="line">TRUNCATE TABLE</span><br><span class="line">postgres[5432]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">postgres[8765]=# TABLE parted_parent;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>可以看到，发布者的 <code>parted_child01</code> 表被清空了，然而订阅者上的 <code>parted_child01</code> 并没有发生变化。这就完了么？当然没有，最后我们来看看订阅者上采用普通表是否可以汇总分区表数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[8765]=# CREATE TABLE parted_parent (a integer, b integer);</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres[8765]=# CREATE SUBSCRIPTION my_parted_sub CONNECTION &#x27;host=localhost port=5432 dbname=postgres&#x27; PUBLICATION my_parted_pub;</span><br><span class="line">NOTICE:  created replication slot &quot;my_parted_sub&quot; on publisher</span><br><span class="line">CREATE SUBSCRIPTION</span><br><span class="line">postgres[8765]=# TABLE parted_parent ;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>这次成功了，说明这种模式下，可以对上游的分区表进行数据汇总，当然我们在下游也可以采用不同的分区策略，一切都是 OK 的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres[5432]=# INSERT INTO parted_parent VALUES (1, 1);</span><br><span class="line">INSERT 0 1</span><br><span class="line">postgres[5432]=# INSERT INTO parted_child01 VALUES (2, 2);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">postgres[8765]=# TABLE parted_parent ;</span><br><span class="line"> a  | b</span><br><span class="line">----+----</span><br><span class="line"> 11 | 11</span><br><span class="line"> 25 | 25</span><br><span class="line">  1 |  1</span><br><span class="line">  2 |  2</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>无论是对分区表或分区子表的数据更新同样被复制到订阅者上了。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>上面的 psql 提示符是通过命令 <code>\set PROMPT1 &#39;%/[%&gt;]=%# &#39;</code> 进行更改的，其中 <code>%/</code> 表示当前数据库，<code>%&gt;</code> 表示监听的端口，<code>%#</code> 表示用户权限，您可以<a href="https://www.postgresql.org/docs/12/app-psql.html">参考 psql 文档获取更多的信息</a>。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li>2021-08-23 - 感谢熊灿灿指出本文中的 BUG，在 <code>publish_via_partition_root (false)</code> 中第一个代码段中第 16 行端口错误，原为 <code>5432</code>，应更正为 <code>8765</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/13/sql-createpublication.html">https://www.postgresql.org/docs/13/sql-createpublication.html</a><br>[2] <a href="https://www.postgresql.org/docs/13/sql-createsubscription.html">https://www.postgresql.org/docs/13/sql-createsubscription.html</a><br>[3] <a href="https://www.enterprisedb.com/postgres-tutorials/logical-replication-postgresql-explained">https://www.enterprisedb.com/postgres-tutorials/logical-replication-postgresql-explained</a><br>[4] <a href="https://www.postgresql.org/docs/13/sql-altersubscription.html">https://www.postgresql.org/docs/13/sql-altersubscription.html</a></p>
<div class="just-for-fun">
笑林广记 - 惯撞席

<p>一乡人做巡捕官，值按院门，太守来见，跪报云：“太老官人进。”<br>按君怒，责之十下。<br>次日太守来，报云：“太公祖进。”<br>按君又责之。<br>至第三日，太守又来，自念乡语不可，通文又不可，乃报云：“前日来的，昨日来的，今日又来了。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 共享表</title>
    <url>/2020/08/postgresql-shared-relations/</url>
    <content><![CDATA[<p>PostgreSQL 数据库中提供的某些系统表是 Cluster 级别共享的，他们在数据库内部被称为 <code>shared_relation</code>，本文就介绍一下 PostgreSQL 是如何创建共享表的。</p>
<span id="more"></span>

<h2 id="SQL-查询"><a href="#SQL-查询" class="headerlink" title="SQL 查询"></a>SQL 查询</h2><p>我们可以通过下面的语句查看系统中提供的共享表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c.oid</span><br><span class="line">    , c.relname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t</span><br><span class="line">        <span class="keyword">ON</span> c.reltablespace <span class="operator">=</span> t.oid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    c.relisshared <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">AND</span> c.relkind <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.oid;</span><br><span class="line"> oid  <span class="operator">|</span>        relname</span><br><span class="line"><span class="comment">------+-----------------------</span></span><br><span class="line"> <span class="number">1136</span> <span class="operator">|</span> pg_pltemplate</span><br><span class="line"> <span class="number">1213</span> <span class="operator">|</span> pg_tablespace</span><br><span class="line"> <span class="number">1214</span> <span class="operator">|</span> pg_shdepend</span><br><span class="line"> <span class="number">1260</span> <span class="operator">|</span> pg_authid</span><br><span class="line"> <span class="number">1261</span> <span class="operator">|</span> pg_auth_members</span><br><span class="line"> <span class="number">1262</span> <span class="operator">|</span> pg_database</span><br><span class="line"> <span class="number">2396</span> <span class="operator">|</span> pg_shdescription</span><br><span class="line"> <span class="number">2964</span> <span class="operator">|</span> pg_db_role_setting</span><br><span class="line"> <span class="number">3592</span> <span class="operator">|</span> pg_shseclabel</span><br><span class="line"> <span class="number">6000</span> <span class="operator">|</span> pg_replication_origin</span><br><span class="line"> <span class="number">6100</span> <span class="operator">|</span> pg_subscription</span><br><span class="line">(<span class="number">11</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>其实除了上述的基本表之外，这些表上的索引和 TOAST 也是共享的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c.oid</span><br><span class="line">    , c.relname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    pg_class c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t</span><br><span class="line">        <span class="keyword">ON</span> c.reltablespace <span class="operator">=</span> t.oid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    c.relisshared <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.oid;</span><br><span class="line"> oid  <span class="operator">|</span>                 relname</span><br><span class="line"><span class="comment">------+-----------------------------------------</span></span><br><span class="line"> <span class="number">1136</span> <span class="operator">|</span> pg_pltemplate</span><br><span class="line"> <span class="number">1137</span> <span class="operator">|</span> pg_pltemplate_name_index</span><br><span class="line"> <span class="number">1213</span> <span class="operator">|</span> pg_tablespace</span><br><span class="line"> <span class="number">1214</span> <span class="operator">|</span> pg_shdepend</span><br><span class="line"> <span class="number">1232</span> <span class="operator">|</span> pg_shdepend_depender_index</span><br><span class="line"> <span class="number">1233</span> <span class="operator">|</span> pg_shdepend_reference_index</span><br><span class="line"> <span class="number">1260</span> <span class="operator">|</span> pg_authid</span><br><span class="line"> <span class="number">1261</span> <span class="operator">|</span> pg_auth_members</span><br><span class="line"> <span class="number">1262</span> <span class="operator">|</span> pg_database</span><br><span class="line"> <span class="number">2396</span> <span class="operator">|</span> pg_shdescription</span><br><span class="line"> <span class="number">2397</span> <span class="operator">|</span> pg_shdescription_o_c_index</span><br><span class="line"> <span class="number">2671</span> <span class="operator">|</span> pg_database_datname_index</span><br><span class="line"> <span class="number">2672</span> <span class="operator">|</span> pg_database_oid_index</span><br><span class="line"> <span class="number">2676</span> <span class="operator">|</span> pg_authid_rolname_index</span><br><span class="line"> <span class="number">2677</span> <span class="operator">|</span> pg_authid_oid_index</span><br><span class="line"> <span class="number">2694</span> <span class="operator">|</span> pg_auth_members_role_member_index</span><br><span class="line"> <span class="number">2695</span> <span class="operator">|</span> pg_auth_members_member_role_index</span><br><span class="line"> <span class="number">2697</span> <span class="operator">|</span> pg_tablespace_oid_index</span><br><span class="line"> <span class="number">2698</span> <span class="operator">|</span> pg_tablespace_spcname_index</span><br><span class="line"> <span class="number">2846</span> <span class="operator">|</span> pg_toast_2396</span><br><span class="line"> <span class="number">2847</span> <span class="operator">|</span> pg_toast_2396_index</span><br><span class="line"> <span class="number">2964</span> <span class="operator">|</span> pg_db_role_setting</span><br><span class="line"> <span class="number">2965</span> <span class="operator">|</span> pg_db_role_setting_databaseid_rol_index</span><br><span class="line"> <span class="number">2966</span> <span class="operator">|</span> pg_toast_2964</span><br><span class="line"> <span class="number">2967</span> <span class="operator">|</span> pg_toast_2964_index</span><br><span class="line"> <span class="number">3592</span> <span class="operator">|</span> pg_shseclabel</span><br><span class="line"> <span class="number">3593</span> <span class="operator">|</span> pg_shseclabel_object_index</span><br><span class="line"> <span class="number">4060</span> <span class="operator">|</span> pg_toast_3592</span><br><span class="line"> <span class="number">4061</span> <span class="operator">|</span> pg_toast_3592_index</span><br><span class="line"> <span class="number">6000</span> <span class="operator">|</span> pg_replication_origin</span><br><span class="line"> <span class="number">6001</span> <span class="operator">|</span> pg_replication_origin_roiident_index</span><br><span class="line"> <span class="number">6002</span> <span class="operator">|</span> pg_replication_origin_roname_index</span><br><span class="line"> <span class="number">6100</span> <span class="operator">|</span> pg_subscription</span><br><span class="line"> <span class="number">6114</span> <span class="operator">|</span> pg_subscription_oid_index</span><br><span class="line"> <span class="number">6115</span> <span class="operator">|</span> pg_subscription_subname_index</span><br><span class="line">(<span class="number">35</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>PostgreSQL 中共享表的都是存储在 pg_global 这个表空间中的。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在源码中，PostgreSQL 通过 <code>IsSharedRelation()</code> 函数来判断表是否为共享表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">IsSharedRelation</span><span class="params">(Oid relationId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* These are the shared catalogs (look for BKI_SHARED_RELATION) */</span></span><br><span class="line">    <span class="keyword">if</span> (relationId == AuthIdRelationId ||</span><br><span class="line">        relationId == AuthMemRelationId ||</span><br><span class="line">        relationId == DatabaseRelationId ||</span><br><span class="line">        relationId == PLTemplateRelationId ||</span><br><span class="line">        relationId == SharedDescriptionRelationId ||</span><br><span class="line">        relationId == SharedDependRelationId ||</span><br><span class="line">        relationId == SharedSecLabelRelationId ||</span><br><span class="line">        relationId == TableSpaceRelationId ||</span><br><span class="line">        relationId == DbRoleSettingRelationId ||</span><br><span class="line">        relationId == ReplicationOriginRelationId ||</span><br><span class="line">        relationId == SubscriptionRelationId)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* These are their indexes (see indexing.h) */</span></span><br><span class="line">    <span class="keyword">if</span> (relationId == AuthIdRolnameIndexId ||</span><br><span class="line">        relationId == AuthIdOidIndexId ||</span><br><span class="line">        relationId == AuthMemRoleMemIndexId ||</span><br><span class="line">        relationId == AuthMemMemRoleIndexId ||</span><br><span class="line">        relationId == DatabaseNameIndexId ||</span><br><span class="line">        relationId == DatabaseOidIndexId ||</span><br><span class="line">        relationId == PLTemplateNameIndexId ||</span><br><span class="line">        relationId == SharedDescriptionObjIndexId ||</span><br><span class="line">        relationId == SharedDependDependerIndexId ||</span><br><span class="line">        relationId == SharedDependReferenceIndexId ||</span><br><span class="line">        relationId == SharedSecLabelObjectIndexId ||</span><br><span class="line">        relationId == TablespaceOidIndexId ||</span><br><span class="line">        relationId == TablespaceNameIndexId ||</span><br><span class="line">        relationId == DbRoleSettingDatidRolidIndexId ||</span><br><span class="line">        relationId == ReplicationOriginIdentIndex ||</span><br><span class="line">        relationId == ReplicationOriginNameIndex ||</span><br><span class="line">        relationId == SubscriptionObjectIndexId ||</span><br><span class="line">        relationId == SubscriptionNameIndexId)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* These are their toast tables and toast indexes (see toasting.h) */</span></span><br><span class="line">    <span class="keyword">if</span> (relationId == PgAuthidToastTable ||</span><br><span class="line">        relationId == PgAuthidToastIndex ||</span><br><span class="line">        relationId == PgDatabaseToastTable ||</span><br><span class="line">        relationId == PgDatabaseToastIndex ||</span><br><span class="line">        relationId == PgDbRoleSettingToastTable ||</span><br><span class="line">        relationId == PgDbRoleSettingToastIndex ||</span><br><span class="line">        relationId == PgPlTemplateToastTable ||</span><br><span class="line">        relationId == PgPlTemplateToastIndex ||</span><br><span class="line">        relationId == PgReplicationOriginToastTable ||</span><br><span class="line">        relationId == PgReplicationOriginToastIndex ||</span><br><span class="line">        relationId == PgShdescriptionToastTable ||</span><br><span class="line">        relationId == PgShdescriptionToastIndex ||</span><br><span class="line">        relationId == PgShseclabelToastTable ||</span><br><span class="line">        relationId == PgShseclabelToastIndex ||</span><br><span class="line">        relationId == PgSubscriptionToastTable ||</span><br><span class="line">        relationId == PgSubscriptionToastIndex ||</span><br><span class="line">        relationId == PgTablespaceToastTable ||</span><br><span class="line">        relationId == PgTablespaceToastIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和我们在上面看到的是一致的。</p>
<p>那么 PostgreSQL 是如何定义共享表的呢？我们知道 PostgreSQL 的系统表都是定义在 <code>src/include/catalog/</code> 目录下。那么我们看看 <code>pg_authid</code> 这个共享表是如何定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CATALOG(pg_authid,1260,AuthIdRelationId) BKI_SHARED_RELATION BKI_ROWTYPE_OID(2842,AuthIdRelation_Rowtype_Id) BKI_SCHEMA_MACRO</span><br><span class="line">&#123;</span><br><span class="line">    Oid         oid;            /* oid */</span><br><span class="line">    NameData    rolname;        /* name of role */</span><br><span class="line">    bool        rolsuper;       /* read this field via superuser() only! */</span><br><span class="line">    bool        rolinherit;     /* inherit privileges from other roles? */</span><br><span class="line">    bool        rolcreaterole;  /* allowed to create more roles? */</span><br><span class="line">    bool        rolcreatedb;    /* allowed to create databases? */</span><br><span class="line">    bool        rolcanlogin;    /* allowed to log in as session user? */</span><br><span class="line">    bool        rolreplication; /* role used for streaming replication */</span><br><span class="line">    bool        rolbypassrls;   /* bypasses row level security? */</span><br><span class="line">    int32       rolconnlimit;   /* max connections allowed (-1=no limit) */</span><br><span class="line"></span><br><span class="line">    /* remaining fields may be null; use heap_getattr to read them! */</span><br><span class="line">#ifdef CATALOG_VARLEN           /* variable-length fields start here */</span><br><span class="line">    text        rolpassword;    /* password, if any */</span><br><span class="line">    timestamptz rolvaliduntil;  /* password expiration time, if any */</span><br><span class="line">#endif</span><br><span class="line">&#125; FormData_pg_authid;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里有一个 <code>BKI_SHARED_RELATION</code> 宏，因此，我们推测只要加上这个宏，那么这个系统表就是共享的。我们可以通过对比其他系统表来进行验证。</p>
<p>所有的系统表定义都将通过 <code>Catalog.pm</code> 来转换为 Perl 中的数据结构，最后通过 <code>genbki.pl</code> 脚步转换为 <code>postgres.bki</code> 文件，而 BKI 文件则用于初始化 PostgreSQL 模版数据库。</p>
<p>例如，<code>pg_authid</code> 经过转换之后在 <code>postgres.bki</code> 中的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create pg_authid 1260 shared_relation rowtype_oid 2842</span><br><span class="line"> (</span><br><span class="line"> oid = oid ,</span><br><span class="line"> rolname = name ,</span><br><span class="line"> rolsuper = bool ,</span><br><span class="line"> rolinherit = bool ,</span><br><span class="line"> rolcreaterole = bool ,</span><br><span class="line"> rolcreatedb = bool ,</span><br><span class="line"> rolcanlogin = bool ,</span><br><span class="line"> rolreplication = bool ,</span><br><span class="line"> rolbypassrls = bool ,</span><br><span class="line"> rolconnlimit = int4 ,</span><br><span class="line"> rolpassword = text ,</span><br><span class="line"> rolvaliduntil = timestamptz</span><br><span class="line"> )</span><br><span class="line">open pg_authid</span><br><span class="line">insert ( 10 POSTGRES t t t t t t t -1 _null_ _null_ )</span><br><span class="line">insert ( 3373 pg_monitor f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 3374 pg_read_all_settings f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 3375 pg_read_all_stats f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 3377 pg_stat_scan_tables f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4569 pg_read_server_files f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4570 pg_write_server_files f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4571 pg_execute_server_program f t f f f f f -1 _null_ _null_ )</span><br><span class="line">insert ( 4200 pg_signal_backend f t f f f f f -1 _null_ _null_ )</span><br><span class="line">close pg_authid</span><br></pre></td></tr></table></figure>

<p>当我们使用 initdb 初始化数据库时，<code>setup_data_file_paths()</code> 函数将会设置 <code>postgres.bki</code> 文件路径，随后通过 <code>initialize_data_directory()</code> 函数调用 <code>bootstrap_template1()</code> 函数来读取 <code>postgres.bki</code> 文件中的内容初始化模版数据库。</p>
<p>最后通过 <code>postgres --boot -x1 -X 16777216 -F</code> 命令来初始化 <code>template1</code> 数据库，在 src/backend/main/main.c 文件中，我们可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--boot&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        AuxiliaryProcessMain(argc, argv);   <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--describe-config&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        GucInfoMain();          <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--single&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        PostgresMain(argc, argv,</span><br><span class="line">                     <span class="literal">NULL</span>,      <span class="comment">/* no dbname */</span></span><br><span class="line">                     strdup(get_user_name_or_exit(progname)));  <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PostmasterMain(argc, argv); <span class="comment">/* does not return */</span></span><br><span class="line">    <span class="built_in">abort</span>();                    <span class="comment">/* should not get here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，在 initdb 的时候执行的是 <code>AuxiliaryProcessMain()</code> 函数，该函数可以用于创建多种类型的辅助进程，例如，Checkpointer、WAL writer 和 WAL receiver 等进程，该函数通过参数 <code>-x num</code> 来创建不同的进程，有如下辅助进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Auxiliary-process type identifiers.  These used to be in bootstrap.h</span></span><br><span class="line"><span class="comment"> * but it seems saner to have them here, with the ProcessingMode stuff.</span></span><br><span class="line"><span class="comment"> * The MyAuxProcType global is defined and set in bootstrap.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NotAnAuxProcess = <span class="number">-1</span>,</span><br><span class="line">    CheckerProcess = <span class="number">0</span>,</span><br><span class="line">    BootstrapProcess,</span><br><span class="line">    StartupProcess,</span><br><span class="line">    BgWriterProcess,</span><br><span class="line">    CheckpointerProcess,</span><br><span class="line">    WalWriterProcess,</span><br><span class="line">    WalReceiverProcess,</span><br><span class="line"></span><br><span class="line">    NUM_AUXPROCTYPES            <span class="comment">/* Must be last! */</span></span><br><span class="line">&#125; AuxProcType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> AuxProcType MyAuxProcType;</span><br></pre></td></tr></table></figure>

<p>从 <code>initdb</code> 中传递过来的参数可以看到，我们的辅助进程类型为 <code>BootstrapProcess</code>，最后执行下面的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AuxiliaryProcessMain(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (MyAuxProcType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CheckerProcess:</span><br><span class="line">            <span class="comment">/* don&#x27;t set signals, they&#x27;re useless here */</span></span><br><span class="line">            CheckerModeMain();</span><br><span class="line">            proc_exit(<span class="number">1</span>);       <span class="comment">/* should never return */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BootstrapProcess:</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * There was a brief instant during which mode was Normal; this is</span></span><br><span class="line"><span class="comment">             * okay.  We need to be in bootstrap mode during BootStrapXLOG for</span></span><br><span class="line"><span class="comment">             * the sake of multixact initialization.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SetProcessingMode(BootstrapProcessing);</span><br><span class="line">            bootstrap_signals();</span><br><span class="line">            BootStrapXLOG();</span><br><span class="line">            BootstrapModeMain();</span><br><span class="line">            proc_exit(<span class="number">1</span>);       <span class="comment">/* should never return */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们关注一下 <code>BootStrapXLOG()</code> 函数，在<a href="/2020/06/postgresql-system-identifier/" title="PostgreSQL 数据库系统标识符">PostgreSQL 数据库系统标识符</a>的文章中我们介绍了这个函数将会创建数据库标识符，此外，他还将创建 <code>pg_control</code> 文件，XLOG 日志文件以及 CLOG 文件。</p>
<p>接着我们看看 <code>BootstrapModeMain()</code> 函数，该函数以 <code>bootstrap</code> 模式运行，并且处理 PostgreSQL 提供的特殊的 <code>bootstrap</code> 语法，即 <code>postgres.bki</code> 文件中的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   The main entry point for running the backend in bootstrap mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The bootstrap mode is used to initialize the template database.</span></span><br><span class="line"><span class="comment"> *   The bootstrap backend doesn&#x27;t speak SQL, but instead expects</span></span><br><span class="line"><span class="comment"> *   commands in a special bootstrap language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">BootstrapModeMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>         i;</span><br><span class="line"></span><br><span class="line">    Assert(!IsUnderPostmaster);</span><br><span class="line">    Assert(IsBootstrapProcessingMode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To ensure that src/common/link-canary.c is linked into the backend, we</span></span><br><span class="line"><span class="comment">     * must call it from somewhere.  Here is as good as anywhere.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pg_link_canary_is_frontend())</span><br><span class="line">        elog(ERROR, <span class="string">&quot;backend is incorrectly linked to frontend functions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do backend-like initialization for bootstrap mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InitProcess();</span><br><span class="line"></span><br><span class="line">    InitPostgres(<span class="literal">NULL</span>, InvalidOid, <span class="literal">NULL</span>, InvalidOid, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize stuff for bootstrap-file processing */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXATTR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        attrtypes[i] = <span class="literal">NULL</span>;</span><br><span class="line">        Nulls[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Process bootstrap input.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    StartTransactionCommand();</span><br><span class="line">    boot_yyparse();</span><br><span class="line">    CommitTransactionCommand();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We should now know about all mapped relations, so it&#x27;s okay to write</span></span><br><span class="line"><span class="comment">     * out the initial relation mapping files.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RelationMapFinishBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up and exit */</span></span><br><span class="line">    cleanup();</span><br><span class="line">    proc_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码的注释我们可以看到整个 <code>postgres.bki</code> 文件的处理是通过 <code>boot_yyparse()</code> 函数来进行的，这个函数是由 <code>bootparse.y</code> 文件提供的，其实就是处理有关 <code>postgres.bki</code> 文件的语法，并将其转化为不同的对象进而调用 PostgreSQL 内部提供的函数。例如，创建 <code>pg_authid</code> 这个系统表，将会执行以下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Boot_CreateStmt:</span><br><span class="line">          XCREATE boot_ident oidspec optbootstrap optsharedrelation optrowtypeoid LPAREN</span><br><span class="line">                &#123;</span><br><span class="line">                    do_start();</span><br><span class="line">                    numattr = <span class="number">0</span>;</span><br><span class="line">                    elog(DEBUG4, <span class="string">&quot;creating%s%s relation %s %u&quot;</span>,</span><br><span class="line">                         $<span class="number">4</span> ? <span class="string">&quot; bootstrap&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         $<span class="number">5</span> ? <span class="string">&quot; shared&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         $<span class="number">2</span>,</span><br><span class="line">                         $<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">          boot_column_list</span><br><span class="line">                &#123;</span><br><span class="line">                    do_end();</span><br><span class="line">                &#125;</span><br><span class="line">          RPAREN</span><br><span class="line">                &#123;</span><br><span class="line">                    TupleDesc tupdesc;</span><br><span class="line">                    <span class="keyword">bool</span>    shared_relation;</span><br><span class="line">                    <span class="keyword">bool</span>    mapped_relation;</span><br><span class="line"></span><br><span class="line">                    do_start();</span><br><span class="line"></span><br><span class="line">                    tupdesc = CreateTupleDesc(numattr, attrtypes);</span><br><span class="line"></span><br><span class="line">                    shared_relation = $<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * The catalogs that use the relation mapper are the</span></span><br><span class="line"><span class="comment">                     * bootstrap catalogs plus the shared catalogs.  If this</span></span><br><span class="line"><span class="comment">                     * ever gets more complicated, we should invent a BKI</span></span><br><span class="line"><span class="comment">                     * keyword to mark the mapped catalogs, but for now a</span></span><br><span class="line"><span class="comment">                     * quick hack seems the most appropriate thing.  Note in</span></span><br><span class="line"><span class="comment">                     * particular that all &quot;nailed&quot; heap rels (see formrdesc</span></span><br><span class="line"><span class="comment">                     * in relcache.c) must be mapped.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    mapped_relation = ($<span class="number">4</span> || shared_relation);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ($<span class="number">4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        TransactionId relfrozenxid;</span><br><span class="line">                        MultiXactId relminmxid;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (boot_reldesc)</span><br><span class="line">                        &#123;</span><br><span class="line">                            elog(DEBUG4, <span class="string">&quot;create bootstrap: warning, open relation exists, closing first&quot;</span>);</span><br><span class="line">                            closerel(<span class="literal">NULL</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        boot_reldesc = heap_create($<span class="number">2</span>,</span><br><span class="line">                                                   PG_CATALOG_NAMESPACE,</span><br><span class="line">                                                   shared_relation ? GLOBALTABLESPACE_OID : <span class="number">0</span>,</span><br><span class="line">                                                   $<span class="number">3</span>,</span><br><span class="line">                                                   InvalidOid,</span><br><span class="line">                                                   HEAP_TABLE_AM_OID,</span><br><span class="line">                                                   tupdesc,</span><br><span class="line">                                                   RELKIND_RELATION,</span><br><span class="line">                                                   RELPERSISTENCE_PERMANENT,</span><br><span class="line">                                                   shared_relation,</span><br><span class="line">                                                   mapped_relation,</span><br><span class="line">                                                   <span class="literal">true</span>,</span><br><span class="line">                                                   &amp;relfrozenxid,</span><br><span class="line">                                                   &amp;relminmxid);</span><br><span class="line">                        elog(DEBUG4, <span class="string">&quot;bootstrap relation created&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Oid id;</span><br><span class="line"></span><br><span class="line">                        id = heap_create_with_catalog($<span class="number">2</span>,</span><br><span class="line">                                                      PG_CATALOG_NAMESPACE,</span><br><span class="line">                                                      shared_relation ? GLOBALTABLESPACE_OID : <span class="number">0</span>,</span><br><span class="line">                                                      $<span class="number">3</span>,</span><br><span class="line">                                                      $<span class="number">6</span>,</span><br><span class="line">                                                      InvalidOid,</span><br><span class="line">                                                      BOOTSTRAP_SUPERUSERID,</span><br><span class="line">                                                      HEAP_TABLE_AM_OID,</span><br><span class="line">                                                      tupdesc,</span><br><span class="line">                                                      NIL,</span><br><span class="line">                                                      RELKIND_RELATION,</span><br><span class="line">                                                      RELPERSISTENCE_PERMANENT,</span><br><span class="line">                                                      shared_relation,</span><br><span class="line">                                                      mapped_relation,</span><br><span class="line">                                                      ONCOMMIT_NOOP,</span><br><span class="line">                                                      (Datum) <span class="number">0</span>,</span><br><span class="line">                                                      <span class="literal">false</span>,</span><br><span class="line">                                                      <span class="literal">true</span>,</span><br><span class="line">                                                      <span class="literal">false</span>,</span><br><span class="line">                                                      InvalidOid,</span><br><span class="line">                                                      <span class="literal">NULL</span>);</span><br><span class="line">                        elog(DEBUG4, <span class="string">&quot;relation created with OID %u&quot;</span>, id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    do_end();</span><br><span class="line">                &#125;</span><br><span class="line">        ;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到 <code>postgres.bki</code> 中的表也是通过 <code>heap_create_with_catalog()</code> 函数来创建的。需要注意的是，我们在通过 SQL 创建表的时候虽然也是通过 <code>heap_create_with_catalog()</code> 来新建表的，但是其参数 <code>shared_relation</code> 始终为 <code>false</code>。</p>
<p>PostgreSQL 的 BKI 文件提供了一下几种基本都命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create - 创建一个表</span><br><span class="line">open - 打开一个表</span><br><span class="line">close - 关闭一个表</span><br><span class="line">declare toast - 创建 TOAST 表</span><br><span class="line">insert - 向表中插入数据</span><br><span class="line">declare index - 声明索引</span><br><span class="line">declare unique index - 声明唯一性索引</span><br><span class="line">build indices - 创建索引</span><br></pre></td></tr></table></figure>
<p>关于各个命令的语法这里就不详细介绍了，感兴趣的朋友可以去看 <code>postgres.bki</code> 和 <code>bootstrap.y</code> 文件。至此，我们对 PostgreSQL 中的共享表的创建有了一个粗略的认识。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 同步逻辑复制 TRUNCATE 表 hang 住</title>
    <url>/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/</url>
    <content><![CDATA[<p>在目前的 PostgreSQL 13 中，如果我们采用同步逻辑复制，那么在同步 TRUNCATE 表时，可能会发生数据库 hang 住的可能。本文便是针对这一问题进行分析。</p>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>这个问题来自于 <a href="https://www.postgresql.org/message-id/OS0PR01MB6113C2499C7DC70EE55ADB82FB759%40OS0PR01MB6113.jpnprd01.prod.outlook.com">PostgresSQL 邮件列表</a>，下面我们来复现一下这个问题（此处我使用的时 <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=409723365b2708acd3bdf2e830257504bdefac4b">pg 14devel</a> 进行复现）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ -- 配置主节点</span><br><span class="line">$ initdb -D pubdb</span><br><span class="line">$ cat &lt;&lt; END &gt;&gt; pubdb/postgresql.auto.conf</span><br><span class="line">port = &#x27;5433&#x27;</span><br><span class="line">wal_level = &#x27;logical&#x27;</span><br><span class="line">wal_sender_timeout = &#x27;0&#x27;</span><br><span class="line">wal_receiver_timeout = &#x27;0&#x27;</span><br><span class="line">END</span><br><span class="line">$ pg_ctl -l pub.log -D pubdb start</span><br><span class="line"></span><br><span class="line">$ -- 配置从节点</span><br><span class="line">$ initdb -D subdb</span><br><span class="line">$ cat &lt;&lt; END &gt;&gt; subdb/postgresql.auto.conf</span><br><span class="line">port = &#x27;5434&#x27;</span><br><span class="line">wal_level = &#x27;logical&#x27;</span><br><span class="line">wal_sender_timeout = &#x27;0&#x27;</span><br><span class="line">wal_receiver_timeout = &#x27;0&#x27;</span><br><span class="line">END</span><br><span class="line">$ pg_ctl -l sub.log -D subdb start</span><br></pre></td></tr></table></figure>

<p>这里设置 <code>wal_sender_timeout</code> 和 <code>wal_receiver_timeout</code> 主要时为了方便调试。</p>
<p>接着，我们创建一个两个表用于逻辑复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 主节点创建表和发布者</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;CREATE TABLE tbl1 (a int primary key);&#x27; -c &#x27;CREATE TABLE tbl2 (a int);&#x27;</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;CREATE PUBLICATION pub FOR TABLE tbl1, tbl2;&#x27;</span><br><span class="line"></span><br><span class="line">-- 从节点创建表和订阅者</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;CREATE TABLE tbl1 (a int primary key);&#x27; -c &#x27;CREATE TABLE tbl2 (a int);&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &quot;CREATE SUBSCRIPTION sub CONNECTION &#x27;dbname=postgres port=5433&#x27; PUBLICATION pub;&quot;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>CREATE SUBSCRIPTION</code> 命令会在主节点创建一个与其同名的复制槽。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl1 VALUES (1);&#x27;</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl2 VALUES (1);&#x27;</span><br><span class="line"></span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line"> 1</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line"> 1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>我们在主节点执行 <code>TRUNCATE</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl2;&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl1;&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure>

<p>上面时异步模式的逻辑复制，下面我们来测试一下同步情况下的逻辑复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &quot;ALTER SYSTEM SET synchronous_standby_names TO &#x27;sub&#x27;;&quot;</span><br><span class="line">$ psql -p 5433 postgres -c &quot;SELECT pg_reload_conf();&quot;</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl2 VALUES (10);&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">----</span><br><span class="line"> 10</span><br><span class="line">(1 row)</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl2;&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl1 VALUES (10);&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">----</span><br><span class="line"> 10</span><br><span class="line">(1 row)</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl1;&#x27;</span><br><span class="line">hang 住了</span><br><span class="line"></span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">----</span><br><span class="line"> 10</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>我们来看一下数据库中的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;SELECT * FROM pg_locks;&#x27;</span><br><span class="line">   locktype    | database | relation | page | tuple | virtualxid | transactionid | classid | objid | objsubid | virtualtransaction |  pid  |        mode         | granted | fastpath |           waitstart</span><br><span class="line">---------------+----------+----------+------+-------+------------+---------------+---------+-------+----------+--------------------+-------+---------------------+---------+----------+-------------------------------</span><br><span class="line"> relation      |    14016 |    13289 |      |       |            |               |         |       |          | 5/19               | 21612 | AccessShareLock     | t       | t        |</span><br><span class="line"> virtualxid    |          |          |      |       | 5/19       |               |         |       |          | 5/19               | 21612 | ExclusiveLock       | t       | t        |</span><br><span class="line"> virtualxid    |          |          |      |       | 4/49       |               |         |       |          | 4/49               | 21133 | ExclusiveLock       | t       | t        |</span><br><span class="line"> virtualxid    |          |          |      |       | 3/29       |               |         |       |          | 3/29               | 19592 | ExclusiveLock       | t       | t        |</span><br><span class="line"> relation      |    14016 |    16387 |      |       |            |               |         |       |          | 3/29               | 19592 | AccessShareLock     | f       | f        | 2021-04-16 16:51:16.268573+08</span><br><span class="line"> relation      |    14016 |    16387 |      |       |            |               |         |       |          | 4/49               | 21133 | AccessExclusiveLock | t       | f        |</span><br><span class="line"> relation      |    14016 |    16384 |      |       |            |               |         |       |          | 4/49               | 21133 | ShareLock           | t       | f        |</span><br><span class="line"> relation      |    14016 |    16384 |      |       |            |               |         |       |          | 4/49               | 21133 | AccessExclusiveLock | t       | f        |</span><br><span class="line"> transactionid |          |          |      |       |            |           553 |         |       |          | 4/49               | 21133 | ExclusiveLock       | t       | f        |</span><br><span class="line"></span><br><span class="line">$ ps -ef | grep postgres</span><br><span class="line">japin    18477     1  0 16:32 ?        00:00:00 /home/japin/Codes/postgres/Debug/pg/bin/postgres -D pubdb</span><br><span class="line">japin    18479 18477  0 16:32 ?        00:00:00 postgres: checkpointer</span><br><span class="line">japin    18480 18477  0 16:32 ?        00:00:00 postgres: background writer</span><br><span class="line">japin    18481 18477  0 16:32 ?        00:00:00 postgres: walwriter</span><br><span class="line">japin    18482 18477  0 16:32 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">japin    18483 18477  0 16:32 ?        00:00:00 postgres: stats collector</span><br><span class="line">japin    18484 18477  0 16:32 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">japin    18646     1  0 16:33 ?        00:00:00 /home/japin/Codes/postgres/Debug/pg/bin/postgres -D subdb</span><br><span class="line">japin    18648 18646  0 16:33 ?        00:00:00 postgres: checkpointer</span><br><span class="line">japin    18649 18646  0 16:33 ?        00:00:00 postgres: background writer</span><br><span class="line">japin    18650 18646  0 16:33 ?        00:00:00 postgres: walwriter</span><br><span class="line">japin    18651 18646  0 16:33 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">japin    18652 18646  0 16:33 ?        00:00:00 postgres: stats collector</span><br><span class="line">japin    18653 18646  0 16:33 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">japin    19590 18646  0 16:40 ?        00:00:00 postgres: logical replication worker for subscription 16392</span><br><span class="line">japin    19592 18477  0 16:40 ?        00:00:00 postgres: walsender japin [local] START_REPLICATION waiting</span><br><span class="line">japin    21132 32595  0 16:51 pts/7    00:00:00 psql -p 5433 postgres -c TRUNCATE tbl1;</span><br><span class="line">japin    21133 18477  0 16:51 ?        00:00:00 postgres: japin postgres [local] TRUNCATE TABLE waiting for 0/1632600</span><br><span class="line">japin    21670  2878  0 16:55 pts/8    00:00:00 grep --color=auto postgres</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;SELECT pg_blocking_pids(&#x27;19592&#x27;);&#x27;</span><br><span class="line"> pg_blocking_pids</span><br><span class="line">------------------</span><br><span class="line"> &#123;21133&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，进程 <code>21133</code> 是执行 <code>TRUNCATE</code> 命令的进程，由于是同步提交，因此它在等待来自从节点的回应，此时进程 <code>19592</code>（walsender 进程）需要获取 <code>14016/16387</code> 上的 <code>AccessShareLock</code> 锁，而进程 <code>21133</code> 在 <code>14016/16387</code> 上持有了 <code>AccessExclusiveLock</code> 锁，因此导致 walsender 进程无法获取锁，这就导致的整个进程 hang 住了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;SELECT relname, relkind FROM pg_class WHERE oid = 16387;&#x27;</span><br><span class="line">  relname  | relkind</span><br><span class="line">-----------+---------</span><br><span class="line"> tbl1_pkey | i</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>14016/16387</code> 对应的就是 <code>tbl1</code> 上的主键索引。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里需要弄清楚为什么 <code>tbl1</code> 别阻塞了，而 <code>tbl2</code> 没有被阻塞。它们的唯一区别是 <code>tbl1</code> 有一个主键索引，在逻辑复制中，它将被作为逻辑复制的 <a href="https://www.postgresql.org/docs/devel/sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY">Replica Identity</a>，可以推测是否是这个原因导致的呢？</p>
<p>我们使用 gdb 附加到 walsender 其调用栈如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007f296071da07 in epoll_wait (epfd=12, events=0x55af98fb9d18, maxevents=1, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line">#1  0x000055af97aa3731 in WaitEventSetWaitBlock (set=0x55af98fb9cb8, cur_timeout=-1, occurred_events=0x7fffbc568a90, nevents=1) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1452</span><br><span class="line">#2  0x000055af97aa35ac in WaitEventSetWait (set=0x55af98fb9cb8, timeout=-1, occurred_events=0x7fffbc568a90, nevents=1, wait_event_info=50331648) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1398</span><br><span class="line">#3  0x000055af97aa290f in WaitLatch (latch=0x7f295fbf4414, wakeEvents=33, timeout=0, wait_event_info=50331648) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:473</span><br><span class="line">#4  0x000055af97ace672 in ProcSleep (locallock=0x55af98fdeb28, lockMethodTable=0x55af981ba820 &lt;default_lockmethod&gt;) at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/proc.c:1361</span><br><span class="line">#5  0x000055af97abc12f in WaitOnLock (locallock=0x55af98fdeb28, owner=0x55af99039de0) at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/lock.c:1858</span><br><span class="line">#6  0x000055af97ababff in LockAcquireExtended (locktag=0x7fffbc568e50, lockmode=1, sessionLock=false, dontWait=false, reportMemoryError=true, locallockp=0x7fffbc568e48)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/lock.c:1100</span><br><span class="line">#7  0x000055af97ab7a0e in LockRelationOid (relid=16387, lockmode=1) at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/lmgr.c:117</span><br><span class="line">#8  0x000055af975afa9e in relation_open (relationId=16387, lockmode=1) at /home/japin/Codes/postgres/Debug/../src/backend/access/common/relation.c:56</span><br><span class="line">#9  0x000055af9763c76e in index_open (relationId=16387, lockmode=1) at /home/japin/Codes/postgres/Debug/../src/backend/access/index/indexam.c:136</span><br><span class="line">#10 0x000055af97c7be60 in RelationGetIndexAttrBitmap (relation=0x7f2961ce9648, attrKind=INDEX_ATTR_BITMAP_IDENTITY_KEY) at /home/japin/Codes/postgres/Debug/../src/backend/utils/cache/relcache.c:5063</span><br><span class="line">#11 0x000055af97a362b1 in logicalrep_write_attrs (out=0x55af990887d0, rel=0x7f2961ce9648) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/proto.c:671</span><br><span class="line">#12 0x000055af97a35952 in logicalrep_write_rel (out=0x55af990887d0, xid=0, rel=0x7f2961ce9648) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/proto.c:418</span><br><span class="line">#13 0x00007f2956c8f7c5 in send_relation_and_attrs (relation=0x7f2961ce9648, xid=0, ctx=0x55af99080450) at /home/japin/Codes/postgres/Debug/../src/backend/replication/pgoutput/pgoutput.c:502</span><br><span class="line">#14 0x00007f2956c8f6a1 in maybe_send_schema (ctx=0x55af99080450, txn=0x55af990ad658, change=0x55af990b69a8, relation=0x7f2961ce9648, relentry=0x55af9909a218)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/pgoutput/pgoutput.c:460</span><br><span class="line">#15 0x00007f2956c8fe13 in pgoutput_truncate (ctx=0x55af99080450, txn=0x55af990ad658, nrelations=1, relations=0x55af990b4608, change=0x55af990b69a8) at /home/japin/Codes/postgres/Debug/../src/backend/replication/pgoutput/pgoutput.c:691</span><br><span class="line">#16 0x000055af97a2f8fe in truncate_cb_wrapper (cache=0x55af99082460, txn=0x55af990ad658, nrelations=1, relations=0x55af990b4608, change=0x55af990b69a8) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/logical.c:1089</span><br><span class="line">#17 0x000055af97a3adbc in ReorderBufferApplyTruncate (rb=0x55af99082460, txn=0x55af990ad658, nrelations=1, relations=0x55af990b4608, change=0x55af990b69a8, streaming=false)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:1910</span><br><span class="line">#18 0x000055af97a3b910 in ReorderBufferProcessTXN (rb=0x55af99082460, txn=0x55af990ad658, commit_lsn=23274800, snapshot_now=0x55af99082678, command_id=2, streaming=false)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:2270</span><br><span class="line">#19 0x000055af97a3c147 in ReorderBufferReplay (txn=0x55af990ad658, rb=0x55af99082460, xid=553, commit_lsn=23274800, end_lsn=23275008, commit_time=671878276266624, origin_id=0, origin_lsn=0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:2568</span><br><span class="line">#20 0x000055af97a3c1c5 in ReorderBufferCommit (rb=0x55af99082460, xid=553, commit_lsn=23274800, end_lsn=23275008, commit_time=671878276266624, origin_id=0, origin_lsn=0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:2592</span><br><span class="line">#21 0x000055af97a2a8e3 in DecodeCommit (ctx=0x55af99080450, buf=0x7fffbc5696c0, parsed=0x7fffbc569560, xid=553, two_phase=false) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/decode.c:744</span><br><span class="line">#22 0x000055af97a29be6 in DecodeXactOp (ctx=0x55af99080450, buf=0x7fffbc5696c0) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/decode.c:278</span><br><span class="line">#23 0x000055af97a297ff in LogicalDecodingProcessRecord (ctx=0x55af99080450, record=0x55af99080810) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/decode.c:142</span><br><span class="line">#24 0x000055af97a674e7 in XLogSendLogical () at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:2865</span><br><span class="line">#25 0x000055af97a666d3 in WalSndLoop (send_data=0x55af97a67408 &lt;XLogSendLogical&gt;) at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:2290</span><br><span class="line">#26 0x000055af97a6505f in StartLogicalReplication (cmd=0x55af99046958) at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:1207</span><br><span class="line">#27 0x000055af97a659f7 in exec_replication_command (cmd_string=0x55af98fc0f20 &quot;START_REPLICATION SLOT \&quot;sub\&quot; LOGICAL 0/0 (proto_version &#x27;2&#x27;, publication_names &#x27;\&quot;pub\&quot;&#x27;)&quot;)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:1647</span><br><span class="line">#28 0x000055af97addd72 in PostgresMain (argc=1, argv=0x7fffbc5699d0, dbname=0x55af98fecbe8 &quot;postgres&quot;, username=0x55af98fecbc8 &quot;japin&quot;) at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:4454</span><br><span class="line">#29 0x000055af97a0c450 in BackendRun (port=0x55af98fe46f0) at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4483</span><br><span class="line">#30 0x000055af97a0bcfe in BackendStartup (port=0x55af98fe46f0) at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4205</span><br><span class="line">#31 0x000055af97a07e10 in ServerLoop () at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1737</span><br><span class="line">#32 0x000055af97a075c1 in PostmasterMain (argc=3, argv=0x55af98fb96c0) at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1409</span><br><span class="line">#33 0x000055af978fd9d7 in main (argc=3, argv=0x55af98fb96c0) at /home/japin/Codes/postgres/Debug/../src/backend/main/main.c:209</span><br></pre></td></tr></table></figure>

<p>从堆栈可以看到 <code>logicalrep_write_attrs()</code> 函数调用 <code>RelationGetIndexAttrBitmap()</code> 函数并在其内部调用 <code>index_open()</code> 中打开索引时无法获取锁，从而导致进程 hang 住。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">logicalrep_write_attrs(StringInfo out, Relation rel)</span><br><span class="line">&#123;</span><br><span class="line">    TupleDesc   desc;</span><br><span class="line">    int         i;</span><br><span class="line">    uint16      nliveatts = 0;</span><br><span class="line">    Bitmapset  *idattrs = NULL;</span><br><span class="line">    bool        replidentfull;</span><br><span class="line"></span><br><span class="line">    desc = RelationGetDescr(rel);</span><br><span class="line"></span><br><span class="line">    /* send number of live attributes */</span><br><span class="line">    for (i = 0; i &lt; desc-&gt;natts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (TupleDescAttr(desc, i)-&gt;attisdropped || TupleDescAttr(desc, i)-&gt;attgenerated)</span><br><span class="line">            continue;</span><br><span class="line">        nliveatts++;</span><br><span class="line">    &#125;</span><br><span class="line">    pq_sendint16(out, nliveatts);</span><br><span class="line"></span><br><span class="line">    /* fetch bitmap of REPLICATION IDENTITY attributes */</span><br><span class="line">    replidentfull = (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL);</span><br><span class="line">    if (!replidentfull)</span><br><span class="line">        idattrs = RelationGetIndexAttrBitmap(rel,</span><br><span class="line">                                             INDEX_ATTR_BITMAP_IDENTITY_KEY);</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看到到不为 <code>REPLICA_IDENTITY_FULL</code> 时，我们需要调用 <code>RelationGetIndexAttrBitmap()</code> 函数来获取 Replica Identity 属性，<code>tbl2</code> 表在执行时由于没有调用 <code>RelationGetIndexAttrBitmap()</code> 所以不会 hang 住。</p>
<p>我们看看 <code>21133</code> 进程的堆栈，可以发现其阻塞在 <code>SyncRepWaitForLSN()</code> 函数调用中，该函数用于等待从节点对于当前事务的提交状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007f296071da07 in epoll_wait (epfd=12, events=0x55af98fb9d18, maxevents=1, timeout=-1)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line">#1  0x000055af97aa3731 in WaitEventSetWaitBlock (set=0x55af98fb9cb8, cur_timeout=-1, occurred_events=0x7fffbc5695e0,</span><br><span class="line">    nevents=1) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1452</span><br><span class="line">#2  0x000055af97aa35ac in WaitEventSetWait (set=0x55af98fb9cb8, timeout=-1, occurred_events=0x7fffbc5695e0,</span><br><span class="line">    nevents=1, wait_event_info=134217771) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1398</span><br><span class="line">#3  0x000055af97aa290f in WaitLatch (latch=0x7f295fbef874, wakeEvents=17, timeout=-1, wait_event_info=134217771)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:473</span><br><span class="line">#4  0x000055af97a5b667 in SyncRepWaitForLSN (lsn=23275008, commit=true)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/syncrep.c:296</span><br><span class="line">#5  0x000055af976a11d8 in RecordTransactionCommit ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/access/transam/xact.c:1456</span><br><span class="line">#6  0x000055af976a1e52 in CommitTransaction ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/access/transam/xact.c:2188</span><br><span class="line">#7  0x000055af976a2bef in CommitTransactionCommand ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/access/transam/xact.c:2965</span><br><span class="line">#8  0x000055af97adbae4 in finish_xact_command ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:2703</span><br><span class="line">#9  0x000055af97ad9282 in exec_simple_query (query_string=0x55af98fc0f20 &quot;TRUNCATE tbl1;&quot;)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:1221</span><br><span class="line">#10 0x000055af97addd99 in PostgresMain (argc=1, argv=0x7fffbc5699d0, dbname=0x55af98ff4448 &quot;postgres&quot;,</span><br><span class="line">    username=0x55af98ff4428 &quot;japin&quot;) at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:4458</span><br><span class="line">#11 0x000055af97a0c450 in BackendRun (port=0x55af98fe6ac0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4483</span><br><span class="line">#12 0x000055af97a0bcfe in BackendStartup (port=0x55af98fe6ac0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4205</span><br><span class="line">#13 0x000055af97a07e10 in ServerLoop ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1737</span><br><span class="line">#14 0x000055af97a075c1 in PostmasterMain (argc=3, argv=0x55af98fb96c0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1409</span><br><span class="line">#15 0x000055af978fd9d7 in main (argc=3, argv=0x55af98fb96c0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/main/main.c:209</span><br></pre></td></tr></table></figure>

<p>事务持用的锁当执行完 <code>RecordTransactionCommit()</code> 函数后，将由 <code>CommitTransaction()</code> 调用 <code>ResourceOwnerRelease(RESOURCE_RELEASE_LOCKS)</code> 来释放锁资源。</p>
<p>那么为什么在异步的情况下不会出现这种情况呢？这就需要理解 PostgreSQL 的同步复制，当异步复制时，PostgreSQL 并不会等待从节点的回应，因此锁可以得到释放。然而在同步模式下，从上面可以看出其没有机会释放锁，从而导致 walsender 进程无法获取锁。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然锁是由执行 <code>TRUNCATE</code> 命令的进程持有，从下面的代码可以看到 <code>TRUNCATE</code> 进程在等待来自从节点的响应时，WAL 日志其实已经刷盘了。那么我们是否可以在等待从节点之前释放锁资源呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static TransactionId</span><br><span class="line">RecordTransactionCommit(void)</span><br><span class="line">&#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">    if ((wrote_xlog &amp;&amp; markXidCommitted &amp;&amp;</span><br><span class="line">         synchronous_commit &gt; SYNCHRONOUS_COMMIT_OFF) ||</span><br><span class="line">        forceSyncCommit || nrels &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        XLogFlush(XactLastRecEnd);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Now we may update the CLOG, if we wrote a COMMIT record above</span><br><span class="line">         */</span><br><span class="line">        if (markXidCommitted)</span><br><span class="line">            TransactionIdCommitTree(xid, nchildren, children);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Asynchronous commit case:</span><br><span class="line">         *</span><br><span class="line">         * This enables possible committed transaction loss in the case of a</span><br><span class="line">         * postmaster crash because WAL buffers are left unwritten. Ideally we</span><br><span class="line">         * could issue the WAL write without the fsync, but some</span><br><span class="line">         * wal_sync_methods do not allow separate write/fsync.</span><br><span class="line">         *</span><br><span class="line">         * Report the latest async commit LSN, so that the WAL writer knows to</span><br><span class="line">         * flush this commit.</span><br><span class="line">         */</span><br><span class="line">        XLogSetAsyncXactLSN(XactLastRecEnd);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * We must not immediately update the CLOG, since we didn&#x27;t flush the</span><br><span class="line">         * XLOG. Instead, we store the LSN up to which the XLOG must be</span><br><span class="line">         * flushed before the CLOG may be updated.</span><br><span class="line">         */</span><br><span class="line">        if (markXidCommitted)</span><br><span class="line">            TransactionIdAsyncCommitTree(xid, nchildren, children, XactLastRecEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Wait for synchronous replication, if required. Similar to the decision</span><br><span class="line">     * above about using committing asynchronously we only want to wait if</span><br><span class="line">     * this backend assigned an xid and wrote WAL.  No need to wait if an xid</span><br><span class="line">     * was assigned due to temporary/unlogged tables or due to HOT pruning.</span><br><span class="line">     *</span><br><span class="line">     * Note that at this stage we have marked clog, but still show as running</span><br><span class="line">     * in the procarray and continue to hold locks.</span><br><span class="line">     */</span><br><span class="line">    if (wrote_xlog &amp;&amp; markXidCommitted)</span><br><span class="line">        SyncRepWaitForLSN(XactLastRecEnd, true);</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，这样做是可以的，它能解决同步流复制下 <code>TRUNCATE</code> 被 hang 的问题，同时整个数据库的测试（<code>make check-world</code>）也可以通过。那么是否就意味这样解决就可以了呢？</p>
<p>上面的解决方案其实就有点类似于头痛医头、脚痛医脚的感觉。这个方案基本上都没有入了社区大神的眼，那么大神们是怎么解决的呢？其实这样的场景存在同步流复制中，那么为什么同步流复制下没有这个问题呢？基于此，Amit Kapila 给出的建议是我们是否可以避免调用 <code>index_open()</code> 函数来打开索引，而是使用缓存中的对象来获取逻辑复制的 Replica Identity，即通过 <code>RelationIdGetRelation()</code> 函数来获取表对象构建 Replica Identity。</p>
<p>下面是一个简单的 POC 测试修改补丁，经过测试其能够修复这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/src/backend/utils/cache/relcache.c b/src/backend/utils/cache/relcache.c</span><br><span class="line">index 29702d6eab..0ad59ef189 100644</span><br><span class="line">--- a/src/backend/utils/cache/relcache.c</span><br><span class="line">+++ b/src/backend/utils/cache/relcache.c</span><br><span class="line">@@ -5060,7 +5060,7 @@ restart:</span><br><span class="line">                bool            isPK;           /* primary key */</span><br><span class="line">                bool            isIDKey;        /* replica identity index */</span><br><span class="line"></span><br><span class="line">-               indexDesc = index_open(indexOid, AccessShareLock);</span><br><span class="line">+               indexDesc = RelationIdGetRelation(indexOid);</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                 * Extract index expressions and index predicate.  Note: Don&#x27;t use</span><br><span class="line">@@ -5134,7 +5134,7 @@ restart:</span><br><span class="line">                /* Collect all attributes in the index predicate, too */</span><br><span class="line">                pull_varattnos(indexPredicate, 1, &amp;indexattrs);</span><br><span class="line"></span><br><span class="line">-               index_close(indexDesc, AccessShareLock);</span><br><span class="line">+               RelationClose(indexDesc);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>RelationGetIndexAttrBitmap()</code> 函数会被其他函数调用，因此这样修改可能会引起其他部分的问题，Amit Kapila 建议单独弄一个函数来实现该功能，目前补丁正在由 Takamichi Osumi 进行更新，后续 review 之后应该就会合并到 14 分支中，至于会不会 backpatch 到其他分支还有待后续。</p>
<h2 id="2021-04-27-更新"><a href="#2021-04-27-更新" class="headerlink" title="2021-04-27 更新"></a>2021-04-27 更新</h2><p>目前，代码已经合并到主分支，并没有 backpatch 到其他分支，下面是 patch 的部分内容。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/replication/logical/proto.c b/src/backend/replication/logical/proto.c</span></span><br><span class="line"><span class="comment">index 2a1f983..1cf59e0 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/replication/logical/proto.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/replication/logical/proto.c</span></span><br><span class="line"><span class="meta">@@ -668,8 +668,7 @@</span> logicalrep_write_attrs(StringInfo out, Relation rel)</span><br><span class="line"> 	/* fetch bitmap of REPLICATION IDENTITY attributes */</span><br><span class="line"> 	replidentfull = (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL);</span><br><span class="line"> 	if (!replidentfull)</span><br><span class="line"><span class="deletion">-		idattrs = RelationGetIndexAttrBitmap(rel,</span></span><br><span class="line"><span class="deletion">-											 INDEX_ATTR_BITMAP_IDENTITY_KEY);</span></span><br><span class="line"><span class="addition">+		idattrs = RelationGetIdentityKeyBitmap(rel);</span></span><br><span class="line"> </span><br><span class="line"> 	/* send the attributes */</span><br><span class="line"> 	for (i = 0; i &lt; desc-&gt;natts; i++)</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/cache/relcache.c b/src/backend/utils/cache/relcache.c</span></span><br><span class="line"><span class="comment">index 29702d6..316a256 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/cache/relcache.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/cache/relcache.c</span></span><br><span class="line"><span class="meta">@@ -5207,6 +5207,81 @@</span> restart:</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"><span class="addition">+ * RelationGetIdentityKeyBitmap -- get a bitmap of replica identity attribute</span></span><br><span class="line"><span class="addition">+ * numbers</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * A bitmap of index attribute numbers for the configured replica identity</span></span><br><span class="line"><span class="addition">+ * index is returned.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * See also comments of RelationGetIndexAttrBitmap().</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * This is a special purpose function used during logical replication. Here,</span></span><br><span class="line"><span class="addition">+ * unlike RelationGetIndexAttrBitmap(), we don&#x27;t acquire a lock on the required</span></span><br><span class="line"><span class="addition">+ * index as we build the cache entry using a historic snapshot and all the</span></span><br><span class="line"><span class="addition">+ * later changes are absorbed while decoding WAL. Due to this reason, we don&#x27;t</span></span><br><span class="line"><span class="addition">+ * need to retry here in case of a change in the set of indexes.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+Bitmapset *</span></span><br><span class="line"><span class="addition">+RelationGetIdentityKeyBitmap(Relation relation)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	Bitmapset  *idindexattrs = NULL;	/* columns in the replica identity */</span></span><br><span class="line"><span class="addition">+	List	   *indexoidlist;</span></span><br><span class="line"><span class="addition">+	Relation	indexDesc;</span></span><br><span class="line"><span class="addition">+	int			i;</span></span><br><span class="line"><span class="addition">+	MemoryContext oldcxt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Quick exit if we already computed the result */</span></span><br><span class="line"><span class="addition">+	if (relation-&gt;rd_idattr != NULL)</span></span><br><span class="line"><span class="addition">+		return bms_copy(relation-&gt;rd_idattr);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Fast path if definitely no indexes */</span></span><br><span class="line"><span class="addition">+	if (!RelationGetForm(relation)-&gt;relhasindex)</span></span><br><span class="line"><span class="addition">+		return NULL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Historic snapshot must be set. */</span></span><br><span class="line"><span class="addition">+	Assert(HistoricSnapshotActive());</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	indexoidlist = RelationGetIndexList(relation);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Fall out if no indexes (but relhasindex was set) */</span></span><br><span class="line"><span class="addition">+	if (indexoidlist == NIL)</span></span><br><span class="line"><span class="addition">+		return NULL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Build attributes to idindexattrs by collecting attribute references */</span></span><br><span class="line"><span class="addition">+	indexDesc = RelationIdGetRelation(relation-&gt;rd_replidindex);</span></span><br><span class="line"><span class="addition">+	for (i = 0; i &lt; indexDesc-&gt;rd_index-&gt;indnatts; i++)</span></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		int			attrnum = indexDesc-&gt;rd_index-&gt;indkey.values[i];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		/*</span></span><br><span class="line"><span class="addition">+		 * We don&#x27;t include non-key columns into idindexattrs bitmaps. See</span></span><br><span class="line"><span class="addition">+		 * RelationGetIndexAttrBitmap.</span></span><br><span class="line"><span class="addition">+		 */</span></span><br><span class="line"><span class="addition">+		if (attrnum != 0)</span></span><br><span class="line"><span class="addition">+		&#123;</span></span><br><span class="line"><span class="addition">+			if (i &lt; indexDesc-&gt;rd_index-&gt;indnkeyatts)</span></span><br><span class="line"><span class="addition">+				idindexattrs = bms_add_member(idindexattrs,</span></span><br><span class="line"><span class="addition">+											  attrnum - FirstLowInvalidHeapAttributeNumber);</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	RelationClose(indexDesc);</span></span><br><span class="line"><span class="addition">+	list_free(indexoidlist);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Don&#x27;t leak the old values of these bitmaps, if any */</span></span><br><span class="line"><span class="addition">+	bms_free(relation-&gt;rd_idattr);</span></span><br><span class="line"><span class="addition">+	relation-&gt;rd_idattr = NULL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Now save copy of the bitmap in the relcache entry */</span></span><br><span class="line"><span class="addition">+	oldcxt = MemoryContextSwitchTo(CacheMemoryContext);</span></span><br><span class="line"><span class="addition">+	relation-&gt;rd_idattr = bms_copy(idindexattrs);</span></span><br><span class="line"><span class="addition">+	MemoryContextSwitchTo(oldcxt);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* We return our original working copy for caller to play with */</span></span><br><span class="line"><span class="addition">+	return idindexattrs;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line">  * RelationGetExclusionInfo -- get info about index&#x27;s exclusion constraint</span><br><span class="line">  *</span><br><span class="line">  * This should be called only for an index that is known to have an</span><br><span class="line"><span class="comment">diff --git a/src/include/utils/relcache.h b/src/include/utils/relcache.h</span></span><br><span class="line"><span class="comment">index 2fcdf79..f772855 100644</span></span><br><span class="line"><span class="comment">--- a/src/include/utils/relcache.h</span></span><br><span class="line"><span class="comment">+++ b/src/include/utils/relcache.h</span></span><br><span class="line"><span class="meta">@@ -65,6 +65,8 @@</span> typedef enum IndexAttrBitmapKind</span><br><span class="line"> extern Bitmapset *RelationGetIndexAttrBitmap(Relation relation,</span><br><span class="line"> 											 IndexAttrBitmapKind attrKind);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern Bitmapset *RelationGetIdentityKeyBitmap(Relation relation);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> extern void RelationGetExclusionInfo(Relation indexRelation,</span><br><span class="line"> 									 Oid **operators,</span><br><span class="line"> 									 Oid **procs,</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的分析过程收益还是颇多的，对 PostgreSQL 的流复制有了更深刻的认识。此外对于 PostgreSQL 的 TAP 测试也有了一点心得，不再像之前修复<a href="https://www.postgresql.org/message-id/CALj2ACV%2B0UFpcZs5czYgBpujM9p0Hg1qdOZai_43OU7bqHU_xw%40mail.gmail.com">逻辑复制行为异常</a>那样对 TAP 测试茫然了。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>[1] <a href="https://www.postgresql.org/message-id/OS0PR01MB6113C2499C7DC70EE55ADB82FB759%40OS0PR01MB6113.jpnprd01.prod.outlook.com">Truncate in synchronous logical replication failed</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 中的查询 - 查询执行阶段</title>
    <url>/2022/03/queries-in-postgresql-query-execution-stages/</url>
    <content><![CDATA[<p>您好！我正在开始另一个关于 PostgreSQL 内部的文章系列。这一篇将侧重于查询计划和执行机制。本系列将涵盖：</p>
<ol>
<li>查询执行阶段（本文）</li>
<li><a href="/2022/03/queries-in-postgresql-statistics/" title="统计信息">统计信息</a></li>
<li>顺序扫描</li>
<li>索引扫描</li>
<li>嵌套循环连接</li>
<li>Hash 连接</li>
<li>归并连接</li>
</ol>
<p>本文借鉴了我们的 <a href="https://postgrespro.ru/education/courses/QPT">QPT 查询优化</a>课程（即将推出英文版），但主要关注查询执行的内部机制，而将优化方面放在一边。另请注意，本系列文章是针对 PostgreSQL 14 编写的。</p>
<span id="more"></span>

<h2 id="简单查询协议"><a href="#简单查询协议" class="headerlink" title="简单查询协议"></a>简单查询协议</h2><p>PostgreSQL 客户端-服务器协议的基本目的有两个：它向服务器发送 SQL 查询，并接收整个执行结果作为响应。服务器收到要执行的查询需经过几个阶段。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先，解析查询文本，以便服务器准确了解需要做什么。</p>
<p>词法分析器（<strong>Lexer</strong>）和解析器（<strong>Parser</strong>）。词法分析器负责识别查询字符串中的词位（如 SQL 关键字、字符串和数字文字等），而解析器确保生成的词位集在语法上是有效的。解析器和词法分析器是使用标准工具 Bison 和 Flex 实现的。</p>
<p>解析的查询表示为抽象语法树。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br></pre></td></tr></table></figure>

<p>上述 SQL 语句将在后端内存中构建一棵树。下图以高度简化的形式显示了树。树的节点用查询的相应部分标记。</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query1.png" class="">

<p><code>RTE</code> 是一个比较晦涩的缩写，它表示 <code>Range Table Entry</code>。PostgreSQL 源码中的 <code>range table</code> 指的是表、子查询、连接结果 – 换句话说，SQL 语句操作的任何记录集。</p>
<p>语义分析器（<strong>Semantic analyzer</strong>)。语义分析器通过名称确定数据库中是否有查询引用的表和其它对象，以及用户是否有权访问这些对象。语义分析所需的所有信息都存储在系统表中。</p>
<p>语义分析器从解析器接收解析树并重建它，并用对特定数据库对象、数据类型信息等的引用来补充它。</p>
<p>如果参数 <code>debug_print_parse</code> 开启，则完整的树将显示在服务器消息日志中，尽管这没有什么实际意义。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>接下来，可以转换（重写）查询。</p>
<p>系统核心将转换用于多种目的。其中之一是将解析树中的视图名称替换为与该视图的查询相对应的子树。</p>
<p>上例中的 <code>pg_tables</code> 是一个视图，转换后解析树将采用以下形式：</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query2.png" class="">

<p>此解析树对应于以下查询（尽管所有操作都只在树上执行，而不是在查询文本上）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="comment">-- pg_tables</span></span><br><span class="line">    <span class="keyword">SELECT</span> n.nspname <span class="keyword">AS</span> schemaname,</span><br><span class="line">      c.relname <span class="keyword">AS</span> tablename,</span><br><span class="line">      pg_get_userbyid(c.relowner) <span class="keyword">AS</span> tableowner,</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">FROM</span> pg_class c</span><br><span class="line">      <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_namespace n <span class="keyword">ON</span> n.oid <span class="operator">=</span> c.relnamespace</span><br><span class="line">      <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t <span class="keyword">ON</span> t.oid <span class="operator">=</span> c.reltablespace</span><br><span class="line">    <span class="keyword">WHERE</span> c.relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="keyword">ARRAY</span>[<span class="string">&#x27;r&#x27;</span>::<span class="type">char</span>, <span class="string">&#x27;p&#x27;</span>::<span class="type">char</span>])</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br></pre></td></tr></table></figure>

<p>解析树反映查询的句法结构，但不反映执行操作的顺序。</p>
<p>行级安全性在转换阶段实施。系统核心使用转换的另一个例子是版本 14 中递归查询的 SEARCH 和 CYCLE 子句的实现。</p>
<p>PostgreSQL 支持自定义转换，用户可以使用重写规则系统来实现。</p>
<p>规则系统旨在作为 Postgres 的<a href="https://dsf.berkeley.edu/papers/ERL-M85-95.pdf">主要功能之一</a>。这些规则得到了项目基础的支持，并在早期开发过程中反复重新设计。这是一个强大的机制，但难以理解和调试。甚至有人提议从 PostgreSQL 中完全删除规则，但没有得到普遍支持。在大多数情况下，使用触发器而不是规则更安全、更方便。</p>
<p>如果参数 <code>debug_print_rewritten</code> 开启，则完整转换的解析树将显示在服务器消息日志中。</p>
<h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>SQL 是一种声明性语言：查询指定要检索什么，但不指定如何检索它。</p>
<p>任何查询都可以通过多种方式执行。解析树中的每个操作都有多个执行选项。例如，您可以通过读取整个表并丢弃不需要的行来从表中检索特定记录，或者您可以使用索引来查找与您的查询匹配的记录。数据集总是成对连接。连接顺序的变化会产生大量的执行选项。然后有多种方法可以将两组记录连接在一起。例如，您可以逐个遍历第一个集合中的记录并在另一个集合中查找匹配的记录，或者您可以先对两个集合进行排序，然后将它们合并在一起。不同的方法在某些情况下表现更好，在另一些情况下表现更差。</p>
<p>最佳计划的执行速度可能比非最佳计划快几个数量级。这就是为什么优化解析查询的规划器是系统中最复杂的元素之一。</p>
<p>计划树（<strong>Plan tree</strong>）。执行计划也可以表示为树，但其节点是对数据的物理操作而不是逻辑操作。</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query3.png" class="">

<p>如果参数 <code>debug_print_plan</code> 开启，则完整的计划树将显示在服务器消息日志中。这是非常不切实际的，因为日志非常混乱。更方便的选择是使用 <code>EXPLAIN</code> 命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                            QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Sort  (cost=21.03..21.04 rows=1 width=128)</span><br><span class="line">   Sort Key: c.relname</span><br><span class="line">   −&gt; Nested Loop Left Join  (cost=0.00..21.02 rows=1 width=128)</span><br><span class="line">       Join Filter: (n.oid = c.relnamespace)</span><br><span class="line">       −&gt; Seq Scan on pg_class c  (cost=0.00..19.93 rows=1 width=72)</span><br><span class="line">           Filter: ((relkind = ANY (&#x27;&#123;r,p&#125;&#x27;::&quot;char&quot;[])) AND (pg_g...</span><br><span class="line">       −&gt; Seq Scan on pg_namespace n  (cost=0.00..1.04 rows=4 wid...</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

<p>该图显示了树的主要节点。相同的节点在 <code>EXPLAIN</code> 输出中用箭头标记。</p>
<p><code>Seq Scan</code> 节点代表读表操作，而 <code>Nested Loop</code> 节点代表连接操作。这里有两个有趣的点需要注意：</p>
<ul>
<li>初始表之一从计划树中消失了，因为规划器发现不需要处理查询并将其删除。</li>
<li>估计要处理的行数和每个节点旁边的处理成本。</li>
</ul>
<p>计划搜索（<strong>Plan search</strong>）。为了找到最佳计划，PostgreSQL 使用了基于成本的查询优化器（<em>cost-based query optimizer</em>）。优化器会检查各种可用的执行计划并估计所需的资源量，例如 I/O 操作和 CPU 周期。这个计算出来的估计，转换成任意单位，被称为计划成本（<em>plan cost</em>）。选择成本最低的计划来执行。</p>
<p>问题是，可能的计划数量随着连接数量的增加而呈指数增长，即使对于相对简单的查询，也无法一一筛选所有计划。因此，动态规划和启发式用于限制搜索范围。这允许在合理的时间内精确地解决查询中更多表的问题，但所选计划不能保证是真正最优的，因为计划员使用简化的数学模型，并且可能使用不精确的初始数据。</p>
<p>连接顺序（<strong>Ordering joins</strong>）。可以以特定方式构建查询，以显着缩小搜索范围（有可能错过找到最佳计划的机会）</p>
<ul>
<li>公共表表达式通常与主查询分开优化。从版本 12 开始，可以使用 MATERIALIZE 子句强制执行此操作。</li>
<li>来自非 SQL 函数的查询与主查询分开优化。（在某些情况下，SQL 函数可以内联到主查询中。）</li>
<li><code>join_collapse_limit</code> 参数与显式 JOIN 子句以及 <code>from_collapse_limit</code> 参数与子查询一起可以定义某些连接的顺序，具体取决于查询语法。</li>
</ul>
<p>最后一个可能需要解释。下面的查询调用 <code>FROM</code> 子句中的几个表，没有显式连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b, c, d, e</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>这是此查询的解析树：</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query4.png" class="">

<p>在这个查询中，规划器将考虑所有可能的连接顺序。</p>
<p>在下一个示例中，一些连接由 JOIN 子句显式定义：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b <span class="keyword">JOIN</span> c <span class="keyword">ON</span> ..., d, e</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>解析树反映了这一点：</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query5.png" class="">

<p>规划器折叠连接树，有效地将其转换为上一个示例中的树。该算法递归地遍历树并用其组件的平面列表替换每个 <code>JOINEXPR</code> 节点。</p>
<p>但是，只有在生成的平面列表包含不超过 <code>join_collapse_limit</code> 个元素（默认为 8 个）时，才会发生这种“扁平化”。在上面的示例中，如果将 <code>join_collapse_limit</code> 设置为 5 或更少，则不会折叠 <code>JOINEXPR</code> 节点。对于规划器来说，这意味着两件事：</p>
<ul>
<li>表 B 必须和表 C 进行连接（反之亦然，对中的连接顺序不受限制）。</li>
<li>表 A，D，E 和表 B，C 连接结果可以以任意顺序进行连接。</li>
</ul>
<p>如果 <code>join_collapse_limit</code> 设置为 <code>1</code>，则将保留任何显式 <code>JOIN</code> 顺序。</p>
<p>请注意，无论 <code>join_collapse_limit</code> 如何，操作 <code>FULL OUTER JOIN</code> 都不会折叠。</p>
<p><code>from_collapse_limit</code> 参数（默认也是 8）以类似的方式限制子查询的展平。子查询似乎与连接没有太多共同之处，但是当它来到解析树级别时，相似性是显而易见的。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b <span class="keyword">JOIN</span> c <span class="keyword">ON</span> ..., d, e</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>这是它的树：</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query6.png" class="">

<p>这里唯一的区别是 <code>JOINEXPR</code> 节点被替换为 <code>FROMEXPR</code>（因此参数名称为 <code>FROM</code>）。</p>
<p>遗传搜索（<strong>Genetic search</strong>）。每当生成的扁平树以太多相同级别的节点（表或连接结果）结束时，规划时间可能会飙升，因为每个节点都需要单独优化。如果参数 <code>geqo</code> 开启（默认开启），当同级节点数量达到 <code>geqo_threshold</code>（默认为 12）时，PostgreSQL 将切换到遗传搜索。</p>
<p>遗传搜索比动态规划方法快得多，但它并不能保证找到最佳计划。该算法有许多可调整的选项，但这是另一篇文章的主题。</p>
<p>选择最佳计划（<strong>Selecting the best plan</strong>）。最佳计划的定义因预期用途而异。当需要完整的输出（例如，生成报告）时，计划必须优化与查询匹配的所有记录的检索。另一方面，如果您只想要前几个匹配的记录（例如，显示在屏幕上），则最佳计划可能会完全不同。</p>
<p>PostgreSQL 通过计算两个成本来解决这个问题。它们显示在 <code>cost</code> 一词之后的查询计划输出中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sort  (cost=21.03..21.04 rows=1 width=128)</span><br></pre></td></tr></table></figure>

<p>第一个组成部分，启动成本，是为节点执行做准备的成本；第二个组成部分，总成本，代表总节点执行成本。</p>
<p>当选择计划时，规划器首先检查游标是否正在使用（可以在 PL/pgSQL 中使用 <code>DECLARE</code> 命令设置游标或明确声明）。如果没有使用游标，那么规划器假定需要全部输出并选择总成本最低的计划。</p>
<p>否则，如果使用游标，那么规划器会选择一个计划，以最佳方式检索匹配行总数中等于 <code>cursor_tuple_fraction</code>（默认为 0.1）的行数。或者，更具体地说，最低的计划 <code>startup cost + cursor_tuple_fraction * (total cost - startup cost)</code>。</p>
<p>成本计算过程（<strong>Cost calculation process</strong>）。要估计计划成本，必须单独估计其每个节点。节点成本取决于节点类型（从表中读取的成本远低于对表排序的成本）和处理的数据量（通常，数据越多，成本越高）。虽然节点类型是立即知道的，但要评估数据量，我们首先需要估计节点的基数（输入行的数量）和选择率（剩余用于输出的行的比例）。为此，我们需要数据统计：表大小、跨列的数据分布。</p>
<p>因此，优化依赖于准确的统计数据，这些数据由自动分析过程收集并保持最新。</p>
<p>如果每个计划节点的基数估计准确，计算出的总成本通常会与实际成本相匹配。常见的计划偏差通常是基数和选择率估计不正确的结果。这些错误是由不准确、过时或不可用的统计数据引起的，并且在较小程度上是规划器所基于的固有模型不完善。</p>
<p>基数估计（<strong>Cardinality estimation</strong>）。基数估计是递归执行的。节点基数使用两个值计算：</p>
<ul>
<li>节点的子节点的基数，或输入行数。</li>
<li>节点的选择率，或输出行与输入行的比例。</li>
</ul>
<p>基数是这两个值的乘积。</p>
<p>选择率是一个介于 0 到 1 之间的数字。选择率的值越接近 0 则具有更高的选择率，反之，越接近 1 则具有更低的选择率。这是因为高选择率会消除较高比例的行，而较低的选择率值会降低阈值，因此丢弃的行数会更少。</p>
<p>首先处理具有数据访问方法的叶节点。这就是统计信息的来源，例如表大小。</p>
<p>应用于表的条件的选择率取决于条件类型。在最简单的形式中，选择率可以是一个常数值，但规划器会尝试使用所有可用信息来产生最准确的估计。最简单条件的选择率估计作为基础，使用布尔运算构建的复杂条件可以使用以下简单公式进一步计算：</p>
<p>$$<br>sel_{x\ and\ y} = sel_{x}\ sel_{y}<br>$$</p>
<p>$$<br>sel_{x\ or\ y} = 1 - (1 -sel_{x})(1 - sel_{y}) = sel_{x} + sel_{y} - sel_{x}\ sel_{y}<br>$$</p>
<p>在这些公式中，$x$ 和 $y$ 被认为是独立的。如果它们相关，则仍使用这些公式，但估计会不太准确。</p>
<p>对于连接的基数估计，计算两个值：笛卡尔积的基数（两个数据集的基数的乘积）和连接条件的选择率，这又取决于条件类型。</p>
<p>其他节点类型的基数，例如排序或聚合节点，也是类似地计算的。</p>
<p>请注意，较低节点中的基数计算错误将向上传播，导致成本估算不准确，并最终导致次优计划。规划器只有表的统计数据，而不是连接结果的统计数据，这使情况变得更糟。</p>
<p>成本估算（<strong>Cost estimation</strong>）。成本估算过程也是递归的。子树的成本包括其子节点的成本加上父节点的成本。</p>
<p>节点成本计算基于其执行操作的数学模型。已经计算的基数用作输入。该过程计算启动成本和总成本。</p>
<p>有些操作不需要任何准备，可以立即开始执行。对于这些操作，启动成本将为零。</p>
<p>其他操作可能有先决条件。例如，排序节点通常需要来自其子节点的所有数据才能开始操作。这些节点的启动成本不为零。即使下一个节点（或客户端）只需要单行输出，也必须支付此成本。</p>
<p>成本是计划者的最佳估计。任何计划错误都会影响成本与实际执行时间的相关程度。成本评估的主要目的是让计划者在相同条件下比较相同查询的不同执行计划。在任何其他情况下，按成本比较查询（更糟糕的是，不同的查询）是没有意义和错误的。例如，考虑由于统计数据不准确而被低估的成本。更新统计数据——成本可能会发生变化，但估算会变得更加准确，计划最终会得到改进。</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>按照计划执行优化查询。</p>
<p>在后端内存中创建了一个称为 <code>portal</code> 的对象。<code>protal</code> 在查询执行时存储查询的状态。此状态表示为一棵树，其结构与计划树相同。</p>
<p>树的节点充当装配线，相互请求和传递行。</p>
<img src="/2022/03/queries-in-postgresql-query-execution-stages/query7.png" class="">

<p>执行器从根节点开始。根节点（示例中的排序节点 <code>SORT</code>）向子节点请求数据。当它接收到所有请求的数据时，它会执行排序操作，然后将数据向上传递给客户端。</p>
<p>一些节点（例如<code>NESTLOOP</code> 节点）连接来自不同来源的数据。该节点从两个子节点请求数据。在接收到与连接条件匹配的两行后，节点立即将结果行传递给父节点（与排序不同，排序必须在处理它们之前接收所有行）。然后该节点停止，直到其父节点请求另一行。因此，如果只需要部分结果（例如由 <code>LIMIT</code> 设置），则操作将不会完全执行。</p>
<p>两个 <code>SEQSCAN</code> 叶是表扫描。根据父节点的请求，叶节点从表中读取下一行并将其返回。</p>
<p>这个节点和其他一些节点根本不存储行，而只是交付并立即丢弃它们。其他节点，例如排序，可能需要一次存储大量数据。为了解决这个问题，在后端内存中分配了一个 <code>work_mem</code> 内存块。它的默认大小为 <code>4MB</code>，这过于保守；当内存用完时，多余的数据会被发送到磁盘上的临时文件中。</p>
<p>一个计划可能包括多个具有存储要求的节点，因此它可能分配了几个内存块，每个内存块的大小为 <code>work_mem</code>。查询进程可能占用的总内存大小没有限制。</p>
<h2 id="扩展查询协议"><a href="#扩展查询协议" class="headerlink" title="扩展查询协议"></a>扩展查询协议</h2><p>使用简单的查询协议，任何命令，即使它一次又一次地重复，也会经历上述所有这些阶段：</p>
<ol>
<li>解析</li>
<li>转换</li>
<li>规划</li>
<li>执行</li>
</ol>
<p>但是没有理由一遍又一遍地解析同一个查询。如果它们仅在常量上有所不同，也没有任何理由重新解析查询：解析树将是相同的。</p>
<p>简单查询协议的另一个烦恼是客户端接收完整的输出，不管它可能有多长。</p>
<p>这两个问题都可以通过使用 SQL 命令来解决：第一个问题可以通过 <code>PREPARE</code> 和 <code>EXECUTE</code> 来解决，第二个问题可以通过 <code>DECLARE</code> 和 <code>FETCH</code> 来解决。但是随后客户端将不得不处理命名新对象，而服务器将需要解析额外的命令。</p>
<p>扩展查询协议可以在协议命令级别对单独的执行阶段进行精确控制。</p>
<h3 id="PREPARE"><a href="#PREPARE" class="headerlink" title="PREPARE"></a>PREPARE</h3><p>在 <code>PREPARE</code> 期间，查询会像往常一样被解析和转换，但解析树存储在后端内存中。</p>
<p>PostgreSQL 没有用于解析查询的全局缓存。即使一个进程之前已经解析过查询，其他进程也必须再次解析它。然而，这种设计也有好处。在高负载下，全局内存缓存很容易因为锁而成为瓶颈。一个客户端发送多个小命令可能会影响整个实例的性能。在 PostgreSQL 中，查询解析很便宜并且与其他进程隔离。</p>
<p>可以为 <code>PREPARE</code> 命令附加查询参数。下面是一个使用 SQL 命令的例子（同样，这并不等同于协议命令级别的准备，但最终的效果是一样的）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PREPARE</span> plane(text) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aircrafts <span class="keyword">WHERE</span> aircraft_code <span class="operator">=</span> $<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>本系列文章中的大多数示例将使用<a href="https://postgrespro.com/education/demodb">“航空公司”演示数据库</a>。</p>
<p>此视图显示所有命名的预准备语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, statement, parameter_types</span><br><span class="line"><span class="keyword">FROM</span> pg_prepared_statements \gx</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">−[ RECORD 1 ]−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">name            | plane</span><br><span class="line">statement       | PREPARE plane(text) AS                           +</span><br><span class="line">                | SELECT * FROM aircrafts WHERE aircraft_code = $1;</span><br><span class="line">parameter_types | &#123;text&#125;</span><br></pre></td></tr></table></figure>

<p>该视图没有列出任何未命名的语句（使用扩展协议或 PL/pgSQL）。它也没有列出来自其他会话的准备好的语句：访问另一个会话的内存是不可能的。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>在执行 <code>PREPARE</code> 的查询之前，会绑定当前参数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;733&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> aircraft_code |     model      | range</span><br><span class="line">---------------+----------------+-------</span><br><span class="line"> 733           | Boeing 737−300 |  4200</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>与文字表达式的串联相比，<code>PREPARE</code> 语句的一个优点是可以防止任何类型的 SQL 注入，因为参数值不会影响已经构建的解析树。在没有 <code>PREPARE</code> 的声明的情况下达到相同的安全级别将需要对来自不受信任来源的所有值进行广泛的转义。</p>
<h4 id="规划和执行"><a href="#规划和执行" class="headerlink" title="规划和执行"></a>规划和执行</h4><p>执行 <code>PREPARE</code> 语句时，首先会考虑提供的参数来计划其查询，然后发送选择的计划以执行。</p>
<p>实际参数值对规划器很重要，因为不同参数集的最优规划也可能不同。例如，在查找高级航班预订时，使用索引扫描（如 <code>Index Scan</code> 字样所示），因为计划者预计匹配的行不多：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> bookings(total_amount);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bookings <span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Bitmap Heap Scan on bookings  (cost=86.38..9227.74 rows=4380 wid...</span><br><span class="line">   Recheck Cond: (total_amount &gt; &#x27;1000000&#x27;::numeric)</span><br><span class="line">   −&gt; Bitmap Index Scan on bookings_total_amount_idx  (cost=0.00....</span><br><span class="line">       Index Cond: (total_amount &gt; &#x27;1000000&#x27;::numeric)</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>然而，下一个条件完全符合所有预订。索引扫描在这里没用，进行顺序扫描（<code>Seq Scan</code>）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bookings <span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                            QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on bookings  (cost=0.00..39835.88 rows=2111110 width=21)</span><br><span class="line">   Filter: (total_amount &gt; &#x27;100&#x27;::numeric)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>在某些情况下，除了解析树之外，规划器还会存储查询计划，以避免在出现时再次规划它。这个没有参数值的计划称为通用计划，而不是使用给定参数值生成的自定义计划。通用计划的一个明显用例是没有参数的语句。</p>
<p>对于前四次运行，带有参数的预处理语句总是根据实际参数值进行优化。然后计算平均计划成本。在第五次及以后，如果通用计划平均比自定义计划便宜（每次都必须重新构建），那么规划器将从那时起存储和使用通用计划，并进行进一步优化。</p>
<p><code>PREPARE</code> 语句 <code>plane</code> 已经执行过一次。在接下来的两次执行中，仍然使用自定义计划，如查询计划中的参数值所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;763&#x27;</span>);</span><br><span class="line"><span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;773&#x27;</span>);</span><br><span class="line">EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;319&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                            QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on aircrafts_data ml  (cost=0.00..1.39 rows=1 width=52)</span><br><span class="line">   Filter: ((aircraft_code)::text = &#x27;319&#x27;::text)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>执行四次后，规划器将切换到通用规划。在这种情况下，通用计划与定制计划相同，成本相同，因此更可取。现在 <code>EXPLAIN</code> 命令显示参数编号，而不是实际值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;320&#x27;</span>);</span><br><span class="line">EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;321&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                            QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on aircrafts_data ml  (cost=0.00..1.39 rows=1 width=52)</span><br><span class="line">   Filter: ((aircraft_code)::text = &#x27;$1&#x27;::text)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>不幸的是，只有前四个定制计划比通用计划更昂贵，而任何进一步的定制计划都会更便宜——但规划器会完全忽略它们。另一个可能的不完善来源是规划器比较成本估算，而不是要花费的实际资源成本。</p>
<p>这就是为什么在版本 12 及更高版本中，如果用户不喜欢自动结果，他们可以强制系统使用通用计划或自定义计划。这是通过参数 <code>plan_cache_mode</code> 完成的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET plan_cache_mode = &#x27;force_custom_plan&#x27;;</span><br><span class="line">EXPLAIN EXECUTE plane(&#x27;CN1&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan on aircrafts_data ml  (cost=0.00..1.39 rows=1 width=52)</span><br><span class="line">  Filter: ((aircraft_code)::text = &#x27;CN1&#x27;::text)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>在 14 及更高版本中，<code>pg_prepared_statements</code> 视图还可以显示计划选择统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, generic_plans, custom_plans</span><br><span class="line">FROM pg_prepared_statements;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> name  | generic_plans | custom_plans</span><br><span class="line">−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−</span><br><span class="line"> plane |             1 |            6</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h3 id="获取输出"><a href="#获取输出" class="headerlink" title="获取输出"></a>获取输出</h3><p>扩展查询协议允许客户端批量获取输出，一次多行，而不是一次全部获取。借助 SQL 游标也可以实现相同的目的，但成本更高，并且规划器将优化对第一个 <code>cursor_tuple_fraction</code> 行的检索：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aircrafts <span class="keyword">ORDER</span> <span class="keyword">BY</span> aircraft_code;</span><br><span class="line"><span class="keyword">FETCH</span> <span class="number">3</span> <span class="keyword">FROM</span> cur;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> aircraft_code |      model       | range</span><br><span class="line">−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−</span><br><span class="line"> 319           | Airbus A319−100 |  6700</span><br><span class="line"> 320           | Airbus A320−200 |  5700</span><br><span class="line"> 321           | Airbus A321−200 |  5600</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> <span class="number">2</span> <span class="keyword">FROM</span> cur;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> aircraft_code |     model     | range</span><br><span class="line">−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−</span><br><span class="line">           733 | Boeing 737−300 |  4200</span><br><span class="line">           763 | Boeing 767−300 |  7900</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>每当查询返回大量行并且客户端都需要它们时，一次检索的行数对于整体数据传输速度至关重要。单批行越大，往返延迟损失的时间就越少。然而，随着批量大小的增加，节省的效率会下降。例如，从批量大小 1 切换到批量大小 10 将显着增加时间节省，但从 10 切换到 100 几乎没有任何区别。</p>
<p>请继续关注<a href="https://postgrespro.com/blog/pgsql/5969296">下一篇文章</a>，我们将讨论成本优化的基础：统计。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><p>本文翻译自 <a href="https://postgrespro.com/">PostgreSQL Pro</a> 的 <a href="https://postgrespro.com/blog/pgsql/5969262">Queries in PostgreSQL: 1. Query execution stages</a>。</p>
<div class="just-for-fun">
笑林广记 - 监生拜父

<p>一人援例入监，吩咐家人备帖拜老相公。<br>仆曰：“父子如何用帖，恐被人谈论。”<br>生曰：“不然，今日进身之始，他客俱拜，焉有亲父不拜之理。”<br>仆问：“用何称呼？”<br>生沉吟曰：“写个‘眷侍教生’罢。”<br>父见，怒责之，生曰：“称呼斟酌切当，你自不解。父子一本至亲，故下一眷字；侍者，父坐子立也；教者，从幼延师教训；生者，父母生我也。”<br>父怒转盛，责其不通。<br>生谓仆曰：“想是嫌我太妄了，你去另换个晚生帖儿来罢。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 中的查询 - 顺序扫描</title>
    <url>/2022/04/queries-in-postgresql-sequential-scan/</url>
    <content><![CDATA[<p>在之前的文章中，我们讨论了系统如何<a href="/2022/03/queries-in-postgresql-query-execution-stages/" title="规划查询">规划查询</a>以及如何<a href="/2022/03/queries-in-postgresql-statistics/" title="收集统计信息">收集统计信息</a>以选择最佳执行计划。从这篇文章开始，后续的文章将终点关注计划的本质、它的组成以及如何执行。</p>
<p>在本文中，我将演示规划器如何计算执行成本。我还将讨论访问方法（Access Methods）以及它们如何影响这些成本，并使用顺序扫描方法作为说明。最后，我将谈谈 PostgreSQL 中的并行执行的工作原理以及何时使用它。</p>
<p>我将在本文后面使用几个看似复杂的数学公式。您无需记住任何一个公式也可以理解规划器是如何工作的；它们只是为了显示我的数据来源。</p>
<span id="more"></span>

<h2 id="可插拔存储引擎"><a href="#可插拔存储引擎" class="headerlink" title="可插拔存储引擎"></a>可插拔存储引擎</h2><p>PostgreSQL 将数据存储在磁盘上的方法并不是对所有的负载类型都是最佳的。幸运的是，您有选择的权利。PostgreSQL 12 及更高版本兑现了其可扩展性的承诺，实现了自定义表访问方法（存储引擎），不过它默认只带有一个对表存储引擎（heap）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> amname, amhandler <span class="keyword">FROM</span> pg_am <span class="keyword">WHERE</span> amtype <span class="operator">=</span> <span class="string">&#x27;t&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> amname |      amhandler</span><br><span class="line">−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> heap   | heap_tableam_handler</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>您可以在创建表时指定存储引擎 <code>(CREATE TABLE ... USING)</code>。如果没有指定，那么将使用 <code>default_table_access_method</code> 中定义的引擎。</p>
<p>系统表 <code>pg_am</code> 中存储了引擎名称（<code>amname</code> 列）以及它们的处理函数（<code>amhandler</code>）。每个存储引擎都伴随着一个内核需要的接口，以便充分的使用存储引擎。处理函数的工作是返回有关接口所有必需的信息。</p>
<p>大多数存储引擎利用现有内核的系统组件：</p>
<ul>
<li>事务管理器，包括 ACID 的支持以及快照隔离</li>
<li>缓冲区管理</li>
<li>I/O 子系统</li>
<li>TOAST</li>
<li>查询优化器和执行器</li>
<li>索引支持</li>
</ul>
<p>存储引擎不一定会使用所有这些组件，但这种能力依然存在。接着，存储引擎必须定义一些东西：</p>
<ul>
<li>行版本格式和数据结构</li>
<li>表扫描例程</li>
<li>插入、删除、更新和 lock 例程</li>
<li>行版本可见性规则</li>
<li>VACUUM 和 ANALYZE 过程</li>
<li>顺序扫描成本估算过程</li>
</ul>
<p>传统上，PostgreSQL 使用单一的数据存储系统，即直接内置到内核中，没有接口。现在，创建一个新的接口是一项挑战–适应标准引擎的所有长期特殊性并且不干扰其他访问方法。由于开销巨大，现有的<a href="https://postgrespro.com/docs/postgresql/13/generic-wal">通用的 WAL 日志</a>机制很少成为一种选择。您可以为新的日志记录类型设计一个单独的接口，但这会使崩溃恢复依赖于外部代码，这是您一直想要避免的。到目前为止，重构内核代码以适应新引擎仍然是唯一可行的选择。</p>
<p>说到新的存储引擎，目前有几个正在开发中。以下是一些比较突出的：</p>
<ul>
<li><p><a href="https://github.com/EnterpriseDB/zheap">Zheap</a> 是针对表膨胀而设计的存储引擎。它实现就地行版本更新并将快照数据存储在单独的 undo 日志中。该引擎对更新密集型工作负载有效。该存储引擎设计类似于 Oracle 的存储引擎（比如索引访问方法接口不支持自带多版本并发控制的索引）。</p>
</li>
<li><p><a href="https://github.com/greenplum-db/postgres/tree/zedstore">Zedstore</a> 实现了列式存储，旨在更有效地处理 OLAP 事务。它将数据组织到由行版本 ID 组成的主 B 树中，并且每一列都存储在其自己的 B 树中，该 B 树引用主 B 树。未来，该存储引擎可能支持在一棵树中存储多个列，本质上成为一个混合存储引擎。</p>
</li>
</ul>
<h2 id="顺序扫描"><a href="#顺序扫描" class="headerlink" title="顺序扫描"></a>顺序扫描</h2><p>存储引擎确定表数据在磁盘上的物理分布方式并提供访问它的方法。顺序扫描是一种对主表 fork 的文件进行完整扫描的方法。在每一页上，系统检查每一行版本的可见性，并丢弃与查询不匹配的版本。</p>
<img src="/2022/04/queries-in-postgresql-sequential-scan/seqscan1-en.png" class="">

<p>扫描是通过缓冲区高速缓存完成的。系统使用一个小的环形缓冲区来防止较大的表从缓存中淘汰可能有用的数据。当另一个进程需要扫描同一张表时，它会加入缓冲环，节省磁盘读取时间。因此，扫描不一定从文件的开头开始。</p>
<p>顺序扫描是扫描整个表或其中重要部分的最具成本效益的方法。换句话说，当选择率较低时，顺序扫描是有效的。在更高的选择率下，当表中只有一小部分行满足筛选要求时，通常最好使用索引扫描。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>执行计划中的顺序扫描阶段由 <code>Seq Scan</code> 节点表示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>行数估计是一个基本的统计量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples</span><br><span class="line">−−−−−−−−−−−</span><br><span class="line">    214867</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>在估算成本时，优化器会考虑磁盘输入/输出和 CPU 处理成本。</p>
<p>I/O 成本按照读取单个页面的开销乘以表中的页面数来估算，前提是这些页面按顺序读取。当缓冲区管理器向操作系统请求一个页面时，系统实际上从磁盘读取了更大的数据块，因此接下来的几个页面可能已经在操作系统的缓存中。这使得顺序读取成本（规划器中由 <code>seq_page_cost</code> 参数给出权重，默认为 1）大大低于随机读取的成本（由 <code>random_page_cost</code> 参数给出权重，默认为 4）。</p>
<p>默认权重适用于 HDD 驱动器。如果您使用 SSD，则可以将 <code>random_page_cost</code> 设置得更低（<code>seq_page_cost</code> 通常保留为 1 作为参考值）。成本取决于硬件，因此通常在表空间级别设置 <code>(ALTER TABLESPACE ... SET)</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> relpages, current_setting(<span class="string">&#x27;seq_page_cost&#x27;</span>) <span class="keyword">AS</span> seq_page_cost,</span><br><span class="line">  relpages <span class="operator">*</span> current_setting(<span class="string">&#x27;seq_page_cost&#x27;</span>)::<span class="type">real</span> <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname<span class="operator">=</span><span class="string">&#x27;flights&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> relpages | seq_page_cost | total</span><br><span class="line">−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−</span><br><span class="line">     2624 |             1 | 2624</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这个公式完美地说明了由于后期清理导致的表膨胀的结果。主表越大，要获取的页面就越多，无论这些页面中的数据是否是最新的。</p>
<p>CPU 处理成本估计为每个行版本的处理成本之和（规划器中由 <code>cpu_tuple_cost</code> 给出权重，默认为 0.01）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples,</span><br><span class="line">  current_setting(<span class="string">&#x27;cpu_tuple_cost&#x27;</span>) <span class="keyword">AS</span> cpu_tuple_cost,</span><br><span class="line">  reltuples <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="type">real</span> <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname<span class="operator">=</span><span class="string">&#x27;flights&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | cpu_tuple_cost | total</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−−−−−−−+−−−−−−−−−</span><br><span class="line">    214867 |           0.01 | 2148.67</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>两项成本之后构成了计划的总成本。该计划的启动成本为零，因为顺序扫描不需要任何准备步骤。</p>
<p>任何表过滤器都将列在计划中 <code>Seq Scan</code> 节点的下方。行数估计将考虑过滤器的选择性，成本估计将包括它们的处理成本。<code>EXPLAIN ANALYZE</code> 命令显示扫描的实际行数和过滤器删除的行数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (analyze, timing off, summary off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;Scheduled&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights</span><br><span class="line">   (cost=0.00..5309.84 rows=15383 width=63)</span><br><span class="line">   (actual rows=15383 loops=1)</span><br><span class="line">   Filter: ((status)::text = &#x27;Scheduled&#x27;::text)</span><br><span class="line">   Rows Removed by Filter: 199484</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>

<h3 id="带有聚合的计划示例"><a href="#带有聚合的计划示例" class="headerlink" title="带有聚合的计划示例"></a>带有聚合的计划示例</h3><p>考虑这个涉及聚合的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> seats;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                          QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Aggregate  (cost=24.74..24.75 rows=1 width=8)</span><br><span class="line">   −&gt; Seq Scan on seats (cost=0.00..21.39 rows=1339 width=0)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>该计划中有两个节点：<code>Aggregate</code> 和 <code>Seq Scan</code>。<code>Seq Scan</code> 扫描表并将数据向上传递给 <code>Aggregate</code>，而 <code>Aggregate</code> 则持续对行进行计数。</p>
<p>注意到 <code>Aggregate</code> 有一个启动成本：聚合函数本身的成本，即需要计算来自子节点的所有行。估计值是根据输入行数乘以任意操作的成本来计算的（<code>cpu_operator_cost</code>，默认为 0.0025）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  reltuples,</span><br><span class="line">  current_setting(<span class="string">&#x27;cpu_operator_cost&#x27;</span>) <span class="keyword">AS</span> cpu_operator_cost,</span><br><span class="line">  round((</span><br><span class="line">    reltuples <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>) <span class="keyword">AS</span> cpu_cost</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname<span class="operator">=</span><span class="string">&#x27;seats&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | cpu_operator_cost | cpu_cost</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−</span><br><span class="line">      1339 |            0.0025 | 3.35</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>随后在该估计值的基础上加上 <code>Seq Scan</code> 节点的总成本。</p>
<p>然后，<code>Aggregate</code> 的总成本需要加上 <code>cpu_tuple_cost</code> 的成本，<code>cpu_tuple_cost</code> 是结果输出行的处理成本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> t(cpu_cost) <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> round((</span><br><span class="line">    reltuples <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;seats&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">21.39</span> <span class="operator">+</span> t.cpu_cost <span class="keyword">AS</span> startup_cost,</span><br><span class="line">  round((</span><br><span class="line">    <span class="number">21.39</span> <span class="operator">+</span> t.cpu_cost <span class="operator">+</span></span><br><span class="line">    <span class="number">1</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>) <span class="keyword">AS</span> total_cost</span><br><span class="line"><span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> startup_cost | total_cost</span><br><span class="line">−−−−−−−−−−−−−−+−−−−−−−−−−−−</span><br><span class="line">        24.74 |      24.75</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="并行执行计划"><a href="#并行执行计划" class="headerlink" title="并行执行计划"></a>并行执行计划</h2><p>在 PostgreSQL 9.6 及更高的版本中，计划的并行执行是很重要的一件事。它是这样工作的：leader 进程创建（通过 postmaster 进程）多个 worker 进程，然后这些进程同时并行执行计划的一部分，最后由 leader 进程在 <code>Gather</code> 节点收集结果。当 leader 进程没有收集数据时，它也可以参与并行计算。</p>
<p>您可以通过设置 <code>parallel_leader_participation</code> 为 0 来禁止 leader 进程参与并行计算，但是仅在 11 及之后的版本中支持。</p>
<img src="/2022/04/queries-in-postgresql-sequential-scan/seqscan2-en.png" class="">

<p>产生新进程并在它们之间发送数据会增加总成本，因此您通常最好不要使用并行执行。</p>
<p>此外，有些操作根本无法并行执行。即使启用了并行模式，leader 进程仍将单独按顺序执行某些步骤。</p>
<h3 id="并行顺序扫描"><a href="#并行顺序扫描" class="headerlink" title="并行顺序扫描"></a>并行顺序扫描</h3><p>该方法的名称可能听起来有争议，声称同时是并行和顺序的，但这正是 <code>Parallel Seq Scan</code> 节点所做的事情。从磁盘的角度来看，所有文件页面都是按顺序获取的，与常规顺序扫描相同。然而，读取是由多个并行工作的进程完成的。这些进程在一个特殊的共享内存部分中同步它们的读取计划，以避免重复读取相同的页面。</p>
<p>另一方面，操作系统不认为这种获取是顺序的。从操作系统的角度来看，它只是几个进程请求看似随机页面。这打破了通过常规顺序扫描为我们提供的预取服务。这个问题在 PostgreSQL 14 中得到了修复，当系统开始时，为每个并行进程分配几个连续的页面来读取而不是一个页面。</p>
<p>并行扫描本身对成本效率没有多大帮助。事实上，它所做的只是在常规页面读取成本之上增加了进程之间的数据传输成本。但是，如果工作进程不仅扫描行，还对它们进行某种程度的处理（例如聚合），那么您可能会节省大量时间。</p>
<h3 id="带有聚合的并行计划示例"><a href="#带有聚合的并行计划示例" class="headerlink" title="带有聚合的并行计划示例"></a>带有聚合的并行计划示例</h3><p>优化器在一个大表上看到这个简单的聚合查询，并提出最佳策略是并行模式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> bookings;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                          QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Finalize Aggregate  (cost=25442.58..25442.59 rows=1 width=8)</span><br><span class="line">   −&gt; Gather (cost=25442.36..25442.57 rows=2 width=8)</span><br><span class="line">       Workers Planned: 2</span><br><span class="line">       −&gt; Partial Aggregate</span><br><span class="line">          (cost=24442.36..24442.37 rows=1 width=8)</span><br><span class="line">          −&gt; Parallel Seq Scan on bookings</span><br><span class="line">              (cost=0.00..22243.29 rows=879629 width=0)</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

<p><code>Gather</code> 节点下的所有节点都是计划中并行的部分。它将由所有的 worker 进程（在本例中，包含 2 个 worker 进程）和 leader 进程（除非禁用 <code>parallel_leader_participation</code> 选项）执行。<code>Gather</code> 节点和它上面的所有节点由 leader 进程顺序执行。</p>
<p>扫描本身发生在 <code>Parallel Seq Scan</code> 节点。<code>rows</code> 字段显示一个进程要处理的行的估计值。计划包含了两个 worker 进程，并且 leader 进程也将提供帮助，因此行估计值等于总表行数除以 2.4（worker 进程为 2，leader 进程为 0.4，worker 进程越多，leader 进程贡献越少）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples::<span class="type">numeric</span>, round(reltuples <span class="operator">/</span> <span class="number">2.4</span>) <span class="keyword">AS</span> per_process</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;bookings&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | per_process</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−−−−</span><br><span class="line">   2111110 |      879629</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>Parallel Seq Scan</code> 成本的估算方式与 <code>Seq Scan</code> 成本估算大致相同。我们通过让每个进程处理更少的行来赢得时间，但我们仍然通过和通过读取表，因此 I/O 成本不受影响：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> round((</span><br><span class="line">  relpages <span class="operator">*</span> current_setting(<span class="string">&#x27;seq_page_cost&#x27;</span>)::<span class="type">real</span> <span class="operator">+</span></span><br><span class="line">  reltuples <span class="operator">/</span> <span class="number">2.4</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">)::<span class="type">numeric</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;bookings&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  round</span><br><span class="line">−−−−−−−−−−</span><br><span class="line"> 22243.29</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>Partial Aggregate</code> 节点将聚合 worker 进程产生的所有数据（在本例中是统计行数）。</p>
<p>聚合的成本估算与之前的方式相同，需要加上扫描的成本。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> t(startup_cost) <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="number">22243.29</span> <span class="operator">+</span> round((</span><br><span class="line">    reltuples <span class="operator">/</span> <span class="number">2.4</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname<span class="operator">=</span><span class="string">&#x27;bookings&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> startup_cost,</span><br><span class="line">  startup_cost <span class="operator">+</span> round((</span><br><span class="line">    <span class="number">1</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>) <span class="keyword">AS</span> total_cost</span><br><span class="line"><span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> startup_cost | total_cost</span><br><span class="line">−−−−−−−−−−−−−−+−−−−−−−−−−−−</span><br><span class="line">     24442.36 |   24442.37</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>下一个 <code>Gathere</code> 节点则由 leader 进程来执行。该节点启动 worker 进程并收集它们输出的数据。</p>
<p>启动一个 worker 进程（或多个；成本不变）的成本由参数 <code>parallel_setup_cost</code>（默认为 1000）定义。将单行从一个进程发送到另一个进程的成本由 <code>parallel_tuple_cost</code>（默认为 0.1）设置。大部分节点成本是并行进程的初始化。它被添加到 <code>Partial Aggregate</code> 节点的启动成本中。它还包括两个数据传输的成本；该成本被添加到 <code>Partial Aggregate</code> 节点的总成本中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">24442.36</span> <span class="operator">+</span> round(</span><br><span class="line">  current_setting(<span class="string">&#x27;parallel_setup_cost&#x27;</span>)::<span class="type">numeric</span>,</span><br><span class="line"><span class="number">2</span>) <span class="keyword">AS</span> setup_cost,</span><br><span class="line"><span class="number">24442.37</span> <span class="operator">+</span> round(</span><br><span class="line">  current_setting(<span class="string">&#x27;parallel_setup_cost&#x27;</span>)::<span class="type">numeric</span> <span class="operator">+</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;parallel_tuple_cost&#x27;</span>)::<span class="type">numeric</span>,</span><br><span class="line"><span class="number">2</span>) <span class="keyword">AS</span> total_cost;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> setup_cost | total_cost</span><br><span class="line">−−−−−−−−−−−−+−−−−−−−−−−−−</span><br><span class="line">   25442.36 |   25442.57</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>Finalize Aggregate</code> 节点将 <code>Gather</code> 节点收集的部分数据连接在一起。它的成本估算就像使用常规的 <code>Aggregate</code> 一样。启动成本包括三个聚合的成本和 <code>Gather</code> 节点的总成本（因为 <code>Finalize Aggregate</code> 需要其所有输出进行计算）。总成本之上的额外开销是一行输出结果的开销。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> t(startup_cost) <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="number">25442.57</span> <span class="operator">+</span> round((</span><br><span class="line">    <span class="number">3</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;bookings&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> startup_cost,</span><br><span class="line">  startup_cost <span class="operator">+</span> round((</span><br><span class="line">    <span class="number">1</span> <span class="operator">*</span> current_setting(<span class="string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="type">real</span></span><br><span class="line">  )::<span class="type">numeric</span>, <span class="number">2</span>) <span class="keyword">AS</span> total_cost</span><br><span class="line"><span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> startup_cost | total_cost</span><br><span class="line">−−−−−−−−−−−−−−+−−−−−−−−−−−−</span><br><span class="line">     25442.58 |   25442.59</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h3 id="并行处理的限制"><a href="#并行处理的限制" class="headerlink" title="并行处理的限制"></a>并行处理的限制</h3><p>我们应该牢记并行处理的几个限制。</p>
<h4 id="worker-进程数"><a href="#worker-进程数" class="headerlink" title="worker 进程数"></a>worker 进程数</h4><p>后台 worker 进程的使用不限于并行查询执行：它们由逻辑复制机制使用，并且可以由扩展创建。系统最多可以同时运行 <code>max_worker_processes</code> 个后台 worker 进程（默认为 8 个）。</p>
<p>其中，最多可以将 <code>max_parallel_workers</code>（默认情况下也是 8 个）分配给并行查询执行。</p>
<p>每个 leader 进程允许的 worker 进程数由 <code>max_parallel_workers_per_gather</code> 参数给出（默认为 2 个）。</p>
<p>您可以根据以下几个因素选择更改这些值：</p>
<ul>
<li>硬件配置：系统必须有备用处理器内核。</li>
<li>表大小：并行查询对较大的表很有帮助。</li>
<li>负载类型：从并行执行中受益最多的查询应该很普遍。</li>
</ul>
<p>这些因素对于 OLAP 系统通常是正确的，而对于 OLTP 系统通常是错误的。</p>
<p>规划器甚至不会考虑并行扫描，除非它期望读取至少 <code>min_parallel_table_scan_size</code> 的数据（默认为 8MB）。</p>
<p>下面是计算计划 worker 进程数的公式：</p>
<img src="/2022/04/queries-in-postgresql-sequential-scan/seqscan3-en.png" class="">

<p>本质上，每当表大小增加三倍时，规划器就会增加一个并行 worker 进程。这是一个带有默认参数的示例表。</p>
<table>
<thead>
<tr>
<th align="center">表 (MB)</th>
<th align="center">worker 进程数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">72</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">216</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">648</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1944</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>您可以使用表存储参数 <code>parallel_workers</code> 显式地设置 worker 进程的数量。不过，worker 进程的数量仍然受到 <code>max_parallel_workers_per_gather</code> 参数的限制。</p>
<p>让我们查询一个 19MB 的小表。这将只会计划和创建一个 worker 进程（查看 <code>Workers Planned</code> 和 <code>Workers Launched</code>）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (analyze, costs off, timing off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Finalize Aggregate (actual rows=1 loops=1)</span><br><span class="line">   −&gt; Gather (actual rows=2 loops=1)</span><br><span class="line">       Workers Planned: 1</span><br><span class="line">       Workers Launched: 1</span><br><span class="line">       −&gt; Partial Aggregate (actual rows=1 loops=2)</span><br><span class="line">           −&gt; Parallel Seq Scan on flights (actual rows=107434 lo...</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>现在让我们查询一个 105MB 的表。系统将只创建两个 worker 进程，遵守 <code>max_parallel_workers_per_gather</code> 的限制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (analyze, costs off, timing off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> bookings;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Finalize Aggregate (actual rows=1 loops=1)</span><br><span class="line">   −&gt; Gather (actual rows=3 loops=1)</span><br><span class="line">       Workers Planned: 2</span><br><span class="line">       Workers Launched: 2</span><br><span class="line">       −&gt; Partial Aggregate (actual rows=1 loops=3)</span><br><span class="line">           −&gt; Parallel Seq Scan on bookings (actual rows=703703 l...</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>如果增加限制，则会创建三个 worker 进程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> max_parallel_workers_per_gather <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">SELECT</span> pg_reload_conf();</span><br><span class="line">EXPLAIN (analyze, costs off, timing off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> bookings;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Finalize Aggregate (actual rows=1 loops=1)</span><br><span class="line">   −&gt; Gather (actual rows=4 loops=1)</span><br><span class="line">       Workers Planned: 3</span><br><span class="line">       Workers Launched: 3</span><br><span class="line">       −&gt; Partial Aggregate (actual rows=1 loops=4)</span><br><span class="line">           −&gt; Parallel Seq Scan on bookings (actual rows=527778 l...</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>当查询执行时，如果计划的 worker 进程并可用的 worker 进程插槽要多，系统也只会创建与可用的 worker 进程插槽相等的 worker 进程。</p>
<h4 id="不可并行的查询"><a href="#不可并行的查询" class="headerlink" title="不可并行的查询"></a>不可并行的查询</h4><p><a href="https://postgrespro.com/docs/postgresql/13/when-can-parallel-query-be-used">并不是所有的查询都可以并行</a>。这些是不可并行化查询的类型：</p>
<ul>
<li><p>修改或锁定数据的查询（<code>UPDATE</code>, <code>DELETE</code>, <code>SELECT FOR UPDATE</code> 等）。</p>
<p>在 PostgreSQL 11 中，诸如 <code>CREATE TABLE AS</code>, <code>SELECT INTO</code> 和 <code>CREATE MATERIALIZED VIEW</code> 这样的查询仍然是可以并行的（在 14 和更高的版本 <code>REFRESH MATERIALIZED VIEW</code> 同样可以并行）。</p>
<p>但是，即使在这些情况下，所有 <code>INSERT</code> 操作仍将按顺序执行。</p>
</li>
<li><p>可以在执行期间暂停的任何查询。游标内的查询，包括 PL/pgSQL <code>FOR</code> 循环中的查询。</p>
</li>
<li><p>调用 <code>PARALLEL UNSAFE</code> 函数的查询。默认情况下，这包括所有用户定义的函数和一些标准函数。您可以从系统表中获取不安全函数的完整列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM pg_proc WHERE proparallel = &#x27;u&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>从已经并行化的查询中调用的函数中的查询（避免递归创建新的后台 worker 进程）。</p>
</li>
</ul>
<p>未来的 PostgreSQL 版本可能会消除其中一些限制。例如，版本 12 添加了在 <code>Serializable</code> 隔离级别并行化查询的能力。</p>
<p>查询不会并行运行的可能原因有多种：</p>
<ul>
<li><p>它首先是不可并行的。</p>
</li>
<li><p>您的配置阻止创建并行计划（包括当表小于并行化阈值时）。</p>
</li>
<li><p>并行计划比顺序计划成本更高。</p>
</li>
</ul>
<p>如果您想强制并行执行查询（用于研究或其他目的），您可以将参数 <code>force_parallel_mode</code> 设置为 <code>on</code>。这将使规划器总是产生并行计划，除非查询是严格不可并行的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> force_parallel_mode <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Gather (cost=1000.00..27259.37 rows=214867 width=63)</span><br><span class="line">   Workers Planned: 1</span><br><span class="line">   Single Copy: true</span><br><span class="line">   −&gt; Seq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<h4 id="并行受限的查询"><a href="#并行受限的查询" class="headerlink" title="并行受限的查询"></a>并行受限的查询</h4><p>一般来说，并行计划的好处主要取决于计划中有多少是并行兼容的。然而，有些操作在技术上不会阻止并行化，<a href="https://postgrespro.com/docs/postgresql/13/parallel-safety">但只能由 leader 进程按顺序执行</a>。换句话说，这些操作不能出现在计划的并行部分，在 <code>Gather</code> 节点下面。</p>
<p>__不可扩展的子查询__。包含不可扩展子查询的操作的一个基本示例是公用表表达式扫描（即下面的 <code>CTE Scan</code> 扫描节点）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (costs off)</span><br><span class="line"><span class="keyword">WITH</span> t <span class="keyword">AS</span> MATERIALIZED (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Aggregate</span><br><span class="line">   CTE t</span><br><span class="line">     −&gt; Seq Scan on flights</span><br><span class="line">   −&gt; CTE Scan on t</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>如果公用表表达式没有进行物化（这只会在 PostgreSQL 12 及更高的版本中可能），那么这里将不会有 <code>CTE Scan</code> 节点并且也不会出现问题。</p>
<p>如果它是更快的选项，表达式本身可以并行处理，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (costs off)</span><br><span class="line"><span class="keyword">WITH</span> t <span class="keyword">AS</span> MATERIALIZED (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> CTE Scan on t</span><br><span class="line">   CTE t</span><br><span class="line">     −&gt; Finalize Aggregate</span><br><span class="line">         −&gt; Gather</span><br><span class="line">             Workers Planned: 1</span><br><span class="line">             −&gt; Partial Aggregate</span><br><span class="line">                 −&gt; Parallel Seq Scan on flights</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

<p>不可扩展子查询的另一个示例是带有 <code>SubPlan</code> 节点的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (costs off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> flights f</span><br><span class="line"><span class="keyword">WHERE</span> f.scheduled_departure <span class="operator">&gt;</span> ( <span class="comment">-- SubPlan</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">min</span>(f2.scheduled_departure)</span><br><span class="line">  <span class="keyword">FROM</span> flights f2</span><br><span class="line">  <span class="keyword">WHERE</span> f2.aircraft_code <span class="operator">=</span> f.aircraft_code</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                      QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights f</span><br><span class="line">   Filter: (scheduled_departure &gt; (SubPlan 1))</span><br><span class="line">   SubPlan 1</span><br><span class="line">     −&gt; Aggregate</span><br><span class="line">         −&gt; Seq Scan on flights f2</span><br><span class="line">            Filter: (aircraft_code = f.aircraft_code)</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>前两行显示主查询的计划：扫描 <code>flights</code> 表并过滤每一行。过滤条件包括一个子查询，其计划遵循主计划。<code>SubPlan</code> 节点执行多次：在这种情况下，每个扫描行执行一次。</p>
<p>父节点 <code>Seq Scan</code> 无法并行化，因为它需要 <code>SubPlan</code> 输出才能继续。</p>
<p>最后一个示例是执行由 <code>InitPlan</code> 节点表示的不可扩展子查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN (costs off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> flights f</span><br><span class="line"><span class="keyword">WHERE</span> f.scheduled_departure <span class="operator">&gt;</span> ( <span class="comment">-- SubPlan</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">min</span>(f2.scheduled_departure) <span class="keyword">FROM</span> flights f2</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="comment">-- InitPlan</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> ticket_flights tf</span><br><span class="line">    <span class="keyword">WHERE</span> tf.flight_id <span class="operator">=</span> f.flight_id</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                      QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights f</span><br><span class="line">   Filter: (scheduled_departure &gt; (SubPlan 2))</span><br><span class="line">   SubPlan 2</span><br><span class="line">     −&gt; Finalize Aggregate</span><br><span class="line">         InitPlan 1 (returns $1)</span><br><span class="line">           −&gt; Seq Scan on ticket_flights tf</span><br><span class="line">               Filter: (flight_id = f.flight_id)</span><br><span class="line">         −&gt; Gather</span><br><span class="line">             Workers Planned: 1</span><br><span class="line">             Params Evaluated: $1</span><br><span class="line">             −&gt; Partial Aggregate</span><br><span class="line">                 −&gt; Result</span><br><span class="line">                     One−Time Filter: $1</span><br><span class="line">                     −&gt; Parallel Seq Scan on flights f2</span><br><span class="line">(14 rows)</span><br></pre></td></tr></table></figure>

<p>与 <code>SubPlan</code> 不同，<code>InitPlan</code> 节点只执行一次（在这种情况下，每次 <code>SubPlan 2</code> 执行一次）。</p>
<p><code>InitPlan</code> 节点的父节点不能并行化，但使用 <code>InitPlan</code> 输出的节点可以，如此处所示。</p>
<p>__临时表__。临时表只能按顺序扫描，因为只有 leader 进程才能访问它们。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> flights_tmp <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br><span class="line">EXPLAIN (costs off)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights_tmp;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Aggregate</span><br><span class="line">   −&gt; Seq Scan on flights_tmp</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>__并行受限的函数__。调用标记为 <code>PARALLEL RESTRICTED</code> 的函数只允许在计划的顺序部分内。您可以在系统表中找到受限函数的列表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_proc <span class="keyword">WHERE</span> proparallel <span class="operator">=</span> <span class="string">&#x27;r&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>只有在彻底研究了现有的限制并非常小心之后，才能标记您自己的函数为 <code>PARALLEL RESTRICTED</code>（更不用说 <code>PARALLEL SAFE</code>）。</p>
<p>未完待续。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><p>本文翻译自 <a href="https://postgrespro.com/">PostgreSQL Pro</a> 的 <a href="https://postgrespro.com/blog/pgsql/5969403">Queries in PostgreSQL: 3. Sequential scan</a>。</p>
<div class="just-for-fun">
笑林广记 - 酸臭

<p>小虎谓老虎曰：“今日出山，搏得一人食之，滋味甚异，上半截酸，下半截臭，究竟不知是何等人。”<br>老虎曰：“此必是秀才纳监者。”</p>
</div>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL SQL 查询路径</title>
    <url>/2021/11/the-path-of-a-query/</url>
    <content><![CDATA[<p>在 PostgreSQL 中，查询一般会经历以下几个阶段：</p>
<ol>
<li>应用程序连接到 PostgreSQL 并发送查询请求，随后等待返回结果。</li>
<li>解析器（parser）检查应用程序传输的查询的语法是否正确并创建查询树（query tree）。</li>
<li>重写系统（rewrite system）采用解析器阶段创建的查询树，并查找存储在系统表中的规则来重写查询树，例如视图。</li>
<li>规划器/优化器（planner/optimizer）采用（重写的）查询树并创建一个查询计划，该计划将作为执行器（executor）的输入。<br>它首先创建得到相同结果的所有路径。例如，在表上有索引，那么将会创建两个查询路径：顺序扫描和索引扫描。接下来估计每条路径的执行成本并选择最便宜的路径，将最便宜的路径扩展为执行器可以使用的完整计划。</li>
<li>执行器递归地遍历计划树并以计划表示的方式检索行。执行器在扫描表时会使用存储系统、执行排序和连接、估算条件并最后归还得到的行。</li>
</ol>
<span id="more"></span>

<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>PostgreSQL 采用客户端服务器模型实现，针对每一个客户端的连接，它将为其创建一个后端服务进程。由于我们不能提前知道有多少了连接，因此我们必须使用一个主进程在每次连接请求时创建一个后端服务进程。主进程是一个被称为 <code>postmaster</code> 的进程，它在一个特定的 TCP/IP 端口监听连接请求。当它监测到连接请求时，它将创建一个后端进程。这些后端进程使用信号量和共享内存相互通信并与实例的其他进程通信，以确保整个并发数据访问过程中的数据完整性。</p>
<p>如下所示，当我们启动数据库后一般会有如下进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">px@ubuntu:~/Codes/postgres/Debug$ ps -ef | grep postgres</span><br><span class="line">px       1785509       1  0 17:34 ?        00:00:00 /home/px/Codes/postgres/Debug/pg/bin/postgres</span><br><span class="line">px       1785510 1785509  0 17:34 ?        00:00:00 postgres: checkpointer</span><br><span class="line">px       1785511 1785509  0 17:34 ?        00:00:00 postgres: background writer</span><br><span class="line">px       1785513 1785509  0 17:34 ?        00:00:00 postgres: walwriter</span><br><span class="line">px       1785514 1785509  0 17:34 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">px       1785515 1785509  0 17:34 ?        00:00:00 postgres: stats collector</span><br><span class="line">px       1785516 1785509  0 17:34 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">px       1788661  578230  0 17:53 pts/8    00:00:00 grep --color=auto postgres</span><br></pre></td></tr></table></figure>

<p>此时，若我们在另一个终端通过 psql 连接数据库，其进程信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">px@ubuntu:~/Codes/postgres/Debug$ ps -ef | grep postgres</span><br><span class="line">px       1785509       1  0 17:34 ?        00:00:00 /home/px/Codes/postgres/Debug/pg/bin/postgres</span><br><span class="line">px       1785510 1785509  0 17:34 ?        00:00:00 postgres: checkpointer</span><br><span class="line">px       1785511 1785509  0 17:34 ?        00:00:00 postgres: background writer</span><br><span class="line">px       1785513 1785509  0 17:34 ?        00:00:00 postgres: walwriter</span><br><span class="line">px       1785514 1785509  0 17:34 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">px       1785515 1785509  0 17:34 ?        00:00:00 postgres: stats collector</span><br><span class="line">px       1785516 1785509  0 17:34 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">px       1788933  578230  0 17:55 pts/8    00:00:00 psql postgres</span><br><span class="line">px       1788934 1785509  0 17:55 ?        00:00:00 postgres: px postgres [local] idle</span><br><span class="line">px       1788954 1784579  0 17:55 pts/4    00:00:00 grep --color=auto postgres</span><br></pre></td></tr></table></figure>

<p>可以看到，后端进程中多了一个进程 ID 为 <code>1788934</code> 的进程。您可以在 psql 端通过 <code>pg_backend_pid()</code> 函数来进行验证。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">SELECT</span> pg_backend_pid();</span><br><span class="line"> pg_backend_pid</span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line">        <span class="number">1788934</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>连接建立后，客户端进程可以向其连接的后端进程发送查询。查询使用纯文本传输，即在客户端没有进行解析。后端进程解析查询，创建执行计划，执行计划，并通过在已建立的连接上传输检索到的行将它们返回给客户端。</p>
<p>为了验证上面的内容，我们创建 <code>friend</code> 的表并插入数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> friend (firstname text, lastname text, age <span class="type">int</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> friend <span class="keyword">VALUES</span> (<span class="string">&#x27;Sandy&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">33</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> friend <span class="keyword">VALUES</span> (<span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Jane&#x27;</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure>

<p>接着我们通过 psql 连接到数据库（注意需要走 TCP/IP，可以使用 <code>psql -h 127.0.0.1</code> 的方式进行连接），并利用 tcpdump 来捕获数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql -h 127.0.0.1 postgres</span><br><span class="line">postgres=# SELECT firstname</span><br><span class="line">postgres-# FROM friend</span><br><span class="line">postgres-# WHERE age = 33;</span><br><span class="line"> firstname</span><br><span class="line">-----------</span><br><span class="line"> Sandy</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>下面是 tcpdump 的输出，我们可以看到数据包中包含了我们在 psql 中输入的查询语句。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tcpdump -X -i lo port 5432</span></span><br><span class="line">18:17:57.376100 IP localhost.55238 &gt; localhost.postgresql: Flags [P.], seq 50:100, ack 113, win 512, options [nop,nop,TS val 1265806437 ecr 1265755262], length 50</span><br><span class="line">        0x0000:  4500 0066 313b 4000 4006 0b55 7f00 0001  E..f1;@.@..U....</span><br><span class="line">        0x0010:  7f00 0001 d7c6 1538 e8dd 8ea1 7e88 14b9  .......8....~...</span><br><span class="line">        0x0020:  8018 0200 fe5a 0000 0101 080a 4b72 ac65  .....Z......Kr.e</span><br><span class="line">        0x0030:  4b71 e47e 5100 0000 3153 454c 4543 5420  Kq.~Q...1SELECT.</span><br><span class="line">        0x0040:  6669 7273 746e 616d 650a 4652 4f4d 2066  firstname.FROM.f</span><br><span class="line">        0x0050:  7269 656e 640a 5748 4552 4520 6167 6520  riend.WHERE.age.</span><br><span class="line">        0x0060:  3d20 3333 3b00                           =.33;.</span><br><span class="line">18:17:57.376956 IP localhost.postgresql &gt; localhost.55238: Flags [P.], seq 113:184, ack 100, win 512, options [nop,nop,TS val 1265806438 ecr 1265806437], length 71</span><br><span class="line">        0x0000:  4500 007b 4194 4000 4006 fae6 7f00 0001  E..&#123;A.@.@.......</span><br><span class="line">        0x0010:  7f00 0001 1538 d7c6 7e88 14b9 e8dd 8ed3  .....8..~.......</span><br><span class="line">        0x0020:  8018 0200 fe6f 0000 0101 080a 4b72 ac66  .....o......Kr.f</span><br><span class="line">        0x0030:  4b72 ac65 5400 0000 2200 0166 6972 7374  Kr.eT...&quot;..first</span><br><span class="line">        0x0040:  6e61 6d65 0000 0040 0600 0100 0000 19ff  name...@........</span><br><span class="line">        0x0050:  ffff ffff ff00 0044 0000 000f 0001 0000  .......D........</span><br><span class="line">        0x0060:  0005 5361 6e64 7943 0000 000d 5345 4c45  ..SandyC....SELE</span><br><span class="line">        0x0070:  4354 2031 005a 0000 0005 49              CT.1.Z....I</span><br></pre></td></tr></table></figure>

<p>下图是 PostgreSQL 数据库连接的示意图，用户终端通过应用程序连接 PostgreSQL 服务器进行查询操作，而应用服务器一般情况下都是通过 libpq 这个库来实现对 PostgreSQL 数据库的访问。</p>
<img src="/2021/11/the-path-of-a-query/connection.png" class="">

<p>为了方便后续查看，建议设置以下选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_min_messages = debug5</span><br><span class="line">debug_print_parse = on</span><br><span class="line">debug_print_rewritten = on</span><br><span class="line">debug_print_plan = on</span><br><span class="line"># debug_pretty_print = on</span><br></pre></td></tr></table></figure>

<p>上面我们通过 ps 命令看到了新进程的创建，我们也可以在日志文件中找到相应的日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-11-21 18:59:25.293 CST [1798570] DEBUG:  forked new backend, pid=1798903 socket=9</span><br><span class="line">2021-11-21 18:59:25.300 CST [1798903] DEBUG:  InitPostgres</span><br><span class="line">2021-11-21 18:59:25.301 CST [1798903] DEBUG:  my backend ID is 3</span><br><span class="line">2021-11-21 18:59:25.303 CST [1798903] DEBUG:  StartTransaction(1) name: unnamed; blockState: DEFAULT; state: INPROGRESS, xid/subid/cid: 0/1/0</span><br><span class="line">2021-11-21 18:59:25.314 CST [1798903] DEBUG:  CommitTransaction(1) name: unnamed; blockState: STARTED; state: INPROGRESS, xid/subid/cid: 0/1/0</span><br><span class="line">2021-11-21 18:59:41.553 CST [1798903] DEBUG:  StartTransaction(1) name: unnamed; blockState: DEFAULT; state: INPROGRESS, xid/subid/cid: 0/1/0</span><br></pre></td></tr></table></figure>

<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>后端进程在接收到查询请求后，首先会进行查询的解析。解析器由两部分组成：</p>
<ul>
<li>定义在 <code>gram.y</code> 和 <code>scan.l</code> 文件中的解析器，它使用 Unix 的 bison 和 flex 工具实现。</li>
<li>转换过程对解析器返回的数据结构进行修改和扩充。</li>
</ul>
<h3 id="解析器-1"><a href="#解析器-1" class="headerlink" title="解析器"></a>解析器</h3><p>解析器必须检查查询字符串（以纯文本形式出现）的语法是否有效。 如果语法正确，则会建立并返回解析树； 否则返回错误。</p>
<p>词法分析其（lexer）定义在 <code>scan.l</code> 文件中，它负责识别标识符、SQL 关键字等。对于找到的每个关键字或标识符，都会生成一个标记（token）并将其传递给解析器。</p>
<p>解析器（parser）定义在 <code>gram.y</code> 文件中，它由一组语法规则和在触发规则时执行的操作组成。操作的代码（实际上是 C 代码）用于构建解析树。</p>
<p>下面就是一颗原始解析树的详细组成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-11-21 19:42:20.293 CST [1805230] LOG:  parse tree:</span><br><span class="line">2021-11-21 19:42:20.293 CST [1805230] DETAIL:  &#123;QUERY :commandType 1 :querySource 0 :canSetTag true :utilityStmt &lt;&gt;</span><br><span class="line">	:resultRelation 0 :hasAggs false :hasWindowFuncs false :hasTargetSRFs false</span><br><span class="line">	:hasSubLinks false :hasDistinctOn false :hasRecursive false :hasModifyingCTE</span><br><span class="line">	false :hasForUpdate false :hasRowSecurity false :isReturn false :cteList &lt;&gt;</span><br><span class="line">	:rtable (&#123;RANGETBLENTRY :alias &lt;&gt; :eref &#123;ALIAS :aliasname friend :colnames</span><br><span class="line">	(&quot;firstname&quot; &quot;lastname&quot; &quot;age&quot;)&#125; :rtekind 0 :relid 16384 :relkind r</span><br><span class="line">	:rellockmode 1 :tablesample &lt;&gt; :lateral false :inh true :inFromCl true</span><br><span class="line">	:requiredPerms 2 :checkAsUser 0 :selectedCols (b 8 10) :insertedCols (b)</span><br><span class="line">	:updatedCols (b) :extraUpdatedCols (b) :securityQuals &lt;&gt;&#125;) :jointree &#123;FROMEXPR</span><br><span class="line">	:fromlist (&#123;RANGETBLREF :rtindex 1&#125;) :quals &#123;OPEXPR :opno 96 :opfuncid 65</span><br><span class="line">	:opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args (&#123;VAR :varno</span><br><span class="line">	1 :varattno 3 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnosyn</span><br><span class="line">	1 :varattnosyn 3 :location 35&#125; &#123;CONST :consttype 23 :consttypmod -1</span><br><span class="line">	:constcollid 0 :constlen 4 :constbyval true :constisnull false :location 41</span><br><span class="line">	:constvalue 4 [ 33 0 0 0 0 0 0 0 ]&#125;) :location 39&#125;&#125; :targetList (&#123;TARGETENTRY</span><br><span class="line">	:expr &#123;VAR :varno 1 :varattno 1 :vartype 1043 :vartypmod 34 :varcollid 100</span><br><span class="line">	:varlevelsup 0 :varnosyn 1 :varattnosyn 1 :location 7&#125; :resno 1 :resname</span><br><span class="line">	firstname :ressortgroupref 0 :resorigtbl 16384 :resorigcol 1 :resjunk false&#125;)</span><br><span class="line">	:override 0 :onConflict &lt;&gt; :returningList &lt;&gt; :groupClause &lt;&gt; :groupDistinct</span><br><span class="line">	false :groupingSets &lt;&gt; :havingQual &lt;&gt; :windowClause &lt;&gt; :distinctClause &lt;&gt;</span><br><span class="line">	:sortClause &lt;&gt; :limitOffset &lt;&gt; :limitCount &lt;&gt; :limitOption 0 :rowMarks &lt;&gt;</span><br><span class="line">	:setOperations &lt;&gt; :constraintDeps &lt;&gt; :withCheckOptions &lt;&gt; :stmt_location 0</span><br><span class="line">	:stmt_len 43&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看 PostgreSQL 是如何识别标识符的。在 <code>scan.l</code> 文件中，您可以找到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">identifier      &#123;ident_start&#125;&#123;ident_cont&#125;*</span><br><span class="line"></span><br><span class="line">&#123;identifier&#125;    &#123;</span><br><span class="line">                    int         kwnum;</span><br><span class="line">                    char       *ident;</span><br><span class="line"></span><br><span class="line">                    SET_YYLLOC();</span><br><span class="line"></span><br><span class="line">                    /* Is it a keyword? */</span><br><span class="line">                    kwnum = ScanKeywordLookup(yytext,</span><br><span class="line">                                              yyextra-&gt;keywordlist);</span><br><span class="line">                    if (kwnum &gt;= 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        yylval-&gt;keyword = GetScanKeyword(kwnum,</span><br><span class="line">                                                         yyextra-&gt;keywordlist);</span><br><span class="line">                        return yyextra-&gt;keyword_tokens[kwnum];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    /*</span><br><span class="line">                     * No.  Convert the identifier to lower case, and truncate</span><br><span class="line">                     * if necessary.</span><br><span class="line">                     */</span><br><span class="line">                    ident = downcase_truncate_identifier(yytext, yyleng, true);</span><br><span class="line">                    yylval-&gt;str = ident;</span><br><span class="line">                    return IDENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&#123;other&#125;         &#123;</span><br><span class="line">                    SET_YYLLOC();</span><br><span class="line">                    return yytext[0];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;EOF&gt;&gt;         &#123;</span><br><span class="line">                    SET_YYLLOC();</span><br><span class="line">                    yyterminate();</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>您可以结合<a href="https://www.postgresql.org/docs/14/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">文档</a>来阅读这部分内容。标识符由 <code>ident_start</code> 和 <code>ident_cont</code> 两部分组成，它们的主要区别在于 <code>ident_start</code> 里面不包含数字，即标识符不能以数字开头。</p>
<p>接着，我们来看看解析器中 <code>SELECT</code> 触发的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">simple_select:</span><br><span class="line">            SELECT opt_all_clause opt_target_list</span><br><span class="line">            into_clause from_clause where_clause</span><br><span class="line">            group_clause having_clause window_clause</span><br><span class="line">                &#123;</span><br><span class="line">                    SelectStmt *n = makeNode(SelectStmt);</span><br><span class="line">                    n-&gt;targetList = $3;</span><br><span class="line">                    n-&gt;intoClause = $4;</span><br><span class="line">                    n-&gt;fromClause = $5;</span><br><span class="line">                    n-&gt;whereClause = $6;</span><br><span class="line">                    n-&gt;groupClause = ($7)-&gt;list;</span><br><span class="line">                    n-&gt;groupDistinct = ($7)-&gt;distinct;</span><br><span class="line">                    n-&gt;havingClause = $8;</span><br><span class="line">                    n-&gt;windowClause = $9;</span><br><span class="line">                    $$ = (Node *)n;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>这里仅给出了部分语法规则的实现，<code>SELECT</code> 语句还包含其他语法规则，您可以在 <code>gram.y</code> 文件的 <code>simple_select</code> 中找到。从上面我们可以看到，解析器将 <code>SELECT</code> 语句的解析结果存放到了 <code>SelectStmt</code> 结构中，<code>SelectStmt</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SelectStmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These fields are used only in &quot;leaf&quot; SelectStmts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List       *distinctClause; <span class="comment">/* NULL, list of DISTINCT ON exprs, or</span></span><br><span class="line"><span class="comment">                                 * lcons(NIL,NIL) for all (SELECT DISTINCT) */</span></span><br><span class="line">    IntoClause *intoClause;     <span class="comment">/* target for SELECT INTO */</span></span><br><span class="line">    List       *targetList;     <span class="comment">/* the target list (of ResTarget) */</span></span><br><span class="line">    List       *fromClause;     <span class="comment">/* the FROM clause */</span></span><br><span class="line">    Node       *whereClause;    <span class="comment">/* WHERE qualification */</span></span><br><span class="line">    List       *groupClause;    <span class="comment">/* GROUP BY clauses */</span></span><br><span class="line">    <span class="keyword">bool</span>        groupDistinct;  <span class="comment">/* Is this GROUP BY DISTINCT? */</span></span><br><span class="line">    Node       *havingClause;   <span class="comment">/* HAVING conditional-expression */</span></span><br><span class="line">    List       *windowClause;   <span class="comment">/* WINDOW window_name AS (...), ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * In a &quot;leaf&quot; node representing a VALUES list, the above fields are all</span></span><br><span class="line"><span class="comment">     * null, and instead this field is set.  Note that the elements of the</span></span><br><span class="line"><span class="comment">     * sublists are just expressions, without ResTarget decoration. Also note</span></span><br><span class="line"><span class="comment">     * that a list element can be DEFAULT (represented as a SetToDefault</span></span><br><span class="line"><span class="comment">     * node), regardless of the context of the VALUES list. It&#x27;s up to parse</span></span><br><span class="line"><span class="comment">     * analysis to reject that where not valid.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List       *valuesLists;    <span class="comment">/* untransformed list of expression lists */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These fields are used in both &quot;leaf&quot; SelectStmts and upper-level</span></span><br><span class="line"><span class="comment">     * SelectStmts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List       *sortClause;     <span class="comment">/* sort clause (a list of SortBy&#x27;s) */</span></span><br><span class="line">    Node       *limitOffset;    <span class="comment">/* # of result tuples to skip */</span></span><br><span class="line">    Node       *limitCount;     <span class="comment">/* # of result tuples to return */</span></span><br><span class="line">    LimitOption limitOption;    <span class="comment">/* limit type */</span></span><br><span class="line">    List       *lockingClause;  <span class="comment">/* FOR UPDATE (list of LockingClause&#x27;s) */</span></span><br><span class="line">    WithClause *withClause;     <span class="comment">/* WITH clause */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These fields are used only in upper-level SelectStmts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SetOperation op;            <span class="comment">/* type of set op */</span></span><br><span class="line">    <span class="keyword">bool</span>        all;            <span class="comment">/* ALL specified? */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SelectStmt</span> *<span class="title">larg</span>;</span>    <span class="comment">/* left child */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SelectStmt</span> *<span class="title">rarg</span>;</span>    <span class="comment">/* right child */</span></span><br><span class="line">    <span class="comment">/* Eventually add fields for CORRESPONDING spec here */</span></span><br><span class="line">&#125; SelectStmt;</span><br></pre></td></tr></table></figure>

<p>解析阶段所用到的数据类型基本上都定义在 <code>src/include/nodes/parsenodes.h</code> 文件中，如 <code>ResTarget</code>、<code>RangeVar</code>、和 <code>ColumnRef</code> 等。</p>
<h3 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h3><p>解析器阶段仅使用有关 SQL 语法结构的固定规则创建解析树。它不会在系统目录中进行任何查找，因此不可能了解所请求操作的详细语义。解析器完成后，转换过程将解析器返回的树作为输入，并进行语义解释以了解查询引用了哪些表、函数和运算符。为表示此信息而构建的数据结构称为查询树（query tree）。</p>
<p>我们将原始解析与语义分析分开的原因是系统目录查找只能在事务内完成，然而，我们并不希望在收到查询字符串后立即启动事务。原始解析阶段足以识别事务控制命令（<code>BEGIN</code>、<code>ROLLBACK</code> 等），然后无需任何进一步分析即可正确执行这些命令。一旦我们知道我们正在处理一个实际的查询（例如 <code>SELECT</code> 或 <code>UPDATE</code>），如果我们还没有进入一个事务，就可以开始一个事务。只有这样才能调用转换过程。</p>
<p>转换过程创建的查询树在大多数地方与原始解析树在结构上类似，但在细节上有很多不同。例如，解析树中的 <code>FuncCall</code> 节点表示在语法上看起来像函数调用的东西。这可能会转换为 <code>FuncExpr</code> 或 <code>Aggref</code> 节点，具体取决于引用的名称是普通函数还是聚合函数。此外，有关列的实际数据类型和表达式结果的信息会添加到查询树中。</p>
<p>转换过程则是通过一系列 <code>transformXXX()</code> 函数实现的，它从顶层的 <code>transformTopLevelStmt()</code> 函数开始，如果需要将针对 <code>SELECT INTO</code> 语句进行处理，最终到 <code>transformStmt()</code> 函数，该函数内部主要是一个 <code>switch ... case ...</code> 语句，针对不同的语句调用对应的 <code>transform</code> 函数，最后将返回一个查询树（query tree）。</p>
<h2 id="规则系统"><a href="#规则系统" class="headerlink" title="规则系统"></a>规则系统</h2><p>PostgreSQL 支持强大的规则系统来规范视图和模糊视图更新。最初的 PostgreSQL 规则系统由两个实现组成：</p>
<ul>
<li>第一个使用行级（row level）处理工作，并在执行程序的深处实现。每当访问单个行时，就会调用规则系统。这个实现在 1995 年被删除，当时伯克利 Postgres 项目的最后一个正式版本被转换成 Postgres95。</li>
<li>规则系统的第二种实现是一种称为查询重写的技术。重写系统是一个存在于解析器阶段和计划器/优化器之间的模块。</li>
</ul>
<p>关于查询重写在 <a href="https://www.postgresql.org/docs/14/rules.html">PostgreSQL 文档</a>中有详细的说明，这也是一个比较大的主题，这里我们简要介绍一下。</p>
<p>查询重写通过函数 <code>QueryRewrite()</code> 实现，它的输入和输出都是查询树，即树中的表示或语义细节级别没有变化。您可以把它认为是一种宏扩展。<code>QueryRewrite()</code> 函数分为三个步骤：</p>
<ol>
<li>应用所有非 <code>SELECT</code> 规则，这可能得到 0 个或多个查询树。</li>
<li>对每个查询应用 RIR 规则。</li>
<li>确定哪个结果查询应该设置命令结果标签；并相应地更新 <code>canSetTag</code> 字段。</li>
</ol>
<h2 id="计划器-优化器"><a href="#计划器-优化器" class="headerlink" title="计划器/优化器"></a>计划器/优化器</h2><p>计划器/优化器的任务是创建一个最佳的执行计划。一个给定的 SQL 查询（今后称为查询树）实际上可以有多种执行方式，每种方式都将产生相同的结果。如果在计算上可行，查询优化器将检查这些可能的执行计划中的每一个，最终选择预期运行速度最快的执行计划。</p>
<p>在某些情况下，检查一个查询所有可能的执行方式会耗费非常多的时间和内存空间。特别是当涉及大量表做连接操作的时候。为了能在合理的时间内给出一个合理的（不一定是最优的）查询计划，当连接数量超过 <a href="https://www.postgresql.org/docs/14/runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a> 时，PostgreSQL 将使用一种<a href="https://www.postgresql.org/docs/14/geqo.html">遗传查询优化器</a>。</p>
<p>计划器的搜索过程实际上使用称为路径（path）的数据结构，这些数据结构只是计划的简化表示，仅包含规划器做出决策所需的信息。在确定最便宜的路径后，将构建一个完整的计划树以传递给执行者。</p>
<p>计划器/优化器首先为每个独立的表生产计划，其中可能的计划取决于该表上可用的索引。通常表上只是存在一个顺序扫描的计划。假设在表上定义了一个索引（例如 B-tree 索引）并且查询包含 <code>relation.attribute OPR constant</code> 限制，如果 <code>relation.attribute</code> 恰好与 B-tree 索引的键匹配、并且 <code>OPR</code> 是索引的运算符中列出的运算符之一，那么将使用 B-tree 索引创建一个扫描计划。如果存在更多索引并且查询中的限制恰好与索引的键匹配，则将考虑这些扫描计划。此外，还有可能为匹配 <code>ORDER BY</code> 子句（如果有）的排序或者对归并连接（merge joining）有用的排序索引生成索引扫描计划。</p>
<p>如果查询包含两个或多个表的连接操作，在找到表的所有扫描计划之后，才会考虑表的连接计划。PostgreSQL 提供了三种策略的连接：</p>
<ul>
<li>嵌套循环连接（nested loop join）- 对于左侧表中的每一行，右侧的表都会执行一次扫描。这种策略实现比较简单，但是非常耗时。但是，如果可以使用索引扫描来扫描右侧的表，这可能是一个很好的策略。可以使用来自左表当前行的值作为右表索引扫描的键。</li>
<li>归并连接（merge join）- 在连接之前，每个表都依据连接属性列进行排序，接着并行的扫描两个表，匹配的行被整合为连接的行。由于每个表都只需扫描一次，因此非常具有吸引力。它所要求的排序可以通过一个显示的排序或使用一个连接键上的索引扫描得到。</li>
<li>哈希连接（hash join）- 首先扫描右侧的表并将其连接键作为哈希键存放到哈希表中。接下来扫描左侧的表并将找到的每一行的适当值用作散列键来定位表中的匹配行。</li>
</ul>
<p>当查询涉及两个以上的表时，最终结果必须由连接树构建，每个连接树有两个输入。规划器检查不同的可能连接序列以找到最便宜的连接序列。</p>
<p>如下图所示，计划中的 JOIN 节点的数据来其子节点，最简单的就是其下有两个扫描节点。</p>
<img src="/2021/11/the-path-of-a-query/join.jpg" class="">

<p>最终的计划树由基本上的顺序或索引扫描，加上可能的嵌套循环连接、归并连接和哈希连接，以及可能的其他辅助节点（例如，排序节点、聚合函数计算节点）组成。这些计划节点类型中的大多数都具有进行选择（丢弃不满足指定布尔条件的行）和投影（根据给定的列值计算派生列集，即在需要时评估标量表达式）的附加能力。计划者的职责之一是将来自 <code>WHERE</code> 子句的选择条件和所需输出表达式的计算附加到计划树的最合适的节点上。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器采用计划器/优化器创建的计划并递归处理它以提取所需的行集。 这本质上是一种需求拉动的管道机制。 每次调用计划节点时，它都必须再交付一行，或者报告已完成交付行。</p>
<p>以下图的例子来看，顶部节点是一个 MergeJoin 节点。在进行任何合并之前，必须获取两行（每个子计划中的一行）。所以执行器递归调用自己来处理子计划（它从附加到左树的子计划开始）。新的顶部节点（左侧子计划的顶部节点）是一个 Sort 节点，并且需要再次递归来获取输入行。Sort 的子节点是一个 SeqScan 节点，代表对表的实际读取。执行此节点会导致执行程序从表中获取一行并将其返回给调用节点。Sort 节点会反复调用它的子节点来获取所有要排序的行。当输入用完时（如子节点返回 NULL 而不是行），Sort 代码执行排序，最后能够返回其第一个输出行，即排序顺序中的第一个。它保存剩余的行，以便它可以按排序顺序传送它们以响应以后的需求。</p>
<img src="/2021/11/the-path-of-a-query/merge-join.jpg" class="">

<p>MergeJoin 节点同样要求其右侧子计划的第一行。然后比较两行，看是否可以连接；如果是，它向调用者返回一个连接行。在下一次调用时，或者如果它无法加入当前的输入对，它会立即前进到一个表或另一个表的下一行（取决于比较的结果），并再次检查是否匹配。最终，一个或另一个子计划用完，并且 MergeJoin 节点返回 NULL 以指示不能形成更多的连接行。</p>
<p>复杂的查询可能涉及多个级别的计划节点，但一般方法是相同的：每个节点每次调用时都会计算并返回其下一个输出行。每个节点还负责应用规划器分配给它的任何选择或投影表达式。</p>
<p>执行器机制用于执行四种基本 SQL 查询类型：<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>。对于 <code>SELECT</code>，顶层的执行器代码只需要将查询计划树返回的每一行发送给客户端。<code>INSERT ... SELECT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 是在名为 <code>ModifyTable</code> 的特殊顶层计划节点下的 <code>SELECT</code>。</p>
<p><code>INSERT ... SELECT</code> 将行记录返回给 <code>ModifyTable</code> 节点执行插入。对于 <code>UPDATE</code>，计划器安排每个计算行包括所有更新的列值，加上原始目标行的 <code>TID</code>（元组 <code>ID</code>，或行 <code>ID</code>）；该数据被传送到 <code>ModifyTable</code> 节点，该节点使用该信息创建一个新的更新行并将旧行标记为已删除。对于 <code>DELETE</code>，计划实际仅返回唯一的 <code>TID</code> 列，<code>ModifyTable</code> 节点使用 <code>TID</code> 访问每个目标行并将其标记为删除。</p>
<p>一个简单的 <code>INSERT ... VALUES</code> 命令创建一个由单个 <code>Result</code> 节点组成的简单计划树，它只计算一个结果行，将其馈送到 <code>ModifyTable</code> 以执行插入。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.postgresql.org/docs/14/query-path.html">https://www.postgresql.org/docs/14/query-path.html</a><br>[2] <a href="https://momjian.us/main/writings/pgsql/internalpics.pdf">https://momjian.us/main/writings/pgsql/internalpics.pdf</a></p>
<div class="just-for-fun">
笑林广记 - 垛子助阵

<p>一武官出征将败，忽有神兵助阵，反大胜。<br>官叩头请神姓名，神曰：“我是垛子。”<br>武官曰：“小将何德，敢劳垛子尊神见救。”<br>答曰：“感汝平昔在教场从不曾伤我一箭。”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】PostgreSQL 中的查询 - 统计信息</title>
    <url>/2022/03/queries-in-postgresql-statistics/</url>
    <content><![CDATA[<p>尽管不幸的事仍在发生<sup>[1]</sup>，但我们还是需要继续这个系列。在<a href="/2022/03/queries-in-postgresql-query-execution-stages/" title="上一篇文章">上一篇文章</a>中，我们回顾了查询执行的各个阶段。在我们继续计划节点操作（数据访问和连接方法）之前，我们需要了解成本优化器的基本要素：统计信息。</p>
<p>和往常一样，我所有的例子都使用<a href="https://postgrespro.com/education/demodb">演示数据库</a>。您可以下载并跟着一起执行。</p>
<p>今天您会在这里看到很多执行计划。我们将在以后的文章中更详细地讨论这些计划是如何运作的。现在只需注意您在每个计划的第一行中看到的数字，在单词 <code>rows</code> 旁边。这些是行数估计值或基数。</p>
<span id="more"></span>

<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>基本的表级别统计信息存放在 <code>pg_class</code> 系统表中。这些信息包括以下内容：</p>
<ul>
<li>表的行数（<code>reltuples</code>）</li>
<li>表的页面数（<code>relpages</code>）</li>
<li>在表的可见性图中标记为全部可见的页面数（<code>relallvisible</code>）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples, relpages, relallvisible</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | relpages | relallvisible</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−</span><br><span class="line">    214867 |     2624 |         2624</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>对于没有条件（过滤器）的查询，基数估计将等于 <code>reltuples</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>数据库在自动或手动分析期间收集统计数据。执行某些操作时也会计算基本统计信息，即重要信息，例如 <code>VACUUM FULL</code>、<code>CLUSTER</code>、<code>CREATE INDEX</code> 和 <code>REINDEX</code>。系统还会在 <code>VACUUM</code> 期间更新统计信息。</p>
<p>为了收集统计信息，分析器随机抽样 <code>300 * default_statistics_target</code> 条记录（默认情况下 <code>default_statistics_target</code> 为 <code>100</code>，即 <code>30,000</code> 条记录）。此处未考虑表大小，因为总体数据集大小对什么样的样本大小足以进行准确的统计几乎没有影响。</p>
<p>随机选择的 <code>300 * default_statistics_target</code> 样本是从随机的页面中选择的。如果表记录小于样本容量，那么分析器将读取整个表。</p>
<p>在大表中，统计数据将不精确，因为分析器不会扫描每一行。即便如此，统计数据也总会有些过时，因为表数据一直在变化。无论如何，我们不需要统计数据那么精确：高达一个数量级的变化仍然足够准确以产生适当的计划。</p>
<p>让我们创建一个禁用自动清理功能的 <code>flights</code> 的副本，以便我们可以控制何时进行分析。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> flights_copy(<span class="keyword">LIKE</span> flights)</span><br><span class="line"><span class="keyword">WITH</span> (autovacuum_enabled <span class="operator">=</span> <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>目前，新表还没有统计信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples, relpages, relallvisible</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | relpages | relallvisible</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−</span><br><span class="line">        −1 |        0 |             0</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>reltuples = -1</code>（PostgreSQL 14 及以上版本）有助于我们区分从未收集过统计信息的表和没有任何行的表。</p>
<p>通常情况下，新创建的表会立即填充。规划器对新表一无所知，因此默认情况下假定该表有 <code>10</code> 页。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights_copy;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights_copy  (cost=0.00..14.10 rows=410 width=170)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>规划器根据单行的宽度计算行数。宽度通常是在分析期间计算的平均值。但是，这次没有分析数据，因此系统根据列数据类型来近似宽度。</p>
<p>让我们将 <code>flights</code> 的数据复制到新表中并运行分析器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> flights_copy <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT 0 214867</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE flights_copy;</span><br></pre></td></tr></table></figure>

<p>现在统计信息与实际行数匹配。该表足够紧凑，分析器可以遍历每一行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples, relpages, relallvisible</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | relpages | relallvisible</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−</span><br><span class="line">    214867 |     2624 |             0</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>relallvisible</code> 的值将在 <code>VACUUM</code> 之后得到更新：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">VACUUM flights_copy;</span><br><span class="line"><span class="keyword">SELECT</span> relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> relallvisible</span><br><span class="line">−−−−−−−−−−−−−−−</span><br><span class="line">          2624</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这个值在估计仅索引扫描（index-only scan）时会被用到。</p>
<p>让我们在保留旧统计信息的同时将行数加倍，看看规划器得出的基数是多少：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> flights_copy <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights_copy;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> count</span><br><span class="line">−−−−−−−−</span><br><span class="line"> 429734</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights_copy;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                            QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights_copy  (cost=0.00..9545.34 rows=429734 width=63)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>尽管 <code>pg_class</code> 中的数据已经过时，但是这个估算是准确的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples, relpages</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> reltuples | relpages</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−</span><br><span class="line">    214867 |     2624</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>规划器注意到数据文件的大小不再匹配旧的 <code>relpages</code> 值，因此它适当地缩放 <code>reltuples</code> 以尝试提高准确性。文件大小增加了一倍，因此行数也相应调整（假设数据密度不变）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> reltuples <span class="operator">*</span></span><br><span class="line">  (pg_relation_size(<span class="string">&#x27;flights_copy&#x27;</span>) <span class="operator">/</span> <span class="number">8192</span>) <span class="operator">/</span> relpages</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ?column?</span><br><span class="line">−−−−−−−−−−</span><br><span class="line">   429734</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这种调整并不总是有效（例如，您有可能删除了某些行，但是统计信息没有更改），但是当进行重大更改时，这种方法可以让统计数据保持不变，直到分析器的出现。</p>
<h2 id="NULL-值"><a href="#NULL-值" class="headerlink" title="NULL 值"></a>NULL 值</h2><p>虽然被纯粹主义者看不起，但 <code>NULL</code> 值可以方便地表示未知或不存在的值。</p>
<p>但是特殊值需要特殊处理。使用 <code>NULL</code> 值时需要牢记一些实际的注意事项。布尔逻辑变成了三进制，<code>NOT IN</code> 构造开始表现得很奇怪。目前尚不清楚 NULL 值是否被视为低于或高于常规值（特殊子句 <code>NULLS FIRST</code> 和 <code>NULLS LAST</code> 对此有所帮助）。在聚合函数中使用 <code>NULL</code> 值也很粗略。因为 <code>NULL</code> 值实际上根本不是值，所以规划器需要额外的数据来容纳它们。</p>
<p>除了基本的表级统计信息，分析器还收集表中每一列的统计信息。这些据存储在系统目录的 <code>pg_statistic</code> 表中，可以使用 <code>pg_stats</code> 视图方便地显示。</p>
<p><code>NULL</code> 值率是列级别的统计信息。它在 <code>pg_stats</code> 中被指定为 <code>null_frac</code>。在这个例子中，一些飞机还没有起飞，所以它们的起飞时间是不确定的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                          QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..4772.67 rows=16036 width=63)</span><br><span class="line">   Filter: (actual_departure IS NULL)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>优化器将总行数乘以 <code>NULL</code> 值率得到估计的行数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> round(reltuples <span class="operator">*</span> s.null_frac) <span class="keyword">AS</span> <span class="keyword">rows</span></span><br><span class="line"><span class="keyword">FROM</span> pg_class</span><br><span class="line">  <span class="keyword">JOIN</span> pg_stats s <span class="keyword">ON</span> s.tablename <span class="operator">=</span> relname</span><br><span class="line"><span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;actual_departure&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> rows</span><br><span class="line">−−−−−−−</span><br><span class="line"> 16036</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="不同值"><a href="#不同值" class="headerlink" title="不同值"></a>不同值</h2><p>列中不同值（distinct values）的数量存储在 <code>pg_stats</code> 的 <code>n_distinct</code> 字段中。</p>
<p>如果 <code>n_distinct</code> 是负数，它的绝对值表示不同值占总数的比例。例如，<code>-1</code> 意味着列中的每个值都是唯一的。当不同值的数量达到总数量的 <code>10%</code> 或更多时，分析器将假设修改数据时该比例通常会保持不变，此时使用正数来表示不同值的数量。</p>
<p>如果不同值的数量计算不正确（因为样本恰好不具有代表性），您可以手动设置此值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ... <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> ... <span class="keyword">SET</span> (n_distinct <span class="operator">=</span> ...);</span><br></pre></td></tr></table></figure>

<img src="/2022/03/queries-in-postgresql-statistics/statistics1-en.png" class="">

<p>在数据均匀分布的情况下，不同值的数量很有用。考虑 <code>column = expression</code> 子句的基数估计。如果在规划阶段表达式的值未知，则规划器假定表达式同样可能从列中返回任何值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> departure_airport <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> airport_code <span class="keyword">FROM</span> airports <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;Saint Petersburg&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                         QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=30.56..5340.40 rows=2066 width=63)</span><br><span class="line">   Filter: (departure_airport = $0)</span><br><span class="line">   InitPlan 1 (returns $0)</span><br><span class="line">     −&gt; Seq Scan on airports_data ml  (cost=0.00..30.56 rows=1 wi...</span><br><span class="line">         Filter: ((city −&gt;&gt; lang()) = &#x27;Saint Petersburg&#x27;::text)</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>

<p><code>InitPlan</code> 节点只执行一次，然后在主计划中使用该值替换 <code>$0</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> round(reltuples <span class="operator">/</span> s.n_distinct) <span class="keyword">AS</span> <span class="keyword">rows</span></span><br><span class="line"><span class="keyword">FROM</span> pg_class</span><br><span class="line">  <span class="keyword">JOIN</span> pg_stats s <span class="keyword">ON</span> s.tablename <span class="operator">=</span> relname</span><br><span class="line"><span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;departure_airport&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> rows</span><br><span class="line">−−−−−−</span><br><span class="line"> 2066</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>如果所有数据均匀分布，则这些统计数据（连同最小值和最大值）足以进行准确的估计。不幸的是，这种估计不适用于非均匀分布，通常后者更为常见：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">min</span>(cnt), round(<span class="built_in">avg</span>(cnt)) avg, <span class="built_in">max</span>(cnt) <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> departure_airport, <span class="built_in">count</span>(<span class="operator">*</span>) cnt</span><br><span class="line">  <span class="keyword">FROM</span> flights <span class="keyword">GROUP</span> <span class="keyword">BY</span> departure_airport</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> min | avg  |  max</span><br><span class="line">−−−−−+−−−−−−+−−−−−−−</span><br><span class="line"> 113 | 2066 | 20875</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="最常见的值"><a href="#最常见的值" class="headerlink" title="最常见的值"></a>最常见的值</h2><p>为了提高非均匀分布的估计精度，分析器收集最常见值 (MCV, Most Common Calues) 及其频率的统计信息。这些信息存储在 <code>pg_stats</code> 的 <code>most_common_vals</code> 和 <code>most_common_freqs</code> 中。</p>
<img src="/2022/03/queries-in-postgresql-statistics/statistics2-en.png" class="">

<p>以下是最常见飞机类型的此类统计数据示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> most_common_vals <span class="keyword">AS</span> mcv,</span><br><span class="line">  <span class="keyword">left</span>(most_common_freqs::text,<span class="number">60</span>) <span class="operator">||</span> <span class="string">&#x27;...&#x27;</span> <span class="keyword">AS</span> mcf</span><br><span class="line"><span class="keyword">FROM</span> pg_stats</span><br><span class="line"><span class="keyword">WHERE</span> tablename <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span> <span class="keyword">AND</span> attname <span class="operator">=</span> <span class="string">&#x27;aircraft_code&#x27;</span> \gx</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">mcv | &#123;CN1,CR2,SU9,321,763,733,319,773&#125;</span><br><span class="line">mcf | &#123;0.2783,0.27473333,0.25816667,0.059233334,0.038533334,0.0370...</span><br></pre></td></tr></table></figure>

<p>估计 <code>column = expression</code> 的选择率非常简单：规划器只需从 <code>most_common_vals</code> 数组中获取一个值，并将其乘以来自 <code>most_common_freqs</code> 数组中相同位置的频率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> aircraft_code <span class="operator">=</span> <span class="string">&#x27;733&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                          QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..5309.84 rows=7957 width=63)</span><br><span class="line">   Filter: (aircraft_code = &#x27;733&#x27;::bpchar)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT round(reltuples * s.most_common_freqs[</span><br><span class="line">  array_position((s.most_common_vals::text::text[]),&#x27;733&#x27;)</span><br><span class="line">])</span><br><span class="line">FROM pg_class</span><br><span class="line">  JOIN pg_stats s ON s.tablename = relname</span><br><span class="line">WHERE s.tablename = &#x27;flights&#x27;</span><br><span class="line">  AND s.attname = &#x27;aircraft_code&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> round</span><br><span class="line">−−−−−−−</span><br><span class="line">  7957</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这个估计值将接近 <code>8263</code> 的真实值。</p>
<p>MCV 列表也用于不等式的选择性估计：为了找到 <code>column &lt; value</code> 的选择率，规划器在 <code>most_common_vals</code> 中搜索所有低于给定值的值，然后将它们从 <code>most_common_freqs</code> 中的频率相加。</p>
<p>当不同值的数量较少时，常用值统计最有效。MCV 数组的最大大小由 <code>default_statistics_target</code> 定义，与分析期间记录的样本大小相同。</p>
<p>在某些情况下，将值（以及数组大小）增加到超出默认值将提供更准确的估计。您可以为每列设置此值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ... <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> ... <span class="keyword">SET</span> STATISTICS ...;</span><br></pre></td></tr></table></figure>

<p>行样本大小也会增加，但仅限于此表。</p>
<p>常用值数组存储值本身，并且根据值的不同，可能会占用大量空间。就是为什么超过 1kB 的值被排除在分析和统计之外的原因。它可以控制 <code>pg_statistic</code> 的大小，并且不会使规划器超载。无论如何，这么大的值通常是不同的，不会包含在 <code>most_common_vals</code> 中。</p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>当不同值的数量变得太大而无法将它们全部存储在数组中时，系统开始使用直方图（Histogram）表示。直方图使用多个存储桶来存储值。存储桶的数量受相同的 <code>default_statistics_target</code> 参数限制。选择每个桶的宽度，以便将值均匀分布在它们之间（如下图所示具有大致相同面积的矩形所示）。这种表示使系统能够只存储直方图边界，而不是浪费空间来存储每个桶的频率。直方图不包括 MCV 列表中的值。</p>
<img src="/2022/03/queries-in-postgresql-statistics/statistics3-en.png" class="">

<p>边界存储在 <code>pg_stats</code> 的 <code>histogram_bounds</code> 字段中。任何桶中值的汇总频率等于 1 / 桶数。</p>
<p>直方图存储桶边界数组：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">left</span>(histogram_bounds::text,<span class="number">60</span>) <span class="operator">||</span> <span class="string">&#x27;...&#x27;</span> <span class="keyword">AS</span> histogram_bounds</span><br><span class="line"><span class="keyword">FROM</span> pg_stats s</span><br><span class="line"><span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;boarding_passes&#x27;</span> <span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;seat_no&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                        histogram_bounds</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> &#123;10B,10D,10D,10F,11B,11C,11H,12H,13B,14B,14H,15H,16D,16D,16H...</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>其中，直方图与 MCV 一起用于评估大于和小于操作的选择率。</p>
<p>示例：计算为后排座位签发的登机牌数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> boarding_passes <span class="keyword">WHERE</span> seat_no <span class="operator">&gt;</span> <span class="string">&#x27;30C&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on boarding_passes  (cost=0.00..157353.30 rows=2943394 ...</span><br><span class="line">   Filter: ((seat_no)::text &gt; &#x27;30C&#x27;::text)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>分割的座位号是专门选择在两个桶之间的边缘。</p>
<p>这个条件的选择率是 N / 桶数，其中 N 是具有匹配值的桶的数量（在分割的座位号的右侧）。请记住，直方图没有考虑最常见的值和未定义的值。让我们先看看匹配最常见值的分数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(s.most_common_freqs[</span><br><span class="line">  array_position((s.most_common_vals::text::text[]),v)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">FROM</span> pg_stats s, <span class="built_in">unnest</span>(s.most_common_vals::text::text[]) v</span><br><span class="line"><span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;boarding_passes&#x27;</span> <span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;seat_no&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> v <span class="operator">&gt;</span> <span class="string">&#x27;30C&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  sum</span><br><span class="line">−−−−−−−−</span><br><span class="line"> 0.2127</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>现在让我们看看最常用值的频率（从直方图中排除）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(s.most_common_freqs[</span><br><span class="line">  array_position((s.most_common_vals::text::text[]),v)</span><br><span class="line">])</span><br><span class="line"><span class="keyword">FROM</span> pg_stats s, <span class="built_in">unnest</span>(s.most_common_vals::text::text[]) v</span><br><span class="line"><span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;boarding_passes&#x27;</span> <span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;seat_no&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  sum</span><br><span class="line">−−−−−−−−</span><br><span class="line"> 0.6762</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>seat_no</code> 列中没有 <code>NULL</code> 值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.null_frac</span><br><span class="line"><span class="keyword">FROM</span> pg_stats s</span><br><span class="line"><span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;boarding_passes&#x27;</span> <span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;seat_no&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> null_frac</span><br><span class="line">−−−−−−−−−−−</span><br><span class="line">         0</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>区间正好涵盖 49 个桶（总共 100 个）。结果估计：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> round( reltuples <span class="operator">*</span> (</span><br><span class="line">   <span class="number">0.2127</span> <span class="comment">-- from most common values</span></span><br><span class="line"> <span class="operator">+</span> (<span class="number">1</span> <span class="operator">-</span> <span class="number">0.6762</span> <span class="operator">-</span> <span class="number">0</span>) <span class="operator">*</span> (<span class="number">49</span> <span class="operator">/</span> <span class="number">100.0</span>) <span class="comment">-- from histogram</span></span><br><span class="line">))</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;boarding_passes&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  round</span><br><span class="line">−−−−−−−−−</span><br><span class="line"> 2943394</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>真实值为 <code>2986429</code>。</p>
<p>当截止值不在桶的边缘时，该桶的匹配分数是使用线性插值计算的。</p>
<img src="/2022/03/queries-in-postgresql-statistics/statistics4-en.png" class="">

<p>较高的 <code>default_statistics_target</code> 值可能会提高估计精度，但是，即便是在有大量不同的值时，直方图与 MCV 列表一起已经产生了很好的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> n_distinct <span class="keyword">FROM</span> pg_stats</span><br><span class="line"><span class="keyword">WHERE</span> tablename <span class="operator">=</span> <span class="string">&#x27;boarding_passes&#x27;</span> <span class="keyword">AND</span> attname <span class="operator">=</span> <span class="string">&#x27;seat_no&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> n_distinct</span><br><span class="line">−−−−−−−−−−−−</span><br><span class="line">        461</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>更高的估计精度只有在提高规划质量时才有用。在没有正当理由的情况下增加 <code>default_statistics_target</code> 可能会减慢分析和计划，但对优化没有影响。</p>
<p>另一方面，降低参数（一直降至零）可能会提高分析和计划速度，但也可能导致计划质量低下，因此这种“节省时间”很少有道理。</p>
<h2 id="非标量数据类型的统计"><a href="#非标量数据类型的统计" class="headerlink" title="非标量数据类型的统计"></a>非标量数据类型的统计</h2><p>非标量数据类型的统计（statistics for nonscalar data types）可能不仅包括非标量值本身的分布数据，还包括它们的组成元素的分布数据。这允许在查询非第一范式中的列时进行更准确的计划。</p>
<ul>
<li>数组 <code>most_common_elems</code> 和 <code>most_common_elem_freqs</code> 分别包含最常见的元素及其频率。这些统计数据被收集并用于估计数组和 <code>tsvector</code> 数据的选择率。</li>
<li><code>elem_count_histogram</code> 数组是一个值中不同元素数量的直方图。收集这些统计数据并仅用于估计数组的选择率。</li>
<li>对于范围数据类型，直方图用于表示范围长度的分布及其下限和上限的分布。然后，这些直方图有助于估计使用这些数据类型的各种操作的选择率。它们没有显示在 <code>pg_stats</code> 视图中。这些统计信息也用于 PostgreSQL 14 中引入的多范围数据类型。</li>
</ul>
<h2 id="平均宽度"><a href="#平均宽度" class="headerlink" title="平均宽度"></a>平均宽度</h2><p><code>pg_stats</code> 视图中的 <code>avg_width</code> 字段表示列中的平均字段宽度（Average field width）。整数或 <code>char(3)</code> 等数据类型的字段宽度显然是固定的，但对于没有设置宽度的数据类型，例如文本，值可能会因列而异：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attname, avg_width <span class="keyword">FROM</span> pg_stats</span><br><span class="line"><span class="keyword">WHERE</span> (tablename, attname) <span class="keyword">IN</span> ( <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;tickets&#x27;</span>, <span class="string">&#x27;passenger_name&#x27;</span>), (<span class="string">&#x27;ticket_flights&#x27;</span>,<span class="string">&#x27;fare_conditions&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     attname     | avg_width</span><br><span class="line">−−−−−−−−−−−−−−−−−+−−−−−−−−−−−</span><br><span class="line"> fare_conditions |         8</span><br><span class="line"> passenger_name  |        16</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>这些统计信息有助于估计排序或散列等操作的内存使用情况。</p>
<h2 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h2><p><code>pg_stats</code> 中的字段 <code>correlation</code> 表示磁盘上的物理行排序与列值的逻辑排序（“大于”或“小于”）之间的相关性（correlation），范围从 -1 到 +1。如果这些值按顺序存储，则相关性将接近 +1。如果它们以相反的顺序存储，则相关性将更接近 -1。数据在磁盘上分布越混乱，值越接近于零。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attname, correlation</span><br><span class="line"><span class="keyword">FROM</span> pg_stats <span class="keyword">WHERE</span> tablename <span class="operator">=</span> <span class="string">&#x27;airports_data&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">abs</span>(correlation) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   attname    | correlation</span><br><span class="line">−−−−−−−−−−−−−−+−−−−−−−−−−−−−</span><br><span class="line"> coordinates  |</span><br><span class="line"> airport_code | −0.21120238</span><br><span class="line"> city         |  −0.1970127</span><br><span class="line"> airport_name | −0.18223621</span><br><span class="line"> timezone     |  0.17961165</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>

<p>无法收集 <code>coordinates</code> 列的统计信息，因为没有为 <code>point</code> 数据类型定义比较操作（“小于”和“大于”）。</p>
<p>相关性用于索引扫描成本估计。</p>
<h2 id="表达式统计信息"><a href="#表达式统计信息" class="headerlink" title="表达式统计信息"></a>表达式统计信息</h2><p>一般来说，列统计只在操作调用列本身时使用，而不是用于以列为参数的表达式。规划器不知道函数将如何影响列统计信息，因此像 <code>function-call = constant</code> 这样的条件总是估计为 0.5%：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">extract</span>(</span><br><span class="line">  <span class="keyword">month</span> <span class="keyword">FROM</span> scheduled_departure <span class="keyword">AT</span> <span class="type">TIME</span> ZONE <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">) <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..6384.17 rows=1074 width=63)</span><br><span class="line">   Filter: (EXTRACT(month FROM (scheduled_departure AT TIME ZONE ...</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> round(reltuples <span class="operator">*</span> <span class="number">0.005</span>)</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> round</span><br><span class="line">−−−−−−−</span><br><span class="line">  1074</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>规划器甚至无法处理标准函数，而对我们来说，很明显 1 月份的航班比例将约为总航班的 1/12：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total,</span><br><span class="line">  <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FILTER</span> (<span class="keyword">WHERE</span> <span class="built_in">extract</span>(</span><br><span class="line">    <span class="keyword">month</span> <span class="keyword">FROM</span> scheduled_departure <span class="keyword">AT</span> <span class="type">TIME</span> ZONE <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">  ) <span class="operator">=</span> <span class="number">1</span>) <span class="keyword">AS</span> january</span><br><span class="line"><span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> total  | january</span><br><span class="line">−−−−−−−−+−−−−−−−−−</span><br><span class="line"> 214867 |   16831</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这就是表达式统计的用武之地。</p>
<h3 id="扩展表达式统计信息"><a href="#扩展表达式统计信息" class="headerlink" title="扩展表达式统计信息"></a>扩展表达式统计信息</h3><p>PostgreSQL 14 引入了一种称为扩展表达式统计信息（extended expression statistics）的特性。扩展表达式统计信息不会自动收集。要手动收集它们，请使用 <code>CREATE STATISTICS</code> 命令创建扩展的统计数据库对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE STATISTICS flights_expr ON (extract(</span><br><span class="line">  month FROM scheduled_departure AT TIME ZONE &#x27;Europe/Moscow&#x27;</span><br><span class="line">))</span><br><span class="line">FROM flights;</span><br></pre></td></tr></table></figure>

<p>新的统计数据将改进估计：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE flights;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">extract</span>(</span><br><span class="line">  <span class="keyword">month</span> <span class="keyword">FROM</span> scheduled_departure <span class="keyword">AT</span> <span class="type">TIME</span> ZONE <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">) <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..6384.17 rows=16222 width=63)</span><br><span class="line">   Filter: (EXTRACT(month FROM (scheduled_departure AT TIME ZONE ...</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>要使统计信息起作用，统计信息生成命令中的表达式必须与原始查询中的表达式相同。扩展统计元数据存储在系统目录的 <code>pg_statistic_ext</code> 表中，而统计数据本身存储在单独的表 <code>pg_statistic_ext_data</code> 中（在 PostgreSQL 12 及更高版本中）。如有必要，它与元数据分开存储，以限制用户访问敏感信息。</p>
<p>有些视图以用户友好的形式显示收集的统计信息。可以使用以下命令显示扩展表达式统计信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">left</span>(expr,<span class="number">50</span>) <span class="operator">||</span> <span class="string">&#x27;...&#x27;</span> <span class="keyword">AS</span> expr,</span><br><span class="line">  null_frac, avg_width, n_distinct,</span><br><span class="line">  most_common_vals <span class="keyword">AS</span> mcv,</span><br><span class="line">  <span class="keyword">left</span>(most_common_freqs::text,<span class="number">50</span>) <span class="operator">||</span> <span class="string">&#x27;...&#x27;</span> <span class="keyword">AS</span> mcf,</span><br><span class="line">  correlation</span><br><span class="line"><span class="keyword">FROM</span> pg_stats_ext_exprs <span class="keyword">WHERE</span> statistics_name <span class="operator">=</span> <span class="string">&#x27;flights_expr&#x27;</span> \gx</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">expr        | EXTRACT(month FROM (scheduled_departure AT TIME ZO...</span><br><span class="line">null_frac   | 0</span><br><span class="line">avg_width   | 8</span><br><span class="line">n_distinct  | 12</span><br><span class="line">mcv         | &#123;8,9,3,5,12,4,10,7,11,1,6,2&#125;</span><br><span class="line">mcf         | &#123;0.12526667,0.11016667,0.07903333,0.07903333,0.078..</span><br><span class="line">correlation | 0.095407926</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>ALTER STATISTICS</code> 命令更改收集的统计数据量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> STATISTICS flights_expr <span class="keyword">SET</span> STATISTICS <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h3 id="表达式索引统计信息"><a href="#表达式索引统计信息" class="headerlink" title="表达式索引统计信息"></a>表达式索引统计信息</h3><p>建立表达式索引时，系统会收集其统计信息，就像使用常规表一样。规划器也可以使用这些统计数据。这很方便，但前提是我们真正关心索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> STATISTICS flights_expr;</span><br><span class="line"><span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> flights(<span class="built_in">extract</span>(</span><br><span class="line">  <span class="keyword">month</span> <span class="keyword">FROM</span> scheduled_departure <span class="keyword">AT</span> <span class="type">TIME</span> ZONE <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">)); <span class="operator">=</span><span class="operator">&gt;</span> ANALYZE flights;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> <span class="built_in">extract</span>(</span><br><span class="line">  <span class="keyword">month</span> <span class="keyword">FROM</span> scheduled_departure <span class="keyword">AT</span> <span class="type">TIME</span> ZONE <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">) <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Bitmap Heap Scan on flights  (cost=318.42..3235.96 rows=16774 wi...</span><br><span class="line">   Recheck Cond: (EXTRACT(month FROM (scheduled_departure AT TIME...</span><br><span class="line">   −&gt; Bitmap Index Scan on flights_extract_idx  (cost=0.00..314.2...</span><br><span class="line">       Index Cond: (EXTRACT(month FROM (scheduled_departure AT TI...</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>表达式索引统计信息的存储方式与表统计信息相同。例如，这是不同值的数量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> n_distinct <span class="keyword">FROM</span> pg_stats</span><br><span class="line"><span class="keyword">WHERE</span> tablename <span class="operator">=</span> <span class="string">&#x27;flights_extract_idx&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> n_distinct</span><br><span class="line">−−−−−−−−−−−−</span><br><span class="line">         12</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>在 PostgreSQL 11 及更高版本中，可以使用 <code>ALTER INDEX</code> 命令更改索引统计信息的准确性。您可能需要引用该表达式的列的名称。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attname <span class="keyword">FROM</span> pg_attribute</span><br><span class="line"><span class="keyword">WHERE</span> attrelid <span class="operator">=</span> <span class="string">&#x27;flights_extract_idx&#x27;</span>::regclass;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> attname</span><br><span class="line">−−−−−−−−−</span><br><span class="line"> extract</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER INDEX flights_extract_idx</span><br><span class="line">  ALTER COLUMN extract SET STATISTICS 42;</span><br></pre></td></tr></table></figure>

<h2 id="多元统计信息"><a href="#多元统计信息" class="headerlink" title="多元统计信息"></a>多元统计信息</h2><p>PostgreSQL 10 引入了同时从多个列收集统计信息的能力，也称为多元统计信息（multivariate statistics）。这需要手动生成必要的扩展统计信息。</p>
<p>多元统计分为三种类型。</p>
<h3 id="列之间的功能依赖关系"><a href="#列之间的功能依赖关系" class="headerlink" title="列之间的功能依赖关系"></a>列之间的功能依赖关系</h3><p>当一列中的值（完全或部分）由另一列中的值确定，并且在查询中存在引用两列的条件时，结果基数将被低估。</p>
<p>这是一个具有两个条件的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> flight_no <span class="operator">=</span> <span class="string">&#x27;PG0007&#x27;</span> <span class="keyword">AND</span> departure_airport <span class="operator">=</span> <span class="string">&#x27;VKO&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> count</span><br><span class="line">−−−−−−−</span><br><span class="line">   396</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>估计值明显低于应有的值，只有 26 行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> flight_no <span class="operator">=</span> <span class="string">&#x27;PG0007&#x27;</span> <span class="keyword">AND</span> departure_airport <span class="operator">=</span> <span class="string">&#x27;VKO&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Bitmap Heap Scan on flights  (cost=12.03..1238.70 rows=26 width=63)</span><br><span class="line">   Recheck Cond: (flight_no = &#x27;PG0007&#x27;::bpchar)</span><br><span class="line">   Filter: (departure_airport = &#x27;VKO&#x27;::bpchar)</span><br><span class="line">   −&gt; Bitmap Index Scan on flights_flight_no_scheduled_departure_key</span><br><span class="line">       (cost=0.00..12.02 rows=480 width=0)</span><br><span class="line">       Index Cond: (flight_no = &#x27;PG0007&#x27;::bpchar)</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>这就是臭名昭著的相关谓词（correlated predicates）问题。规划器期望谓词是独立的，并将结果选择率计算为条件选择率的乘积，与 AND 相结合。在应用位图堆扫描中的 <code>departure_airport</code> 条件后，为 <code>flight_no</code> 条件计算的位图索引扫描估计值明显下降。</p>
<p>事实上，一个航班号已经明确定义了出发机场，所以第二个条件实际上是多余的。这就是扩展的功能依存度统计可以帮助改进估计的地方。</p>
<p>让我们为两列创建扩展的函数依赖统计信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> STATISTICS flights_dep(dependencies)</span><br><span class="line"><span class="keyword">ON</span> flight_no, departure_airport <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<p>再次分析，现在使用新的统计数据，估计得到改善：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE flights;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> flight_no <span class="operator">=</span> <span class="string">&#x27;PG0007&#x27;</span> <span class="keyword">AND</span> departure_airport <span class="operator">=</span> <span class="string">&#x27;VKO&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Bitmap Heap Scan on flights  (cost=10.56..816.91 rows=276 width=63)</span><br><span class="line">   Recheck Cond: (flight_no = &#x27;PG0007&#x27;::bpchar)</span><br><span class="line">   Filter: (departure_airport = &#x27;VKO&#x27;::bpchar)</span><br><span class="line">   −&gt; Bitmap Index Scan on flights_flight_no_scheduled_departure_key</span><br><span class="line">       (cost=0.00..10.49 rows=276 width=0)</span><br><span class="line">       Index Cond: (flight_no = &#x27;PG0007&#x27;::bpchar)</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>统计信息存储在系统目录中，可以使用以下命令查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dependencies</span><br><span class="line"><span class="keyword">FROM</span> pg_stats_ext <span class="keyword">WHERE</span> statistics_name <span class="operator">=</span> <span class="string">&#x27;flights_dep&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">               dependencies</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> &#123;&quot;2 =&gt; 5&quot;: 1.000000, &quot;5 =&gt; 2&quot;: 0.010567&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>数字 2 和 5 是来自 <code>pg_attribute</code> 的表列号。它们旁边的值表示函数依赖的程度，从 0（独立）到 1（第二列中的值完全由第一列中的值定义）。</p>
<h3 id="多元不同值的数量"><a href="#多元不同值的数量" class="headerlink" title="多元不同值的数量"></a>多元不同值的数量</h3><p>来自多列的不同值组合数量的统计信息将显着提高对多列进行 <code>GROUP BY</code> 操作的基数。</p>
<p>在此示例中，规划器将可能的出发和到达机场对的数量估计为机场总数的平方。然而，真实的成对数量要低得多，因为并非每两个机场都通过直飞航班连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> departure_airport, arrival_airport <span class="keyword">FROM</span> flights</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> count</span><br><span class="line">−−−−−−−</span><br><span class="line">   618</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> departure_airport, arrival_airport <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> HashAggregate  (cost=5847.01..5955.16 rows=10816 width=8)</span><br><span class="line">   Group Key: departure_airport, arrival_airport</span><br><span class="line">   −&gt; Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=8)</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>让我们为不同值的数量创建一个扩展统计信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> STATISTICS flights_nd(ndistinct)</span><br><span class="line"><span class="keyword">ON</span> departure_airport, arrival_airport <span class="keyword">FROM</span> flights;</span><br><span class="line">ANALYZE flights;</span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> departure_airport, arrival_airport <span class="keyword">FROM</span> flights;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> HashAggregate (cost=5847.01..5853.19 rows=618 width=8)</span><br><span class="line">   Group Key: departure_airport, arrival_airport</span><br><span class="line">   −&gt; Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=8)</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>统计信息存储在系统目录中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> n_distinct</span><br><span class="line"><span class="keyword">FROM</span> pg_stats_ext <span class="keyword">WHERE</span> statistics_name <span class="operator">=</span> <span class="string">&#x27;flights_nd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  n_distinct</span><br><span class="line">−−−−−−−−−−−−−−−</span><br><span class="line"> &#123;&quot;5, 6&quot;: 618&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h3 id="多元最常见值列表"><a href="#多元最常见值列表" class="headerlink" title="多元最常见值列表"></a>多元最常见值列表</h3><p>当值分布不均匀时，仅功能依赖数据可能不够，因为估计值将根据特定的值对而显着变化。考虑这个例子，规划器错误地估计了波音 737 从 Sheremetyevo 机场起飞的航班数量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> departure_airport <span class="operator">=</span> <span class="string">&#x27;SVO&#x27;</span> <span class="keyword">AND</span> aircraft_code <span class="operator">=</span> <span class="string">&#x27;733&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> count</span><br><span class="line">−−−−−−−</span><br><span class="line">  2037</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> departure_airport <span class="operator">=</span> <span class="string">&#x27;SVO&#x27;</span> <span class="keyword">AND</span> aircraft_code <span class="operator">=</span> <span class="string">&#x27;733&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..5847.00 rows=733 width=63)</span><br><span class="line">   Filter: ((departure_airport = &#x27;SVO&#x27;::bpchar) AND (aircraft_cod...</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>我们可以使用多元 MCV 列表统计来改进估计：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> STATISTICS flights_mcv(mcv)</span><br><span class="line"><span class="keyword">ON</span> departure_airport, aircraft_code <span class="keyword">FROM</span> flights;</span><br><span class="line">ANALYZE flights;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> departure_airport <span class="operator">=</span> <span class="string">&#x27;SVO&#x27;</span> <span class="keyword">AND</span> aircraft_code <span class="operator">=</span> <span class="string">&#x27;733&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> Seq Scan on flights  (cost=0.00..5847.00 rows=2077 width=63)</span><br><span class="line">   Filter: ((departure_airport = &#x27;SVO&#x27;::bpchar) AND (aircraft_cod...</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>现在系统表中有频率数据供规划器使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">values</span>, frequency</span><br><span class="line"><span class="keyword">FROM</span> pg_statistic_ext stx</span><br><span class="line">  <span class="keyword">JOIN</span> pg_statistic_ext_data stxd <span class="keyword">ON</span> stx.oid <span class="operator">=</span> stxd.stxoid,</span><br><span class="line">  pg_mcv_list_items(stxdmcv) m</span><br><span class="line"><span class="keyword">WHERE</span> stxname <span class="operator">=</span> <span class="string">&#x27;flights_mcv&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">values</span> <span class="operator">=</span> <span class="string">&#x27;&#123;SVO,773&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  values   |      frequency</span><br><span class="line">−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"> &#123;SVO,773&#125; | 0.005733333333333333</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>多元最常见值列表存储 <code>default_statistics_target</code> 个值，就像常规 MCV 列表一样。如果参数是在列级别定义的，则使用最大值。</p>
<p>与扩展表达式统计信息一样，您可以更改列表大小（在 PostgreSQL 13 及更高版本中）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> STATISTICS ... <span class="keyword">SET</span> STATISTICS ...;</span><br></pre></td></tr></table></figure>

<p>在这些示例中，仅为两列收集了多元统计信息，但您可以根据需要为任意多的列收集它们。</p>
<p>您还可以将不同类型的统计信息收集到单个扩展统计信息对象中。为此，只需在创建对象时列出用逗号分隔的所需统计类型。如果没有定义特定的统计类型，系统将一次收集所有可用的统计信息。</p>
<p>PostgreSQL 14 还允许您在进行多元变量和表达式统计时不仅使用列名，还可以使用任意表达式。</p>
<p>未完待续。</p>
<h2 id="译者著"><a href="#译者著" class="headerlink" title="译者著"></a>译者著</h2><p>本文翻译自 <a href="https://postgrespro.com/">PostgreSQL Pro</a> 的 <a href="https://postgrespro.com/blog/pgsql/5969296">Queries in PostgreSQL: 2. Statistics</a>。</p>
<hr/>

<p>[1] 应该指的是俄乌战争。</p>
<div class="just-for-fun">
笑林广记 - 半字不值

<p>一监生妻谓其孤陋寡闻。使劝读书。<br>问：“读书有甚好处？”<br>妻曰：“一字值千金，如何无益？”<br>生答曰：“难道我此身半个字也不值？”</p>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
</search>
