<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.japinli.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="在目前的 PostgreSQL 13 中，如果我们采用同步逻辑复制，那么在同步 TRUNCATE 表时，可能会发生数据库 hang 住的可能。本文便是针对这一问题进行分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="PostgreSQL 同步逻辑复制 TRUNCATE 表 hang 住">
<meta property="og:url" content="https://blog.japinli.top/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/index.html">
<meta property="og:site_name" content="Japin">
<meta property="og:description" content="在目前的 PostgreSQL 13 中，如果我们采用同步逻辑复制，那么在同步 TRUNCATE 表时，可能会发生数据库 hang 住的可能。本文便是针对这一问题进行分析。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-16T15:09:12.000Z">
<meta property="article:modified_time" content="2021-10-20T02:36:34.692Z">
<meta property="article:author" content="Japin Li">
<meta property="article:tag" content="PostgreSQL">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.japinli.top/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.japinli.top/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/","path":"2021/04/postgresql-truncate-table-in-synchronous-logical-replication/","title":"PostgreSQL 同步逻辑复制 TRUNCATE 表 hang 住"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PostgreSQL 同步逻辑复制 TRUNCATE 表 hang 住 | Japin</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Japin</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">登高必自卑，行远必自迩</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">49</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">137</span></a></li>
        <li class="menu-item menu-item-readings"><a href="/readings/" rel="section"><i class="fa fa-book fa-fw"></i>阅读</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">现象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-number">3.</span> <span class="nav-text">解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-04-27-%E6%9B%B4%E6%96%B0"><span class="nav-number">4.</span> <span class="nav-text">2021-04-27 更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A8%E8%AE%BA"><span class="nav-number">6.</span> <span class="nav-text">讨论</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Japin Li"
      src="/images/logo.png">
  <p class="site-author-name" itemprop="name">Japin Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">137</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/japinli" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;japinli" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:japinli@hotmail.com" title="E-Mail → mailto:japinli@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.japinli.top/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="Japin Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Japin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PostgreSQL 同步逻辑复制 TRUNCATE 表 hang 住
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-16 23:09:12" itemprop="dateCreated datePublished" datetime="2021-04-16T23:09:12+08:00">2021-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在目前的 PostgreSQL 13 中，如果我们采用同步逻辑复制，那么在同步 TRUNCATE 表时，可能会发生数据库 hang 住的可能。本文便是针对这一问题进行分析。</p>
<span id="more"></span>

<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>这个问题来自于 <a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/OS0PR01MB6113C2499C7DC70EE55ADB82FB759%40OS0PR01MB6113.jpnprd01.prod.outlook.com">PostgresSQL 邮件列表</a>，下面我们来复现一下这个问题（此处我使用的时 <a target="_blank" rel="noopener" href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=409723365b2708acd3bdf2e830257504bdefac4b">pg 14devel</a> 进行复现）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ -- 配置主节点</span><br><span class="line">$ initdb -D pubdb</span><br><span class="line">$ cat &lt;&lt; END &gt;&gt; pubdb/postgresql.auto.conf</span><br><span class="line">port = &#x27;5433&#x27;</span><br><span class="line">wal_level = &#x27;logical&#x27;</span><br><span class="line">wal_sender_timeout = &#x27;0&#x27;</span><br><span class="line">wal_receiver_timeout = &#x27;0&#x27;</span><br><span class="line">END</span><br><span class="line">$ pg_ctl -l pub.log -D pubdb start</span><br><span class="line"></span><br><span class="line">$ -- 配置从节点</span><br><span class="line">$ initdb -D subdb</span><br><span class="line">$ cat &lt;&lt; END &gt;&gt; subdb/postgresql.auto.conf</span><br><span class="line">port = &#x27;5434&#x27;</span><br><span class="line">wal_level = &#x27;logical&#x27;</span><br><span class="line">wal_sender_timeout = &#x27;0&#x27;</span><br><span class="line">wal_receiver_timeout = &#x27;0&#x27;</span><br><span class="line">END</span><br><span class="line">$ pg_ctl -l sub.log -D subdb start</span><br></pre></td></tr></table></figure>

<p>这里设置 <code>wal_sender_timeout</code> 和 <code>wal_receiver_timeout</code> 主要时为了方便调试。</p>
<p>接着，我们创建一个两个表用于逻辑复制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 主节点创建表和发布者</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;CREATE TABLE tbl1 (a int primary key);&#x27; -c &#x27;CREATE TABLE tbl2 (a int);&#x27;</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;CREATE PUBLICATION pub FOR TABLE tbl1, tbl2;&#x27;</span><br><span class="line"></span><br><span class="line">-- 从节点创建表和订阅者</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;CREATE TABLE tbl1 (a int primary key);&#x27; -c &#x27;CREATE TABLE tbl2 (a int);&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &quot;CREATE SUBSCRIPTION sub CONNECTION &#x27;dbname=postgres port=5433&#x27; PUBLICATION pub;&quot;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>CREATE SUBSCRIPTION</code> 命令会在主节点创建一个与其同名的复制槽。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl1 VALUES (1);&#x27;</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl2 VALUES (1);&#x27;</span><br><span class="line"></span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line"> 1</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line"> 1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>我们在主节点执行 <code>TRUNCATE</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl2;&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl1;&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure>

<p>上面时异步模式的逻辑复制，下面我们来测试一下同步情况下的逻辑复制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &quot;ALTER SYSTEM SET synchronous_standby_names TO &#x27;sub&#x27;;&quot;</span><br><span class="line">$ psql -p 5433 postgres -c &quot;SELECT pg_reload_conf();&quot;</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl2 VALUES (10);&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">----</span><br><span class="line"> 10</span><br><span class="line">(1 row)</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl2;&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl2;&#x27;</span><br><span class="line"> a</span><br><span class="line">---</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;INSERT INTO tbl1 VALUES (10);&#x27;</span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">----</span><br><span class="line"> 10</span><br><span class="line">(1 row)</span><br><span class="line">$ psql -p 5433 postgres -c &#x27;TRUNCATE tbl1;&#x27;</span><br><span class="line">hang 住了</span><br><span class="line"></span><br><span class="line">$ psql -p 5434 postgres -c &#x27;SELECT * FROM tbl1;&#x27;</span><br><span class="line"> a</span><br><span class="line">----</span><br><span class="line"> 10</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>我们来看一下数据库中的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;SELECT * FROM pg_locks;&#x27;</span><br><span class="line">   locktype    | database | relation | page | tuple | virtualxid | transactionid | classid | objid | objsubid | virtualtransaction |  pid  |        mode         | granted | fastpath |           waitstart</span><br><span class="line">---------------+----------+----------+------+-------+------------+---------------+---------+-------+----------+--------------------+-------+---------------------+---------+----------+-------------------------------</span><br><span class="line"> relation      |    14016 |    13289 |      |       |            |               |         |       |          | 5/19               | 21612 | AccessShareLock     | t       | t        |</span><br><span class="line"> virtualxid    |          |          |      |       | 5/19       |               |         |       |          | 5/19               | 21612 | ExclusiveLock       | t       | t        |</span><br><span class="line"> virtualxid    |          |          |      |       | 4/49       |               |         |       |          | 4/49               | 21133 | ExclusiveLock       | t       | t        |</span><br><span class="line"> virtualxid    |          |          |      |       | 3/29       |               |         |       |          | 3/29               | 19592 | ExclusiveLock       | t       | t        |</span><br><span class="line"> relation      |    14016 |    16387 |      |       |            |               |         |       |          | 3/29               | 19592 | AccessShareLock     | f       | f        | 2021-04-16 16:51:16.268573+08</span><br><span class="line"> relation      |    14016 |    16387 |      |       |            |               |         |       |          | 4/49               | 21133 | AccessExclusiveLock | t       | f        |</span><br><span class="line"> relation      |    14016 |    16384 |      |       |            |               |         |       |          | 4/49               | 21133 | ShareLock           | t       | f        |</span><br><span class="line"> relation      |    14016 |    16384 |      |       |            |               |         |       |          | 4/49               | 21133 | AccessExclusiveLock | t       | f        |</span><br><span class="line"> transactionid |          |          |      |       |            |           553 |         |       |          | 4/49               | 21133 | ExclusiveLock       | t       | f        |</span><br><span class="line"></span><br><span class="line">$ ps -ef | grep postgres</span><br><span class="line">japin    18477     1  0 16:32 ?        00:00:00 /home/japin/Codes/postgres/Debug/pg/bin/postgres -D pubdb</span><br><span class="line">japin    18479 18477  0 16:32 ?        00:00:00 postgres: checkpointer</span><br><span class="line">japin    18480 18477  0 16:32 ?        00:00:00 postgres: background writer</span><br><span class="line">japin    18481 18477  0 16:32 ?        00:00:00 postgres: walwriter</span><br><span class="line">japin    18482 18477  0 16:32 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">japin    18483 18477  0 16:32 ?        00:00:00 postgres: stats collector</span><br><span class="line">japin    18484 18477  0 16:32 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">japin    18646     1  0 16:33 ?        00:00:00 /home/japin/Codes/postgres/Debug/pg/bin/postgres -D subdb</span><br><span class="line">japin    18648 18646  0 16:33 ?        00:00:00 postgres: checkpointer</span><br><span class="line">japin    18649 18646  0 16:33 ?        00:00:00 postgres: background writer</span><br><span class="line">japin    18650 18646  0 16:33 ?        00:00:00 postgres: walwriter</span><br><span class="line">japin    18651 18646  0 16:33 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">japin    18652 18646  0 16:33 ?        00:00:00 postgres: stats collector</span><br><span class="line">japin    18653 18646  0 16:33 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">japin    19590 18646  0 16:40 ?        00:00:00 postgres: logical replication worker for subscription 16392</span><br><span class="line">japin    19592 18477  0 16:40 ?        00:00:00 postgres: walsender japin [local] START_REPLICATION waiting</span><br><span class="line">japin    21132 32595  0 16:51 pts/7    00:00:00 psql -p 5433 postgres -c TRUNCATE tbl1;</span><br><span class="line">japin    21133 18477  0 16:51 ?        00:00:00 postgres: japin postgres [local] TRUNCATE TABLE waiting for 0/1632600</span><br><span class="line">japin    21670  2878  0 16:55 pts/8    00:00:00 grep --color=auto postgres</span><br><span class="line"></span><br><span class="line">$ psql -p 5433 postgres -c &#x27;SELECT pg_blocking_pids(&#x27;19592&#x27;);&#x27;</span><br><span class="line"> pg_blocking_pids</span><br><span class="line">------------------</span><br><span class="line"> &#123;21133&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，进程 <code>21133</code> 是执行 <code>TRUNCATE</code> 命令的进程，由于是同步提交，因此它在等待来自从节点的回应，此时进程 <code>19592</code>（walsender 进程）需要获取 <code>14016/16387</code> 上的 <code>AccessShareLock</code> 锁，而进程 <code>21133</code> 在 <code>14016/16387</code> 上持有了 <code>AccessExclusiveLock</code> 锁，因此导致 walsender 进程无法获取锁，这就导致的整个进程 hang 住了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ psql -p 5433 postgres -c &#x27;SELECT relname, relkind FROM pg_class WHERE oid = 16387;&#x27;</span><br><span class="line">  relname  | relkind</span><br><span class="line">-----------+---------</span><br><span class="line"> tbl1_pkey | i</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><code>14016/16387</code> 对应的就是 <code>tbl1</code> 上的主键索引。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里需要弄清楚为什么 <code>tbl1</code> 别阻塞了，而 <code>tbl2</code> 没有被阻塞。它们的唯一区别是 <code>tbl1</code> 有一个主键索引，在逻辑复制中，它将被作为逻辑复制的 <a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/devel/sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY">Replica Identity</a>，可以推测是否是这个原因导致的呢？</p>
<p>我们使用 gdb 附加到 walsender 其调用栈如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007f296071da07 in epoll_wait (epfd=12, events=0x55af98fb9d18, maxevents=1, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line">#1  0x000055af97aa3731 in WaitEventSetWaitBlock (set=0x55af98fb9cb8, cur_timeout=-1, occurred_events=0x7fffbc568a90, nevents=1) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1452</span><br><span class="line">#2  0x000055af97aa35ac in WaitEventSetWait (set=0x55af98fb9cb8, timeout=-1, occurred_events=0x7fffbc568a90, nevents=1, wait_event_info=50331648) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1398</span><br><span class="line">#3  0x000055af97aa290f in WaitLatch (latch=0x7f295fbf4414, wakeEvents=33, timeout=0, wait_event_info=50331648) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:473</span><br><span class="line">#4  0x000055af97ace672 in ProcSleep (locallock=0x55af98fdeb28, lockMethodTable=0x55af981ba820 &lt;default_lockmethod&gt;) at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/proc.c:1361</span><br><span class="line">#5  0x000055af97abc12f in WaitOnLock (locallock=0x55af98fdeb28, owner=0x55af99039de0) at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/lock.c:1858</span><br><span class="line">#6  0x000055af97ababff in LockAcquireExtended (locktag=0x7fffbc568e50, lockmode=1, sessionLock=false, dontWait=false, reportMemoryError=true, locallockp=0x7fffbc568e48)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/lock.c:1100</span><br><span class="line">#7  0x000055af97ab7a0e in LockRelationOid (relid=16387, lockmode=1) at /home/japin/Codes/postgres/Debug/../src/backend/storage/lmgr/lmgr.c:117</span><br><span class="line">#8  0x000055af975afa9e in relation_open (relationId=16387, lockmode=1) at /home/japin/Codes/postgres/Debug/../src/backend/access/common/relation.c:56</span><br><span class="line">#9  0x000055af9763c76e in index_open (relationId=16387, lockmode=1) at /home/japin/Codes/postgres/Debug/../src/backend/access/index/indexam.c:136</span><br><span class="line">#10 0x000055af97c7be60 in RelationGetIndexAttrBitmap (relation=0x7f2961ce9648, attrKind=INDEX_ATTR_BITMAP_IDENTITY_KEY) at /home/japin/Codes/postgres/Debug/../src/backend/utils/cache/relcache.c:5063</span><br><span class="line">#11 0x000055af97a362b1 in logicalrep_write_attrs (out=0x55af990887d0, rel=0x7f2961ce9648) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/proto.c:671</span><br><span class="line">#12 0x000055af97a35952 in logicalrep_write_rel (out=0x55af990887d0, xid=0, rel=0x7f2961ce9648) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/proto.c:418</span><br><span class="line">#13 0x00007f2956c8f7c5 in send_relation_and_attrs (relation=0x7f2961ce9648, xid=0, ctx=0x55af99080450) at /home/japin/Codes/postgres/Debug/../src/backend/replication/pgoutput/pgoutput.c:502</span><br><span class="line">#14 0x00007f2956c8f6a1 in maybe_send_schema (ctx=0x55af99080450, txn=0x55af990ad658, change=0x55af990b69a8, relation=0x7f2961ce9648, relentry=0x55af9909a218)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/pgoutput/pgoutput.c:460</span><br><span class="line">#15 0x00007f2956c8fe13 in pgoutput_truncate (ctx=0x55af99080450, txn=0x55af990ad658, nrelations=1, relations=0x55af990b4608, change=0x55af990b69a8) at /home/japin/Codes/postgres/Debug/../src/backend/replication/pgoutput/pgoutput.c:691</span><br><span class="line">#16 0x000055af97a2f8fe in truncate_cb_wrapper (cache=0x55af99082460, txn=0x55af990ad658, nrelations=1, relations=0x55af990b4608, change=0x55af990b69a8) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/logical.c:1089</span><br><span class="line">#17 0x000055af97a3adbc in ReorderBufferApplyTruncate (rb=0x55af99082460, txn=0x55af990ad658, nrelations=1, relations=0x55af990b4608, change=0x55af990b69a8, streaming=false)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:1910</span><br><span class="line">#18 0x000055af97a3b910 in ReorderBufferProcessTXN (rb=0x55af99082460, txn=0x55af990ad658, commit_lsn=23274800, snapshot_now=0x55af99082678, command_id=2, streaming=false)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:2270</span><br><span class="line">#19 0x000055af97a3c147 in ReorderBufferReplay (txn=0x55af990ad658, rb=0x55af99082460, xid=553, commit_lsn=23274800, end_lsn=23275008, commit_time=671878276266624, origin_id=0, origin_lsn=0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:2568</span><br><span class="line">#20 0x000055af97a3c1c5 in ReorderBufferCommit (rb=0x55af99082460, xid=553, commit_lsn=23274800, end_lsn=23275008, commit_time=671878276266624, origin_id=0, origin_lsn=0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/reorderbuffer.c:2592</span><br><span class="line">#21 0x000055af97a2a8e3 in DecodeCommit (ctx=0x55af99080450, buf=0x7fffbc5696c0, parsed=0x7fffbc569560, xid=553, two_phase=false) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/decode.c:744</span><br><span class="line">#22 0x000055af97a29be6 in DecodeXactOp (ctx=0x55af99080450, buf=0x7fffbc5696c0) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/decode.c:278</span><br><span class="line">#23 0x000055af97a297ff in LogicalDecodingProcessRecord (ctx=0x55af99080450, record=0x55af99080810) at /home/japin/Codes/postgres/Debug/../src/backend/replication/logical/decode.c:142</span><br><span class="line">#24 0x000055af97a674e7 in XLogSendLogical () at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:2865</span><br><span class="line">#25 0x000055af97a666d3 in WalSndLoop (send_data=0x55af97a67408 &lt;XLogSendLogical&gt;) at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:2290</span><br><span class="line">#26 0x000055af97a6505f in StartLogicalReplication (cmd=0x55af99046958) at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:1207</span><br><span class="line">#27 0x000055af97a659f7 in exec_replication_command (cmd_string=0x55af98fc0f20 &quot;START_REPLICATION SLOT \&quot;sub\&quot; LOGICAL 0/0 (proto_version &#x27;2&#x27;, publication_names &#x27;\&quot;pub\&quot;&#x27;)&quot;)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/walsender.c:1647</span><br><span class="line">#28 0x000055af97addd72 in PostgresMain (argc=1, argv=0x7fffbc5699d0, dbname=0x55af98fecbe8 &quot;postgres&quot;, username=0x55af98fecbc8 &quot;japin&quot;) at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:4454</span><br><span class="line">#29 0x000055af97a0c450 in BackendRun (port=0x55af98fe46f0) at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4483</span><br><span class="line">#30 0x000055af97a0bcfe in BackendStartup (port=0x55af98fe46f0) at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4205</span><br><span class="line">#31 0x000055af97a07e10 in ServerLoop () at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1737</span><br><span class="line">#32 0x000055af97a075c1 in PostmasterMain (argc=3, argv=0x55af98fb96c0) at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1409</span><br><span class="line">#33 0x000055af978fd9d7 in main (argc=3, argv=0x55af98fb96c0) at /home/japin/Codes/postgres/Debug/../src/backend/main/main.c:209</span><br></pre></td></tr></table></figure>

<p>从堆栈可以看到 <code>logicalrep_write_attrs()</code> 函数调用 <code>RelationGetIndexAttrBitmap()</code> 函数并在其内部调用 <code>index_open()</code> 中打开索引时无法获取锁，从而导致进程 hang 住。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">logicalrep_write_attrs(StringInfo out, Relation rel)</span><br><span class="line">&#123;</span><br><span class="line">    TupleDesc   desc;</span><br><span class="line">    int         i;</span><br><span class="line">    uint16      nliveatts = 0;</span><br><span class="line">    Bitmapset  *idattrs = NULL;</span><br><span class="line">    bool        replidentfull;</span><br><span class="line"></span><br><span class="line">    desc = RelationGetDescr(rel);</span><br><span class="line"></span><br><span class="line">    /* send number of live attributes */</span><br><span class="line">    for (i = 0; i &lt; desc-&gt;natts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (TupleDescAttr(desc, i)-&gt;attisdropped || TupleDescAttr(desc, i)-&gt;attgenerated)</span><br><span class="line">            continue;</span><br><span class="line">        nliveatts++;</span><br><span class="line">    &#125;</span><br><span class="line">    pq_sendint16(out, nliveatts);</span><br><span class="line"></span><br><span class="line">    /* fetch bitmap of REPLICATION IDENTITY attributes */</span><br><span class="line">    replidentfull = (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL);</span><br><span class="line">    if (!replidentfull)</span><br><span class="line">        idattrs = RelationGetIndexAttrBitmap(rel,</span><br><span class="line">                                             INDEX_ATTR_BITMAP_IDENTITY_KEY);</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看到到不为 <code>REPLICA_IDENTITY_FULL</code> 时，我们需要调用 <code>RelationGetIndexAttrBitmap()</code> 函数来获取 Replica Identity 属性，<code>tbl2</code> 表在执行时由于没有调用 <code>RelationGetIndexAttrBitmap()</code> 所以不会 hang 住。</p>
<p>我们看看 <code>21133</code> 进程的堆栈，可以发现其阻塞在 <code>SyncRepWaitForLSN()</code> 函数调用中，该函数用于等待从节点对于当前事务的提交状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007f296071da07 in epoll_wait (epfd=12, events=0x55af98fb9d18, maxevents=1, timeout=-1)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line">#1  0x000055af97aa3731 in WaitEventSetWaitBlock (set=0x55af98fb9cb8, cur_timeout=-1, occurred_events=0x7fffbc5695e0,</span><br><span class="line">    nevents=1) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1452</span><br><span class="line">#2  0x000055af97aa35ac in WaitEventSetWait (set=0x55af98fb9cb8, timeout=-1, occurred_events=0x7fffbc5695e0,</span><br><span class="line">    nevents=1, wait_event_info=134217771) at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:1398</span><br><span class="line">#3  0x000055af97aa290f in WaitLatch (latch=0x7f295fbef874, wakeEvents=17, timeout=-1, wait_event_info=134217771)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/storage/ipc/latch.c:473</span><br><span class="line">#4  0x000055af97a5b667 in SyncRepWaitForLSN (lsn=23275008, commit=true)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/replication/syncrep.c:296</span><br><span class="line">#5  0x000055af976a11d8 in RecordTransactionCommit ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/access/transam/xact.c:1456</span><br><span class="line">#6  0x000055af976a1e52 in CommitTransaction ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/access/transam/xact.c:2188</span><br><span class="line">#7  0x000055af976a2bef in CommitTransactionCommand ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/access/transam/xact.c:2965</span><br><span class="line">#8  0x000055af97adbae4 in finish_xact_command ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:2703</span><br><span class="line">#9  0x000055af97ad9282 in exec_simple_query (query_string=0x55af98fc0f20 &quot;TRUNCATE tbl1;&quot;)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:1221</span><br><span class="line">#10 0x000055af97addd99 in PostgresMain (argc=1, argv=0x7fffbc5699d0, dbname=0x55af98ff4448 &quot;postgres&quot;,</span><br><span class="line">    username=0x55af98ff4428 &quot;japin&quot;) at /home/japin/Codes/postgres/Debug/../src/backend/tcop/postgres.c:4458</span><br><span class="line">#11 0x000055af97a0c450 in BackendRun (port=0x55af98fe6ac0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4483</span><br><span class="line">#12 0x000055af97a0bcfe in BackendStartup (port=0x55af98fe6ac0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:4205</span><br><span class="line">#13 0x000055af97a07e10 in ServerLoop ()</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1737</span><br><span class="line">#14 0x000055af97a075c1 in PostmasterMain (argc=3, argv=0x55af98fb96c0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/postmaster/postmaster.c:1409</span><br><span class="line">#15 0x000055af978fd9d7 in main (argc=3, argv=0x55af98fb96c0)</span><br><span class="line">    at /home/japin/Codes/postgres/Debug/../src/backend/main/main.c:209</span><br></pre></td></tr></table></figure>

<p>事务持用的锁当执行完 <code>RecordTransactionCommit()</code> 函数后，将由 <code>CommitTransaction()</code> 调用 <code>ResourceOwnerRelease(RESOURCE_RELEASE_LOCKS)</code> 来释放锁资源。</p>
<p>那么为什么在异步的情况下不会出现这种情况呢？这就需要理解 PostgreSQL 的同步复制，当异步复制时，PostgreSQL 并不会等待从节点的回应，因此锁可以得到释放。然而在同步模式下，从上面可以看出其没有机会释放锁，从而导致 walsender 进程无法获取锁。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然锁是由执行 <code>TRUNCATE</code> 命令的进程持有，从下面的代码可以看到 <code>TRUNCATE</code> 进程在等待来自从节点的响应时，WAL 日志其实已经刷盘了。那么我们是否可以在等待从节点之前释放锁资源呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static TransactionId</span><br><span class="line">RecordTransactionCommit(void)</span><br><span class="line">&#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">    if ((wrote_xlog &amp;&amp; markXidCommitted &amp;&amp;</span><br><span class="line">         synchronous_commit &gt; SYNCHRONOUS_COMMIT_OFF) ||</span><br><span class="line">        forceSyncCommit || nrels &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        XLogFlush(XactLastRecEnd);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Now we may update the CLOG, if we wrote a COMMIT record above</span><br><span class="line">         */</span><br><span class="line">        if (markXidCommitted)</span><br><span class="line">            TransactionIdCommitTree(xid, nchildren, children);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Asynchronous commit case:</span><br><span class="line">         *</span><br><span class="line">         * This enables possible committed transaction loss in the case of a</span><br><span class="line">         * postmaster crash because WAL buffers are left unwritten. Ideally we</span><br><span class="line">         * could issue the WAL write without the fsync, but some</span><br><span class="line">         * wal_sync_methods do not allow separate write/fsync.</span><br><span class="line">         *</span><br><span class="line">         * Report the latest async commit LSN, so that the WAL writer knows to</span><br><span class="line">         * flush this commit.</span><br><span class="line">         */</span><br><span class="line">        XLogSetAsyncXactLSN(XactLastRecEnd);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * We must not immediately update the CLOG, since we didn&#x27;t flush the</span><br><span class="line">         * XLOG. Instead, we store the LSN up to which the XLOG must be</span><br><span class="line">         * flushed before the CLOG may be updated.</span><br><span class="line">         */</span><br><span class="line">        if (markXidCommitted)</span><br><span class="line">            TransactionIdAsyncCommitTree(xid, nchildren, children, XactLastRecEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Wait for synchronous replication, if required. Similar to the decision</span><br><span class="line">     * above about using committing asynchronously we only want to wait if</span><br><span class="line">     * this backend assigned an xid and wrote WAL.  No need to wait if an xid</span><br><span class="line">     * was assigned due to temporary/unlogged tables or due to HOT pruning.</span><br><span class="line">     *</span><br><span class="line">     * Note that at this stage we have marked clog, but still show as running</span><br><span class="line">     * in the procarray and continue to hold locks.</span><br><span class="line">     */</span><br><span class="line">    if (wrote_xlog &amp;&amp; markXidCommitted)</span><br><span class="line">        SyncRepWaitForLSN(XactLastRecEnd, true);</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，这样做是可以的，它能解决同步流复制下 <code>TRUNCATE</code> 被 hang 的问题，同时整个数据库的测试（<code>make check-world</code>）也可以通过。那么是否就意味这样解决就可以了呢？</p>
<p>上面的解决方案其实就有点类似于头痛医头、脚痛医脚的感觉。这个方案基本上都没有入了社区大神的眼，那么大神们是怎么解决的呢？其实这样的场景存在同步流复制中，那么为什么同步流复制下没有这个问题呢？基于此，Amit Kapila 给出的建议是我们是否可以避免调用 <code>index_open()</code> 函数来打开索引，而是使用缓存中的对象来获取逻辑复制的 Replica Identity，即通过 <code>RelationIdGetRelation()</code> 函数来获取表对象构建 Replica Identity。</p>
<p>下面是一个简单的 POC 测试修改补丁，经过测试其能够修复这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/backend/utils/cache/relcache.c b/src/backend/utils/cache/relcache.c</span><br><span class="line">index 29702d6eab..0ad59ef189 100644</span><br><span class="line">--- a/src/backend/utils/cache/relcache.c</span><br><span class="line">+++ b/src/backend/utils/cache/relcache.c</span><br><span class="line">@@ -5060,7 +5060,7 @@ restart:</span><br><span class="line">                bool            isPK;           /* primary key */</span><br><span class="line">                bool            isIDKey;        /* replica identity index */</span><br><span class="line"></span><br><span class="line">-               indexDesc = index_open(indexOid, AccessShareLock);</span><br><span class="line">+               indexDesc = RelationIdGetRelation(indexOid);</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                 * Extract index expressions and index predicate.  Note: Don&#x27;t use</span><br><span class="line">@@ -5134,7 +5134,7 @@ restart:</span><br><span class="line">                /* Collect all attributes in the index predicate, too */</span><br><span class="line">                pull_varattnos(indexPredicate, 1, &amp;indexattrs);</span><br><span class="line"></span><br><span class="line">-               index_close(indexDesc, AccessShareLock);</span><br><span class="line">+               RelationClose(indexDesc);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>RelationGetIndexAttrBitmap()</code> 函数会被其他函数调用，因此这样修改可能会引起其他部分的问题，Amit Kapila 建议单独弄一个函数来实现该功能，目前补丁正在由 Takamichi Osumi 进行更新，后续 review 之后应该就会合并到 14 分支中，至于会不会 backpatch 到其他分支还有待后续。</p>
<h2 id="2021-04-27-更新"><a href="#2021-04-27-更新" class="headerlink" title="2021-04-27 更新"></a>2021-04-27 更新</h2><p>目前，代码已经合并到主分支，并没有 backpatch 到其他分支，下面是 patch 的部分内容。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/backend/replication/logical/proto.c b/src/backend/replication/logical/proto.c</span></span><br><span class="line"><span class="comment">index 2a1f983..1cf59e0 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/replication/logical/proto.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/replication/logical/proto.c</span></span><br><span class="line"><span class="meta">@@ -668,8 +668,7 @@</span> logicalrep_write_attrs(StringInfo out, Relation rel)</span><br><span class="line"> 	/* fetch bitmap of REPLICATION IDENTITY attributes */</span><br><span class="line"> 	replidentfull = (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL);</span><br><span class="line"> 	if (!replidentfull)</span><br><span class="line"><span class="deletion">-		idattrs = RelationGetIndexAttrBitmap(rel,</span></span><br><span class="line"><span class="deletion">-											 INDEX_ATTR_BITMAP_IDENTITY_KEY);</span></span><br><span class="line"><span class="addition">+		idattrs = RelationGetIdentityKeyBitmap(rel);</span></span><br><span class="line"> </span><br><span class="line"> 	/* send the attributes */</span><br><span class="line"> 	for (i = 0; i &lt; desc-&gt;natts; i++)</span><br><span class="line"><span class="comment">diff --git a/src/backend/utils/cache/relcache.c b/src/backend/utils/cache/relcache.c</span></span><br><span class="line"><span class="comment">index 29702d6..316a256 100644</span></span><br><span class="line"><span class="comment">--- a/src/backend/utils/cache/relcache.c</span></span><br><span class="line"><span class="comment">+++ b/src/backend/utils/cache/relcache.c</span></span><br><span class="line"><span class="meta">@@ -5207,6 +5207,81 @@</span> restart:</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"><span class="addition">+ * RelationGetIdentityKeyBitmap -- get a bitmap of replica identity attribute</span></span><br><span class="line"><span class="addition">+ * numbers</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * A bitmap of index attribute numbers for the configured replica identity</span></span><br><span class="line"><span class="addition">+ * index is returned.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * See also comments of RelationGetIndexAttrBitmap().</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * This is a special purpose function used during logical replication. Here,</span></span><br><span class="line"><span class="addition">+ * unlike RelationGetIndexAttrBitmap(), we don&#x27;t acquire a lock on the required</span></span><br><span class="line"><span class="addition">+ * index as we build the cache entry using a historic snapshot and all the</span></span><br><span class="line"><span class="addition">+ * later changes are absorbed while decoding WAL. Due to this reason, we don&#x27;t</span></span><br><span class="line"><span class="addition">+ * need to retry here in case of a change in the set of indexes.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+Bitmapset *</span></span><br><span class="line"><span class="addition">+RelationGetIdentityKeyBitmap(Relation relation)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+	Bitmapset  *idindexattrs = NULL;	/* columns in the replica identity */</span></span><br><span class="line"><span class="addition">+	List	   *indexoidlist;</span></span><br><span class="line"><span class="addition">+	Relation	indexDesc;</span></span><br><span class="line"><span class="addition">+	int			i;</span></span><br><span class="line"><span class="addition">+	MemoryContext oldcxt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Quick exit if we already computed the result */</span></span><br><span class="line"><span class="addition">+	if (relation-&gt;rd_idattr != NULL)</span></span><br><span class="line"><span class="addition">+		return bms_copy(relation-&gt;rd_idattr);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Fast path if definitely no indexes */</span></span><br><span class="line"><span class="addition">+	if (!RelationGetForm(relation)-&gt;relhasindex)</span></span><br><span class="line"><span class="addition">+		return NULL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Historic snapshot must be set. */</span></span><br><span class="line"><span class="addition">+	Assert(HistoricSnapshotActive());</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	indexoidlist = RelationGetIndexList(relation);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Fall out if no indexes (but relhasindex was set) */</span></span><br><span class="line"><span class="addition">+	if (indexoidlist == NIL)</span></span><br><span class="line"><span class="addition">+		return NULL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Build attributes to idindexattrs by collecting attribute references */</span></span><br><span class="line"><span class="addition">+	indexDesc = RelationIdGetRelation(relation-&gt;rd_replidindex);</span></span><br><span class="line"><span class="addition">+	for (i = 0; i &lt; indexDesc-&gt;rd_index-&gt;indnatts; i++)</span></span><br><span class="line"><span class="addition">+	&#123;</span></span><br><span class="line"><span class="addition">+		int			attrnum = indexDesc-&gt;rd_index-&gt;indkey.values[i];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		/*</span></span><br><span class="line"><span class="addition">+		 * We don&#x27;t include non-key columns into idindexattrs bitmaps. See</span></span><br><span class="line"><span class="addition">+		 * RelationGetIndexAttrBitmap.</span></span><br><span class="line"><span class="addition">+		 */</span></span><br><span class="line"><span class="addition">+		if (attrnum != 0)</span></span><br><span class="line"><span class="addition">+		&#123;</span></span><br><span class="line"><span class="addition">+			if (i &lt; indexDesc-&gt;rd_index-&gt;indnkeyatts)</span></span><br><span class="line"><span class="addition">+				idindexattrs = bms_add_member(idindexattrs,</span></span><br><span class="line"><span class="addition">+											  attrnum - FirstLowInvalidHeapAttributeNumber);</span></span><br><span class="line"><span class="addition">+		&#125;</span></span><br><span class="line"><span class="addition">+	&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	RelationClose(indexDesc);</span></span><br><span class="line"><span class="addition">+	list_free(indexoidlist);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Don&#x27;t leak the old values of these bitmaps, if any */</span></span><br><span class="line"><span class="addition">+	bms_free(relation-&gt;rd_idattr);</span></span><br><span class="line"><span class="addition">+	relation-&gt;rd_idattr = NULL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* Now save copy of the bitmap in the relcache entry */</span></span><br><span class="line"><span class="addition">+	oldcxt = MemoryContextSwitchTo(CacheMemoryContext);</span></span><br><span class="line"><span class="addition">+	relation-&gt;rd_idattr = bms_copy(idindexattrs);</span></span><br><span class="line"><span class="addition">+	MemoryContextSwitchTo(oldcxt);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/* We return our original working copy for caller to play with */</span></span><br><span class="line"><span class="addition">+	return idindexattrs;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line">  * RelationGetExclusionInfo -- get info about index&#x27;s exclusion constraint</span><br><span class="line">  *</span><br><span class="line">  * This should be called only for an index that is known to have an</span><br><span class="line"><span class="comment">diff --git a/src/include/utils/relcache.h b/src/include/utils/relcache.h</span></span><br><span class="line"><span class="comment">index 2fcdf79..f772855 100644</span></span><br><span class="line"><span class="comment">--- a/src/include/utils/relcache.h</span></span><br><span class="line"><span class="comment">+++ b/src/include/utils/relcache.h</span></span><br><span class="line"><span class="meta">@@ -65,6 +65,8 @@</span> typedef enum IndexAttrBitmapKind</span><br><span class="line"> extern Bitmapset *RelationGetIndexAttrBitmap(Relation relation,</span><br><span class="line"> 											 IndexAttrBitmapKind attrKind);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern Bitmapset *RelationGetIdentityKeyBitmap(Relation relation);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> extern void RelationGetExclusionInfo(Relation indexRelation,</span><br><span class="line"> 									 Oid **operators,</span><br><span class="line"> 									 Oid **procs,</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的分析过程收益还是颇多的，对 PostgreSQL 的流复制有了更深刻的认识。此外对于 PostgreSQL 的 TAP 测试也有了一点心得，不再像之前修复<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/CALj2ACV%2B0UFpcZs5czYgBpujM9p0Hg1qdOZai_43OU7bqHU_xw%40mail.gmail.com">逻辑复制行为异常</a>那样对 TAP 测试茫然了。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>[1] <a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/OS0PR01MB6113C2499C7DC70EE55ADB82FB759%40OS0PR01MB6113.jpnprd01.prod.outlook.com">Truncate in synchronous logical replication failed</a></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/10/logical-replication-with-different-datestyle-between-publisher-and-subscriber/" rel="bookmark">PostgreSQL 发布者与订阅者不同的 datestyle 导致失败</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2022/07/postgres-relcache-and-syscache/" rel="bookmark">PostgreSQL RelCache 和 SysCache 缓存</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/02/postgresql-auto-explain-memory-leak/" rel="bookmark">PostgreSQL auto_explain 插件内存泄露</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/05/postgresql-create-table-query-plan/" rel="bookmark">PostgreSQL CREATE TABLE 查询计划树及执行计划树的生成</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/05/postgresql-create-table-syntax-analysis/" rel="bookmark">PostgreSQL CREATE TABLE 语法分析</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Japin Li
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.japinli.top/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/" title="PostgreSQL 同步逻辑复制 TRUNCATE 表 hang 住">https://blog.japinli.top/2021/04/postgresql-truncate-table-in-synchronous-logical-replication/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/PostgreSQL/" rel="tag"># PostgreSQL</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/oracle-wm-concat/" rel="prev" title="Oracle wm_concat 函数说明">
                  <i class="fa fa-chevron-left"></i> Oracle wm_concat 函数说明
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/go-in-action/" rel="next" title="Go 语言实战">
                  Go 语言实战 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Japin Li</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">688k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:25</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"japinli/japinli.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
